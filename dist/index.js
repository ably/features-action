require('./sourcemap-register.js');/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 48782:
/***/ ((module) => {

/**
 * Compares two string keys, using our preferred comparison method.
 *
 * This method uses `localCompare` with the `sensitivity` option set to 'base',
 * meaning that comparisons are case insensitive.
 *
 * @param {string} a The first string (a.k.a. `referenceStr`).
 * @param {string} b The second string (a.k.a. `compareString`).
 * @returns {number} A negative number if `a` occurs before `b`;
 * positive if the `a` occurs after `b`; 0 if they are equivalent.
 */
function compareKeys(a, b) {
  return a.localeCompare(b, 'en', { sensitivity: 'base' });
}

module.exports = {
  compareKeys,
};


/***/ }),

/***/ 25772:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const fs = __nccwpck_require__(57147);
const path = __nccwpck_require__(71017);
const YAML = __nccwpck_require__(44603);

const { Manifest } = __nccwpck_require__(39046);
const { MatrixGenerator } = __nccwpck_require__(55091);
const { writeDocument } = __nccwpck_require__(9454);
const { validateStructure } = __nccwpck_require__(19398);
const { isString } = __nccwpck_require__(12699);

const loadSource = (filePath) => fs.readFileSync(filePath).toString();
const yamlParserOptions = { mapAsMap: true };

class ManifestObjects {
  /**
   * Loads SDK feature compliance manifest(s) from YAML file(s).
   *
   * @param {string[]} suffixes In the order they're to be explored for each feature.
   * @param {Map} sourcePaths The paths to the YAML documents containing SDK manifests, keyed by suffix.
   */
  constructor(suffixes, sourcePaths) {
    if (!suffixes || suffixes.length < 1) {
      throw new Error('suffixes must be defined and not empty.');
    }
    if ((new Set(suffixes)).size !== suffixes.length) {
      throw new Error('Values in suffixes must all be unique (array as ordered set).');
    }
    if (suffixes.length !== sourcePaths.size) {
      throw new Error('suffixes.length must match sourcePaths.size.');
    }

    // Load YAML sources up-front and do first-pass (first parse) structural validation.
    const sources = new Map();
    suffixes.forEach((suffix) => {
      const source = loadSource(sourcePaths.get(suffix));
      validateStructure(YAML.parseDocument(source).contents);
      sources.set(suffix, source);
    });

    // Do second-pass (second parse) parsing raw YAML sources to JS objects.
    const objects = new Map();
    sources.forEach((source, suffix) => {
      try {
        const object = YAML.parse(source, yamlParserOptions);
        objects.set(suffix, object);
      } catch (error) {
        throw new Error(
          `Failed YAML parse for manifest with ${suffix}.`,
          { cause: error },
        );
      }
    });

    // Ensure that all objects contain a top-level key with a value indicating the
    // version of the canonical feature list to which this manifest aligns.
    let commonVersion;
    objects.forEach((object, suffix) => {
      try {
        if (!(object instanceof Map)) {
          throw new Error('manifest must be a Map.');
        }
        const version = object.get('common-version');
        if (!isString(version)) {
          throw new Error('common-version must be a string.');
        }
        if (version.trim().length < 1) {
          throw new Error('common-version may not be empty.');
        }
        if (commonVersion) {
          if (commonVersion !== version) {
            throw new Error(`common-version '${version}' must match '${commonVersion}' from previously processed manifests.`);
          }
        } else {
          commonVersion = version;
        }
      } catch (error) {
        throw new Error(
          `Failed common version locate for manifest with ${suffix}.`,
          { cause: error },
        );
      }
    });

    this.commonVersion = commonVersion;
    this.suffixes = suffixes; // in desired order
    this.objects = objects;
  }
}

/**
 * Renders the canonical feature list to HTML, with SDK columns.
 *
 * @param {string} canonicalSource The YAML document containing the canonical feature list.
 * @param {ManifestObjects} sdkManifestObjects In memory, having passed initial structural validation and YAML parse.
 * @param {string} outputDirectoryPath The path to the directory to generate the HTML document to.
 */
const build = (
  canonicalSource,
  sdkManifestObjects,
  outputDirectoryPath,
) => {
  // Load YAML source up-front for the canonical features list.
  validateStructure(YAML.parseDocument(canonicalSource).contents);

  // Second Parse: using YAML's simplest API, rendering pure JS entities representing our data model
  const features = YAML.parse(canonicalSource, yamlParserOptions);
  const sdkManifests = new Map();
  sdkManifestObjects.objects.forEach((object, suffix) => {
    try {
      const manifest = new Manifest(object, features);
      sdkManifests.set(suffix, manifest);
    } catch (error) {
      throw new Error(
        `Failed manifest validation for ${suffix}.`,
        { cause: error },
      );
    }
  });

  const sortedManifests = sdkManifestObjects.suffixes.map((suffix) => sdkManifests.get(suffix));
  const generator = new MatrixGenerator(features, sortedManifests);

  // First Pass: Measure depth.
  const arbitraryMaximumDepth = 10;
  const levelCount = generator.generate(arbitraryMaximumDepth);
  console.log(`levelCount = ${levelCount}`);

  // Create output directory in standard location within working directory.
  // The expectation is that this tool is run from the root of the repository.
  createDirectory(outputDirectoryPath);

  writeDocument(
    path.join(outputDirectoryPath, 'index.html'),
    generator,
    sdkManifestObjects.suffixes,
    levelCount,
  );

  /**
   * Creates a directory at the given path if it doesn't exist, recursively if necessary.
   *
   * @param {string} directoryPath The directory path. Can be relative to current working directory.
   */
  function createDirectory(directoryPath) {
    if (!fs.existsSync(directoryPath)) {
      fs.mkdirSync(directoryPath, { recursive: true });
    }
  }
};

module.exports = {
  build,
  loadSource,
  ManifestObjects,
};


/***/ }),

/***/ 9454:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const fs = __nccwpck_require__(57147);
const escape = __nccwpck_require__(94070);
const { marked } = __nccwpck_require__(65741);
const {
  DocumentWriter,
  TableWriter,
} = __nccwpck_require__(18656);
const { MatrixGenerator, MatrixConsumer } = __nccwpck_require__(55091);

// from Google Fonts' Icons (originally called 'Close' and 'Done').
// https://fonts.google.com/icons
const svgSize = '1.5em';
const crossSvg = `<svg xmlns="http://www.w3.org/2000/svg" height="${svgSize}" width="${svgSize}" viewBox="0 0 48 48"><path d="M12.45 37.65 10.35 35.55 21.9 24 10.35 12.45 12.45 10.35 24 21.9 35.55 10.35 37.65 12.45 26.1 24 37.65 35.55 35.55 37.65 24 26.1Z"/></svg>`;
const tickSvg = `<svg xmlns="http://www.w3.org/2000/svg" height="${svgSize}" width="${svgSize}" viewBox="0 0 48 48"><path d="M18.9 35.7 7.7 24.5 9.85 22.35 18.9 31.4 38.1 12.2 40.25 14.35Z"/></svg>`;
const partialSvg = `<svg xmlns="http://www.w3.org/2000/svg" height="${svgSize}" width="${svgSize}" viewBox="0 0 48 48"><path d="M10.4 26.4Q9.4 26.4 8.7 25.7Q8 25 8 24Q8 23 8.7 22.3Q9.4 21.6 10.4 21.6Q11.4 21.6 12.1 22.3Q12.8 23 12.8 24Q12.8 25 12.1 25.7Q11.4 26.4 10.4 26.4ZM24 26.4Q23 26.4 22.3 25.7Q21.6 25 21.6 24Q21.6 23 22.3 22.3Q23 21.6 24 21.6Q25 21.6 25.7 22.3Q26.4 23 26.4 24Q26.4 25 25.7 25.7Q25 26.4 24 26.4ZM37.6 26.4Q36.6 26.4 35.9 25.7Q35.2 25 35.2 24Q35.2 23 35.9 22.3Q36.6 21.6 37.6 21.6Q38.6 21.6 39.3 22.3Q40 23 40 24Q40 25 39.3 25.7Q38.6 26.4 37.6 26.4Z"/></svg>`;

const verticalBordersStyle = 'border-slate-300 border-b-2';

const title = 'Ably';
const subTitle = 'SDK Features Matrix';

const commonFeatureCellStyle = `${verticalBordersStyle} border-r-2`;

/**
 * @implements {MatrixConsumer}
 */
class TableRenderer extends MatrixConsumer {
  constructor(tableWriter) {
    super();
    this.tableWriter = tableWriter;
  }

  onFeature(parentKeys, key, properties, maximumLevel) {
    const {
      specificationPoints,
      documentationUrls,
      requires,
      synopsis,
      isHeading,
    } = properties;
    const level = parentKeys.length;

    const { tableWriter } = this;
    tableWriter.class(`align-middle tooltip-container${isHeading ? ' bg-slate-200' : ''}`);
    const rowWriter = tableWriter.startRow();
    this.rowWriter = rowWriter; // used by calls to onCompliance() for this feature row

    // Indent using empty cells
    for (let i = 1; i <= level; i += 1) {
      rowWriter.class(`px-3 ${verticalBordersStyle}`);
      rowWriter.cell((cellContentWriter) => {
        cellContentWriter.write('&nbsp;');
      });
    }

    // Contents, with column spanning to fill remaining cells, after indentation
    const cellCount = maximumLevel - level;
    if (cellCount > 1) {
      rowWriter.columnSpan(cellCount);
    }
    rowWriter.class(`pr-3 whitespace-nowrap ${commonFeatureCellStyle} ${isHeading ? 'font-bold' : ''}`);
    rowWriter.cell((cellContentWriter) => {
      if (level > 0) {
        const tip = `<strong>${escape(parentKeys.join(': '))}</strong>: ${escape(key)}`;
        cellContentWriter.write(`<span class="tooltip-contents">${tip}</span>`);
      }
      cellContentWriter.text(key);
    });

    // Specification Points
    rowWriter.class(`px-1 ${commonFeatureCellStyle}`);
    rowWriter.cell((cellContentWriter) => {
      cellContentWriter.write(specificationPoints
        ? specificationPoints
          .map((element) => element.toHtmlLink())
          .join(', ')
        : '&nbsp;');
    });

    // Conceptual Documentation Links and Synopsis
    rowWriter.class(`px-1 ${commonFeatureCellStyle}`);
    rowWriter.cell((cellContentWriter) => {
      let empty = true;

      const markdownRequires = requires
        ? `Requires: ${requires.map((featureNodePath) => `**${featureNodePath.join(': ')}**`).join(' | ')}`
        : null;
      const markdown = synopsis
        ? `${synopsis}${markdownRequires ? `\n${markdownRequires}` : ''}`
        : markdownRequires;

      if (documentationUrls) {
        const needComplexLayout = !!markdown;

        if (needComplexLayout) {
          // With Synopsis and Documentation URLs we need a more complex layout
          cellContentWriter.write('<div class="flex flex-row">'); // this div is closed below, after writing documentation URLs
          cellContentWriter.write(`<div class="grow">${marked.parse(markdown)}</div>`);
          cellContentWriter.write('<div class="grow-0">'); // this div is closed below, after writing documentation URLs
        }

        cellContentWriter.write(documentationUrls
          .map((element) => `<a class="btn btn-blue" href="${element}" target="_blank" rel="noopener">${titleForLink(element)}</a>`)
          .join(' '));

        if (needComplexLayout) {
          cellContentWriter.write('</div></div>');
        }

        empty = false;
      } else if (markdown) {
        // No Documentation URLs, so simply render the Synopsis.
        cellContentWriter.write(marked.parse(markdown));
        empty = false;
      }
      if (empty) {
        cellContentWriter.write('&nbsp;');
      }
    });
  }

  onCompliance(compliance, manifest, featureProperties) {
    const { rowWriter } = this;
    const { isHeading } = featureProperties;

    let colourClass = 'bg-red-400';
    let svg = crossSvg;
    if (compliance) {
      const { caveats, variants } = compliance;
      const hasPartialSupportForVariants = variants && manifest.isPartialVariantsCoverage(variants);
      if (hasPartialSupportForVariants || caveats) {
        colourClass = 'bg-amber-400';
        svg = partialSvg;
      } else {
        colourClass = 'bg-green-400';
        svg = tickSvg;
      }
    }

    rowWriter.class(`px-1 ${isHeading ? '' : colourClass} ${commonFeatureCellStyle}`);
    rowWriter.cell((cellContentWriter) => {
      cellContentWriter.write('<div class="flex justify-center">');
      cellContentWriter.write(isHeading ? '&nbsp;' : svg);
      cellContentWriter.write('</div>');
    });
  }

  onFeatureFinished() {
    this.tableWriter.finishRow();
    this.rowWriter = undefined;
  }

  // eslint-disable-next-line class-methods-use-this
  onIgnoredNode(level, description) {
    const consoleIndent = ' '.repeat(2).repeat(level);
    console.log(`${consoleIndent}"${description}"`);
  }
}

/**
 * Render column headings to a table row.
 *
 * @param {TableWriter} writer The HTML table writer to use.
 * @param {number} maximumLevel The maximum depth, previously measured.
 * @param {string[]} sdkManifestSuffixes In the order they're to be explored for each feature, same as supplied to the generator.
 */
function renderTableHeaderRow(writer, maximumLevel, sdkManifestSuffixes) {
  writer.class('align-top sticky top-0 bg-blue-700 text-white font-bold');
  const commonCellStyle = 'pt-2 pb-2 border-y-4 border-white border-r-4 sticky top-0 align-middle';
  writer.row((rowWriter) => {
    rowWriter.columnSpan(maximumLevel);
    rowWriter.class(`pr-1 text-center ${commonCellStyle}`);
    rowWriter.cell((cellContentWriter) => {
      cellContentWriter.text('Feature');
    });

    // Specification Points
    rowWriter.class(`px-1 ${commonCellStyle}`);
    rowWriter.cell((cellContentWriter) => {
      cellContentWriter.text('Specification');
    });

    // Conceptual Documentation Links and Synopsis
    rowWriter.class(`px-1 ${commonCellStyle}`);
    rowWriter.cell((cellContentWriter) => {
      cellContentWriter.text('Synopsis and Links to Conceptual Documentation');
    });

    // SDK columns
    // eslint-disable-next-line no-restricted-syntax
    sdkManifestSuffixes.forEach((sdkManifestSuffix) => {
      rowWriter.class(`px-1 ${commonCellStyle}`);
      rowWriter.cell((cellContentWriter) => {
        cellContentWriter.write('<div class="-rotate-180 m-auto vertical-lr">');
        cellContentWriter.text(sdkManifestSuffix);
        cellContentWriter.write('</div>');
      });
    });
  });
}

/**
 * Writes an HTML document to file, containing the rendered matrix.
 *
 * @param {string} outputFilePath Where to create the HTML document.
 * @param {MatrixGenerator} generator To be used to generate the matrix, where this implementation is the consumer.
 * @param {string[]} sdkManifestSuffixes In the order they're to be explored for each feature, same as supplied to the generator.
 * @param {number} levelCount The depth of the canonical features tree being rendered.
 */
const writeDocument = (outputFilePath, generator, sdkManifestSuffixes, levelCount) => {
  const documentWriter = new DocumentWriter(
    { title: `${subTitle} | ${title}` },
    fs.createWriteStream(outputFilePath),
  );

  documentWriter.document((contentWriter) => {
    contentWriter.h(1, `${title} ${subTitle}`);

    // Our convention, for this table, is borders to the right and bottom of cells.
    // (only exception being the top row, where there's also a border to the top)
    contentWriter.class('border-separate zero-border-spacing');

    contentWriter.table((tableWriter) => {
      renderTableHeaderRow(tableWriter, levelCount, sdkManifestSuffixes);

      // Second Pass: Render rows.
      generator.generate(levelCount, new TableRenderer(tableWriter));
    });
  });
};

/**
 * Returns a short title to be used as the button label for linking to the given URL.
 *
 * @param {url} url The URL to which the button will link.
 * @returns {string} A short title to be used as a button label.
 */
function titleForLink(url) {
  const titlesForPrefixes = [
    ['ably.com/blog', 'blog'],
    ['ably.com/docs', 'docs'],
    ['faqs.ably.com', 'faq'],
    ['github.com/ably/.*/issues', 'issue'],
  ];

  const foundPair = titlesForPrefixes.find((element) => (new RegExp(`https://${element[0]}/`)).test(url));
  return foundPair ? foundPair[1] : 'link';
}

module.exports = {
  writeDocument,
};


/***/ }),

/***/ 18656:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const escape = __nccwpck_require__(94070);
const fs = __nccwpck_require__(57147);

/**
 * Callback populating a table.
 *
 * @callback TableGenerator
 * @param {TableWriter} writer Used to create rows in the table.
 * @returns {void}
 */

/**
 * Callback populating a table row.
 *
 * @callback TableRowGenerator
 * @param {TableRowWriter} writer Used to create cells in the table row.
 * @returns {void}
 */

/**
 * Callback populating content.
 *
 * @callback ContentGenerator
 * @param {ContentWriter} writer Used to create content.
 * @returns {void}
 */

/**
 * Callback populating a document.
 *
 * @callback DocumentGenerator
 * @param {DocumentWriter} writer Used to create content.
 * @returns {void}
 */

class Writer {
  /**
   * @param {fs.WriteStream} writeStream The stream to wrap.
   */
  constructor(writeStream) {
    this.writeStream = writeStream;
  }

  class(classNames) {
    this.classAttributeValue = classNames;
  }

  /**
   * Consumes the attribute value(s) and then resets them to undefined.
   * The idea is that this method is called when the next element is generated.
   *
   * @returns {string[]} Zero or more attribute strings in `key=value` form.
   */
  useAttributes() {
    const classValue = this.classAttributeValue;
    this.classAttributeValue = undefined;
    return classValue ? [`class="${classValue}"`] : [];
  }

  /**
   * Write raw HTML.
   *
   * @param {string} chunk The raw contents to write.
   */
  write(chunk) {
    this.writeStream.write(chunk);
  }

  /**
   * Write plain text, with HTML special characters escaped.
   *
   * @param {string} text The plain text to write.
   */
  text(text) {
    this.write(escape(text));
  }
}

class ContentWriter extends Writer {
  h(depth, text) {
    const attributes = this.useAttributes();
    this.write(`<h${depth} ${attributes.join(' ')}>${escape(text)}</h${depth}>`);
  }

  /**
   * Create a table.
   *
   * @param {TableGenerator} generator Code to populate the table. Called synchronously.
   */
  table(generator) {
    const attributes = this.useAttributes();
    this.write(`<table ${attributes.join(' ')}>`);
    generator(new TableWriter(this.writeStream));
    this.write('</table>');
  }
}

/**
 * Utility wrapping a writeable stream, offering methods to fluidly write an HTML document to it.
 */
class DocumentWriter extends ContentWriter {
  constructor(properties, writeStream) {
    super(writeStream);
    this.properties = properties ?? {};
    this.documentCalled = false;
  }

  /**
   * Create the document.
   * This method may only be called once.
   *
   * @param {ContentGenerator} generator Code to populate the document. Called synchronously.
   */
  document(generator) {
    if (this.documentCalled) {
      throw new Error('Only a single document may be written for a single writer instance.');
    }
    this.documentCalled = true;

    this.write(`
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <link href="tailwind.css" rel="stylesheet">
          <title>${this.properties.title || 'Document'}</title>
        </head>
        <body>
          <div class="my-1 mx-2">
    `);
    generator(new ContentWriter(this.writeStream));
    this.write(`
          </div>
        </body>
      </html>
    `);
  }
}

class TableWriter extends Writer {
  /**
   * Create a table row.
   *
   * @param {TableRowGenerator} generator Code to populate the table row. Called synchronously.
   */
  row(generator) {
    generator(this.startRow());
    this.finishRow();
  }

  /**
   * Create a table row. The finishRow() method must be called after the row has been populated using the returned writer.
   *
   * @returns {TableRowWriter} The writer to be used to populate content for this row.
   */
  startRow() {
    if (this.inTableRow) {
      throw new Error('Already within startRow() for this TableWriter.');
    }

    const attributes = this.useAttributes();
    this.write(`<tr ${attributes.join(' ')}>`);
    this.inTableRow = true;
    return new TableRowWriter(this.writeStream);
  }

  /**
   * Finish a table row. This method must be called after a matching call to startRow().
   */
  finishRow() {
    if (!this.inTableRow) {
      throw new Error('Not seen startRow() for this TableWriter.');
    }

    this.write('</tr>');
    this.inTableRow = false;
  }
}

class TableRowWriter extends Writer {
  columnSpan(count) {
    this.columnSpanAttributeValue = count;
  }

  useAttributes() {
    const attributes = super.useAttributes();
    const columnSpanValue = this.columnSpanAttributeValue;
    this.columnSpanAttributeValue = undefined;
    return columnSpanValue ? [`colspan=${columnSpanValue}`, ...attributes] : attributes;
  }

  /**
   * Create a table cell.
   *
   * @param {ContentGenerator} generator Code to populate the table cell. Called synchronously.
   */
  cell(generator) {
    const attributes = this.useAttributes();
    this.write(`<td ${attributes.join(' ')}>`);
    generator(new ContentWriter(this.writeStream));
    this.write('</td>');
  }
}

module.exports = {
  DocumentWriter,
  TableWriter,
};


/***/ }),

/***/ 39046:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const {
  isPropertyKey,
  Properties,
} = __nccwpck_require__(92144);

const COMPLIANCE_KEY = 'compliance';
const VARIANTS_KEY = 'variants';

class Manifest {
  constructor(manifest, canonicalFeatures) {
    if (!(manifest instanceof Map)) {
      throw new Error('manifest should be a Map.');
    }
    if (!(manifest.get(COMPLIANCE_KEY) instanceof Map)) {
      throw new Error('manifest compliance should be a Map.');
    }
    assertFeatures(canonicalFeatures, [], manifest.get(COMPLIANCE_KEY));
    this.manifest = manifest;
  }

  /**
   * Locate a node indicating compliance with a particular feature.
   *
   * @param {string[]} featurePath The feature node names, from root, forming a path to the feature.
   * @returns {Properties|undefined} The manifest's compliance node properties, or `undefined` if a node doesn't exist.
   */
  find(featurePath) {
    let node = this.manifest.get(COMPLIANCE_KEY);
    let notFound = false;
    featurePath.forEach((featurePathComponent) => {
      if (node) {
        node = node.get(featurePathComponent);
        if (node === undefined) {
          notFound = true;
        } else if (node !== null && !(node instanceof Map)) {
          throw new Error(`manifest node with key '${featurePathComponent}' should be a Map but it is of type '${typeof node}'.`);
        }
      } else {
        notFound = true;
      }
    });
    if (notFound) {
      return undefined; // not found
    }
    return new Properties(node);
  }

  /**
   * Check whether a variants node property includes all canonically listed variants for this manifest.
   *
   * @param {string[]} variants The list of variants supported for a particular feature.
   * @returns {boolean} `true` if only a subset of the canonically listed variants are included.
   * @throws If the given variants list is of wrong type or empty, or there is no canonical list to refer to.
   */
  isPartialVariantsCoverage(variants) {
    if (!Array.isArray(variants)) {
      throw new Error('Expected an array (of strings).');
    }
    if (variants.length < 1) {
      throw new Error('Expected a non-empty array (of strings).');
    }
    const canonicalVariants = this.manifest.get(VARIANTS_KEY);
    if (!canonicalVariants || canonicalVariants.length < 1) {
      throw new Error('There is not a non-empty list of canonical variants to refer to.');
    }

    let isPartial = false;
    canonicalVariants.forEach((variant) => {
      if (!variants.includes(variant)) {
        isPartial = true;
      }
    });

    return isPartial;
  }
}

/**
 * Validates that all feature nodes in the manifest are listed in the canonical tree.
 *
 * @param {Map} canonicalNode The node in the canonical tree to inspect.
 * @param {string[]} path The path to this node, mainly for debugging errors but also to cap recursion depth.
 * @param {Map} manifestNode The node in the manifest to inspect.
 * @returns {number} The number of direct child nodes underlying manifestNode.
 * @throws If nodes aren't maps or if validation fails.
 */
function assertFeatures(canonicalNode, path, manifestNode) {
  if (path.length > 10) {
    throw new Error('Depth has exceeded arbitrary limit.');
  }
  if (!(manifestNode instanceof Map)) {
    throw new Error(`Manifest node is not a Map at path "${path}". Type is "${typeof manifestNode}", Stringified Value is "${manifestNode}".`);
  }
  if (!(canonicalNode instanceof Map) && canonicalNode !== null) {
    throw new Error(`Canonical node is not a Map, or null, at path "${path}". Type is "${typeof canonicalNode}", Stringified Value is "${canonicalNode}".`);
  }

  let directChildCount = 0;
  manifestNode.forEach((value, key) => {
    if (!isPropertyKey(key)) {
      const fullPath = [...path, key];
      if (!(canonicalNode instanceof Map)) {
        throw new Error(`Canonical node is not a Map at path "${path}". Type is "${typeof canonicalNode}", Stringified Value is "${canonicalNode}".`);
      }
      const canonicalValue = canonicalNode.get(key);
      if (canonicalValue === undefined) {
        throw new Error(`Canonical node not found for manifest node at path "${fullPath}".`);
      }

      // value will be null here where the key in the YAML document doesn't have an explicit value,
      // typically a Map, Array or string. e.g. in the case of nullValue here:
      //
      // %YAML 1.2
      // ---
      // arrayValue:
      //   - arrayElement
      // nullValue:
      // mapValue:
      //   mapKey: mapValue
      // stringValue: Hello World

      let hasNoChildren = true;
      if (value !== null) {
        hasNoChildren = (assertFeatures(canonicalValue, fullPath, value) < 1);
      }

      const canonicalProperties = new Properties(canonicalValue);
      if (hasNoChildren && canonicalProperties.isHeading) {
        throw new Error(`Canonical node is a Header at path "${fullPath}", yet the manifest node has no children.`);
      }

      directChildCount += 1;
    }
  });

  return directChildCount;
}

module.exports = {
  Manifest,
};


/***/ }),

/***/ 55091:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { compareKeys } = __nccwpck_require__(48782);
const { Manifest } = __nccwpck_require__(39046);
const { isPropertyKey, Properties } = __nccwpck_require__(92144);

/**
 * Abstract class (interface) implemented by users of {@link MatrixGenerator#generate}.
 *
 * Implementations of this protocol may be supplied in order to receive callbacks while inspecting the canonical feature
 * list alongside SDK manifests.
 *
 * @interface
 */
class MatrixConsumer {
  /**
   * Called first, upon encountering a feature, before any calls to {@link #onCompliance}.
   *
   * @param {string[]} parentKeys The names of the feature nodes forming the hierarchy above this feature node.
   * @param {string} key The name of this feature node.
   * @param {Properties} properties Of this feature node.
   * @param {number} maximumLevel The maximum depth, previously measured or arbitrary.
   */
  // eslint-disable-next-line class-methods-use-this, no-unused-vars
  onFeature(parentKeys, key, properties, maximumLevel) {
    throw new Error('Not implemented.');
  }

  /**
   * Called one or more times, once for each manifest, for each each feature.
   *
   * @param {Properties|undefined} compliance Of the manifest's compliance node, or `undefined` if compliance not indicated.
   * @param {Manifest} manifest From which this compliance was deduced.
   * @param {Properties} featureProperties Of the feature for which this compliance applies.
   */
  // eslint-disable-next-line class-methods-use-this, no-unused-vars
  onCompliance(compliance, manifest, featureProperties) {
    throw new Error('Not implemented.');
  }

  /**
   * Called last, per feature, once all calls to {@link #onCompliance} have been completed for that feature.
   */
  // eslint-disable-next-line class-methods-use-this
  onFeatureFinished() {
    throw new Error('Not implemented.');
  }

  /**
   * Called when generating if a node was encountered which hasn't been processed. Implementors should log this
   * information somewhere in case it is needed for debugging purposes.
   *
   * @param {number} level The depth within the hierarchy at which this feature node was found.
   * @param {string} description Of this feature node.
   */
  // eslint-disable-next-line class-methods-use-this, no-unused-vars
  onIgnoredNode(level, description) {
    throw new Error('Not implemented.');
  }
}

/**
 * A no-op implementation of MatrixConsumer.
 *
 * @implements {MatrixConsumer}
 */
class VoidConsumer extends MatrixConsumer {
  // eslint-disable-next-line class-methods-use-this
  onFeature() { }

  // eslint-disable-next-line class-methods-use-this
  onCompliance() { }

  // eslint-disable-next-line class-methods-use-this
  onFeatureFinished() { }

  // eslint-disable-next-line class-methods-use-this
  onIgnoredNode() { }
}

class MatrixGenerator {
  /**
   * @param {Map} canonicalFeatureList The canonical feature list.
   * @param {Manifest[]} manifests In the order they're to be explored for each feature.
   */
  constructor(canonicalFeatureList, manifests) {
    this.canonicalFeatureList = canonicalFeatureList;
    this.manifests = manifests;
  }

  /**
   * Inspect the canonical tree from the root node, optionally calling the consumer as that exploration progresses.
   *
   * @param {number} maximumDepth The maximum depth, previously measured or arbitrary.
   * @param {MatrixConsumer} [consumer] To be called during the exploration.
   * @returns {number} The number of levels found.
   */
  generate(maximumDepth, consumer) {
    return generateMatrix(
      this.manifests,
      consumer ?? new VoidConsumer(),
      maximumDepth,
      [],
      this.canonicalFeatureList,
    );
  }
}

/**
 * Inspect a node, and it's children, optionally rendering to table rows.
 *
 * @param {Manifest[]} manifests In the order they're to be explored for each feature.
 * @param {MatrixConsumer} consumer Call during the generation process.
 * @param {number} maximumLevel The maximum depth, previously measured or arbitrary.
 * @param {string[]} parentKeys Parent keys, also indicating the depth of this node. Nodes at root have an empty array.
 * @param {*} node The canonical feature node.
 * @returns {number} The number of levels, including this node and its children.
 */
function generateMatrix(manifests, consumer, maximumLevel, parentKeys, node) {
  const level = parentKeys.length;
  if (level > maximumLevel) {
    throw new Error(`Maximum depth limit exceeded (${maximumLevel}).`);
  }

  let maximumDepth = 0;
  if (node instanceof Map) {
    const sortedKeys = Array.from(node.keys()).sort(compareKeys);
    sortedKeys.forEach((key) => {
      const value = node.get(key);
      if (!isPropertyKey(key)) {
        const properties = new Properties(value);

        consumer.onFeature(parentKeys, key, properties, maximumLevel);
        manifests.forEach((manifest) => {
          const compliance = manifest.find([...parentKeys, key]);
          consumer.onCompliance(compliance, manifest, properties);
        });
        consumer.onFeatureFinished();

        const depth = generateMatrix(manifests, consumer, maximumLevel, [...parentKeys, key], value);
        maximumDepth = Math.max(maximumDepth, 1 + depth);
      }
    });
  } else if (Array.isArray(node)) {
    node.forEach((element) => {
      const depth = generateMatrix(manifests, consumer, maximumLevel, parentKeys, element);
      maximumDepth = Math.max(maximumDepth, depth);
    });
  } else if (node instanceof String || typeof node === 'string') {
    if (consumer) {
      consumer.onIgnoredNode(level, `${node}`);
    }
    maximumDepth = 1;
  } else if (node === null) {
    // the value for a key with no value defined
  } else if (consumer) {
    // informational only, while debugging
    consumer.onIgnoredNode(level, `${typeof node} = ${node}`);
  }

  return maximumDepth;
}

module.exports = {
  MatrixGenerator,
  MatrixConsumer,
};


/***/ }),

/***/ 92144:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const escape = __nccwpck_require__(94070);

const {
  IDENTITY_TRANSFORM,
  transformPath,
  transformString,
  transformStrings,
} = __nccwpck_require__(12699);

const isPropertyKey = (key) => key.startsWith('.');
const propertyKeyName = (key) => key.substring(1);

const specificationPointRegExp = /^[A-Z]{1,3}[1-9]\d*([a-z]((([1-9]\d*)?[a-z])?([1-9]\d*)?)?)?$/;

class SpecificationPoint {
  constructor(value) {
    if (!specificationPointRegExp.test(value)) {
      throw new Error(`Value '${value}' is not formatted like a specification point.`);
    }
    this.value = value;
  }

  toString() {
    return this.value;
  }

  toHtmlLink() {
    const url = `https://sdk.ably.com/builds/ably/specification/main/features/#${this.value}`;
    return `<a href="${url}" target="_blank" rel="noopener"><code>${escape(this.value)}</code></a>`;
  }
}

class Properties {
  constructor(node) {
    if (!(node instanceof Map)) {
      return; // nothing to be extracted
    }
    node.forEach((value, key) => {
      if (isPropertyKey(key)) {
        const name = propertyKeyName(key);
        switch (name) {
          case 'caveats':
            // used in the canonical features list
            this.caveats = transformString(value, IDENTITY_TRANSFORM);
            break;

          case 'class':
            // used in the canonical features list
            if (transformString(value, IDENTITY_TRANSFORM) !== 'Heading') {
              throw new Error("Class value is not recognised, expected 'Heading'.");
            }
            this.isHeading = true;
            break;

          case 'documentation':
            // used in the canonical features list
            this.documentationUrls = transformStrings(value, (stringValue) => new URL(stringValue));
            break;

          case 'requires':
            // used in the canonical features list
            this.requires = transformStrings(value, transformPath);
            break;

          case 'specification':
            // used in the canonical features list
            this.specificationPoints = transformStrings(value, (stringValue) => new SpecificationPoint(stringValue));
            break;

          case 'synopsis':
            // used in the canonical features list
            this.synopsis = transformString(value, IDENTITY_TRANSFORM);
            break;

          case 'variants':
            // used in the SDK manifests
            this.variants = transformStrings(value, IDENTITY_TRANSFORM);
            break;

          default:
            throw new Error(`Property key '${name}' is not recognised.`);
        }
      }
    });
  }
}

module.exports = {
  isPropertyKey,
  Properties,
  SpecificationPoint,
};


/***/ }),

/***/ 12699:
/***/ ((module) => {

const IDENTITY_TRANSFORM = (value) => value;

const isString = (value) => value instanceof String || typeof value === 'string';

/**
 * Callback transforming a string.
 *
 * @callback StringTransformer
 * @param {string} value The string to be transformed.
 * @returns {*} The result of transforming the string.
 */

/**
 * Creates a new array populated with one or more strings, each representing a segment of a path.
 *
 * @param {string} value A single string, representing a path, with segments delimited by ': '.
 * @returns {string[]} The path segments. Will never have zero length.
 * @throws If the provided value was not a string or could not be parsed as path segments.
 */
function transformPath(value) {
  if (!isString(value)) {
    throw new Error(`Encountered value of type '${typeof value}' (${value}) when expecting a string path.`);
  }

  const segments = value.split(': ');
  segments.forEach((segment, segmentIndex) => {
    const errorContext = () => `in segment #${segmentIndex} '${segment}' when parsing path value '${value}'.`;
    const trimmed = segment.trim();
    if (trimmed.length < 1) {
      throw new Error('Empty or whitespace-only'.concat(errorContext()));
    }
    if (trimmed !== segment) {
      throw new Error('Spurious leading or trailing whitespace'.concat(errorContext()));
    }
    if (segment.includes(':')) {
      throw new Error("Illegal character ':'".concat(errorContext()));
    }
  });

  return segments;
}

/**
 * Creates a new array populated with the results of calling a provided function with one
 * or more string values.
 *
 * Supported Translations:
 * - string => [string]
 * - [string1, string2] => [string1, string2]
 *
 * @param {string|string[]} value A single string, or an array of strings.
 * @param {StringTransformer} transformer A function to be called with each string.
 * @returns {*[]} The results of transforming the string(s).
 * @throws If no values were provided or some values were not strings.
 */
function transformStrings(value, transformer) {
  if (value === null || value === undefined) {
    throw new Error('The value may not be null or undefined.');
  }
  const array = Array.isArray(value) ? value : [value];
  if (array.length < 1) {
    throw new Error('No values to transform.');
  }
  return array.map((element) => transformString(element, transformer));
}

/**
 * Returns the result of calling a provided function with a string value.
 *
 * @param {string} value A single string.
 * @param {StringTransformer} transformer A function to be called with the string.
 * @returns {*} The result of transforming the string.
 * @throws If the value provided is not a string.
 */
function transformString(value, transformer) {
  if (isString(value)) {
    return transformer(value);
  }
  throw new Error(`Encountered '${typeof value}' (${value}) when expecting a string.`);
}

module.exports = {
  IDENTITY_TRANSFORM,
  transformPath,
  transformStrings,
  transformString,
  isString,
};


/***/ }),

/***/ 19398:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { compareKeys } = __nccwpck_require__(48782);

/**
 * Inspects YAML AST to ensure source constraints are met (e.g. ordered keys).
 * Used as our First Parse: using YAML's mid-level API, rendering a graph of the YAML structure,
 * and then running some of our checks over that structure to check foundational requirements.
 *
 * @param {*} astNode The YAML AST node.
 * @param {string[]} parentKeys Parent keys, also indicating the depth of this node. Nodes at root have an empty array.
 */
function validateStructure(astNode, parentKeys = []) {
  if (astNode === undefined || astNode === null) {
    throw new Error(`Unexpected - astNode value cannot be undefined or null at "${parentKeys}".`);
  }
  if (parentKeys.length > 20) {
    throw new Error('Recursion depth exceeded arbitrary limit.');
  }

  const nodeType = astNode.type;
  let arrayIndex = 0;
  switch (nodeType) {
    case 'MAP':
      validateMapItems(astNode.items, parentKeys);
      break;

    case 'FLOW_SEQ':
    case 'SEQ':
      astNode.items.forEach((item) => {
        validateStructure(item, [...parentKeys, `${arrayIndex}`]);
        arrayIndex += 1;
      });
      break;

    case 'PLAIN':
    case 'BLOCK_LITERAL':
    case 'QUOTE_SINGLE':
      break;

    default:
      throw new Error(`Unhandled YAML AST node type "${nodeType}".`);
  }
}

/**
 * Inspects items of YAML AST map to ensure source constraints are met.
 *
 * @param {*[]} items The YAML AST 'MAP' node items.
 * @param {string[]} parentKeys Parent keys, also indicating the depth of this node. Nodes at root have an empty array.
 */
function validateMapItems(items, parentKeys) {
  let previousKeyValue;
  items.forEach((item) => {
    if (item.type !== 'PAIR') {
      throw new Error('Map items should be pairs.');
    }

    const { key, value } = item;
    if (key.type !== 'PLAIN') {
      throw new Error('Map keys must be plain scalars.');
    }
    const keyValue = key.value;

    if (previousKeyValue && compareKeys(keyValue, previousKeyValue) < 0) {
      throw new Error(`Keys not sorted ("${keyValue}" should not be after "${previousKeyValue}").`);
    }
    previousKeyValue = keyValue;

    // It is normal for `value` to be `null` here, where the map key is 'hanging' in the YAML - e.g. in the case of the
    // 'Hanging Parent Key' in this snippet:
    //
    // ```yaml
    // Some Parent Key:
    //   Hanging Parent Key:
    //   Some Other Key that Does have a Value: Hello World
    // ```
    //
    // The hanging key represents that there is intended to be a node at this location in the tree, but that there is
    // no additional information to convey about this node - above and beyond its name (the key).
    if (value !== null) {
      validateStructure(value, [...parentKeys, key]);
    }
  });
}

module.exports = {
  validateStructure,
};


/***/ }),

/***/ 87351:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__nccwpck_require__(22037));
const utils_1 = __nccwpck_require__(5278);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 42186:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __nccwpck_require__(87351);
const file_command_1 = __nccwpck_require__(717);
const utils_1 = __nccwpck_require__(5278);
const os = __importStar(__nccwpck_require__(22037));
const path = __importStar(__nccwpck_require__(71017));
const oidc_utils_1 = __nccwpck_require__(98041);
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));
    }
    command_1.issueCommand('set-env', { name }, convertedVal);
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueFileCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    if (options && options.trimWhitespace === false) {
        return inputs;
    }
    return inputs.map(input => input.trim());
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    const filePath = process.env['GITHUB_OUTPUT'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));
    }
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function error(message, properties = {}) {
    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds a warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function warning(message, properties = {}) {
    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Adds a notice issue
 * @param message notice issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function notice(message, properties = {}) {
    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.notice = notice;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    const filePath = process.env['GITHUB_STATE'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));
    }
    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
function getIDToken(aud) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
}
exports.getIDToken = getIDToken;
/**
 * Summary exports
 */
var summary_1 = __nccwpck_require__(81327);
Object.defineProperty(exports, "summary", ({ enumerable: true, get: function () { return summary_1.summary; } }));
/**
 * @deprecated use core.summary
 */
var summary_2 = __nccwpck_require__(81327);
Object.defineProperty(exports, "markdownSummary", ({ enumerable: true, get: function () { return summary_2.markdownSummary; } }));
/**
 * Path exports
 */
var path_utils_1 = __nccwpck_require__(2981);
Object.defineProperty(exports, "toPosixPath", ({ enumerable: true, get: function () { return path_utils_1.toPosixPath; } }));
Object.defineProperty(exports, "toWin32Path", ({ enumerable: true, get: function () { return path_utils_1.toWin32Path; } }));
Object.defineProperty(exports, "toPlatformPath", ({ enumerable: true, get: function () { return path_utils_1.toPlatformPath; } }));
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 717:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__nccwpck_require__(57147));
const os = __importStar(__nccwpck_require__(22037));
const uuid_1 = __nccwpck_require__(75840);
const utils_1 = __nccwpck_require__(5278);
function issueFileCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueFileCommand = issueFileCommand;
function prepareKeyValueMessage(key, value) {
    const delimiter = `ghadelimiter_${uuid_1.v4()}`;
    const convertedValue = utils_1.toCommandValue(value);
    // These should realistically never happen, but just in case someone finds a
    // way to exploit uuid generation let's not allow keys or values that contain
    // the delimiter.
    if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    }
    if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    }
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
}
exports.prepareKeyValueMessage = prepareKeyValueMessage;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 98041:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OidcClient = void 0;
const http_client_1 = __nccwpck_require__(96255);
const auth_1 = __nccwpck_require__(35526);
const core_1 = __nccwpck_require__(42186);
class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
        };
        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
        if (!token) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
        }
        return token;
    }
    static getIDTokenUrl() {
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
        if (!runtimeUrl) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
        }
        return runtimeUrl;
    }
    static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient();
            const res = yield httpclient
                .getJson(id_token_url)
                .catch(error => {
                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.result.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
                throw new Error('Response json body do not have ID Token field');
            }
            return id_token;
        });
    }
    static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // New ID Token is requested from action service
                let id_token_url = OidcClient.getIDTokenUrl();
                if (audience) {
                    const encodedAudience = encodeURIComponent(audience);
                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                }
                core_1.debug(`ID token url is ${id_token_url}`);
                const id_token = yield OidcClient.getCall(id_token_url);
                core_1.setSecret(id_token);
                return id_token;
            }
            catch (error) {
                throw new Error(`Error message: ${error.message}`);
            }
        });
    }
}
exports.OidcClient = OidcClient;
//# sourceMappingURL=oidc-utils.js.map

/***/ }),

/***/ 2981:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
const path = __importStar(__nccwpck_require__(71017));
/**
 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
 * replaced with /.
 *
 * @param pth. Path to transform.
 * @return string Posix path.
 */
function toPosixPath(pth) {
    return pth.replace(/[\\]/g, '/');
}
exports.toPosixPath = toPosixPath;
/**
 * toWin32Path converts the given path to the win32 form. On Linux, / will be
 * replaced with \\.
 *
 * @param pth. Path to transform.
 * @return string Win32 path.
 */
function toWin32Path(pth) {
    return pth.replace(/[/]/g, '\\');
}
exports.toWin32Path = toWin32Path;
/**
 * toPlatformPath converts the given path to a platform-specific path. It does
 * this by replacing instances of / and \ with the platform-specific path
 * separator.
 *
 * @param pth The path to platformize.
 * @return string The platform-specific path.
 */
function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
}
exports.toPlatformPath = toPlatformPath;
//# sourceMappingURL=path-utils.js.map

/***/ }),

/***/ 81327:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
const os_1 = __nccwpck_require__(22037);
const fs_1 = __nccwpck_require__(57147);
const { access, appendFile, writeFile } = fs_1.promises;
exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
class Summary {
    constructor() {
        this._buffer = '';
    }
    /**
     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
     * Also checks r/w permissions.
     *
     * @returns step summary file path
     */
    filePath() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._filePath) {
                return this._filePath;
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
            if (!pathFromEnv) {
                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
            }
            try {
                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
            }
            catch (_a) {
                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
            }
            this._filePath = pathFromEnv;
            return this._filePath;
        });
    }
    /**
     * Wraps content in an HTML tag, adding any HTML attributes
     *
     * @param {string} tag HTML tag to wrap
     * @param {string | null} content content within the tag
     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
     *
     * @returns {string} content wrapped in HTML element
     */
    wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('');
        if (!content) {
            return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    /**
     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
     *
     * @param {SummaryWriteOptions} [options] (optional) options for write operation
     *
     * @returns {Promise<Summary>} summary instance
     */
    write(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
            const filePath = yield this.filePath();
            const writeFunc = overwrite ? writeFile : appendFile;
            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
            return this.emptyBuffer();
        });
    }
    /**
     * Clears the summary buffer and wipes the summary file
     *
     * @returns {Summary} summary instance
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true });
        });
    }
    /**
     * Returns the current summary buffer as a string
     *
     * @returns {string} string of summary buffer
     */
    stringify() {
        return this._buffer;
    }
    /**
     * If the summary buffer is empty
     *
     * @returns {boolen} true if the buffer is empty
     */
    isEmptyBuffer() {
        return this._buffer.length === 0;
    }
    /**
     * Resets the summary buffer without writing to summary file
     *
     * @returns {Summary} summary instance
     */
    emptyBuffer() {
        this._buffer = '';
        return this;
    }
    /**
     * Adds raw text to the summary buffer
     *
     * @param {string} text content to add
     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
     *
     * @returns {Summary} summary instance
     */
    addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
    }
    /**
     * Adds the operating system-specific end-of-line marker to the buffer
     *
     * @returns {Summary} summary instance
     */
    addEOL() {
        return this.addRaw(os_1.EOL);
    }
    /**
     * Adds an HTML codeblock to the summary buffer
     *
     * @param {string} code content to render within fenced code block
     * @param {string} lang (optional) language to syntax highlight code
     *
     * @returns {Summary} summary instance
     */
    addCodeBlock(code, lang) {
        const attrs = Object.assign({}, (lang && { lang }));
        const element = this.wrap('pre', this.wrap('code', code), attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML list to the summary buffer
     *
     * @param {string[]} items list of items to render
     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
     *
     * @returns {Summary} summary instance
     */
    addList(items, ordered = false) {
        const tag = ordered ? 'ol' : 'ul';
        const listItems = items.map(item => this.wrap('li', item)).join('');
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML table to the summary buffer
     *
     * @param {SummaryTableCell[]} rows table rows
     *
     * @returns {Summary} summary instance
     */
    addTable(rows) {
        const tableBody = rows
            .map(row => {
            const cells = row
                .map(cell => {
                if (typeof cell === 'string') {
                    return this.wrap('td', cell);
                }
                const { header, data, colspan, rowspan } = cell;
                const tag = header ? 'th' : 'td';
                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
                return this.wrap(tag, data, attrs);
            })
                .join('');
            return this.wrap('tr', cells);
        })
            .join('');
        const element = this.wrap('table', tableBody);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds a collapsable HTML details element to the summary buffer
     *
     * @param {string} label text for the closed state
     * @param {string} content collapsable content
     *
     * @returns {Summary} summary instance
     */
    addDetails(label, content) {
        const element = this.wrap('details', this.wrap('summary', label) + content);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML image tag to the summary buffer
     *
     * @param {string} src path to the image you to embed
     * @param {string} alt text description of the image
     * @param {SummaryImageOptions} options (optional) addition image attributes
     *
     * @returns {Summary} summary instance
     */
    addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML section heading element
     *
     * @param {string} text heading text
     * @param {number | string} [level=1] (optional) the heading level, default: 1
     *
     * @returns {Summary} summary instance
     */
    addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
            ? tag
            : 'h1';
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML thematic break (<hr>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addSeparator() {
        const element = this.wrap('hr', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML line break (<br>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addBreak() {
        const element = this.wrap('br', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML blockquote to the summary buffer
     *
     * @param {string} text quote text
     * @param {string} cite (optional) citation url
     *
     * @returns {Summary} summary instance
     */
    addQuote(text, cite) {
        const attrs = Object.assign({}, (cite && { cite }));
        const element = this.wrap('blockquote', text, attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML anchor tag to the summary buffer
     *
     * @param {string} text link text/content
     * @param {string} href hyperlink
     *
     * @returns {Summary} summary instance
     */
    addLink(text, href) {
        const element = this.wrap('a', text, { href });
        return this.addRaw(element).addEOL();
    }
}
const _summary = new Summary();
/**
 * @deprecated use `core.summary`
 */
exports.markdownSummary = _summary;
exports.summary = _summary;
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ 5278:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandProperties = exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
/**
 *
 * @param annotationProperties
 * @returns The command properties to send with the actual annotation command
 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
 */
function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
        return {};
    }
    return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
    };
}
exports.toCommandProperties = toCommandProperties;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 35526:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
class BasicCredentialHandler {
    constructor(username, password) {
        this.username = username;
        this.password = password;
    }
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BasicCredentialHandler = BasicCredentialHandler;
class BearerCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Bearer ${this.token}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BearerCredentialHandler = BearerCredentialHandler;
class PersonalAccessTokenCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
//# sourceMappingURL=auth.js.map

/***/ }),

/***/ 96255:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
const http = __importStar(__nccwpck_require__(13685));
const https = __importStar(__nccwpck_require__(95687));
const pm = __importStar(__nccwpck_require__(19835));
const tunnel = __importStar(__nccwpck_require__(74294));
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                let output = Buffer.alloc(0);
                this.message.on('data', (chunk) => {
                    output = Buffer.concat([output, chunk]);
                });
                this.message.on('end', () => {
                    resolve(output.toString());
                });
            }));
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
        });
    }
    get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('GET', requestUrl, null, additionalHeaders || {});
        });
    }
    del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
        });
    }
    post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('POST', requestUrl, data, additionalHeaders || {});
        });
    }
    patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
        });
    }
    put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PUT', requestUrl, data, additionalHeaders || {});
        });
    }
    head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
        });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders);
        });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            const res = yield this.get(requestUrl, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.post(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.put(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.patch(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._disposed) {
                throw new Error('Client has already been disposed.');
            }
            const parsedUrl = new URL(requestUrl);
            let info = this._prepareRequest(verb, parsedUrl, headers);
            // Only perform retries on reads since writes may not be idempotent.
            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
                ? this._maxRetries + 1
                : 1;
            let numTries = 0;
            let response;
            do {
                response = yield this.requestRaw(info, data);
                // Check if it's an authentication challenge
                if (response &&
                    response.message &&
                    response.message.statusCode === HttpCodes.Unauthorized) {
                    let authenticationHandler;
                    for (const handler of this.handlers) {
                        if (handler.canHandleAuthentication(response)) {
                            authenticationHandler = handler;
                            break;
                        }
                    }
                    if (authenticationHandler) {
                        return authenticationHandler.handleAuthentication(this, info, data);
                    }
                    else {
                        // We have received an unauthorized response but have no handlers to handle it.
                        // Let the response return to the caller.
                        return response;
                    }
                }
                let redirectsRemaining = this._maxRedirects;
                while (response.message.statusCode &&
                    HttpRedirectCodes.includes(response.message.statusCode) &&
                    this._allowRedirects &&
                    redirectsRemaining > 0) {
                    const redirectUrl = response.message.headers['location'];
                    if (!redirectUrl) {
                        // if there's no location to redirect to, we won't
                        break;
                    }
                    const parsedRedirectUrl = new URL(redirectUrl);
                    if (parsedUrl.protocol === 'https:' &&
                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                        !this._allowRedirectDowngrade) {
                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                    }
                    // we need to finish reading the response before reassigning response
                    // which will leak the open socket.
                    yield response.readBody();
                    // strip authorization header if redirected to a different hostname
                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                        for (const header in headers) {
                            // header names are case insensitive
                            if (header.toLowerCase() === 'authorization') {
                                delete headers[header];
                            }
                        }
                    }
                    // let's make the request with the new redirectUrl
                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                    response = yield this.requestRaw(info, data);
                    redirectsRemaining--;
                }
                if (!response.message.statusCode ||
                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                    // If not a retry code, return immediately instead of retrying
                    return response;
                }
                numTries += 1;
                if (numTries < maxTries) {
                    yield response.readBody();
                    yield this._performExponentialBackoff(numTries);
                }
            } while (numTries < maxTries);
            return response;
        });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                function callbackForResult(err, res) {
                    if (err) {
                        reject(err);
                    }
                    else if (!res) {
                        // If `err` is not passed, then `res` must be passed.
                        reject(new Error('Unknown error'));
                    }
                    else {
                        resolve(res);
                    }
                }
                this.requestRawWithCallback(info, data, callbackForResult);
            });
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        if (typeof data === 'string') {
            if (!info.options.headers) {
                info.options.headers = {};
            }
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        function handleResult(err, res) {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        }
        const req = info.httpModule.request(info.options, (msg) => {
            const res = new HttpClientResponse(msg);
            handleResult(undefined, res);
        });
        let socket;
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            for (const handler of this.handlers) {
                handler.prepareRequest(info.options);
            }
        }
        return info;
    }
    _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
        if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
                maxSockets,
                keepAlive: this._keepAlive,
                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                })), { host: proxyUrl.hostname, port: proxyUrl.port })
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
            return new Promise(resolve => setTimeout(() => resolve(), ms));
        });
    }
    _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const statusCode = res.message.statusCode || 0;
                const response = {
                    statusCode,
                    result: null,
                    headers: {}
                };
                // not found leads to null obj returned
                if (statusCode === HttpCodes.NotFound) {
                    resolve(response);
                }
                // get the result from the body
                function dateTimeDeserializer(key, value) {
                    if (typeof value === 'string') {
                        const a = new Date(value);
                        if (!isNaN(a.valueOf())) {
                            return a;
                        }
                    }
                    return value;
                }
                let obj;
                let contents;
                try {
                    contents = yield res.readBody();
                    if (contents && contents.length > 0) {
                        if (options && options.deserializeDates) {
                            obj = JSON.parse(contents, dateTimeDeserializer);
                        }
                        else {
                            obj = JSON.parse(contents);
                        }
                        response.result = obj;
                    }
                    response.headers = res.message.headers;
                }
                catch (err) {
                    // Invalid resource (contents not json);  leaving result obj null
                }
                // note that 3xx redirects are handled by the http layer.
                if (statusCode > 299) {
                    let msg;
                    // if exception/error in body, attempt to get better error
                    if (obj && obj.message) {
                        msg = obj.message;
                    }
                    else if (contents && contents.length > 0) {
                        // it may be the case that the exception is in the body message as string
                        msg = contents;
                    }
                    else {
                        msg = `Failed request: (${statusCode})`;
                    }
                    const err = new HttpClientError(msg, statusCode);
                    err.result = response.result;
                    reject(err);
                }
                else {
                    resolve(response);
                }
            }));
        });
    }
}
exports.HttpClient = HttpClient;
const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 19835:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkBypass = exports.getProxyUrl = void 0;
function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === 'https:';
    if (checkBypass(reqUrl)) {
        return undefined;
    }
    const proxyVar = (() => {
        if (usingSsl) {
            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
        }
        else {
            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
        }
    })();
    if (proxyVar) {
        return new URL(proxyVar);
    }
    else {
        return undefined;
    }
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (const upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperReqHosts.some(x => x === upperNoProxyItem)) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;
//# sourceMappingURL=proxy.js.map

/***/ }),

/***/ 63803:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
const fs = __nccwpck_require__(57147);
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;


/***/ }),

/***/ 18838:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
const NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.');
if (NODE_PROCESS_VERSION_PARTS[0] === undefined || NODE_PROCESS_VERSION_PARTS[1] === undefined) {
    throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
}
const MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
const MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
const SUPPORTED_MAJOR_VERSION = 10;
const SUPPORTED_MINOR_VERSION = 10;
const IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
const IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
/**
 * IS `true` for Node.js 10.10 and greater.
 */
exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;


/***/ }),

/***/ 75667:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Settings = exports.scandirSync = exports.scandir = void 0;
const async = __nccwpck_require__(84507);
const sync = __nccwpck_require__(69560);
const settings_1 = __nccwpck_require__(88662);
exports.Settings = settings_1.default;
function scandir(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
}
exports.scandir = scandir;
function scandirSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
}
exports.scandirSync = scandirSync;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),

/***/ 84507:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
const fsStat = __nccwpck_require__(70109);
const rpl = __nccwpck_require__(75288);
const constants_1 = __nccwpck_require__(18838);
const utils = __nccwpck_require__(16297);
const common = __nccwpck_require__(3847);
function read(directory, settings, callback) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
    }
    readdir(directory, settings, callback);
}
exports.read = read;
function readdirWithFileTypes(directory, settings, callback) {
    settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
            callFailureCallback(callback, readdirError);
            return;
        }
        const entries = dirents.map((dirent) => ({
            dirent,
            name: dirent.name,
            path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
            callSuccessCallback(callback, entries);
            return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
            if (rplError !== null) {
                callFailureCallback(callback, rplError);
                return;
            }
            callSuccessCallback(callback, rplEntries);
        });
    });
}
exports.readdirWithFileTypes = readdirWithFileTypes;
function makeRplTaskEntry(entry, settings) {
    return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
            done(null, entry);
            return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    done(statError);
                    return;
                }
                done(null, entry);
                return;
            }
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            done(null, entry);
        });
    };
}
function readdir(directory, settings, callback) {
    settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
            callFailureCallback(callback, readdirError);
            return;
        }
        const tasks = names.map((name) => {
            const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
            return (done) => {
                fsStat.stat(path, settings.fsStatSettings, (error, stats) => {
                    if (error !== null) {
                        done(error);
                        return;
                    }
                    const entry = {
                        name,
                        path,
                        dirent: utils.fs.createDirentFromStats(name, stats)
                    };
                    if (settings.stats) {
                        entry.stats = stats;
                    }
                    done(null, entry);
                });
            };
        });
        rpl(tasks, (rplError, entries) => {
            if (rplError !== null) {
                callFailureCallback(callback, rplError);
                return;
            }
            callSuccessCallback(callback, entries);
        });
    });
}
exports.readdir = readdir;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, result) {
    callback(null, result);
}


/***/ }),

/***/ 3847:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.joinPathSegments = void 0;
function joinPathSegments(a, b, separator) {
    /**
     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
     */
    if (a.endsWith(separator)) {
        return a + b;
    }
    return a + separator + b;
}
exports.joinPathSegments = joinPathSegments;


/***/ }),

/***/ 69560:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
const fsStat = __nccwpck_require__(70109);
const constants_1 = __nccwpck_require__(18838);
const utils = __nccwpck_require__(16297);
const common = __nccwpck_require__(3847);
function read(directory, settings) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
    }
    return readdir(directory, settings);
}
exports.read = read;
function readdirWithFileTypes(directory, settings) {
    const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
    return dirents.map((dirent) => {
        const entry = {
            dirent,
            name: dirent.name,
            path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
            try {
                const stats = settings.fs.statSync(entry.path);
                entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            }
            catch (error) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    throw error;
                }
            }
        }
        return entry;
    });
}
exports.readdirWithFileTypes = readdirWithFileTypes;
function readdir(directory, settings) {
    const names = settings.fs.readdirSync(directory);
    return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
            name,
            path: entryPath,
            dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
            entry.stats = stats;
        }
        return entry;
    });
}
exports.readdir = readdir;


/***/ }),

/***/ 88662:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __nccwpck_require__(71017);
const fsStat = __nccwpck_require__(70109);
const fs = __nccwpck_require__(63803);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this.followSymbolicLinks,
            fs: this.fs,
            throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
exports["default"] = Settings;


/***/ }),

/***/ 60883:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDirentFromStats = void 0;
class DirentFromStats {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
exports.createDirentFromStats = createDirentFromStats;


/***/ }),

/***/ 16297:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fs = void 0;
const fs = __nccwpck_require__(60883);
exports.fs = fs;


/***/ }),

/***/ 32987:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
const fs = __nccwpck_require__(57147);
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;


/***/ }),

/***/ 70109:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.statSync = exports.stat = exports.Settings = void 0;
const async = __nccwpck_require__(34147);
const sync = __nccwpck_require__(34527);
const settings_1 = __nccwpck_require__(12410);
exports.Settings = settings_1.default;
function stat(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
}
exports.stat = stat;
function statSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
}
exports.statSync = statSync;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),

/***/ 34147:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.read = void 0;
function read(path, settings, callback) {
    settings.fs.lstat(path, (lstatError, lstat) => {
        if (lstatError !== null) {
            callFailureCallback(callback, lstatError);
            return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
            callSuccessCallback(callback, lstat);
            return;
        }
        settings.fs.stat(path, (statError, stat) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    callFailureCallback(callback, statError);
                    return;
                }
                callSuccessCallback(callback, lstat);
                return;
            }
            if (settings.markSymbolicLink) {
                stat.isSymbolicLink = () => true;
            }
            callSuccessCallback(callback, stat);
        });
    });
}
exports.read = read;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, result) {
    callback(null, result);
}


/***/ }),

/***/ 34527:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.read = void 0;
function read(path, settings) {
    const lstat = settings.fs.lstatSync(path);
    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
    }
    try {
        const stat = settings.fs.statSync(path);
        if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
        }
        return stat;
    }
    catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
            return lstat;
        }
        throw error;
    }
}
exports.read = read;


/***/ }),

/***/ 12410:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __nccwpck_require__(32987);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
exports["default"] = Settings;


/***/ }),

/***/ 26026:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;
const async_1 = __nccwpck_require__(77523);
const stream_1 = __nccwpck_require__(96737);
const sync_1 = __nccwpck_require__(13068);
const settings_1 = __nccwpck_require__(50141);
exports.Settings = settings_1.default;
function walk(directory, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
    }
    new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
}
exports.walk = walk;
function walkSync(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new sync_1.default(directory, settings);
    return provider.read();
}
exports.walkSync = walkSync;
function walkStream(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new stream_1.default(directory, settings);
    return provider.read();
}
exports.walkStream = walkStream;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),

/***/ 77523:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async_1 = __nccwpck_require__(55732);
class AsyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
    }
    read(callback) {
        this._reader.onError((error) => {
            callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
            this._storage.push(entry);
        });
        this._reader.onEnd(() => {
            callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
    }
}
exports["default"] = AsyncProvider;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, entries) {
    callback(null, entries);
}


/***/ }),

/***/ 96737:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __nccwpck_require__(12781);
const async_1 = __nccwpck_require__(55732);
class StreamProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
            objectMode: true,
            read: () => { },
            destroy: () => {
                if (!this._reader.isDestroyed) {
                    this._reader.destroy();
                }
            }
        });
    }
    read() {
        this._reader.onError((error) => {
            this._stream.emit('error', error);
        });
        this._reader.onEntry((entry) => {
            this._stream.push(entry);
        });
        this._reader.onEnd(() => {
            this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
    }
}
exports["default"] = StreamProvider;


/***/ }),

/***/ 13068:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sync_1 = __nccwpck_require__(13595);
class SyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
    }
    read() {
        return this._reader.read();
    }
}
exports["default"] = SyncProvider;


/***/ }),

/***/ 55732:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __nccwpck_require__(82361);
const fsScandir = __nccwpck_require__(75667);
const fastq = __nccwpck_require__(7340);
const common = __nccwpck_require__(97988);
const reader_1 = __nccwpck_require__(88311);
class AsyncReader extends reader_1.default {
    constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
            if (!this._isFatalError) {
                this._emitter.emit('end');
            }
        };
    }
    read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
            this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
    }
    get isDestroyed() {
        return this._isDestroyed;
    }
    destroy() {
        if (this._isDestroyed) {
            throw new Error('The reader is already destroyed');
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
    }
    onEntry(callback) {
        this._emitter.on('entry', callback);
    }
    onError(callback) {
        this._emitter.once('error', callback);
    }
    onEnd(callback) {
        this._emitter.once('end', callback);
    }
    _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
            if (error !== null) {
                this._handleError(error);
            }
        });
    }
    _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
            if (error !== null) {
                done(error, undefined);
                return;
            }
            for (const entry of entries) {
                this._handleEntry(entry, item.base);
            }
            done(null, undefined);
        });
    }
    _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
            return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit('error', error);
    }
    _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
            return;
        }
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);
        }
    }
    _emitEntry(entry) {
        this._emitter.emit('entry', entry);
    }
}
exports["default"] = AsyncReader;


/***/ }),

/***/ 97988:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;
function isFatalError(settings, error) {
    if (settings.errorFilter === null) {
        return true;
    }
    return !settings.errorFilter(error);
}
exports.isFatalError = isFatalError;
function isAppliedFilter(filter, value) {
    return filter === null || filter(value);
}
exports.isAppliedFilter = isAppliedFilter;
function replacePathSegmentSeparator(filepath, separator) {
    return filepath.split(/[/\\]/).join(separator);
}
exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
function joinPathSegments(a, b, separator) {
    if (a === '') {
        return b;
    }
    /**
     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
     */
    if (a.endsWith(separator)) {
        return a + b;
    }
    return a + separator + b;
}
exports.joinPathSegments = joinPathSegments;


/***/ }),

/***/ 88311:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const common = __nccwpck_require__(97988);
class Reader {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
    }
}
exports["default"] = Reader;


/***/ }),

/***/ 13595:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsScandir = __nccwpck_require__(75667);
const common = __nccwpck_require__(97988);
const reader_1 = __nccwpck_require__(88311);
class SyncReader extends reader_1.default {
    constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = new Set();
    }
    read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
    }
    _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
    }
    _handleQueue() {
        for (const item of this._queue.values()) {
            this._handleDirectory(item.directory, item.base);
        }
    }
    _handleDirectory(directory, base) {
        try {
            const entries = this._scandir(directory, this._settings.fsScandirSettings);
            for (const entry of entries) {
                this._handleEntry(entry, base);
            }
        }
        catch (error) {
            this._handleError(error);
        }
    }
    _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
            return;
        }
        throw error;
    }
    _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);
        }
    }
    _pushToStorage(entry) {
        this._storage.push(entry);
    }
}
exports["default"] = SyncReader;


/***/ }),

/***/ 50141:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __nccwpck_require__(71017);
const fsScandir = __nccwpck_require__(75667);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, undefined);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.fsScandirSettings = new fsScandir.Settings({
            followSymbolicLinks: this._options.followSymbolicLinks,
            fs: this._options.fs,
            pathSegmentSeparator: this._options.pathSegmentSeparator,
            stats: this._options.stats,
            throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
exports["default"] = Settings;


/***/ }),

/***/ 30315:
/***/ ((module, exports, __nccwpck_require__) => {

var acorn = __nccwpck_require__(80390)
var xtend = __nccwpck_require__(91208)

var CJSParser = acorn.Parser
  .extend(__nccwpck_require__(45777))
  .extend(__nccwpck_require__(74836))
  .extend(__nccwpck_require__(86245))
  .extend(__nccwpck_require__(63698))
  .extend((__nccwpck_require__(32893)/* ["default"] */ .ZP))
var ESModulesParser = CJSParser
  .extend(__nccwpck_require__(34210))
  .extend(__nccwpck_require__(2441))

function mapOptions (opts) {
  if (!opts) opts = {}
  return xtend({
    ecmaVersion: 2020,
    allowHashBang: true,
    allowReturnOutsideFunction: true
  }, opts)
}

function getParser (opts) {
  if (!opts) opts = {}
  return opts.sourceType === 'module' ? ESModulesParser : CJSParser
}

module.exports = exports = xtend(acorn, {
  parse: function parse (src, opts) {
    return getParser(opts).parse(src, mapOptions(opts))
  },
  parseExpressionAt: function parseExpressionAt (src, offset, opts) {
    return getParser(opts).parseExpressionAt(src, offset, mapOptions(opts))
  },
  tokenizer: function tokenizer (src, opts) {
    return getParser(opts).tokenizer(src, mapOptions(opts))
  }
})


/***/ }),

/***/ 45777:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* Generated by `npm run build`, do not edit! */



var acorn = __nccwpck_require__(80390)
var tt = acorn.tokTypes
var isIdentifierStart = acorn.isIdentifierStart

module.exports = function(Parser) {
  return /*@__PURE__*/(function (Parser) {
    function anonymous () {
      Parser.apply(this, arguments);
    }

    if ( Parser ) anonymous.__proto__ = Parser;
    anonymous.prototype = Object.create( Parser && Parser.prototype );
    anonymous.prototype.constructor = anonymous;

    anonymous.prototype.parseLiteral = function parseLiteral (value) {
      var node = Parser.prototype.parseLiteral.call(this, value)
      if (node.raw.charCodeAt(node.raw.length - 1) == 110) { node.bigint = this.getNumberInput(node.start, node.end) }
      return node
    };

    anonymous.prototype.readRadixNumber = function readRadixNumber (radix) {
      var start = this.pos
      this.pos += 2 // 0x
      var val = this.readInt(radix)
      if (val === null) { this.raise(this.start + 2, ("Expected number in radix " + radix)) }
      if (this.input.charCodeAt(this.pos) == 110) {
        var str = this.getNumberInput(start, this.pos)
        val = typeof BigInt !== "undefined" ? BigInt(str) : null
        ++this.pos
      } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number") }
      return this.finishToken(tt.num, val)
    };

    anonymous.prototype.readNumber = function readNumber (startsWithDot) {
      var start = this.pos

      // Not an int
      if (startsWithDot) { return Parser.prototype.readNumber.call(this, startsWithDot) }

      // Legacy octal
      if (this.input.charCodeAt(start) === 48 && this.input.charCodeAt(start + 1) !== 110) {
        return Parser.prototype.readNumber.call(this, startsWithDot)
      }

      if (this.readInt(10) === null) { this.raise(start, "Invalid number") }

      // Not a BigInt, reset and parse again
      if (this.input.charCodeAt(this.pos) != 110) {
        this.pos = start
        return Parser.prototype.readNumber.call(this, startsWithDot)
      }

      var str = this.getNumberInput(start, this.pos)
      var val = typeof BigInt !== "undefined" ? BigInt(str) : null
      ++this.pos
      return this.finishToken(tt.num, val)
    };

    // This is basically a hook for acorn-numeric-separator
    anonymous.prototype.getNumberInput = function getNumberInput (start, end) {
      if (Parser.prototype.getNumberInput) { return Parser.prototype.getNumberInput.call(this, start, end) }
      return this.input.slice(start, end)
    };

    return anonymous;
  }(Parser))
}


/***/ }),

/***/ 74836:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* Generated by `npm run build`, do not edit! */



var acorn = __nccwpck_require__(80390)
var tt = acorn.tokTypes
var privateClassElements = __nccwpck_require__(93378)

function maybeParseFieldValue(field) {
  if (this.eat(tt.eq)) {
    var oldInFieldValue = this._inFieldValue
    this._inFieldValue = true
    field.value = this.parseExpression()
    this._inFieldValue = oldInFieldValue
  } else { field.value = null }
}

module.exports = function(Parser) {
  Parser = privateClassElements(Parser)
  return /*@__PURE__*/(function (Parser) {
    function anonymous () {
      Parser.apply(this, arguments);
    }

    if ( Parser ) anonymous.__proto__ = Parser;
    anonymous.prototype = Object.create( Parser && Parser.prototype );
    anonymous.prototype.constructor = anonymous;

    anonymous.prototype.parseClassElement = function parseClassElement (_constructorAllowsSuper) {
      if (this.options.ecmaVersion >= 8 && (this.type == tt.name || this.type == this.privateNameToken || this.type == tt.bracketL || this.type == tt.string)) {
        var branch = this._branch()
        if (branch.type == tt.bracketL) {
          var count = 0
          do {
            if (branch.eat(tt.bracketL)) { ++count }
            else if (branch.eat(tt.bracketR)) { --count }
            else { branch.next() }
          } while (count > 0)
        } else { branch.next() }
        if (branch.type == tt.eq || branch.canInsertSemicolon() || branch.type == tt.semi) {
          var node = this.startNode()
          if (this.type == this.privateNameToken) {
            this.parsePrivateClassElementName(node)
          } else {
            this.parsePropertyName(node)
          }
          if ((node.key.type === "Identifier" && node.key.name === "constructor") ||
              (node.key.type === "Literal" && node.key.value === "constructor")) {
            this.raise(node.key.start, "Classes may not have a field called constructor")
          }
          maybeParseFieldValue.call(this, node)
          this.finishNode(node, "FieldDefinition")
          this.semicolon()
          return node
        }
      }

      return Parser.prototype.parseClassElement.apply(this, arguments)
    };

    // Prohibit arguments in class field initializers
    anonymous.prototype.parseIdent = function parseIdent (liberal, isBinding) {
      var ident = Parser.prototype.parseIdent.call(this, liberal, isBinding)
      if (this._inFieldValue && ident.name == "arguments") { this.raise(ident.start, "A class field initializer may not contain arguments") }
      return ident
    };

    return anonymous;
  }(Parser))
}


/***/ }),

/***/ 32893:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
var __webpack_unused_export__;
/* Generated by `npm run build`, do not edit! */



__webpack_unused_export__ = ({
  value: true
});
__webpack_unused_export__ = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();

var _get = function () {
  function get(object, property, receiver) { if (object === null) { object = Function.prototype; } var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

  return get;
}();

exports.ZP = dynamicImport;

var _acorn = __nccwpck_require__(80390);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) { Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } } /* eslint-disable no-underscore-dangle */


var DynamicImportKey = __webpack_unused_export__ = 'Import';

// NOTE: This allows `yield import()` to parse correctly.
_acorn.tokTypes._import.startsExpr = true;

function parseDynamicImport() {
  var node = this.startNode();
  this.next();
  if (this.type !== _acorn.tokTypes.parenL) {
    this.unexpected();
  }
  return this.finishNode(node, DynamicImportKey);
}

function parenAfter() {
  return (/^(\s|\/\/.*|\/\*[^]*?\*\/)*\(/.test(this.input.slice(this.pos))
  );
}

function dynamicImport(Parser) {
  return function (_Parser) {
    _inherits(_class, _Parser);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'parseStatement',
      value: function () {
        function parseStatement(context, topLevel, exports) {
          if (this.type === _acorn.tokTypes._import && parenAfter.call(this)) {
            return this.parseExpressionStatement(this.startNode(), this.parseExpression());
          }
          return _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'parseStatement', this).call(this, context, topLevel, exports);
        }

        return parseStatement;
      }()
    }, {
      key: 'parseExprAtom',
      value: function () {
        function parseExprAtom(refDestructuringErrors) {
          if (this.type === _acorn.tokTypes._import) {
            return parseDynamicImport.call(this);
          }
          return _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'parseExprAtom', this).call(this, refDestructuringErrors);
        }

        return parseExprAtom;
      }()
    }]);

    return _class;
  }(Parser);
}

/***/ }),

/***/ 34210:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* Generated by `npm run build`, do not edit! */



var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g

var tt = (__nccwpck_require__(80390).tokTypes)

module.exports = function(Parser) {
  return /*@__PURE__*/(function (Parser) {
    function anonymous () {
      Parser.apply(this, arguments);
    }

    if ( Parser ) anonymous.__proto__ = Parser;
    anonymous.prototype = Object.create( Parser && Parser.prototype );
    anonymous.prototype.constructor = anonymous;

    anonymous.prototype.parseExport = function parseExport (node, exports) {
      skipWhiteSpace.lastIndex = this.pos
      var skip = skipWhiteSpace.exec(this.input)
      var next = this.input.charAt(this.pos + skip[0].length)
      if (next !== "*") { return Parser.prototype.parseExport.call(this, node, exports) }

      this.next()
      var specifier = this.startNode()
      this.expect(tt.star)
      if (this.eatContextual("as")) {
        node.declaration = null
        specifier.exported = this.parseIdent(true)
        this.checkExport(exports, specifier.exported.name, this.lastTokStart)
        node.specifiers = [this.finishNode(specifier, "ExportNamespaceSpecifier")]
      }
      this.expectContextual("from")
      if (this.type !== tt.string) { this.unexpected() }
      node.source = this.parseExprAtom()
      this.semicolon()
      return this.finishNode(node, node.specifiers ? "ExportNamedDeclaration" : "ExportAllDeclaration")
    };

    return anonymous;
  }(Parser))
}


/***/ }),

/***/ 2441:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* Generated by `npm run build`, do not edit! */



var tt = (__nccwpck_require__(80390).tokTypes)

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g

var nextTokenIsDot = function (parser) {
  skipWhiteSpace.lastIndex = parser.pos
  var skip = skipWhiteSpace.exec(parser.input)
  var next = parser.pos + skip[0].length
  return parser.input.slice(next, next + 1) === "."
}

module.exports = function(Parser) {
  return /*@__PURE__*/(function (Parser) {
    function anonymous () {
      Parser.apply(this, arguments);
    }

    if ( Parser ) anonymous.__proto__ = Parser;
    anonymous.prototype = Object.create( Parser && Parser.prototype );
    anonymous.prototype.constructor = anonymous;

    anonymous.prototype.parseExprAtom = function parseExprAtom (refDestructuringErrors) {
      if (this.type !== tt._import || !nextTokenIsDot(this)) { return Parser.prototype.parseExprAtom.call(this, refDestructuringErrors) }

      if (!this.options.allowImportExportEverywhere && !this.inModule) {
        this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")
      }

      var node = this.startNode()
      node.meta = this.parseIdent(true)
      this.expect(tt.dot)
      node.property = this.parseIdent(true)
      if (node.property.name !== "meta") {
        this.raiseRecoverable(node.property.start, "The only valid meta property for import is import.meta")
      }
      return this.finishNode(node, "MetaProperty")
    };

    anonymous.prototype.parseStatement = function parseStatement (context, topLevel, exports) {
      if (this.type !== tt._import || !nextTokenIsDot(this)) {
        return Parser.prototype.parseStatement.call(this, context, topLevel, exports)
      }

      var node = this.startNode()
      var expr = this.parseExpression()
      return this.parseExpressionStatement(node, expr)
    };

    return anonymous;
  }(Parser))
}


/***/ }),

/***/ 63698:
/***/ ((module) => {

"use strict";
/* Generated by `npm run build`, do not edit! */



module.exports = function(Parser) {
  return /*@__PURE__*/(function (Parser) {
    function anonymous () {
      Parser.apply(this, arguments);
    }

    if ( Parser ) anonymous.__proto__ = Parser;
    anonymous.prototype = Object.create( Parser && Parser.prototype );
    anonymous.prototype.constructor = anonymous;

    anonymous.prototype.readInt = function readInt (radix, len) {
      // Hack: len is only != null for unicode escape sequences,
      // where numeric separators are not allowed
      if (len != null) { return Parser.prototype.readInt.call(this, radix, len) }

      var start = this.pos, total = 0, acceptUnderscore = false
      for (;;) {
        var code = this.input.charCodeAt(this.pos), val = (void 0)
        if (code >= 97) { val = code - 97 + 10 } // a
        else if (code == 95) {
          if (!acceptUnderscore) { this.raise(this.pos, "Invalid numeric separator") }
          ++this.pos
          acceptUnderscore = false
          continue
        } else if (code >= 65) { val = code - 65 + 10 } // A
        else if (code >= 48 && code <= 57) { val = code - 48 } // 0-9
        else { val = Infinity }
        if (val >= radix) { break }
        ++this.pos
        total = total * radix + val
        acceptUnderscore = true
      }
      if (this.pos === start) { return null }
      if (!acceptUnderscore) { this.raise(this.pos - 1, "Invalid numeric separator") }

      return total
    };

    anonymous.prototype.readNumber = function readNumber (startsWithDot) {
      var token = Parser.prototype.readNumber.call(this, startsWithDot)
      var octal = this.end - this.start >= 2 && this.input.charCodeAt(this.start) === 48
      var stripped = this.getNumberInput(this.start, this.end)
      if (stripped.length < this.end - this.start) {
        if (octal) { this.raise(this.start, "Invalid number") }
        this.value = parseFloat(stripped)
      }
      return token
    };

    // This is used by acorn-bigint
    anonymous.prototype.getNumberInput = function getNumberInput (start, end) {
      return this.input.slice(start, end).replace(/_/g, "")
    };

    return anonymous;
  }(Parser))
}


/***/ }),

/***/ 93378:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* Generated by `npm run build`, do not edit! */



var acorn = __nccwpck_require__(80390)
if (false) {}
var tt = acorn.tokTypes
var TokenType = acorn.TokenType

module.exports = function(Parser) {
  // Only load this plugin once.
  if (Parser.prototype.parsePrivateName) {
    return Parser
  }

  // Make sure `Parser` comes from the same acorn as our `tt`,
  // otherwise the comparisons fail.
  var cur = Parser
  while (cur && cur !== acorn.Parser) {
    cur = cur.__proto__
  }
  if (cur !== acorn.Parser) {
    throw new Error("acorn-private-class-elements does not support mixing different acorn copies")
  }

  Parser = /*@__PURE__*/(function (Parser) {
    function Parser_ () {
      Parser.apply(this, arguments);
    }

    if ( Parser ) Parser_.__proto__ = Parser;
    Parser_.prototype = Object.create( Parser && Parser.prototype );
    Parser_.prototype.constructor = Parser_;

    Parser_.prototype._branch = function _branch () {
      this.__branch = this.__branch || new Parser({ecmaVersion: this.options.ecmaVersion}, this.input)
      this.__branch.end = this.end
      this.__branch.pos = this.pos
      this.__branch.type = this.type
      this.__branch.value = this.value
      this.__branch.containsEsc = this.containsEsc
      return this.__branch
    };

    Parser_.prototype.parsePrivateClassElementName = function parsePrivateClassElementName (element) {
      element.computed = false
      element.key = this.parsePrivateName()
      if (element.key.name == "constructor") { this.raise(element.key.start, "Classes may not have a private element named constructor") }
      var accept = {get: "set", set: "get"}[element.kind]
      var privateBoundNames = this._privateBoundNamesStack[this._privateBoundNamesStack.length - 1]
      if (Object.prototype.hasOwnProperty.call(privateBoundNames, element.key.name) && privateBoundNames[element.key.name] !== accept) {
        this.raise(element.start, "Duplicate private element")
      }
      privateBoundNames[element.key.name] = element.kind || true
      delete this._unresolvedPrivateNamesStack[this._unresolvedPrivateNamesStack.length - 1][element.key.name]
      return element.key
    };

    Parser_.prototype.parsePrivateName = function parsePrivateName () {
      var node = this.startNode()
      node.name = this.value
      this.next()
      this.finishNode(node, "PrivateName")
      if (this.options.allowReserved == "never") { this.checkUnreserved(node) }
      return node
    };

    // Parse # token
    Parser_.prototype.getTokenFromCode = function getTokenFromCode (code) {
      if (code === 35) {
        ++this.pos
        var word = this.readWord1()
        return this.finishToken(this.privateNameToken, word)
      }
      return Parser.prototype.getTokenFromCode.call(this, code)
    };

    // Manage stacks and check for undeclared private names
    Parser_.prototype.parseClass = function parseClass (node, isStatement) {
      this._privateBoundNamesStack = this._privateBoundNamesStack || []
      var privateBoundNames = Object.create(this._privateBoundNamesStack[this._privateBoundNamesStack.length - 1] || null)
      this._privateBoundNamesStack.push(privateBoundNames)
      this._unresolvedPrivateNamesStack = this._unresolvedPrivateNamesStack || []
      var unresolvedPrivateNames = Object.create(null)
      this._unresolvedPrivateNamesStack.push(unresolvedPrivateNames)
      var _return = Parser.prototype.parseClass.call(this, node, isStatement)
      this._privateBoundNamesStack.pop()
      this._unresolvedPrivateNamesStack.pop()
      if (!this._unresolvedPrivateNamesStack.length) {
        var names = Object.keys(unresolvedPrivateNames)
        if (names.length) {
          names.sort(function (n1, n2) { return unresolvedPrivateNames[n1] - unresolvedPrivateNames[n2]; })
          this.raise(unresolvedPrivateNames[names[0]], "Usage of undeclared private name")
        }
      } else { Object.assign(this._unresolvedPrivateNamesStack[this._unresolvedPrivateNamesStack.length - 1], unresolvedPrivateNames) }
      return _return
    };

    // Parse private element access
    Parser_.prototype.parseSubscript = function parseSubscript (base, startPos, startLoc, noCalls, maybeAsyncArrow) {
      if (!this.eat(tt.dot)) {
        return Parser.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, maybeAsyncArrow)
      }
      var node = this.startNodeAt(startPos, startLoc)
      node.object = base
      node.computed = false
      if (this.type == this.privateNameToken) {
        node.property = this.parsePrivateName()
        if (!this._privateBoundNamesStack.length || !this._privateBoundNamesStack[this._privateBoundNamesStack.length - 1][node.property.name]) {
          this._unresolvedPrivateNamesStack[this._unresolvedPrivateNamesStack.length - 1][node.property.name] = node.property.start
        }
      } else {
        node.property = this.parseIdent(true)
      }
      return this.finishNode(node, "MemberExpression")
    };

    // Prohibit delete of private class elements
    Parser_.prototype.parseMaybeUnary = function parseMaybeUnary (refDestructuringErrors, sawUnary) {
      var _return = Parser.prototype.parseMaybeUnary.call(this, refDestructuringErrors, sawUnary)
      if (_return.operator == "delete") {
        if (_return.argument.type == "MemberExpression" && _return.argument.property.type == "PrivateName") {
          this.raise(_return.start, "Private elements may not be deleted")
        }
      }
      return _return
    };

    return Parser_;
  }(Parser))
  Parser.prototype.privateNameToken = new TokenType("privateName")
  return Parser
}


/***/ }),

/***/ 86245:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/* Generated by `npm run build`, do not edit! */



var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g

var acorn = __nccwpck_require__(80390)
var tt = acorn.tokTypes

function maybeParseFieldValue(field) {
  if (this.eat(tt.eq)) {
    var oldInFieldValue = this._inStaticFieldValue
    this._inStaticFieldValue = true
    field.value = this.parseExpression()
    this._inStaticFieldValue = oldInFieldValue
  } else { field.value = null }
}

var privateClassElements = __nccwpck_require__(93378)

module.exports = function(Parser) {
  var ExtendedParser = privateClassElements(Parser)

  return /*@__PURE__*/(function (ExtendedParser) {
    function anonymous () {
      ExtendedParser.apply(this, arguments);
    }

    if ( ExtendedParser ) anonymous.__proto__ = ExtendedParser;
    anonymous.prototype = Object.create( ExtendedParser && ExtendedParser.prototype );
    anonymous.prototype.constructor = anonymous;

    anonymous.prototype.parseClassElement = function parseClassElement (_constructorAllowsSuper) {
      var this$1 = this;

      if (this.eat(tt.semi)) { return null }

      var node = this.startNode()

      var tryContextual = function (k, noLineBreak) {
        if (typeof noLineBreak == "undefined") { noLineBreak = false }
        var start = this$1.start, startLoc = this$1.startLoc
        if (!this$1.eatContextual(k)) { return false }
        if (this$1.type !== tt.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
        if (node.key) { this$1.unexpected() }
        node.computed = false
        node.key = this$1.startNodeAt(start, startLoc)
        node.key.name = k
        this$1.finishNode(node.key, "Identifier")
        return false
      }

      node.static = tryContextual("static")
      if (!node.static) { return ExtendedParser.prototype.parseClassElement.apply(this, arguments) }

      var isGenerator = this.eat(tt.star)
      var isAsync = false
      if (!isGenerator) {
        // Special-case for `async`, since `parseClassMember` currently looks
        // for `(` to determine whether `async` is a method name
        if (this.options.ecmaVersion >= 8 && this.isContextual("async")) {
          skipWhiteSpace.lastIndex = this.pos
          var skip = skipWhiteSpace.exec(this.input)
          var next = this.input.charAt(this.pos + skip[0].length)
          if (next === ";" || next === "=") {
            node.key = this.parseIdent(true)
            node.computed = false
            maybeParseFieldValue.call(this, node)
            this.finishNode(node, "FieldDefinition")
            this.semicolon()
            return node
          } else if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
            isAsync = true
            isGenerator = this.options.ecmaVersion >= 9 && this.eat(tt.star)
          }
        } else if (tryContextual("get")) {
          node.kind = "get"
        } else if (tryContextual("set")) {
          node.kind = "set"
        }
      }
      if (this.type === this.privateNameToken) {
        this.parsePrivateClassElementName(node)
        if (this.type !== tt.parenL) {
          if (node.key.name === "prototype") {
            this.raise(node.key.start, "Classes may not have a private static property named prototype")
          }
          maybeParseFieldValue.call(this, node)
          this.finishNode(node, "FieldDefinition")
          this.semicolon()
          return node
        }
      } else if (!node.key) {
        this.parsePropertyName(node)
        if ((node.key.name || node.key.value) === "prototype" && !node.computed) {
          this.raise(node.key.start, "Classes may not have a static property named prototype")
        }
      }
      if (!node.kind) { node.kind = "method" }
      this.parseClassMethod(node, isGenerator, isAsync)
      if (!node.kind && (node.key.name || node.key.value) === "constructor" && !node.computed) {
        this.raise(node.key.start, "Classes may not have a static field named constructor")
      }
      if (node.kind === "get" && node.value.params.length !== 0) {
        this.raiseRecoverable(node.value.start, "getter should have no params")
      }
      if (node.kind === "set" && node.value.params.length !== 1) {
        this.raiseRecoverable(node.value.start, "setter should have exactly one param")
      }
      if (node.kind === "set" && node.value.params[0].type === "RestElement") {
        this.raiseRecoverable(node.value.params[0].start, "Setter cannot use rest params")
      }

      return node

    };

    // Parse public static fields
    anonymous.prototype.parseClassMethod = function parseClassMethod (method, isGenerator, isAsync, _allowsDirectSuper) {
      if (isGenerator || isAsync || method.kind != "method" || !method.static || this.options.ecmaVersion < 8 || this.type == tt.parenL) {
        return ExtendedParser.prototype.parseClassMethod.apply(this, arguments)
      }
      maybeParseFieldValue.call(this, method)
      delete method.kind
      method = this.finishNode(method, "FieldDefinition")
      this.semicolon()
      return method
    };

    // Prohibit arguments in class field initializers
    anonymous.prototype.parseIdent = function parseIdent (liberal, isBinding) {
      var ident = ExtendedParser.prototype.parseIdent.call(this, liberal, isBinding)
      if (this._inStaticFieldValue && ident.name == "arguments") { this.raise(ident.start, "A static class field initializer may not contain arguments") }
      return ident
    };

    return anonymous;
  }(ExtendedParser))
}


/***/ }),

/***/ 20083:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

var xtend = __nccwpck_require__(91208)
var walk = __nccwpck_require__(88390)

var base = xtend(walk.base)
base.Import = function () {}

function simple (node, visitors, baseVisitor, state, override) {
  return walk.simple(node, visitors, baseVisitor || base, state, override)
}

function ancestor (node, visitors, baseVisitor, state) {
  return walk.ancestor(node, visitors, baseVisitor || base, state)
}

function recursive (node, state, funcs, baseVisitor, override) {
  return walk.recursive(node, state, funcs, baseVisitor || base, override)
}

function full (node, callback, baseVisitor, state, override) {
  return walk.full(node, callback, baseVisitor || base, state, override)
}

function fullAncestor (node, callback, baseVisitor, state) {
  return walk.fullAncestor(node, callback, baseVisitor || base, state)
}

function findNodeAt (node, start, end, test, baseVisitor, state) {
  return walk.findNodeAt(node, start, end, test, baseVisitor || base, state)
}

function findNodeAround (node, pos, test, baseVisitor, state) {
  return walk.findNodeAround(node, pos, test, baseVisitor || base, state)
}

function findNodeAfter (node, pos, test, baseVisitor, state) {
  return walk.findNodeAfter(node, pos, test, baseVisitor || base, state)
}

function findNodeBefore (node, pos, test, baseVisitor, state) {
  return walk.findNodeBefore(node, pos, test, baseVisitor || base, state)
}

function make (funcs, baseVisitor) {
  return walk.make(funcs, baseVisitor || base)
}

exports.simple = simple
exports.ancestor = ancestor
exports.recursive = recursive
exports.full = full
exports.fullAncestor = fullAncestor
exports.findNodeAt = findNodeAt
exports.findNodeAround = findNodeAround
exports.findNodeAfter = findNodeAfter
exports.findNodeBefore = findNodeBefore
exports.make = make
exports.base = base


/***/ }),

/***/ 88390:
/***/ (function(__unused_webpack_module, exports) {

(function (global, factory) {
   true ? factory(exports) :
  0;
}(this, (function (exports) { 'use strict';

  // AST walker module for Mozilla Parser API compatible trees

  // A simple walk is one where you simply specify callbacks to be
  // called on specific nodes. The last two arguments are optional. A
  // simple use would be
  //
  //     walk.simple(myTree, {
  //         Expression: function(node) { ... }
  //     });
  //
  // to do something with all expressions. All Parser API node types
  // can be used to identify node types, as well as Expression and
  // Statement, which denote categories of nodes.
  //
  // The base argument can be used to pass a custom (recursive)
  // walker, and state can be used to give this walked an initial
  // state.

  function simple(node, visitors, baseVisitor, state, override) {
    if (!baseVisitor) { baseVisitor = base
    ; }(function c(node, st, override) {
      var type = override || node.type, found = visitors[type];
      baseVisitor[type](node, st, c);
      if (found) { found(node, st); }
    })(node, state, override);
  }

  // An ancestor walk keeps an array of ancestor nodes (including the
  // current node) and passes them to the callback as third parameter
  // (and also as state parameter when no other state is present).
  function ancestor(node, visitors, baseVisitor, state, override) {
    var ancestors = [];
    if (!baseVisitor) { baseVisitor = base
    ; }(function c(node, st, override) {
      var type = override || node.type, found = visitors[type];
      var isNew = node !== ancestors[ancestors.length - 1];
      if (isNew) { ancestors.push(node); }
      baseVisitor[type](node, st, c);
      if (found) { found(node, st || ancestors, ancestors); }
      if (isNew) { ancestors.pop(); }
    })(node, state, override);
  }

  // A recursive walk is one where your functions override the default
  // walkers. They can modify and replace the state parameter that's
  // threaded through the walk, and can opt how and whether to walk
  // their child nodes (by calling their third argument on these
  // nodes).
  function recursive(node, state, funcs, baseVisitor, override) {
    var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor
    ;(function c(node, st, override) {
      visitor[override || node.type](node, st, c);
    })(node, state, override);
  }

  function makeTest(test) {
    if (typeof test === "string")
      { return function (type) { return type === test; } }
    else if (!test)
      { return function () { return true; } }
    else
      { return test }
  }

  var Found = function Found(node, state) { this.node = node; this.state = state; };

  // A full walk triggers the callback on each node
  function full(node, callback, baseVisitor, state, override) {
    if (!baseVisitor) { baseVisitor = base
    ; }(function c(node, st, override) {
      var type = override || node.type;
      baseVisitor[type](node, st, c);
      if (!override) { callback(node, st, type); }
    })(node, state, override);
  }

  // An fullAncestor walk is like an ancestor walk, but triggers
  // the callback on each node
  function fullAncestor(node, callback, baseVisitor, state) {
    if (!baseVisitor) { baseVisitor = base; }
    var ancestors = []
    ;(function c(node, st, override) {
      var type = override || node.type;
      var isNew = node !== ancestors[ancestors.length - 1];
      if (isNew) { ancestors.push(node); }
      baseVisitor[type](node, st, c);
      if (!override) { callback(node, st || ancestors, ancestors, type); }
      if (isNew) { ancestors.pop(); }
    })(node, state);
  }

  // Find a node with a given start, end, and type (all are optional,
  // null can be used as wildcard). Returns a {node, state} object, or
  // undefined when it doesn't find a matching node.
  function findNodeAt(node, start, end, test, baseVisitor, state) {
    if (!baseVisitor) { baseVisitor = base; }
    test = makeTest(test);
    try {
      (function c(node, st, override) {
        var type = override || node.type;
        if ((start == null || node.start <= start) &&
            (end == null || node.end >= end))
          { baseVisitor[type](node, st, c); }
        if ((start == null || node.start === start) &&
            (end == null || node.end === end) &&
            test(type, node))
          { throw new Found(node, st) }
      })(node, state);
    } catch (e) {
      if (e instanceof Found) { return e }
      throw e
    }
  }

  // Find the innermost node of a given type that contains the given
  // position. Interface similar to findNodeAt.
  function findNodeAround(node, pos, test, baseVisitor, state) {
    test = makeTest(test);
    if (!baseVisitor) { baseVisitor = base; }
    try {
      (function c(node, st, override) {
        var type = override || node.type;
        if (node.start > pos || node.end < pos) { return }
        baseVisitor[type](node, st, c);
        if (test(type, node)) { throw new Found(node, st) }
      })(node, state);
    } catch (e) {
      if (e instanceof Found) { return e }
      throw e
    }
  }

  // Find the outermost matching node after a given position.
  function findNodeAfter(node, pos, test, baseVisitor, state) {
    test = makeTest(test);
    if (!baseVisitor) { baseVisitor = base; }
    try {
      (function c(node, st, override) {
        if (node.end < pos) { return }
        var type = override || node.type;
        if (node.start >= pos && test(type, node)) { throw new Found(node, st) }
        baseVisitor[type](node, st, c);
      })(node, state);
    } catch (e) {
      if (e instanceof Found) { return e }
      throw e
    }
  }

  // Find the outermost matching node before a given position.
  function findNodeBefore(node, pos, test, baseVisitor, state) {
    test = makeTest(test);
    if (!baseVisitor) { baseVisitor = base; }
    var max
    ;(function c(node, st, override) {
      if (node.start > pos) { return }
      var type = override || node.type;
      if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))
        { max = new Found(node, st); }
      baseVisitor[type](node, st, c);
    })(node, state);
    return max
  }

  // Fallback to an Object.create polyfill for older environments.
  var create = Object.create || function(proto) {
    function Ctor() {}
    Ctor.prototype = proto;
    return new Ctor
  };

  // Used to create a custom walker. Will fill in all missing node
  // type properties with the defaults.
  function make(funcs, baseVisitor) {
    var visitor = create(baseVisitor || base);
    for (var type in funcs) { visitor[type] = funcs[type]; }
    return visitor
  }

  function skipThrough(node, st, c) { c(node, st); }
  function ignore(_node, _st, _c) {}

  // Node walkers.

  var base = {};

  base.Program = base.BlockStatement = function (node, st, c) {
    for (var i = 0, list = node.body; i < list.length; i += 1)
      {
      var stmt = list[i];

      c(stmt, st, "Statement");
    }
  };
  base.Statement = skipThrough;
  base.EmptyStatement = ignore;
  base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression =
    function (node, st, c) { return c(node.expression, st, "Expression"); };
  base.IfStatement = function (node, st, c) {
    c(node.test, st, "Expression");
    c(node.consequent, st, "Statement");
    if (node.alternate) { c(node.alternate, st, "Statement"); }
  };
  base.LabeledStatement = function (node, st, c) { return c(node.body, st, "Statement"); };
  base.BreakStatement = base.ContinueStatement = ignore;
  base.WithStatement = function (node, st, c) {
    c(node.object, st, "Expression");
    c(node.body, st, "Statement");
  };
  base.SwitchStatement = function (node, st, c) {
    c(node.discriminant, st, "Expression");
    for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {
      var cs = list$1[i$1];

      if (cs.test) { c(cs.test, st, "Expression"); }
      for (var i = 0, list = cs.consequent; i < list.length; i += 1)
        {
        var cons = list[i];

        c(cons, st, "Statement");
      }
    }
  };
  base.SwitchCase = function (node, st, c) {
    if (node.test) { c(node.test, st, "Expression"); }
    for (var i = 0, list = node.consequent; i < list.length; i += 1)
      {
      var cons = list[i];

      c(cons, st, "Statement");
    }
  };
  base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {
    if (node.argument) { c(node.argument, st, "Expression"); }
  };
  base.ThrowStatement = base.SpreadElement =
    function (node, st, c) { return c(node.argument, st, "Expression"); };
  base.TryStatement = function (node, st, c) {
    c(node.block, st, "Statement");
    if (node.handler) { c(node.handler, st); }
    if (node.finalizer) { c(node.finalizer, st, "Statement"); }
  };
  base.CatchClause = function (node, st, c) {
    if (node.param) { c(node.param, st, "Pattern"); }
    c(node.body, st, "Statement");
  };
  base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
    c(node.test, st, "Expression");
    c(node.body, st, "Statement");
  };
  base.ForStatement = function (node, st, c) {
    if (node.init) { c(node.init, st, "ForInit"); }
    if (node.test) { c(node.test, st, "Expression"); }
    if (node.update) { c(node.update, st, "Expression"); }
    c(node.body, st, "Statement");
  };
  base.ForInStatement = base.ForOfStatement = function (node, st, c) {
    c(node.left, st, "ForInit");
    c(node.right, st, "Expression");
    c(node.body, st, "Statement");
  };
  base.ForInit = function (node, st, c) {
    if (node.type === "VariableDeclaration") { c(node, st); }
    else { c(node, st, "Expression"); }
  };
  base.DebuggerStatement = ignore;

  base.FunctionDeclaration = function (node, st, c) { return c(node, st, "Function"); };
  base.VariableDeclaration = function (node, st, c) {
    for (var i = 0, list = node.declarations; i < list.length; i += 1)
      {
      var decl = list[i];

      c(decl, st);
    }
  };
  base.VariableDeclarator = function (node, st, c) {
    c(node.id, st, "Pattern");
    if (node.init) { c(node.init, st, "Expression"); }
  };

  base.Function = function (node, st, c) {
    if (node.id) { c(node.id, st, "Pattern"); }
    for (var i = 0, list = node.params; i < list.length; i += 1)
      {
      var param = list[i];

      c(param, st, "Pattern");
    }
    c(node.body, st, node.expression ? "Expression" : "Statement");
  };

  base.Pattern = function (node, st, c) {
    if (node.type === "Identifier")
      { c(node, st, "VariablePattern"); }
    else if (node.type === "MemberExpression")
      { c(node, st, "MemberPattern"); }
    else
      { c(node, st); }
  };
  base.VariablePattern = ignore;
  base.MemberPattern = skipThrough;
  base.RestElement = function (node, st, c) { return c(node.argument, st, "Pattern"); };
  base.ArrayPattern = function (node, st, c) {
    for (var i = 0, list = node.elements; i < list.length; i += 1) {
      var elt = list[i];

      if (elt) { c(elt, st, "Pattern"); }
    }
  };
  base.ObjectPattern = function (node, st, c) {
    for (var i = 0, list = node.properties; i < list.length; i += 1) {
      var prop = list[i];

      if (prop.type === "Property") {
        if (prop.computed) { c(prop.key, st, "Expression"); }
        c(prop.value, st, "Pattern");
      } else if (prop.type === "RestElement") {
        c(prop.argument, st, "Pattern");
      }
    }
  };

  base.Expression = skipThrough;
  base.ThisExpression = base.Super = base.MetaProperty = ignore;
  base.ArrayExpression = function (node, st, c) {
    for (var i = 0, list = node.elements; i < list.length; i += 1) {
      var elt = list[i];

      if (elt) { c(elt, st, "Expression"); }
    }
  };
  base.ObjectExpression = function (node, st, c) {
    for (var i = 0, list = node.properties; i < list.length; i += 1)
      {
      var prop = list[i];

      c(prop, st);
    }
  };
  base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
  base.SequenceExpression = function (node, st, c) {
    for (var i = 0, list = node.expressions; i < list.length; i += 1)
      {
      var expr = list[i];

      c(expr, st, "Expression");
    }
  };
  base.TemplateLiteral = function (node, st, c) {
    for (var i = 0, list = node.quasis; i < list.length; i += 1)
      {
      var quasi = list[i];

      c(quasi, st);
    }

    for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)
      {
      var expr = list$1[i$1];

      c(expr, st, "Expression");
    }
  };
  base.TemplateElement = ignore;
  base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
    c(node.argument, st, "Expression");
  };
  base.BinaryExpression = base.LogicalExpression = function (node, st, c) {
    c(node.left, st, "Expression");
    c(node.right, st, "Expression");
  };
  base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {
    c(node.left, st, "Pattern");
    c(node.right, st, "Expression");
  };
  base.ConditionalExpression = function (node, st, c) {
    c(node.test, st, "Expression");
    c(node.consequent, st, "Expression");
    c(node.alternate, st, "Expression");
  };
  base.NewExpression = base.CallExpression = function (node, st, c) {
    c(node.callee, st, "Expression");
    if (node.arguments)
      { for (var i = 0, list = node.arguments; i < list.length; i += 1)
        {
          var arg = list[i];

          c(arg, st, "Expression");
        } }
  };
  base.MemberExpression = function (node, st, c) {
    c(node.object, st, "Expression");
    if (node.computed) { c(node.property, st, "Expression"); }
  };
  base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
    if (node.declaration)
      { c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression"); }
    if (node.source) { c(node.source, st, "Expression"); }
  };
  base.ExportAllDeclaration = function (node, st, c) {
    if (node.exported)
      { c(node.exported, st); }
    c(node.source, st, "Expression");
  };
  base.ImportDeclaration = function (node, st, c) {
    for (var i = 0, list = node.specifiers; i < list.length; i += 1)
      {
      var spec = list[i];

      c(spec, st);
    }
    c(node.source, st, "Expression");
  };
  base.ImportExpression = function (node, st, c) {
    c(node.source, st, "Expression");
  };
  base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;

  base.TaggedTemplateExpression = function (node, st, c) {
    c(node.tag, st, "Expression");
    c(node.quasi, st, "Expression");
  };
  base.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, "Class"); };
  base.Class = function (node, st, c) {
    if (node.id) { c(node.id, st, "Pattern"); }
    if (node.superClass) { c(node.superClass, st, "Expression"); }
    c(node.body, st);
  };
  base.ClassBody = function (node, st, c) {
    for (var i = 0, list = node.body; i < list.length; i += 1)
      {
      var elt = list[i];

      c(elt, st);
    }
  };
  base.MethodDefinition = base.Property = function (node, st, c) {
    if (node.computed) { c(node.key, st, "Expression"); }
    c(node.value, st, "Expression");
  };

  exports.ancestor = ancestor;
  exports.base = base;
  exports.findNodeAfter = findNodeAfter;
  exports.findNodeAround = findNodeAround;
  exports.findNodeAt = findNodeAt;
  exports.findNodeBefore = findNodeBefore;
  exports.full = full;
  exports.fullAncestor = fullAncestor;
  exports.make = make;
  exports.recursive = recursive;
  exports.simple = simple;

  Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ 80390:
/***/ (function(__unused_webpack_module, exports) {

(function (global, factory) {
   true ? factory(exports) :
  0;
}(this, (function (exports) { 'use strict';

  // Reserved word lists for various dialects of the language

  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };

  // And the keywords

  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

  var keywords = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };

  var keywordRelationalOperator = /^in(stanceof)?$/;

  // ## Character categories

  // Big ugly regular expressions that match characters in the
  // whitespace, identifier, and identifier-start categories. These
  // are only applied when a character is found to actually have a
  // code point above 128.
  // Generated by `bin/generate-identifier-regex.js`.
  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

  // These are a run-length and offset encoded representation of the
  // >0xffff code points that are a valid part of identifiers. The
  // offset starts at 0x10000, and each pair of numbers represents an
  // offset to the next range, and then a size of the range. They were
  // generated by bin/generate-identifier-regex.js

  // eslint-disable-next-line comma-spacing
  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938];

  // eslint-disable-next-line comma-spacing
  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];

  // This has a complexity linear to the value of the code. The
  // assumption is that looking up astral identifier characters is
  // rare.
  function isInAstralSet(code, set) {
    var pos = 0x10000;
    for (var i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code) { return false }
      pos += set[i + 1];
      if (pos >= code) { return true }
    }
  }

  // Test whether a given character code starts an identifier.

  function isIdentifierStart(code, astral) {
    if (code < 65) { return code === 36 }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes)
  }

  // Test whether a given character is part of an identifier.

  function isIdentifierChar(code, astral) {
    if (code < 48) { return code === 36 }
    if (code < 58) { return true }
    if (code < 65) { return false }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
  }

  // ## Token types

  // The assignment of fine-grained, information-carrying type objects
  // allows the tokenizer to store the information it has about a
  // token in a way that is very cheap for the parser to look up.

  // All token type variables start with an underscore, to make them
  // easy to recognize.

  // The `beforeExpr` property is used to disambiguate between regular
  // expressions and divisions. It is set on all token types that can
  // be followed by an expression (thus, a slash after them would be a
  // regular expression).
  //
  // The `startsExpr` property is used to check if the token ends a
  // `yield` expression. It is set on all token types that either can
  // directly start an expression (like a quotation mark) or can
  // continue an expression (like the body of a string).
  //
  // `isLoop` marks a keyword as starting a loop, which is important
  // to know when parsing a label, in order to allow or disallow
  // continue jumps to that label.

  var TokenType = function TokenType(label, conf) {
    if ( conf === void 0 ) conf = {};

    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };

  function binop(name, prec) {
    return new TokenType(name, {beforeExpr: true, binop: prec})
  }
  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

  // Map keyword names to token types.

  var keywords$1 = {};

  // Succinct definitions of keyword token types
  function kw(name, options) {
    if ( options === void 0 ) options = {};

    options.keyword = name;
    return keywords$1[name] = new TokenType(name, options)
  }

  var types = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    eof: new TokenType("eof"),

    // Punctuation token types.
    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

    // Operators. These carry several kinds of properties to help the
    // parser use them properly (the presence of these properties is
    // what categorizes them as operators).
    //
    // `binop`, when present, specifies that this operator is a binary
    // operator, and will refer to its precedence.
    //
    // `prefix` and `postfix` mark the operator as a prefix or postfix
    // unary operator.
    //
    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
    // binary operators with a very low precedence, that should result
    // in AssignmentExpression nodes.

    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
    prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {beforeExpr: true}),
    coalesce: binop("??", 1),

    // Keyword token types.
    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {isLoop: true, beforeExpr: true}),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {isLoop: true}),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {isLoop: true}),
    _with: kw("with"),
    _new: kw("new", {beforeExpr: true, startsExpr: true}),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {beforeExpr: true, binop: 7}),
    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
  };

  // Matches a whole line break (where CRLF is considered a single
  // line break). Used to count lines.

  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");

  function isNewLine(code, ecma2019String) {
    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
  }

  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

  var ref = Object.prototype;
  var hasOwnProperty = ref.hasOwnProperty;
  var toString = ref.toString;

  // Checks if an object has a property.

  function has(obj, propName) {
    return hasOwnProperty.call(obj, propName)
  }

  var isArray = Array.isArray || (function (obj) { return (
    toString.call(obj) === "[object Array]"
  ); });

  function wordsRegexp(words) {
    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
  }

  // These are used when `options.locations` is on, for the
  // `startLoc` and `endLoc` properties.

  var Position = function Position(line, col) {
    this.line = line;
    this.column = col;
  };

  Position.prototype.offset = function offset (n) {
    return new Position(this.line, this.column + n)
  };

  var SourceLocation = function SourceLocation(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) { this.source = p.sourceFile; }
  };

  // The `getLineInfo` function is mostly useful when the
  // `locations` option is off (for performance reasons) and you
  // want to find the line/column position for a given character
  // offset. `input` should be the code string that the offset refers
  // into.

  function getLineInfo(input, offset) {
    for (var line = 1, cur = 0;;) {
      lineBreakG.lastIndex = cur;
      var match = lineBreakG.exec(input);
      if (match && match.index < offset) {
        ++line;
        cur = match.index + match[0].length;
      } else {
        return new Position(line, offset - cur)
      }
    }
  }

  // A second optional argument can be given to further configure
  // the parser process. These options are recognized:

  var defaultOptions = {
    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
    // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
    // (2019). This influences support for strict mode, the set of
    // reserved words, and support for new syntax features. The default
    // is 10.
    ecmaVersion: 10,
    // `sourceType` indicates the mode the code should be parsed in.
    // Can be either `"script"` or `"module"`. This influences global
    // strict mode and parsing of `import` and `export` declarations.
    sourceType: "script",
    // `onInsertedSemicolon` can be a callback that will be called
    // when a semicolon is automatically inserted. It will be passed
    // the position of the comma as an offset, and if `locations` is
    // enabled, it is given the location as a `{line, column}` object
    // as second argument.
    onInsertedSemicolon: null,
    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
    // trailing commas.
    onTrailingComma: null,
    // By default, reserved words are only enforced if ecmaVersion >= 5.
    // Set `allowReserved` to a boolean value to explicitly turn this on
    // an off. When this option has the value "never", reserved words
    // and keywords can also not be used as property names.
    allowReserved: null,
    // When enabled, a return at the top level is not considered an
    // error.
    allowReturnOutsideFunction: false,
    // When enabled, import/export statements are not constrained to
    // appearing at the top of the program.
    allowImportExportEverywhere: false,
    // When enabled, await identifiers are allowed to appear at the top-level scope,
    // but they are still not allowed in non-async functions.
    allowAwaitOutsideFunction: false,
    // When enabled, hashbang directive in the beginning of file
    // is allowed and treated as a line comment.
    allowHashBang: false,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: false,
    // A function can be passed as `onToken` option, which will
    // cause Acorn to call that function with object in the same
    // format as tokens returned from `tokenizer().getToken()`. Note
    // that you are not allowed to call the parser from the
    // callback—that will corrupt its internal state.
    onToken: null,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments. Note that you are not allowed to call the
    // parser from the callback—that will corrupt its internal state.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: false,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `locations` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `locations` is on or off.
    directSourceFile: null,
    // When enabled, parenthesized expressions are represented by
    // (non-standard) ParenthesizedExpression nodes
    preserveParens: false
  };

  // Interpret and default an options object

  function getOptions(opts) {
    var options = {};

    for (var opt in defaultOptions)
      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

    if (options.ecmaVersion >= 2015)
      { options.ecmaVersion -= 2009; }

    if (options.allowReserved == null)
      { options.allowReserved = options.ecmaVersion < 5; }

    if (isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function (token) { return tokens.push(token); };
    }
    if (isArray(options.onComment))
      { options.onComment = pushComment(options, options.onComment); }

    return options
  }

  function pushComment(options, array) {
    return function(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text,
        start: start,
        end: end
      };
      if (options.locations)
        { comment.loc = new SourceLocation(this, startLoc, endLoc); }
      if (options.ranges)
        { comment.range = [start, end]; }
      array.push(comment);
    }
  }

  // Each scope gets a bitset that may contain these flags
  var
      SCOPE_TOP = 1,
      SCOPE_FUNCTION = 2,
      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
      SCOPE_ASYNC = 4,
      SCOPE_GENERATOR = 8,
      SCOPE_ARROW = 16,
      SCOPE_SIMPLE_CATCH = 32,
      SCOPE_SUPER = 64,
      SCOPE_DIRECT_SUPER = 128;

  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
  }

  // Used in checkLVal and declareName to determine the type of a binding
  var
      BIND_NONE = 0, // Not a binding
      BIND_VAR = 1, // Var-style binding
      BIND_LEXICAL = 2, // Let- or const-style binding
      BIND_FUNCTION = 3, // Function declaration
      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

  var Parser = function Parser(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options.allowReserved !== true) {
      for (var v = options.ecmaVersion;; v--)
        { if (reserved = reservedWords[v]) { break } }
      if (options.sourceType === "module") { reserved += " await"; }
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);

    // Used to signal to callers of `readWord1` whether the word
    // contained any escape sequences. This is needed because words with
    // escape sequences must not be interpreted as keywords.
    this.containsEsc = false;

    // Set up token state

    // The current position of the tokenizer in the input.
    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }

    // Properties of the current token:
    // Its type
    this.type = types.eof;
    // For tokens that include more information than their type, the value
    this.value = null;
    // Its start and end offset
    this.start = this.end = this.pos;
    // And, if locations are used, the {line, column} object
    // corresponding to those offsets
    this.startLoc = this.endLoc = this.curPosition();

    // Position information for the previous token
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    // The context stack is used to superficially track syntactic
    // context to predict whether a regular expression is allowed in a
    // given position.
    this.context = this.initialContext();
    this.exprAllowed = true;

    // Figure out if it's a module code.
    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);

    // Used to signify the start of a potential arrow function
    this.potentialArrowAt = -1;

    // Positions to delayed-check that yield/await does not exist in default parameters.
    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    // Labels in scope.
    this.labels = [];
    // Thus-far undefined exports.
    this.undefinedExports = {};

    // If enabled, skip leading hashbang line.
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
      { this.skipLineComment(2); }

    // Scope tracking for duplicate variable names (see scope.js)
    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);

    // For RegExp validation
    this.regexpState = null;
  };

  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

  Parser.prototype.parse = function parse () {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node)
  };

  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
  prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

  // Switch to a getter for 7.0.0.
  Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

  Parser.extend = function extend () {
      var plugins = [], len = arguments.length;
      while ( len-- ) plugins[ len ] = arguments[ len ];

    var cls = this;
    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
    return cls
  };

  Parser.parse = function parse (input, options) {
    return new this(options, input).parse()
  };

  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression()
  };

  Parser.tokenizer = function tokenizer (input, options) {
    return new this(options, input)
  };

  Object.defineProperties( Parser.prototype, prototypeAccessors );

  var pp = Parser.prototype;

  // ## Parser utilities

  var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
  pp.strictDirective = function(start) {
    for (;;) {
      // Try to find string literal.
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start));
      if (!match) { return false }
      if ((match[1] || match[2]) === "use strict") {
        skipWhiteSpace.lastIndex = start + match[0].length;
        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
        var next = this.input.charAt(end);
        return next === ";" || next === "}" ||
          (lineBreak.test(spaceAfter[0]) &&
           !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
      }
      start += match[0].length;

      // Skip semicolon, if any.
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start] === ";")
        { start++; }
    }
  };

  // Predicate that tests whether the next token is of the given
  // type, and if yes, consumes it as a side effect.

  pp.eat = function(type) {
    if (this.type === type) {
      this.next();
      return true
    } else {
      return false
    }
  };

  // Tests whether parsed token is a contextual keyword.

  pp.isContextual = function(name) {
    return this.type === types.name && this.value === name && !this.containsEsc
  };

  // Consumes contextual keyword if possible.

  pp.eatContextual = function(name) {
    if (!this.isContextual(name)) { return false }
    this.next();
    return true
  };

  // Asserts that following token is given contextual keyword.

  pp.expectContextual = function(name) {
    if (!this.eatContextual(name)) { this.unexpected(); }
  };

  // Test whether a semicolon can be inserted at the current position.

  pp.canInsertSemicolon = function() {
    return this.type === types.eof ||
      this.type === types.braceR ||
      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  pp.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon)
        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
      return true
    }
  };

  // Consume a semicolon, or, failing that, see if we are allowed to
  // pretend that there is a semicolon at this position.

  pp.semicolon = function() {
    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
  };

  pp.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma)
        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
      if (!notNext)
        { this.next(); }
      return true
    }
  };

  // Expect a token of a given type. If found, consume it, otherwise,
  // raise an unexpected token error.

  pp.expect = function(type) {
    this.eat(type) || this.unexpected();
  };

  // Raise an unexpected token error.

  pp.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };

  function DestructuringErrors() {
    this.shorthandAssign =
    this.trailingComma =
    this.parenthesizedAssign =
    this.parenthesizedBind =
    this.doubleProto =
      -1;
  }

  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) { return }
    if (refDestructuringErrors.trailingComma > -1)
      { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
  };

  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) { return false }
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
    if (shorthandAssign >= 0)
      { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
    if (doubleProto >= 0)
      { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
  };

  pp.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
      { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
    if (this.awaitPos)
      { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
  };

  pp.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression")
      { return this.isSimpleAssignTarget(expr.expression) }
    return expr.type === "Identifier" || expr.type === "MemberExpression"
  };

  var pp$1 = Parser.prototype;

  // ### Statement parsing

  // Parse a program. Initializes the parser, reads any number of
  // statements, and wraps them in a Program node.  Optionally takes a
  // `program` argument.  If present, the statements will be appended
  // to its body instead of creating a new node.

  pp$1.parseTopLevel = function(node) {
    var exports = {};
    if (!node.body) { node.body = []; }
    while (this.type !== types.eof) {
      var stmt = this.parseStatement(null, true, exports);
      node.body.push(stmt);
    }
    if (this.inModule)
      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
        {
          var name = list[i];

          this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
        } }
    this.adaptDirectivePrologue(node.body);
    this.next();
    node.sourceType = this.options.sourceType;
    return this.finishNode(node, "Program")
  };

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  pp$1.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    // For ambiguous cases, determine if a LexicalDeclaration (or only a
    // Statement) is allowed here. If context is not empty then only a Statement
    // is allowed. However, `let [` is an explicit negative lookahead for
    // ExpressionStatement, so special-case it first.
    if (nextCh === 91) { return true } // '['
    if (context) { return false }

    if (nextCh === 123) { return true } // '{'
    if (isIdentifierStart(nextCh, true)) {
      var pos = next + 1;
      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) { return true }
    }
    return false
  };

  // check 'async [no LineTerminator here] function'
  // - 'async /*foo*/ function' is OK.
  // - 'async /*\n*/ function' is invalid.
  pp$1.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
      { return false }

    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length;
    return !lineBreak.test(this.input.slice(this.pos, next)) &&
      this.input.slice(next, next + 8) === "function" &&
      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
  };

  // Parse a single statement.
  //
  // If expecting a statement and finding a slash operator, parse a
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
  // does not help.

  pp$1.parseStatement = function(context, topLevel, exports) {
    var starttype = this.type, node = this.startNode(), kind;

    if (this.isLet(context)) {
      starttype = types._var;
      kind = "let";
    }

    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.

    switch (starttype) {
    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
    case types._debugger: return this.parseDebuggerStatement(node)
    case types._do: return this.parseDoStatement(node)
    case types._for: return this.parseForStatement(node)
    case types._function:
      // Function as sole body of either an if statement or a labeled statement
      // works, but not when it is part of a labeled statement that is the sole
      // body of an if statement.
      if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
      return this.parseFunctionStatement(node, false, !context)
    case types._class:
      if (context) { this.unexpected(); }
      return this.parseClass(node, true)
    case types._if: return this.parseIfStatement(node)
    case types._return: return this.parseReturnStatement(node)
    case types._switch: return this.parseSwitchStatement(node)
    case types._throw: return this.parseThrowStatement(node)
    case types._try: return this.parseTryStatement(node)
    case types._const: case types._var:
      kind = kind || this.value;
      if (context && kind !== "var") { this.unexpected(); }
      return this.parseVarStatement(node, kind)
    case types._while: return this.parseWhileStatement(node)
    case types._with: return this.parseWithStatement(node)
    case types.braceL: return this.parseBlock(true, node)
    case types.semi: return this.parseEmptyStatement(node)
    case types._export:
    case types._import:
      if (this.options.ecmaVersion > 10 && starttype === types._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) // '(' or '.'
          { return this.parseExpressionStatement(node, this.parseExpression()) }
      }

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel)
          { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
        if (!this.inModule)
          { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
      }
      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

      // If the statement does not start with a statement keyword or a
      // brace, it's an ExpressionStatement or LabeledStatement. We
      // simply start parsing an expression, and afterwards, if the
      // next token is a colon and the expression was a simple
      // Identifier node, we switch to interpreting it as a label.
    default:
      if (this.isAsyncFunction()) {
        if (context) { this.unexpected(); }
        this.next();
        return this.parseFunctionStatement(node, true, !context)
      }

      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
        { return this.parseLabeledStatement(node, maybeName, expr, context) }
      else { return this.parseExpressionStatement(node, expr) }
    }
  };

  pp$1.parseBreakContinueStatement = function(node, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
    else if (this.type !== types.name) { this.unexpected(); }
    else {
      node.label = this.parseIdent();
      this.semicolon();
    }

    // Verify that there is an actual destination to break or
    // continue to.
    var i = 0;
    for (; i < this.labels.length; ++i) {
      var lab = this.labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
        if (node.label && isBreak) { break }
      }
    }
    if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
  };

  pp$1.parseDebuggerStatement = function(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement")
  };

  pp$1.parseDoStatement = function(node) {
    this.next();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types._while);
    node.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6)
      { this.eat(types.semi); }
    else
      { this.semicolon(); }
    return this.finishNode(node, "DoWhileStatement")
  };

  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
  // loop is non-trivial. Basically, we have to parse the init `var`
  // statement or expression, disallowing the `in` operator (see
  // the second parameter to `parseExpression`), and then check
  // whether the next token is `in` or `of`. When there is no init
  // part (semicolon immediately after the opening parenthesis), it
  // is a regular `for` loop.

  pp$1.parseForStatement = function(node) {
    this.next();
    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types.parenL);
    if (this.type === types.semi) {
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, null)
    }
    var isLet = this.isLet();
    if (this.type === types._var || this.type === types._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types._in) {
            if (awaitAt > -1) { this.unexpected(awaitAt); }
          } else { node.await = awaitAt > -1; }
        }
        return this.parseForIn(node, init$1)
      }
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, init$1)
    }
    var refDestructuringErrors = new DestructuringErrors;
    var init = this.parseExpression(true, refDestructuringErrors);
    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      this.toAssignable(init, false, refDestructuringErrors);
      this.checkLVal(init);
      return this.parseForIn(node, init)
    } else {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init)
  };

  pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
  };

  pp$1.parseIfStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    // allow function declarations in branches, but only in non-strict mode
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement")
  };

  pp$1.parseReturnStatement = function(node) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
      { this.raise(this.start, "'return' outside of function"); }
    this.next();

    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.

    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
    else { node.argument = this.parseExpression(); this.semicolon(); }
    return this.finishNode(node, "ReturnStatement")
  };

  pp$1.parseSwitchStatement = function(node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    node.cases = [];
    this.expect(types.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);

    // Statements under must be grouped (by label) in SwitchCase
    // nodes. `cur` is used to keep the node that we are currently
    // adding statements to.

    var cur;
    for (var sawDefault = false; this.type !== types.braceR;) {
      if (this.type === types._case || this.type === types._default) {
        var isCase = this.type === types._case;
        if (cur) { this.finishNode(cur, "SwitchCase"); }
        node.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types.colon);
      } else {
        if (!cur) { this.unexpected(); }
        cur.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    if (cur) { this.finishNode(cur, "SwitchCase"); }
    this.next(); // Closing brace
    this.labels.pop();
    return this.finishNode(node, "SwitchStatement")
  };

  pp$1.parseThrowStatement = function(node) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
      { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement")
  };

  // Reused empty array added for node fields that are always empty.

  var empty = [];

  pp$1.parseTryStatement = function(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.type === types._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types.parenL)) {
        clause.param = this.parseBindingAtom();
        var simple = clause.param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types.parenR);
      } else {
        if (this.options.ecmaVersion < 10) { this.unexpected(); }
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node.handler = this.finishNode(clause, "CatchClause");
    }
    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer)
      { this.raise(node.start, "Missing catch or finally clause"); }
    return this.finishNode(node, "TryStatement")
  };

  pp$1.parseVarStatement = function(node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration")
  };

  pp$1.parseWhileStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node, "WhileStatement")
  };

  pp$1.parseWithStatement = function(node) {
    if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement("with");
    return this.finishNode(node, "WithStatement")
  };

  pp$1.parseEmptyStatement = function(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement")
  };

  pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
      {
      var label = list[i$1];

      if (label.name === maybeName)
        { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    } }
    var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
    for (var i = this.labels.length - 1; i >= 0; i--) {
      var label$1 = this.labels[i];
      if (label$1.statementStart === node.start) {
        // Update information about previous labels on this node
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else { break }
    }
    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement")
  };

  pp$1.parseExpressionStatement = function(node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement")
  };

  // Parse a semicolon-enclosed block of statements, handling `"use
  // strict"` declarations when `allowStrict` is true (used for
  // function bodies).

  pp$1.parseBlock = function(createNewLexicalScope, node, exitStrict) {
    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
    if ( node === void 0 ) node = this.startNode();

    node.body = [];
    this.expect(types.braceL);
    if (createNewLexicalScope) { this.enterScope(0); }
    while (this.type !== types.braceR) {
      var stmt = this.parseStatement(null);
      node.body.push(stmt);
    }
    if (exitStrict) { this.strict = false; }
    this.next();
    if (createNewLexicalScope) { this.exitScope(); }
    return this.finishNode(node, "BlockStatement")
  };

  // Parse a regular `for` loop. The disambiguation code in
  // `parseStatement` will already have parsed the init statement or
  // expression.

  pp$1.parseFor = function(node, init) {
    node.init = init;
    this.expect(types.semi);
    node.test = this.type === types.semi ? null : this.parseExpression();
    this.expect(types.semi);
    node.update = this.type === types.parenR ? null : this.parseExpression();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, "ForStatement")
  };

  // Parse a `for`/`in` and `for`/`of` loop, which are almost
  // same from parser's perspective.

  pp$1.parseForIn = function(node, init) {
    var isForIn = this.type === types._in;
    this.next();

    if (
      init.type === "VariableDeclaration" &&
      init.declarations[0].init != null &&
      (
        !isForIn ||
        this.options.ecmaVersion < 8 ||
        this.strict ||
        init.kind !== "var" ||
        init.declarations[0].id.type !== "Identifier"
      )
    ) {
      this.raise(
        init.start,
        ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
      );
    } else if (init.type === "AssignmentPattern") {
      this.raise(init.start, "Invalid left-hand side in for-loop");
    }
    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
  };

  // Parse a list of variable declarations.

  pp$1.parseVar = function(node, isFor, kind) {
    node.declarations = [];
    node.kind = kind;
    for (;;) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
        this.unexpected();
      } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types.comma)) { break }
    }
    return node
  };

  pp$1.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };

  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

  // Parse a function declaration or literal (depending on the
  // `statement & FUNC_STATEMENT`).

  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
  pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
    this.initFunction(node);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
        { this.unexpected(); }
      node.generator = this.eat(types.star);
    }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    if (statement & FUNC_STATEMENT) {
      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
      if (node.id && !(statement & FUNC_HANGING_STATEMENT))
        // If it is a regular function declaration in sloppy mode, then it is
        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
        // mode depends on properties of the current scope (see
        // treatFunctionsAsVar).
        { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
    }

    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node.async, node.generator));

    if (!(statement & FUNC_STATEMENT))
      { node.id = this.type === types.name ? this.parseIdent() : null; }

    this.parseFunctionParams(node);
    this.parseFunctionBody(node, allowExpressionBody, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
  };

  pp$1.parseFunctionParams = function(node) {
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };

  // Parse a class declaration or literal (depending on the
  // `isStatement` parameter).

  pp$1.parseClass = function(node, isStatement) {
    this.next();

    // ecma-262 14.6 Class Definitions
    // A class definition is always strict mode code.
    var oldStrict = this.strict;
    this.strict = true;

    this.parseClassId(node, isStatement);
    this.parseClassSuper(node);
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types.braceL);
    while (this.type !== types.braceR) {
      var element = this.parseClassElement(node.superClass !== null);
      if (element) {
        classBody.body.push(element);
        if (element.type === "MethodDefinition" && element.kind === "constructor") {
          if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
          hadConstructor = true;
        }
      }
    }
    this.strict = oldStrict;
    this.next();
    node.body = this.finishNode(classBody, "ClassBody");
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
  };

  pp$1.parseClassElement = function(constructorAllowsSuper) {
    var this$1 = this;

    if (this.eat(types.semi)) { return null }

    var method = this.startNode();
    var tryContextual = function (k, noLineBreak) {
      if ( noLineBreak === void 0 ) noLineBreak = false;

      var start = this$1.start, startLoc = this$1.startLoc;
      if (!this$1.eatContextual(k)) { return false }
      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
      if (method.key) { this$1.unexpected(); }
      method.computed = false;
      method.key = this$1.startNodeAt(start, startLoc);
      method.key.name = k;
      this$1.finishNode(method.key, "Identifier");
      return false
    };

    method.kind = "method";
    method.static = tryContextual("static");
    var isGenerator = this.eat(types.star);
    var isAsync = false;
    if (!isGenerator) {
      if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      } else if (tryContextual("get")) {
        method.kind = "get";
      } else if (tryContextual("set")) {
        method.kind = "set";
      }
    }
    if (!method.key) { this.parsePropertyName(method); }
    var key = method.key;
    var allowsDirectSuper = false;
    if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
        key.type === "Literal" && key.value === "constructor")) {
      if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
      if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
      if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
      method.kind = "constructor";
      allowsDirectSuper = constructorAllowsSuper;
    } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
      this.raise(key.start, "Classes may not have a static property named prototype");
    }
    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && method.value.params.length !== 0)
      { this.raiseRecoverable(method.value.start, "getter should have no params"); }
    if (method.kind === "set" && method.value.params.length !== 1)
      { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
    if (method.kind === "set" && method.value.params[0].type === "RestElement")
      { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
    return method
  };

  pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    return this.finishNode(method, "MethodDefinition")
  };

  pp$1.parseClassId = function(node, isStatement) {
    if (this.type === types.name) {
      node.id = this.parseIdent();
      if (isStatement)
        { this.checkLVal(node.id, BIND_LEXICAL, false); }
    } else {
      if (isStatement === true)
        { this.unexpected(); }
      node.id = null;
    }
  };

  pp$1.parseClassSuper = function(node) {
    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
  };

  // Parses module export declaration.

  pp$1.parseExport = function(node, exports) {
    this.next();
    // export * from '...'
    if (this.eat(types.star)) {
      if (this.options.ecmaVersion >= 11) {
        if (this.eatContextual("as")) {
          node.exported = this.parseIdent(true);
          this.checkExport(exports, node.exported.name, this.lastTokStart);
        } else {
          node.exported = null;
        }
      }
      this.expectContextual("from");
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
      this.semicolon();
      return this.finishNode(node, "ExportAllDeclaration")
    }
    if (this.eat(types._default)) { // export default ...
      this.checkExport(exports, "default", this.lastTokStart);
      var isAsync;
      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync) { this.next(); }
        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
      } else if (this.type === types._class) {
        var cNode = this.startNode();
        node.declaration = this.parseClass(cNode, "nullableID");
      } else {
        node.declaration = this.parseMaybeAssign();
        this.semicolon();
      }
      return this.finishNode(node, "ExportDefaultDeclaration")
    }
    // export var|const|let|function|class ...
    if (this.shouldParseExportStatement()) {
      node.declaration = this.parseStatement(null);
      if (node.declaration.type === "VariableDeclaration")
        { this.checkVariableExport(exports, node.declaration.declarations); }
      else
        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
      node.specifiers = [];
      node.source = null;
    } else { // export { x, y as z } [from '...']
      node.declaration = null;
      node.specifiers = this.parseExportSpecifiers(exports);
      if (this.eatContextual("from")) {
        if (this.type !== types.string) { this.unexpected(); }
        node.source = this.parseExprAtom();
      } else {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          // check for keywords used as local names
          var spec = list[i];

          this.checkUnreserved(spec.local);
          // check if export is defined
          this.checkLocalExport(spec.local);
        }

        node.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(node, "ExportNamedDeclaration")
  };

  pp$1.checkExport = function(exports, name, pos) {
    if (!exports) { return }
    if (has(exports, name))
      { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
    exports[name] = true;
  };

  pp$1.checkPatternExport = function(exports, pat) {
    var type = pat.type;
    if (type === "Identifier")
      { this.checkExport(exports, pat.name, pat.start); }
    else if (type === "ObjectPattern")
      { for (var i = 0, list = pat.properties; i < list.length; i += 1)
        {
          var prop = list[i];

          this.checkPatternExport(exports, prop);
        } }
    else if (type === "ArrayPattern")
      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
        var elt = list$1[i$1];

          if (elt) { this.checkPatternExport(exports, elt); }
      } }
    else if (type === "Property")
      { this.checkPatternExport(exports, pat.value); }
    else if (type === "AssignmentPattern")
      { this.checkPatternExport(exports, pat.left); }
    else if (type === "RestElement")
      { this.checkPatternExport(exports, pat.argument); }
    else if (type === "ParenthesizedExpression")
      { this.checkPatternExport(exports, pat.expression); }
  };

  pp$1.checkVariableExport = function(exports, decls) {
    if (!exports) { return }
    for (var i = 0, list = decls; i < list.length; i += 1)
      {
      var decl = list[i];

      this.checkPatternExport(exports, decl.id);
    }
  };

  pp$1.shouldParseExportStatement = function() {
    return this.type.keyword === "var" ||
      this.type.keyword === "const" ||
      this.type.keyword === "class" ||
      this.type.keyword === "function" ||
      this.isLet() ||
      this.isAsyncFunction()
  };

  // Parses a comma-separated list of module exports.

  pp$1.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    // export { x, y as z } [from '...']
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node = this.startNode();
      node.local = this.parseIdent(true);
      node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
      this.checkExport(exports, node.exported.name, node.exported.start);
      nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    return nodes
  };

  // Parses import declaration.

  pp$1.parseImport = function(node) {
    this.next();
    // import '...'
    if (this.type === types.string) {
      node.specifiers = empty;
      node.source = this.parseExprAtom();
    } else {
      node.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration")
  };

  // Parses a comma-separated list of module imports.

  pp$1.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types.name) {
      // import defaultObj, { x, y as z } from '...'
      var node = this.startNode();
      node.local = this.parseIdent();
      this.checkLVal(node.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
      if (!this.eat(types.comma)) { return nodes }
    }
    if (this.type === types.star) {
      var node$1 = this.startNode();
      this.next();
      this.expectContextual("as");
      node$1.local = this.parseIdent();
      this.checkLVal(node$1.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
      return nodes
    }
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node$2 = this.startNode();
      node$2.imported = this.parseIdent(true);
      if (this.eatContextual("as")) {
        node$2.local = this.parseIdent();
      } else {
        this.checkUnreserved(node$2.imported);
        node$2.local = node$2.imported;
      }
      this.checkLVal(node$2.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$2, "ImportSpecifier"));
    }
    return nodes
  };

  // Set `ExpressionStatement#directive` property for directive prologues.
  pp$1.adaptDirectivePrologue = function(statements) {
    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
      statements[i].directive = statements[i].expression.raw.slice(1, -1);
    }
  };
  pp$1.isDirectiveCandidate = function(statement) {
    return (
      statement.type === "ExpressionStatement" &&
      statement.expression.type === "Literal" &&
      typeof statement.expression.value === "string" &&
      // Reject parenthesized strings.
      (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
    )
  };

  var pp$2 = Parser.prototype;

  // Convert existing expression atom to assignable pattern
  // if possible.

  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node) {
      switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await")
          { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
        break

      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break

      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];

        this.toAssignable(prop, isBinding);
          // Early error:
          //   AssignmentRestProperty[Yield, Await] :
          //     `...` DestructuringAssignmentTarget[Yield, Await]
          //
          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
          if (
            prop.type === "RestElement" &&
            (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
          ) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break

      case "Property":
        // AssignmentProperty has type === "Property"
        if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
        this.toAssignable(node.value, isBinding);
        break

      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        this.toAssignableList(node.elements, isBinding);
        break

      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern")
          { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
        break

      case "AssignmentExpression":
        if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        // falls through to AssignmentPattern

      case "AssignmentPattern":
        break

      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break

      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break

      case "MemberExpression":
        if (!isBinding) { break }

      default:
        this.raise(node.start, "Assigning to rvalue");
      }
    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
    return node
  };

  // Convert list of expression atoms to binding list.

  pp$2.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for (var i = 0; i < end; i++) {
      var elt = exprList[i];
      if (elt) { this.toAssignable(elt, isBinding); }
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
        { this.unexpected(last.argument.start); }
    }
    return exprList
  };

  // Parses spread element.

  pp$2.parseSpread = function(refDestructuringErrors) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node, "SpreadElement")
  };

  pp$2.parseRestBinding = function() {
    var node = this.startNode();
    this.next();

    // RestElement inside of a function parameter must be an identifier
    if (this.options.ecmaVersion === 6 && this.type !== types.name)
      { this.unexpected(); }

    node.argument = this.parseBindingAtom();

    return this.finishNode(node, "RestElement")
  };

  // Parses lvalue (assignable) atom.

  pp$2.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) {
      switch (this.type) {
      case types.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern")

      case types.braceL:
        return this.parseObj(true)
      }
    }
    return this.parseIdent()
  };

  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (first) { first = false; }
      else { this.expect(types.comma); }
      if (allowEmpty && this.type === types.comma) {
        elts.push(null);
      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
        break
      } else if (this.type === types.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        this.expect(close);
        break
      } else {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        elts.push(elem);
      }
    }
    return elts
  };

  pp$2.parseBindingListItem = function(param) {
    return param
  };

  // Parses assignment pattern around given atom if possible.

  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern")
  };

  // Verify that a node is an lval — something that can be assigned
  // to.
  // bindingType can be either:
  // 'var' indicating that the lval creates a 'var' binding
  // 'let' indicating that the lval creates a lexical ('let' or 'const') binding
  // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

  pp$2.checkLVal = function(expr, bindingType, checkClashes) {
    if ( bindingType === void 0 ) bindingType = BIND_NONE;

    switch (expr.type) {
    case "Identifier":
      if (bindingType === BIND_LEXICAL && expr.name === "let")
        { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
        { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
      if (checkClashes) {
        if (has(checkClashes, expr.name))
          { this.raiseRecoverable(expr.start, "Argument name clash"); }
        checkClashes[expr.name] = true;
      }
      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
      break

    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break

    case "MemberExpression":
      if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
      break

    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1)
        {
      var prop = list[i];

      this.checkLVal(prop, bindingType, checkClashes);
    }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      this.checkLVal(expr.value, bindingType, checkClashes);
      break

    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];

      if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
      }
      break

    case "AssignmentPattern":
      this.checkLVal(expr.left, bindingType, checkClashes);
      break

    case "RestElement":
      this.checkLVal(expr.argument, bindingType, checkClashes);
      break

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, bindingType, checkClashes);
      break

    default:
      this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
    }
  };

  // A recursive descent parser operates by defining functions for all

  var pp$3 = Parser.prototype;

  // Check if property name clashes with already added.
  // Object/class getters and setters are not allowed to clash —
  // either with each other or with an init property — and in
  // strict mode, init properties are also not allowed to be repeated.

  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
      { return }
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
      { return }
    var key = prop.key;
    var name;
    switch (key.type) {
    case "Identifier": name = key.name; break
    case "Literal": name = String(key.value); break
    default: return
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors) {
            if (refDestructuringErrors.doubleProto < 0)
              { refDestructuringErrors.doubleProto = key.start; }
            // Backwards-compat kludge. Can be removed in version 6.0
          } else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
        }
        propHash.proto = true;
      }
      return
    }
    name = "$" + name;
    var other = propHash[name];
    if (other) {
      var redefinition;
      if (kind === "init") {
        redefinition = this.strict && other.init || other.get || other.set;
      } else {
        redefinition = other.init || other[kind];
      }
      if (redefinition)
        { this.raiseRecoverable(key.start, "Redefinition of property"); }
    } else {
      other = propHash[name] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  };

  // ### Expression parsing

  // These nest, from the most general expression type at the top to
  // 'atomic', nondivisible expression types at the bottom. Most of
  // the functions will simply let the function(s) below them parse,
  // and, *if* the syntactic construct they handle is present, wrap
  // the AST node that the inner parser gave them in another node.

  // Parse a full expression. The optional arguments are used to
  // forbid the `in` operator (in for loops initalization expressions)
  // and provide reference for storing '=' operator inside shorthand
  // property assignment in contexts where both object expression
  // and object pattern might appear (so it's possible to raise
  // delayed syntax error at correct position).

  pp$3.parseExpression = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
    if (this.type === types.comma) {
      var node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];
      while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
      return this.finishNode(node, "SequenceExpression")
    }
    return expr
  };

  // Parse an assignment expression. This includes applications of
  // operators like `+=`.

  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) { return this.parseYield(noIn) }
      // The tokenizer will assume an expression is allowed after
      // `yield`, but this isn't that kind of yield
      else { this.exprAllowed = false; }
    }

    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors;
      ownDestructuringErrors = true;
    }

    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types.parenL || this.type === types.name)
      { this.potentialArrowAt = this.start; }
    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
    if (this.type.isAssign) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
      if (!ownDestructuringErrors) {
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
      }
      if (refDestructuringErrors.shorthandAssign >= node.left.start)
        { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
      this.checkLVal(left);
      this.next();
      node.right = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "AssignmentExpression")
    } else {
      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
    }
    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
    return left
  };

  // Parse a ternary conditional (`?:`) operator.

  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(noIn, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    if (this.eat(types.question)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(types.colon);
      node.alternate = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "ConditionalExpression")
    }
    return expr
  };

  // Start the precedence parser.

  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
  };

  // Parse binary operators with the operator precedence parsing
  // algorithm. `left` is the left-hand side of the operator.
  // `minPrec` provides context that allows the function to stop and
  // defer further parser to one of its callers when it encounters an
  // operator that has a lower precedence than the set it is parsing.

  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    var prec = this.type.binop;
    if (prec != null && (!noIn || this.type !== types._in)) {
      if (prec > minPrec) {
        var logical = this.type === types.logicalOR || this.type === types.logicalAND;
        var coalesce = this.type === types.coalesce;
        if (coalesce) {
          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
          prec = types.logicalAND.binop;
        }
        var op = this.value;
        this.next();
        var startPos = this.start, startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
        if ((logical && this.type === types.coalesce) || (coalesce && (this.type === types.logicalOR || this.type === types.logicalAND))) {
          this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
        }
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
      }
    }
    return left
  };

  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.operator = op;
    node.right = right;
    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
  };

  // Parse unary operators, both prefix and postfix.

  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
      expr = this.parseAwait();
      sawUnary = true;
    } else if (this.type.prefix) {
      var node = this.startNode(), update = this.type === types.incDec;
      node.operator = this.value;
      node.prefix = true;
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update) { this.checkLVal(node.argument); }
      else if (this.strict && node.operator === "delete" &&
               node.argument.type === "Identifier")
        { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
      else { sawUnary = true; }
      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.operator = this.value;
        node$1.prefix = false;
        node$1.argument = expr;
        this.checkLVal(expr);
        this.next();
        expr = this.finishNode(node$1, "UpdateExpression");
      }
    }

    if (!sawUnary && this.eat(types.starstar))
      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
    else
      { return expr }
  };

  // Parse call, dot, and `[]`-subscript expressions.

  pp$3.parseExprSubscripts = function(refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
      { return expr }
    var result = this.parseSubscripts(expr, startPos, startLoc);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
    }
    return result
  };

  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
        this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
        this.potentialArrowAt === base.start;
    var optionalChained = false;

    while (true) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);

      if (element.optional) { optionalChained = true; }
      if (element === base || element.type === "ArrowFunctionExpression") {
        if (optionalChained) {
          var chainNode = this.startNodeAt(startPos, startLoc);
          chainNode.expression = element;
          element = this.finishNode(chainNode, "ChainExpression");
        }
        return element
      }

      base = element;
    }
  };

  pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
    var optionalSupported = this.options.ecmaVersion >= 11;
    var optional = optionalSupported && this.eat(types.questionDot);
    if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

    var computed = this.eat(types.bracketL);
    if (computed || (optional && this.type !== types.parenL && this.type !== types.backQuote) || this.eat(types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
      node.computed = !!computed;
      if (computed) { this.expect(types.bracketR); }
      if (optionalSupported) {
        node.optional = optional;
      }
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0)
          { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      if (optionalSupported) {
        node$1.optional = optional;
      }
      base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types.backQuote) {
      if (optional || optionalChained) {
        this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
      }
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({isTagged: true});
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base
  };

  // Parse an atomic expression — either a single token that is an
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.

  pp$3.parseExprAtom = function(refDestructuringErrors) {
    // If a division operator appears in an expression position, the
    // tokenizer got confused, and we force it to read a regexp instead.
    if (this.type === types.slash) { this.readRegexp(); }

    var node, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
    case types._super:
      if (!this.allowSuper)
        { this.raise(this.start, "'super' keyword outside a method"); }
      node = this.startNode();
      this.next();
      if (this.type === types.parenL && !this.allowDirectSuper)
        { this.raise(node.start, "super() call outside constructor of a subclass"); }
      // The `super` keyword can appear at below:
      // SuperProperty:
      //     super [ Expression ]
      //     super . IdentifierName
      // SuperCall:
      //     super ( Arguments )
      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
        { this.unexpected(); }
      return this.finishNode(node, "Super")

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression")

    case types.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
        { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types.arrow))
          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types.arrow))
            { this.unexpected(); }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
        }
      }
      return id

    case types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = {pattern: value.pattern, flags: value.flags};
      return node

    case types.num: case types.string:
      return this.parseLiteral(this.value)

    case types._null: case types._true: case types._false:
      node = this.startNode();
      node.value = this.type === types._null ? null : this.type === types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal")

    case types.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
          { refDestructuringErrors.parenthesizedAssign = start; }
        if (refDestructuringErrors.parenthesizedBind < 0)
          { refDestructuringErrors.parenthesizedBind = start; }
      }
      return expr

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression")

    case types.braceL:
      return this.parseObj(false, refDestructuringErrors)

    case types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0)

    case types._class:
      return this.parseClass(this.startNode(), false)

    case types._new:
      return this.parseNew()

    case types.backQuote:
      return this.parseTemplate()

    case types._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport()
      } else {
        return this.unexpected()
      }

    default:
      this.unexpected();
    }
  };

  pp$3.parseExprImport = function() {
    var node = this.startNode();

    // Consume `import` as an identifier for `import.meta`.
    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
    var meta = this.parseIdent(true);

    switch (this.type) {
    case types.parenL:
      return this.parseDynamicImport(node)
    case types.dot:
      node.meta = meta;
      return this.parseImportMeta(node)
    default:
      this.unexpected();
    }
  };

  pp$3.parseDynamicImport = function(node) {
    this.next(); // skip `(`

    // Parse node.source.
    node.source = this.parseMaybeAssign();

    // Verify ending.
    if (!this.eat(types.parenR)) {
      var errorPos = this.start;
      if (this.eat(types.comma) && this.eat(types.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }

    return this.finishNode(node, "ImportExpression")
  };

  pp$3.parseImportMeta = function(node) {
    this.next(); // skip `.`

    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);

    if (node.property.name !== "meta")
      { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
    if (containsEsc)
      { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
    if (this.options.sourceType !== "module")
      { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

    return this.finishNode(node, "MetaProperty")
  };

  pp$3.parseLiteral = function(value) {
    var node = this.startNode();
    node.value = value;
    node.raw = this.input.slice(this.start, this.end);
    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
    this.next();
    return this.finishNode(node, "Literal")
  };

  pp$3.parseParenExpression = function() {
    this.expect(types.parenL);
    var val = this.parseExpression();
    this.expect(types.parenR);
    return val
  };

  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();

      var innerStartPos = this.start, innerStartLoc = this.startLoc;
      var exprList = [], first = true, lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      // Do not save awaitIdentPos to allow checking awaits nested in parameters
      while (this.type !== types.parenR) {
        first ? first = false : this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
          lastIsComma = true;
          break
        } else if (this.type === types.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
          break
        } else {
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
      }
      var innerEndPos = this.start, innerEndLoc = this.startLoc;
      this.expect(types.parenR);

      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList)
      }

      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
      if (spreadStart) { this.unexpected(spreadStart); }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
    } else {
      val = this.parseParenExpression();
    }

    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression")
    } else {
      return val
    }
  };

  pp$3.parseParenItem = function(item) {
    return item
  };

  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
  };

  // New's precedence is slightly tricky. It must allow its argument to
  // be a `[]` or dot subscript expression, but not a call — at least,
  // not without wrapping it in parentheses. Thus, it uses the noCalls
  // argument to parseSubscripts to prevent it from consuming the
  // argument list.

  var empty$1 = [];

  pp$3.parseNew = function() {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
    var node = this.startNode();
    var meta = this.parseIdent(true);
    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
      node.meta = meta;
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "target")
        { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
      if (containsEsc)
        { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
      if (!this.inNonArrowFunction())
        { this.raiseRecoverable(node.start, "'new.target' can only be used in functions"); }
      return this.finishNode(node, "MetaProperty")
    }
    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    if (isImport && node.callee.type === "ImportExpression") {
      this.raise(startPos, "Cannot use new with import()");
    }
    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
    else { node.arguments = empty$1; }
    return this.finishNode(node, "NewExpression")
  };

  // Parse template expression.

  pp$3.parseTemplateElement = function(ref) {
    var isTagged = ref.isTagged;

    var elem = this.startNode();
    if (this.type === types.invalidTemplate) {
      if (!isTagged) {
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      }
      elem.value = {
        raw: this.value,
        cooked: null
      };
    } else {
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    }
    this.next();
    elem.tail = this.type === types.backQuote;
    return this.finishNode(elem, "TemplateElement")
  };

  pp$3.parseTemplate = function(ref) {
    if ( ref === void 0 ) ref = {};
    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

    var node = this.startNode();
    this.next();
    node.expressions = [];
    var curElt = this.parseTemplateElement({isTagged: isTagged});
    node.quasis = [curElt];
    while (!curElt.tail) {
      if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
      this.expect(types.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(types.braceR);
      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral")
  };

  pp$3.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  // Parse an object literal or binding pattern.

  pp$3.parseObj = function(isPattern, refDestructuringErrors) {
    var node = this.startNode(), first = true, propHash = {};
    node.properties = [];
    this.next();
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
      node.properties.push(prop);
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
  };

  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        return this.finishNode(prop, "RestElement")
      }
      // To disallow parenthesized identifier via `this.toAssignable()`.
      if (this.type === types.parenL && refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0) {
          refDestructuringErrors.parenthesizedAssign = this.start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = this.start;
        }
      }
      // Parse argument.
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      // To disallow trailing comma via `this.toAssignable()`.
      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
      // Finish
      return this.finishNode(prop, "SpreadElement")
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern)
        { isGenerator = this.eat(types.star); }
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      this.parsePropertyName(prop, refDestructuringErrors);
    } else {
      isAsync = false;
    }
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property")
  };

  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types.colon)
      { this.unexpected(); }

    if (this.eat(types.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
      if (isPattern) { this.unexpected(); }
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc &&
               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
               (prop.key.name === "get" || prop.key.name === "set") &&
               (this.type !== types.comma && this.type !== types.braceR && this.type !== types.eq)) {
      if (isGenerator || isAsync) { this.unexpected(); }
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get")
          { this.raiseRecoverable(start, "getter should have no params"); }
        else
          { this.raiseRecoverable(start, "setter should have exactly one param"); }
      } else {
        if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
          { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
      }
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync) { this.unexpected(); }
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = startPos; }
      prop.kind = "init";
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else if (this.type === types.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0)
          { refDestructuringErrors.shorthandAssign = this.start; }
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else {
        prop.value = prop.key;
      }
      prop.shorthand = true;
    } else { this.unexpected(); }
  };

  pp$3.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types.bracketR);
        return prop.key
      } else {
        prop.computed = false;
      }
    }
    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
  };

  // Initialize empty function node.

  pp$3.initFunction = function(node) {
    node.id = null;
    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
    if (this.options.ecmaVersion >= 8) { node.async = false; }
  };

  // Parse object or class method.

  pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.initFunction(node);
    if (this.options.ecmaVersion >= 6)
      { node.generator = isGenerator; }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node, false, true);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "FunctionExpression")
  };

  // Parse arrow function expression with given parameters.

  pp$3.parseArrowExpression = function(node, params, isAsync) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node);
    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;

    node.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node, true, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "ArrowFunctionExpression")
  };

  // Parse function body and check parameters.

  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
    var isExpression = isArrowFunction && this.type !== types.braceL;
    var oldStrict = this.strict, useStrict = false;

    if (isExpression) {
      node.body = this.parseMaybeAssign();
      node.expression = true;
      this.checkParams(node, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        // If this is a strict mode function, verify that argument names
        // are not repeated, and it does not try to bind the words `eval`
        // or `arguments`.
        if (useStrict && nonSimple)
          { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
      }
      // Start a new scope with regard to labels and the `inFunction`
      // flag (restore them to their old value afterwards).
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict) { this.strict = true; }

      // Add the params to varDeclaredNames to ensure that an error is thrown
      // if a let/const declaration in the function clashes with one of the params.
      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
      // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
      if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
      node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
      node.expression = false;
      this.adaptDirectivePrologue(node.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();
  };

  pp$3.isSimpleParamList = function(params) {
    for (var i = 0, list = params; i < list.length; i += 1)
      {
      var param = list[i];

      if (param.type !== "Identifier") { return false
    } }
    return true
  };

  // Checks function params for various disallowed patterns such as using "eval"
  // or "arguments" and duplicate parameters.

  pp$3.checkParams = function(node, allowDuplicates) {
    var nameHash = {};
    for (var i = 0, list = node.params; i < list.length; i += 1)
      {
      var param = list[i];

      this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };

  // Parses a comma-separated list of expressions, and returns them as
  // an array. `close` is the token type that ends the list, and
  // `allowEmpty` can be turned on to allow subsequent commas with
  // nothing in between them to be parsed as `null` (which is needed
  // for array literals).

  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (!first) {
        this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(close)) { break }
      } else { first = false; }

      var elt = (void 0);
      if (allowEmpty && this.type === types.comma)
        { elt = null; }
      else if (this.type === types.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
          { refDestructuringErrors.trailingComma = this.start; }
      } else {
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      }
      elts.push(elt);
    }
    return elts
  };

  pp$3.checkUnreserved = function(ref) {
    var start = ref.start;
    var end = ref.end;
    var name = ref.name;

    if (this.inGenerator && name === "yield")
      { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
    if (this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
    if (this.keywords.test(name))
      { this.raise(start, ("Unexpected keyword '" + name + "'")); }
    if (this.options.ecmaVersion < 6 &&
      this.input.slice(start, end).indexOf("\\") !== -1) { return }
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name)) {
      if (!this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
      this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
    }
  };

  // Parse the next token as an identifier. If `liberal` is true (used
  // when parsing properties), it will also convert keywords into
  // identifiers.

  pp$3.parseIdent = function(liberal, isBinding) {
    var node = this.startNode();
    if (this.type === types.name) {
      node.name = this.value;
    } else if (this.type.keyword) {
      node.name = this.type.keyword;

      // To fix https://github.com/acornjs/acorn/issues/575
      // `class` and `function` keywords push new context into this.context.
      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
      if ((node.name === "class" || node.name === "function") &&
          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
        this.context.pop();
      }
    } else {
      this.unexpected();
    }
    this.next(!!liberal);
    this.finishNode(node, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node);
      if (node.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = node.start; }
    }
    return node
  };

  // Parses yield expression inside generator.

  pp$3.parseYield = function(noIn) {
    if (!this.yieldPos) { this.yieldPos = this.start; }

    var node = this.startNode();
    this.next();
    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(types.star);
      node.argument = this.parseMaybeAssign(noIn);
    }
    return this.finishNode(node, "YieldExpression")
  };

  pp$3.parseAwait = function() {
    if (!this.awaitPos) { this.awaitPos = this.start; }

    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(null, false);
    return this.finishNode(node, "AwaitExpression")
  };

  var pp$4 = Parser.prototype;

  // This function is used to raise exceptions on parse errors. It
  // takes an offset integer (into the current `input`) to indicate
  // the location of the error, attaches the position to the end
  // of the error message, and then raises a `SyntaxError` with that
  // message.

  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
    throw err
  };

  pp$4.raiseRecoverable = pp$4.raise;

  pp$4.curPosition = function() {
    if (this.options.locations) {
      return new Position(this.curLine, this.pos - this.lineStart)
    }
  };

  var pp$5 = Parser.prototype;

  var Scope = function Scope(flags) {
    this.flags = flags;
    // A list of var-declared names in the current lexical scope
    this.var = [];
    // A list of lexically-declared names in the current lexical scope
    this.lexical = [];
    // A list of lexically-declared FunctionDeclaration names in the current lexical scope
    this.functions = [];
  };

  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

  pp$5.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
  };

  pp$5.exitScope = function() {
    this.scopeStack.pop();
  };

  // The spec says:
  // > At the top level of a function, or script, function declarations are
  // > treated like var declarations rather than like lexical declarations.
  pp$5.treatFunctionsAsVarInScope = function(scope) {
    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
  };

  pp$5.declareName = function(name, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope = this.currentScope();
      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
      scope.lexical.push(name);
      if (this.inModule && (scope.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
    } else if (bindingType === BIND_SIMPLE_CATCH) {
      var scope$1 = this.currentScope();
      scope$1.lexical.push(name);
    } else if (bindingType === BIND_FUNCTION) {
      var scope$2 = this.currentScope();
      if (this.treatFunctionsAsVar)
        { redeclared = scope$2.lexical.indexOf(name) > -1; }
      else
        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
      scope$2.functions.push(name);
    } else {
      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
        var scope$3 = this.scopeStack[i];
        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
          redeclared = true;
          break
        }
        scope$3.var.push(name);
        if (this.inModule && (scope$3.flags & SCOPE_TOP))
          { delete this.undefinedExports[name]; }
        if (scope$3.flags & SCOPE_VAR) { break }
      }
    }
    if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
  };

  pp$5.checkLocalExport = function(id) {
    // scope.functions must be empty as Module code is always strict.
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
        this.scopeStack[0].var.indexOf(id.name) === -1) {
      this.undefinedExports[id.name] = id;
    }
  };

  pp$5.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1]
  };

  pp$5.currentVarScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR) { return scope }
    }
  };

  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
  pp$5.currentThisScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
    }
  };

  var Node = function Node(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations)
      { this.loc = new SourceLocation(parser, loc); }
    if (parser.options.directSourceFile)
      { this.sourceFile = parser.options.directSourceFile; }
    if (parser.options.ranges)
      { this.range = [pos, 0]; }
  };

  // Start an AST node, attaching a start offset.

  var pp$6 = Parser.prototype;

  pp$6.startNode = function() {
    return new Node(this, this.start, this.startLoc)
  };

  pp$6.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc)
  };

  // Finish an AST node, adding `type` and `end` properties.

  function finishNodeAt(node, type, pos, loc) {
    node.type = type;
    node.end = pos;
    if (this.options.locations)
      { node.loc.end = loc; }
    if (this.options.ranges)
      { node.range[1] = pos; }
    return node
  }

  pp$6.finishNode = function(node, type) {
    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
  };

  // Finish node at given position

  pp$6.finishNodeAt = function(node, type, pos, loc) {
    return finishNodeAt.call(this, node, type, pos, loc)
  };

  // The algorithm used to determine whether a regexp can appear at a

  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };

  var types$1 = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };

  var pp$7 = Parser.prototype;

  pp$7.initialContext = function() {
    return [types$1.b_stat]
  };

  pp$7.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types$1.f_expr || parent === types$1.f_stat)
      { return true }
    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
      { return !parent.isExpr }

    // The check for `tt.name && exprAllowed` detects whether we are
    // after a `yield` or `of` construct. See the `updateContext` for
    // `tt.name`.
    if (prevType === types._return || prevType === types.name && this.exprAllowed)
      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
      { return true }
    if (prevType === types.braceL)
      { return parent === types$1.b_stat }
    if (prevType === types._var || prevType === types._const || prevType === types.name)
      { return false }
    return !this.exprAllowed
  };

  pp$7.inGeneratorContext = function() {
    for (var i = this.context.length - 1; i >= 1; i--) {
      var context = this.context[i];
      if (context.token === "function")
        { return context.generator }
    }
    return false
  };

  pp$7.updateContext = function(prevType) {
    var update, type = this.type;
    if (type.keyword && prevType === types.dot)
      { this.exprAllowed = false; }
    else if (update = type.updateContext)
      { update.call(this, prevType); }
    else
      { this.exprAllowed = type.beforeExpr; }
  };

  // Token-specific context update code

  types.parenR.updateContext = types.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return
    }
    var out = this.context.pop();
    if (out === types$1.b_stat && this.curContext().token === "function") {
      out = this.context.pop();
    }
    this.exprAllowed = !out.isExpr;
  };

  types.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
    this.exprAllowed = true;
  };

  types.dollarBraceL.updateContext = function() {
    this.context.push(types$1.b_tmpl);
    this.exprAllowed = true;
  };

  types.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
    this.exprAllowed = true;
  };

  types.incDec.updateContext = function() {
    // tokExprAllowed stays unchanged
  };

  types._function.updateContext = types._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
        !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
      { this.context.push(types$1.f_expr); }
    else
      { this.context.push(types$1.f_stat); }
    this.exprAllowed = false;
  };

  types.backQuote.updateContext = function() {
    if (this.curContext() === types$1.q_tmpl)
      { this.context.pop(); }
    else
      { this.context.push(types$1.q_tmpl); }
    this.exprAllowed = false;
  };

  types.star.updateContext = function(prevType) {
    if (prevType === types._function) {
      var index = this.context.length - 1;
      if (this.context[index] === types$1.f_expr)
        { this.context[index] = types$1.f_expr_gen; }
      else
        { this.context[index] = types$1.f_gen; }
    }
    this.exprAllowed = true;
  };

  types.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
      if (this.value === "of" && !this.exprAllowed ||
          this.value === "yield" && this.inGeneratorContext())
        { allowed = true; }
    }
    this.exprAllowed = allowed;
  };

  // This file contains Unicode properties extracted from the ECMAScript
  // specification. The lists are extracted like so:
  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

  // #table-binary-unicode-properties
  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
  var ecma11BinaryProperties = ecma10BinaryProperties;
  var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties
  };

  // #table-unicode-general-category-values
  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

  // #table-unicode-script-values
  var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues
  };

  var data = {};
  function buildUnicodeData(ecmaVersion) {
    var d = data[ecmaVersion] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;

    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }
  buildUnicodeData(9);
  buildUnicodeData(10);
  buildUnicodeData(11);

  var pp$8 = Parser.prototype;

  var RegExpValidationState = function RegExpValidationState(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = [];
    this.backReferenceNames = [];
  };

  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  };

  RegExpValidationState.prototype.raise = function raise (message) {
    this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
  };

  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
  RegExpValidationState.prototype.at = function at (i, forceU) {
      if ( forceU === void 0 ) forceU = false;

    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return -1
    }
    var c = s.charCodeAt(i);
    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
      return c
    }
    var next = s.charCodeAt(i + 1);
    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
  };

  RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
      if ( forceU === void 0 ) forceU = false;

    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return l
    }
    var c = s.charCodeAt(i), next;
    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
      return i + 1
    }
    return i + 2
  };

  RegExpValidationState.prototype.current = function current (forceU) {
      if ( forceU === void 0 ) forceU = false;

    return this.at(this.pos, forceU)
  };

  RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
      if ( forceU === void 0 ) forceU = false;

    return this.at(this.nextIndex(this.pos, forceU), forceU)
  };

  RegExpValidationState.prototype.advance = function advance (forceU) {
      if ( forceU === void 0 ) forceU = false;

    this.pos = this.nextIndex(this.pos, forceU);
  };

  RegExpValidationState.prototype.eat = function eat (ch, forceU) {
      if ( forceU === void 0 ) forceU = false;

    if (this.current(forceU) === ch) {
      this.advance(forceU);
      return true
    }
    return false
  };

  function codePointToString(ch) {
    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
    ch -= 0x10000;
    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
  }

  /**
   * Validate the flags part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */
  pp$8.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;

    for (var i = 0; i < flags.length; i++) {
      var flag = flags.charAt(i);
      if (validFlags.indexOf(flag) === -1) {
        this.raise(state.start, "Invalid regular expression flag");
      }
      if (flags.indexOf(flag, i + 1) > -1) {
        this.raise(state.start, "Duplicate regular expression flag");
      }
    }
  };

  /**
   * Validate the pattern part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */
  pp$8.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);

    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
    // parsing contains a |GroupName|, reparse with the goal symbol
    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
    // exception if _P_ did not conform to the grammar, if any elements of _P_
    // were not matched by the parse, or if any Early Error conditions exist.
    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
      state.switchN = true;
      this.regexp_pattern(state);
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
  pp$8.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames.length = 0;
    state.backReferenceNames.length = 0;

    this.regexp_disjunction(state);

    if (state.pos !== state.source.length) {
      // Make the same messages as V8.
      if (state.eat(0x29 /* ) */)) {
        state.raise("Unmatched ')'");
      }
      if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
        state.raise("Lone quantifier brackets");
      }
    }
    if (state.maxBackReference > state.numCapturingParens) {
      state.raise("Invalid escape");
    }
    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
      var name = list[i];

      if (state.groupNames.indexOf(name) === -1) {
        state.raise("Invalid named capture referenced");
      }
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
  pp$8.regexp_disjunction = function(state) {
    this.regexp_alternative(state);
    while (state.eat(0x7C /* | */)) {
      this.regexp_alternative(state);
    }

    // Make the same message as V8.
    if (this.regexp_eatQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    if (state.eat(0x7B /* { */)) {
      state.raise("Lone quantifier brackets");
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
  pp$8.regexp_alternative = function(state) {
    while (state.pos < state.source.length && this.regexp_eatTerm(state))
      { }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
  pp$8.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
      // Handle `QuantifiableAssertion Quantifier` alternative.
      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
      // is a QuantifiableAssertion.
      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
        // Make the same message as V8.
        if (state.switchU) {
          state.raise("Invalid quantifier");
        }
      }
      return true
    }

    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
      this.regexp_eatQuantifier(state);
      return true
    }

    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
  pp$8.regexp_eatAssertion = function(state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;

    // ^, $
    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
      return true
    }

    // \b \B
    if (state.eat(0x5C /* \ */)) {
      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
        return true
      }
      state.pos = start;
    }

    // Lookahead / Lookbehind
    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
      var lookbehind = false;
      if (this.options.ecmaVersion >= 9) {
        lookbehind = state.eat(0x3C /* < */);
      }
      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
        this.regexp_disjunction(state);
        if (!state.eat(0x29 /* ) */)) {
          state.raise("Unterminated group");
        }
        state.lastAssertionIsQuantifiable = !lookbehind;
        return true
      }
    }

    state.pos = start;
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
  pp$8.regexp_eatQuantifier = function(state, noError) {
    if ( noError === void 0 ) noError = false;

    if (this.regexp_eatQuantifierPrefix(state, noError)) {
      state.eat(0x3F /* ? */);
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
  pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
    return (
      state.eat(0x2A /* * */) ||
      state.eat(0x2B /* + */) ||
      state.eat(0x3F /* ? */) ||
      this.regexp_eatBracedQuantifier(state, noError)
    )
  };
  pp$8.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(0x7B /* { */)) {
      var min = 0, max = -1;
      if (this.regexp_eatDecimalDigits(state)) {
        min = state.lastIntValue;
        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
          max = state.lastIntValue;
        }
        if (state.eat(0x7D /* } */)) {
          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
          if (max !== -1 && max < min && !noError) {
            state.raise("numbers out of order in {} quantifier");
          }
          return true
        }
      }
      if (state.switchU && !noError) {
        state.raise("Incomplete quantifier");
      }
      state.pos = start;
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
  pp$8.regexp_eatAtom = function(state) {
    return (
      this.regexp_eatPatternCharacters(state) ||
      state.eat(0x2E /* . */) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state)
    )
  };
  pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(0x5C /* \ */)) {
      if (this.regexp_eatAtomEscape(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(0x28 /* ( */)) {
      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
        this.regexp_disjunction(state);
        if (state.eat(0x29 /* ) */)) {
          return true
        }
        state.raise("Unterminated group");
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatCapturingGroup = function(state) {
    if (state.eat(0x28 /* ( */)) {
      if (this.options.ecmaVersion >= 9) {
        this.regexp_groupSpecifier(state);
      } else if (state.current() === 0x3F /* ? */) {
        state.raise("Invalid group");
      }
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        state.numCapturingParens += 1;
        return true
      }
      state.raise("Unterminated group");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
  pp$8.regexp_eatExtendedAtom = function(state) {
    return (
      state.eat(0x2E /* . */) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state) ||
      this.regexp_eatInvalidBracedQuantifier(state) ||
      this.regexp_eatExtendedPatternCharacter(state)
    )
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
  pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
  pp$8.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }
    return false
  };
  function isSyntaxCharacter(ch) {
    return (
      ch === 0x24 /* $ */ ||
      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
      ch === 0x2E /* . */ ||
      ch === 0x3F /* ? */ ||
      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
      ch >= 0x7B /* { */ && ch <= 0x7D /* } */
    )
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
  // But eat eager.
  pp$8.regexp_eatPatternCharacters = function(state) {
    var start = state.pos;
    var ch = 0;
    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
      state.advance();
    }
    return state.pos !== start
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
  pp$8.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    if (
      ch !== -1 &&
      ch !== 0x24 /* $ */ &&
      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
      ch !== 0x2E /* . */ &&
      ch !== 0x3F /* ? */ &&
      ch !== 0x5B /* [ */ &&
      ch !== 0x5E /* ^ */ &&
      ch !== 0x7C /* | */
    ) {
      state.advance();
      return true
    }
    return false
  };

  // GroupSpecifier ::
  //   [empty]
  //   `?` GroupName
  pp$8.regexp_groupSpecifier = function(state) {
    if (state.eat(0x3F /* ? */)) {
      if (this.regexp_eatGroupName(state)) {
        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
          state.raise("Duplicate capture group name");
        }
        state.groupNames.push(state.lastStringValue);
        return
      }
      state.raise("Invalid group");
    }
  };

  // GroupName ::
  //   `<` RegExpIdentifierName `>`
  // Note: this updates `state.lastStringValue` property with the eaten name.
  pp$8.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(0x3C /* < */)) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
        return true
      }
      state.raise("Invalid capture group name");
    }
    return false
  };

  // RegExpIdentifierName ::
  //   RegExpIdentifierStart
  //   RegExpIdentifierName RegExpIdentifierPart
  // Note: this updates `state.lastStringValue` property with the eaten name.
  pp$8.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
      while (this.regexp_eatRegExpIdentifierPart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
      }
      return true
    }
    return false
  };

  // RegExpIdentifierStart ::
  //   UnicodeIDStart
  //   `$`
  //   `_`
  //   `\` RegExpUnicodeEscapeSequence[+U]
  pp$8.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);

    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierStart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierStart(ch) {
    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
  }

  // RegExpIdentifierPart ::
  //   UnicodeIDContinue
  //   `$`
  //   `_`
  //   `\` RegExpUnicodeEscapeSequence[+U]
  //   <ZWNJ>
  //   <ZWJ>
  pp$8.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);

    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierPart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
  pp$8.regexp_eatAtomEscape = function(state) {
    if (
      this.regexp_eatBackReference(state) ||
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state) ||
      (state.switchN && this.regexp_eatKGroupName(state))
    ) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      if (state.current() === 0x63 /* c */) {
        state.raise("Invalid unicode escape");
      }
      state.raise("Invalid escape");
    }
    return false
  };
  pp$8.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n = state.lastIntValue;
      if (state.switchU) {
        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
        if (n > state.maxBackReference) {
          state.maxBackReference = n;
        }
        return true
      }
      if (n <= state.numCapturingParens) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatKGroupName = function(state) {
    if (state.eat(0x6B /* k */)) {
      if (this.regexp_eatGroupName(state)) {
        state.backReferenceNames.push(state.lastStringValue);
        return true
      }
      state.raise("Invalid named reference");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
  pp$8.regexp_eatCharacterEscape = function(state) {
    return (
      this.regexp_eatControlEscape(state) ||
      this.regexp_eatCControlLetter(state) ||
      this.regexp_eatZero(state) ||
      this.regexp_eatHexEscapeSequence(state) ||
      this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
      this.regexp_eatIdentityEscape(state)
    )
  };
  pp$8.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(0x63 /* c */)) {
      if (this.regexp_eatControlLetter(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatZero = function(state) {
    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
      state.lastIntValue = 0;
      state.advance();
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
  pp$8.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    if (ch === 0x74 /* t */) {
      state.lastIntValue = 0x09; /* \t */
      state.advance();
      return true
    }
    if (ch === 0x6E /* n */) {
      state.lastIntValue = 0x0A; /* \n */
      state.advance();
      return true
    }
    if (ch === 0x76 /* v */) {
      state.lastIntValue = 0x0B; /* \v */
      state.advance();
      return true
    }
    if (ch === 0x66 /* f */) {
      state.lastIntValue = 0x0C; /* \f */
      state.advance();
      return true
    }
    if (ch === 0x72 /* r */) {
      state.lastIntValue = 0x0D; /* \r */
      state.advance();
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
  pp$8.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };
  function isControlLetter(ch) {
    return (
      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
    )
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
    if ( forceU === void 0 ) forceU = false;

    var start = state.pos;
    var switchU = forceU || state.switchU;

    if (state.eat(0x75 /* u */)) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 0xDC00 && trail <= 0xDFFF) {
              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
              return true
            }
          }
          state.pos = leadSurrogateEnd;
          state.lastIntValue = lead;
        }
        return true
      }
      if (
        switchU &&
        state.eat(0x7B /* { */) &&
        this.regexp_eatHexDigits(state) &&
        state.eat(0x7D /* } */) &&
        isValidUnicode(state.lastIntValue)
      ) {
        return true
      }
      if (switchU) {
        state.raise("Invalid unicode escape");
      }
      state.pos = start;
    }

    return false
  };
  function isValidUnicode(ch) {
    return ch >= 0 && ch <= 0x10FFFF
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
  pp$8.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
      if (this.regexp_eatSyntaxCharacter(state)) {
        return true
      }
      if (state.eat(0x2F /* / */)) {
        state.lastIntValue = 0x2F; /* / */
        return true
      }
      return false
    }

    var ch = state.current();
    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
  pp$8.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
        state.advance();
      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
  pp$8.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();

    if (isCharacterClassEscape(ch)) {
      state.lastIntValue = -1;
      state.advance();
      return true
    }

    if (
      state.switchU &&
      this.options.ecmaVersion >= 9 &&
      (ch === 0x50 /* P */ || ch === 0x70 /* p */)
    ) {
      state.lastIntValue = -1;
      state.advance();
      if (
        state.eat(0x7B /* { */) &&
        this.regexp_eatUnicodePropertyValueExpression(state) &&
        state.eat(0x7D /* } */)
      ) {
        return true
      }
      state.raise("Invalid property name");
    }

    return false
  };
  function isCharacterClassEscape(ch) {
    return (
      ch === 0x64 /* d */ ||
      ch === 0x44 /* D */ ||
      ch === 0x73 /* s */ ||
      ch === 0x53 /* S */ ||
      ch === 0x77 /* w */ ||
      ch === 0x57 /* W */
    )
  }

  // UnicodePropertyValueExpression ::
  //   UnicodePropertyName `=` UnicodePropertyValue
  //   LoneUnicodePropertyNameOrValue
  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;

    // UnicodePropertyName `=` UnicodePropertyValue
    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
      var name = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
        return true
      }
    }
    state.pos = start;

    // LoneUnicodePropertyNameOrValue
    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
      return true
    }
    return false
  };
  pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
    if (!has(state.unicodeProperties.nonBinary, name))
      { state.raise("Invalid property name"); }
    if (!state.unicodeProperties.nonBinary[name].test(value))
      { state.raise("Invalid property value"); }
  };
  pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (!state.unicodeProperties.binary.test(nameOrValue))
      { state.raise("Invalid property name"); }
  };

  // UnicodePropertyName ::
  //   UnicodePropertyNameCharacters
  pp$8.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyNameCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 0x5F /* _ */
  }

  // UnicodePropertyValue ::
  //   UnicodePropertyValueCharacters
  pp$8.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyValueCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
  }

  // LoneUnicodePropertyNameOrValue ::
  //   UnicodePropertyValueCharacters
  pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state)
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
  pp$8.regexp_eatCharacterClass = function(state) {
    if (state.eat(0x5B /* [ */)) {
      state.eat(0x5E /* ^ */);
      this.regexp_classRanges(state);
      if (state.eat(0x5D /* ] */)) {
        return true
      }
      // Unreachable since it threw "unterminated regular expression" error before.
      state.raise("Unterminated character class");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
  pp$8.regexp_classRanges = function(state) {
    while (this.regexp_eatClassAtom(state)) {
      var left = state.lastIntValue;
      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        if (state.switchU && (left === -1 || right === -1)) {
          state.raise("Invalid character class");
        }
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
      }
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
  pp$8.regexp_eatClassAtom = function(state) {
    var start = state.pos;

    if (state.eat(0x5C /* \ */)) {
      if (this.regexp_eatClassEscape(state)) {
        return true
      }
      if (state.switchU) {
        // Make the same message as V8.
        var ch$1 = state.current();
        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
          state.raise("Invalid class escape");
        }
        state.raise("Invalid escape");
      }
      state.pos = start;
    }

    var ch = state.current();
    if (ch !== 0x5D /* ] */) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
  pp$8.regexp_eatClassEscape = function(state) {
    var start = state.pos;

    if (state.eat(0x62 /* b */)) {
      state.lastIntValue = 0x08; /* <BS> */
      return true
    }

    if (state.switchU && state.eat(0x2D /* - */)) {
      state.lastIntValue = 0x2D; /* - */
      return true
    }

    if (!state.switchU && state.eat(0x63 /* c */)) {
      if (this.regexp_eatClassControlLetter(state)) {
        return true
      }
      state.pos = start;
    }

    return (
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state)
    )
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
  pp$8.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
  pp$8.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(0x78 /* x */)) {
      if (this.regexp_eatFixedHexDigits(state, 2)) {
        return true
      }
      if (state.switchU) {
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
  pp$8.regexp_eatDecimalDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isDecimalDigit(ch = state.current())) {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    }
    return state.pos !== start
  };
  function isDecimalDigit(ch) {
    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
  pp$8.regexp_eatHexDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isHexDigit(ch = state.current())) {
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return state.pos !== start
  };
  function isHexDigit(ch) {
    return (
      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
    )
  }
  function hexToInt(ch) {
    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
      return 10 + (ch - 0x41 /* A */)
    }
    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
      return 10 + (ch - 0x61 /* a */)
    }
    return ch - 0x30 /* 0 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
  // Allows only 0-377(octal) i.e. 0-255(decimal).
  pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n1 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n2 = state.lastIntValue;
        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
        } else {
          state.lastIntValue = n1 * 8 + n2;
        }
      } else {
        state.lastIntValue = n1;
      }
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
  pp$8.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
      state.lastIntValue = ch - 0x30; /* 0 */
      state.advance();
      return true
    }
    state.lastIntValue = 0;
    return false
  };
  function isOctalDigit(ch) {
    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
  pp$8.regexp_eatFixedHexDigits = function(state, length) {
    var start = state.pos;
    state.lastIntValue = 0;
    for (var i = 0; i < length; ++i) {
      var ch = state.current();
      if (!isHexDigit(ch)) {
        state.pos = start;
        return false
      }
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return true
  };

  // Object type used to represent tokens. Note that normally, tokens
  // simply exist as properties on the parser object. This is only
  // used for the onToken callback and the external tokenizer.

  var Token = function Token(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations)
      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
    if (p.options.ranges)
      { this.range = [p.start, p.end]; }
  };

  // ## Tokenizer

  var pp$9 = Parser.prototype;

  // Move to the next token

  pp$9.next = function(ignoreEscapeSequenceInKeyword) {
    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
      { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
    if (this.options.onToken)
      { this.options.onToken(new Token(this)); }

    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };

  pp$9.getToken = function() {
    this.next();
    return new Token(this)
  };

  // If we're in an ES6 environment, make parsers iterable
  if (typeof Symbol !== "undefined")
    { pp$9[Symbol.iterator] = function() {
      var this$1 = this;

      return {
        next: function () {
          var token = this$1.getToken();
          return {
            done: token.type === types.eof,
            value: token
          }
        }
      }
    }; }

  // Toggle strict mode. Re-reads the next number or string to please
  // pedantic tests (`"use strict"; 010;` should fail).

  pp$9.curContext = function() {
    return this.context[this.context.length - 1]
  };

  // Read a single token, updating the parser object's token-related
  // properties.

  pp$9.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

    this.start = this.pos;
    if (this.options.locations) { this.startLoc = this.curPosition(); }
    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

    if (curContext.override) { return curContext.override(this) }
    else { this.readToken(this.fullCharCodeAtPos()); }
  };

  pp$9.readToken = function(code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
      { return this.readWord() }

    return this.getTokenFromCode(code)
  };

  pp$9.fullCharCodeAtPos = function() {
    var code = this.input.charCodeAt(this.pos);
    if (code <= 0xd7ff || code >= 0xe000) { return code }
    var next = this.input.charCodeAt(this.pos + 1);
    return (code << 10) + next - 0x35fdc00
  };

  pp$9.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
    this.pos = end + 2;
    if (this.options.locations) {
      lineBreakG.lastIndex = start;
      var match;
      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
        ++this.curLine;
        this.lineStart = match.index + match[0].length;
      }
    }
    if (this.options.onComment)
      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                             startLoc, this.curPosition()); }
  };

  pp$9.skipLineComment = function(startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while (this.pos < this.input.length && !isNewLine(ch)) {
      ch = this.input.charCodeAt(++this.pos);
    }
    if (this.options.onComment)
      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                             startLoc, this.curPosition()); }
  };

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  pp$9.skipSpace = function() {
    loop: while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
      case 32: case 160: // ' '
        ++this.pos;
        break
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10: case 8232: case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break
      case 47: // '/'
        switch (this.input.charCodeAt(this.pos + 1)) {
        case 42: // '*'
          this.skipBlockComment();
          break
        case 47:
          this.skipLineComment(2);
          break
        default:
          break loop
        }
        break
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop
        }
      }
    }
  };

  // Called at the end of every token. Sets `end`, `val`, and
  // maintains `context` and `exprAllowed`, and skips the space after
  // the token, so that the next one's `start` will point at the
  // right position.

  pp$9.finishToken = function(type, val) {
    this.end = this.pos;
    if (this.options.locations) { this.endLoc = this.curPosition(); }
    var prevType = this.type;
    this.type = type;
    this.value = val;

    this.updateContext(prevType);
  };

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //
  pp$9.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) { return this.readNumber(true) }
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
      this.pos += 3;
      return this.finishToken(types.ellipsis)
    } else {
      ++this.pos;
      return this.finishToken(types.dot)
    }
  };

  pp$9.readToken_slash = function() { // '/'
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.slash, 1)
  };

  pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code === 42 ? types.star : types.modulo;

    // exponentiation operator ** and **=
    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
      ++size;
      tokentype = types.starstar;
      next = this.input.charCodeAt(this.pos + 2);
    }

    if (next === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(tokentype, size)
  };

  pp$9.readToken_pipe_amp = function(code) { // '|&'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (this.options.ecmaVersion >= 12) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 === 61) { return this.finishOp(types.assign, 3) }
      }
      return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2)
    }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
  };

  pp$9.readToken_caret = function() { // '^'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.bitwiseXOR, 1)
  };

  pp$9.readToken_plus_min = function(code) { // '+-'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
        // A `-->` line comment
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken()
      }
      return this.finishOp(types.incDec, 2)
    }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.plusMin, 1)
  };

  pp$9.readToken_lt_gt = function(code) { // '<>'
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
      return this.finishOp(types.bitShift, size)
    }
    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
        this.input.charCodeAt(this.pos + 3) === 45) {
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken()
    }
    if (next === 61) { size = 2; }
    return this.finishOp(types.relational, size)
  };

  pp$9.readToken_eq_excl = function(code) { // '=!'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
      this.pos += 2;
      return this.finishToken(types.arrow)
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
  };

  pp$9.readToken_question = function() { // '?'
    var ecmaVersion = this.options.ecmaVersion;
    if (ecmaVersion >= 11) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 46) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 < 48 || next2 > 57) { return this.finishOp(types.questionDot, 2) }
      }
      if (next === 63) {
        if (ecmaVersion >= 12) {
          var next2$1 = this.input.charCodeAt(this.pos + 2);
          if (next2$1 === 61) { return this.finishOp(types.assign, 3) }
        }
        return this.finishOp(types.coalesce, 2)
      }
    }
    return this.finishOp(types.question, 1)
  };

  pp$9.getTokenFromCode = function(code) {
    switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46: // '.'
      return this.readToken_dot()

    // Punctuation tokens.
    case 40: ++this.pos; return this.finishToken(types.parenL)
    case 41: ++this.pos; return this.finishToken(types.parenR)
    case 59: ++this.pos; return this.finishToken(types.semi)
    case 44: ++this.pos; return this.finishToken(types.comma)
    case 91: ++this.pos; return this.finishToken(types.bracketL)
    case 93: ++this.pos; return this.finishToken(types.bracketR)
    case 123: ++this.pos; return this.finishToken(types.braceL)
    case 125: ++this.pos; return this.finishToken(types.braceR)
    case 58: ++this.pos; return this.finishToken(types.colon)

    case 96: // '`'
      if (this.options.ecmaVersion < 6) { break }
      ++this.pos;
      return this.finishToken(types.backQuote)

    case 48: // '0'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
      }

    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
      return this.readNumber(false)

    // Quotes produce strings.
    case 34: case 39: // '"', "'"
      return this.readString(code)

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case 47: // '/'
      return this.readToken_slash()

    case 37: case 42: // '%*'
      return this.readToken_mult_modulo_exp(code)

    case 124: case 38: // '|&'
      return this.readToken_pipe_amp(code)

    case 94: // '^'
      return this.readToken_caret()

    case 43: case 45: // '+-'
      return this.readToken_plus_min(code)

    case 60: case 62: // '<>'
      return this.readToken_lt_gt(code)

    case 61: case 33: // '=!'
      return this.readToken_eq_excl(code)

    case 63: // '?'
      return this.readToken_question()

    case 126: // '~'
      return this.finishOp(types.prefix, 1)
    }

    this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
  };

  pp$9.finishOp = function(type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type, str)
  };

  pp$9.readRegexp = function() {
    var escaped, inClass, start = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
      var ch = this.input.charAt(this.pos);
      if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
      if (!escaped) {
        if (ch === "[") { inClass = true; }
        else if (ch === "]" && inClass) { inClass = false; }
        else if (ch === "/" && !inClass) { break }
        escaped = ch === "\\";
      } else { escaped = false; }
      ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) { this.unexpected(flagsStart); }

    // Validate pattern
    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);

    // Create Literal#value property value.
    var value = null;
    try {
      value = new RegExp(pattern, flags);
    } catch (e) {
      // ESTree requires null if it failed to instantiate RegExp object.
      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
    }

    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
  };

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  pp$9.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
    // `len` is used for character escape sequences. In that case, disallow separators.
    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

    // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
    // and isn't fraction part nor exponent part. In that case, if the first digit
    // is zero then disallow separators.
    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

    var start = this.pos, total = 0, lastCode = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
      var code = this.input.charCodeAt(this.pos), val = (void 0);

      if (allowSeparators && code === 95) {
        if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
        if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
        if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
        lastCode = code;
        continue
      }

      if (code >= 97) { val = code - 97 + 10; } // a
      else if (code >= 65) { val = code - 65 + 10; } // A
      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
      else { val = Infinity; }
      if (val >= radix) { break }
      lastCode = code;
      total = total * radix + val;
    }

    if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
    if (this.pos === start || len != null && this.pos - start !== len) { return null }

    return total
  };

  function stringToNumber(str, isLegacyOctalNumericLiteral) {
    if (isLegacyOctalNumericLiteral) {
      return parseInt(str, 8)
    }

    // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
    return parseFloat(str.replace(/_/g, ""))
  }

  function stringToBigInt(str) {
    if (typeof BigInt !== "function") {
      return null
    }

    // `BigInt(value)` throws syntax error if the string contains numeric separators.
    return BigInt(str.replace(/_/g, ""))
  }

  pp$9.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2; // 0x
    var val = this.readInt(radix);
    if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
      val = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types.num, val)
  };

  // Read an integer, octal integer, or floating-point number.

  pp$9.readNumber = function(startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict) { this.raise(start, "Invalid number"); }
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
      var val$1 = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
      return this.finishToken(types.num, val$1)
    }
    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
    if (next === 46 && !octal) { // '.'
      ++this.pos;
      this.readInt(10);
      next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) { // 'eE'
      next = this.input.charCodeAt(++this.pos);
      if (next === 43 || next === 45) { ++this.pos; } // '+-'
      if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

    var val = stringToNumber(this.input.slice(start, this.pos), octal);
    return this.finishToken(types.num, val)
  };

  // Read a string value, interpreting backslash-escapes.

  pp$9.readCodePoint = function() {
    var ch = this.input.charCodeAt(this.pos), code;

    if (ch === 123) { // '{'
      if (this.options.ecmaVersion < 6) { this.unexpected(); }
      var codePos = ++this.pos;
      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
    } else {
      code = this.readHexChar(4);
    }
    return code
  };

  function codePointToString$1(code) {
    // UTF-16 Decoding
    if (code <= 0xFFFF) { return String.fromCharCode(code) }
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
  }

  pp$9.readString = function(quote) {
    var out = "", chunkStart = ++this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) { break }
      if (ch === 92) { // '\'
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.pos;
      } else {
        if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types.string, out)
  };

  // Reads template string tokens.

  var INVALID_TEMPLATE_ESCAPE_ERROR = {};

  pp$9.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
      this.readTmplToken();
    } catch (err) {
      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
        this.readInvalidTemplateToken();
      } else {
        throw err
      }
    }

    this.inTemplateElement = false;
  };

  pp$9.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
      throw INVALID_TEMPLATE_ESCAPE_ERROR
    } else {
      this.raise(position, message);
    }
  };

  pp$9.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
        if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
          if (ch === 36) {
            this.pos += 2;
            return this.finishToken(types.dollarBraceL)
          } else {
            ++this.pos;
            return this.finishToken(types.backQuote)
          }
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(types.template, out)
      }
      if (ch === 92) { // '\'
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        ++this.pos;
        switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
        case 10:
          out += "\n";
          break
        default:
          out += String.fromCharCode(ch);
          break
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
  };

  // Reads a template token to search for the end, without validating any escape sequences
  pp$9.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++) {
      switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break

      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break
        }
      // falls through

      case "`":
        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

      // no default
      }
    }
    this.raise(this.start, "Unterminated template");
  };

  // Used to read escaped characters

  pp$9.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch (ch) {
    case 110: return "\n" // 'n' -> '\n'
    case 114: return "\r" // 'r' -> '\r'
    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
    case 117: return codePointToString$1(this.readCodePoint()) // 'u'
    case 116: return "\t" // 't' -> '\t'
    case 98: return "\b" // 'b' -> '\b'
    case 118: return "\u000b" // 'v' -> '\u000b'
    case 102: return "\f" // 'f' -> '\f'
    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
    case 10: // ' \n'
      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
      return ""
    case 56:
    case 57:
      if (inTemplate) {
        var codePos = this.pos - 1;

        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );

        return null
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate
              ? "Octal literal in template string"
              : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal)
      }
      if (isNewLine(ch)) {
        // Unicode new line characters after \ get removed from output in both
        // template literals and strings
        return ""
      }
      return String.fromCharCode(ch)
    }
  };

  // Used to read character escape sequences ('\x', '\u', '\U').

  pp$9.readHexChar = function(len) {
    var codePos = this.pos;
    var n = this.readInt(16, len);
    if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
    return n
  };

  // Read an identifier, and return it as a string. Sets `this.containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Incrementally adds only escaped chars, adding other chunks as-is
  // as a micro-optimization.

  pp$9.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while (this.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch, astral)) {
        this.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) { // "\"
        this.containsEsc = true;
        word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        if (this.input.charCodeAt(++this.pos) !== 117) // "u"
          { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
        ++this.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
          { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
        word += codePointToString$1(esc);
        chunkStart = this.pos;
      } else {
        break
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.pos)
  };

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  pp$9.readWord = function() {
    var word = this.readWord1();
    var type = types.name;
    if (this.keywords.test(word)) {
      type = keywords$1[word];
    }
    return this.finishToken(type, word)
  };

  // Acorn is a tiny, fast JavaScript parser written in JavaScript.

  var version = "7.4.1";

  Parser.acorn = {
    Parser: Parser,
    version: version,
    defaultOptions: defaultOptions,
    Position: Position,
    SourceLocation: SourceLocation,
    getLineInfo: getLineInfo,
    Node: Node,
    TokenType: TokenType,
    tokTypes: types,
    keywordTypes: keywords$1,
    TokContext: TokContext,
    tokContexts: types$1,
    isIdentifierChar: isIdentifierChar,
    isIdentifierStart: isIdentifierStart,
    Token: Token,
    isNewLine: isNewLine,
    lineBreak: lineBreak,
    lineBreakG: lineBreakG,
    nonASCIIwhitespace: nonASCIIwhitespace
  };

  // The main exported interface (under `self.acorn` when in the
  // browser) is a `parse` function that takes a code string and
  // returns an abstract syntax tree as specified by [Mozilla parser
  // API][api].
  //
  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

  function parse(input, options) {
    return Parser.parse(input, options)
  }

  // This function tries to parse a single expression at a given
  // offset in a string. Useful for parsing mixed-language formats
  // that embed JavaScript expressions.

  function parseExpressionAt(input, pos, options) {
    return Parser.parseExpressionAt(input, pos, options)
  }

  // Acorn is organized as a tokenizer and a recursive-descent parser.
  // The `tokenizer` export provides an interface to the tokenizer.

  function tokenizer(input, options) {
    return Parser.tokenizer(input, options)
  }

  exports.Node = Node;
  exports.Parser = Parser;
  exports.Position = Position;
  exports.SourceLocation = SourceLocation;
  exports.TokContext = TokContext;
  exports.Token = Token;
  exports.TokenType = TokenType;
  exports.defaultOptions = defaultOptions;
  exports.getLineInfo = getLineInfo;
  exports.isIdentifierChar = isIdentifierChar;
  exports.isIdentifierStart = isIdentifierStart;
  exports.isNewLine = isNewLine;
  exports.keywordTypes = keywords$1;
  exports.lineBreak = lineBreak;
  exports.lineBreakG = lineBreakG;
  exports.nonASCIIwhitespace = nonASCIIwhitespace;
  exports.parse = parse;
  exports.parseExpressionAt = parseExpressionAt;
  exports.tokContexts = types$1;
  exports.tokTypes = types;
  exports.tokenizer = tokenizer;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ 79659:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let unpack = (__nccwpck_require__(64006).feature)

function browsersSort(a, b) {
  a = a.split(' ')
  b = b.split(' ')
  if (a[0] > b[0]) {
    return 1
  } else if (a[0] < b[0]) {
    return -1
  } else {
    return Math.sign(parseFloat(a[1]) - parseFloat(b[1]))
  }
}

// Convert Can I Use data
function f(data, opts, callback) {
  data = unpack(data)

  if (!callback) {
    ;[callback, opts] = [opts, {}]
  }

  let match = opts.match || /\sx($|\s)/
  let need = []

  for (let browser in data.stats) {
    let versions = data.stats[browser]
    for (let version in versions) {
      let support = versions[version]
      if (support.match(match)) {
        need.push(browser + ' ' + version)
      }
    }
  }

  callback(need.sort(browsersSort))
}

// Add data for all properties
let result = {}

function prefix(names, data) {
  for (let name of names) {
    result[name] = Object.assign({}, data)
  }
}

function add(names, data) {
  for (let name of names) {
    result[name].browsers = result[name].browsers
      .concat(data.browsers)
      .sort(browsersSort)
  }
}

module.exports = result

// Border Radius
let prefixBorderRadius = __nccwpck_require__(72853)

f(prefixBorderRadius, browsers =>
  prefix(
    [
      'border-radius',
      'border-top-left-radius',
      'border-top-right-radius',
      'border-bottom-right-radius',
      'border-bottom-left-radius'
    ],
    {
      mistakes: ['-khtml-', '-ms-', '-o-'],
      feature: 'border-radius',
      browsers
    }
  )
)

// Box Shadow
let prefixBoxshadow = __nccwpck_require__(22004)

f(prefixBoxshadow, browsers =>
  prefix(['box-shadow'], {
    mistakes: ['-khtml-'],
    feature: 'css-boxshadow',
    browsers
  })
)

// Animation
let prefixAnimation = __nccwpck_require__(40083)

f(prefixAnimation, browsers =>
  prefix(
    [
      'animation',
      'animation-name',
      'animation-duration',
      'animation-delay',
      'animation-direction',
      'animation-fill-mode',
      'animation-iteration-count',
      'animation-play-state',
      'animation-timing-function',
      '@keyframes'
    ],
    {
      mistakes: ['-khtml-', '-ms-'],
      feature: 'css-animation',
      browsers
    }
  )
)

// Transition
let prefixTransition = __nccwpck_require__(61964)

f(prefixTransition, browsers =>
  prefix(
    [
      'transition',
      'transition-property',
      'transition-duration',
      'transition-delay',
      'transition-timing-function'
    ],
    {
      mistakes: ['-khtml-', '-ms-'],
      browsers,
      feature: 'css-transitions'
    }
  )
)

// Transform 2D
let prefixTransform2d = __nccwpck_require__(98415)

f(prefixTransform2d, browsers =>
  prefix(['transform', 'transform-origin'], {
    feature: 'transforms2d',
    browsers
  })
)

// Transform 3D
let prefixTransforms3d = __nccwpck_require__(48912)

f(prefixTransforms3d, browsers => {
  prefix(['perspective', 'perspective-origin'], {
    feature: 'transforms3d',
    browsers
  })
  return prefix(['transform-style'], {
    mistakes: ['-ms-', '-o-'],
    browsers,
    feature: 'transforms3d'
  })
})

f(prefixTransforms3d, { match: /y\sx|y\s#2/ }, browsers =>
  prefix(['backface-visibility'], {
    mistakes: ['-ms-', '-o-'],
    feature: 'transforms3d',
    browsers
  })
)

// Gradients
let prefixGradients = __nccwpck_require__(13657)

f(prefixGradients, { match: /y\sx/ }, browsers =>
  prefix(
    [
      'linear-gradient',
      'repeating-linear-gradient',
      'radial-gradient',
      'repeating-radial-gradient'
    ],
    {
      props: [
        'background',
        'background-image',
        'border-image',
        'mask',
        'list-style',
        'list-style-image',
        'content',
        'mask-image'
      ],
      mistakes: ['-ms-'],
      feature: 'css-gradients',
      browsers
    }
  )
)

f(prefixGradients, { match: /a\sx/ }, browsers => {
  browsers = browsers.map(i => {
    if (/firefox|op/.test(i)) {
      return i
    } else {
      return `${i} old`
    }
  })
  return add(
    [
      'linear-gradient',
      'repeating-linear-gradient',
      'radial-gradient',
      'repeating-radial-gradient'
    ],
    {
      feature: 'css-gradients',
      browsers
    }
  )
})

// Box sizing
let prefixBoxsizing = __nccwpck_require__(47610)

f(prefixBoxsizing, browsers =>
  prefix(['box-sizing'], {
    feature: 'css3-boxsizing',
    browsers
  })
)

// Filter Effects
let prefixFilters = __nccwpck_require__(35123)

f(prefixFilters, browsers =>
  prefix(['filter'], {
    feature: 'css-filters',
    browsers
  })
)

// filter() function
let prefixFilterFunction = __nccwpck_require__(19533)

f(prefixFilterFunction, browsers =>
  prefix(['filter-function'], {
    props: [
      'background',
      'background-image',
      'border-image',
      'mask',
      'list-style',
      'list-style-image',
      'content',
      'mask-image'
    ],
    feature: 'css-filter-function',
    browsers
  })
)

// Backdrop-filter
let prefixBackdrop = __nccwpck_require__(74043)

f(prefixBackdrop, { match: /y\sx|y\s#2/ }, browsers =>
  prefix(['backdrop-filter'], {
    feature: 'css-backdrop-filter',
    browsers
  })
)

// element() function
let prefixElementFunction = __nccwpck_require__(21694)

f(prefixElementFunction, browsers =>
  prefix(['element'], {
    props: [
      'background',
      'background-image',
      'border-image',
      'mask',
      'list-style',
      'list-style-image',
      'content',
      'mask-image'
    ],
    feature: 'css-element-function',
    browsers
  })
)

// Multicolumns
let prefixMulticolumns = __nccwpck_require__(24233)

f(prefixMulticolumns, browsers => {
  prefix(
    [
      'columns',
      'column-width',
      'column-gap',
      'column-rule',
      'column-rule-color',
      'column-rule-width',
      'column-count',
      'column-rule-style',
      'column-span',
      'column-fill'
    ],
    {
      feature: 'multicolumn',
      browsers
    }
  )

  let noff = browsers.filter(i => !/firefox/.test(i))
  prefix(['break-before', 'break-after', 'break-inside'], {
    feature: 'multicolumn',
    browsers: noff
  })
})

// User select
let prefixUserSelect = __nccwpck_require__(85671)

f(prefixUserSelect, browsers =>
  prefix(['user-select'], {
    mistakes: ['-khtml-'],
    feature: 'user-select-none',
    browsers
  })
)

// Flexible Box Layout
let prefixFlexbox = __nccwpck_require__(48976)

f(prefixFlexbox, { match: /a\sx/ }, browsers => {
  browsers = browsers.map(i => {
    if (/ie|firefox/.test(i)) {
      return i
    } else {
      return `${i} 2009`
    }
  })
  prefix(['display-flex', 'inline-flex'], {
    props: ['display'],
    feature: 'flexbox',
    browsers
  })
  prefix(['flex', 'flex-grow', 'flex-shrink', 'flex-basis'], {
    feature: 'flexbox',
    browsers
  })
  prefix(
    [
      'flex-direction',
      'flex-wrap',
      'flex-flow',
      'justify-content',
      'order',
      'align-items',
      'align-self',
      'align-content'
    ],
    {
      feature: 'flexbox',
      browsers
    }
  )
})

f(prefixFlexbox, { match: /y\sx/ }, browsers => {
  add(['display-flex', 'inline-flex'], {
    feature: 'flexbox',
    browsers
  })
  add(['flex', 'flex-grow', 'flex-shrink', 'flex-basis'], {
    feature: 'flexbox',
    browsers
  })
  add(
    [
      'flex-direction',
      'flex-wrap',
      'flex-flow',
      'justify-content',
      'order',
      'align-items',
      'align-self',
      'align-content'
    ],
    {
      feature: 'flexbox',
      browsers
    }
  )
})

// calc() unit
let prefixCalc = __nccwpck_require__(287)

f(prefixCalc, browsers =>
  prefix(['calc'], {
    props: ['*'],
    feature: 'calc',
    browsers
  })
)

// Background options
let prefixBackgroundOptions = __nccwpck_require__(22115)

f(prefixBackgroundOptions, browsers =>
  prefix(['background-origin', 'background-size'], {
    feature: 'background-img-opts',
    browsers
  })
)

// background-clip: text
let prefixBackgroundClipText = __nccwpck_require__(13197)

f(prefixBackgroundClipText, browsers =>
  prefix(['background-clip'], {
    feature: 'background-clip-text',
    browsers
  })
)

// Font feature settings
let prefixFontFeature = __nccwpck_require__(26538)

f(prefixFontFeature, browsers =>
  prefix(
    [
      'font-feature-settings',
      'font-variant-ligatures',
      'font-language-override'
    ],
    {
      feature: 'font-feature',
      browsers
    }
  )
)

// CSS font-kerning property
let prefixFontKerning = __nccwpck_require__(88367)

f(prefixFontKerning, browsers =>
  prefix(['font-kerning'], {
    feature: 'font-kerning',
    browsers
  })
)

// Border image
let prefixBorderImage = __nccwpck_require__(14915)

f(prefixBorderImage, browsers =>
  prefix(['border-image'], {
    feature: 'border-image',
    browsers
  })
)

// Selection selector
let prefixSelection = __nccwpck_require__(16302)

f(prefixSelection, browsers =>
  prefix(['::selection'], {
    selector: true,
    feature: 'css-selection',
    browsers
  })
)

// Placeholder selector
let prefixPlaceholder = __nccwpck_require__(83448)

f(prefixPlaceholder, browsers => {
  prefix(['::placeholder'], {
    selector: true,
    feature: 'css-placeholder',
    browsers: browsers.concat(['ie 10 old', 'ie 11 old', 'firefox 18 old'])
  })
})

// Placeholder-shown selector
let prefixPlaceholderShown = __nccwpck_require__(70361)

f(prefixPlaceholderShown, browsers => {
  prefix([':placeholder-shown'], {
    selector: true,
    feature: 'css-placeholder-shown',
    browsers
  })
})

// Hyphenation
let prefixHyphens = __nccwpck_require__(89317)

f(prefixHyphens, browsers =>
  prefix(['hyphens'], {
    feature: 'css-hyphens',
    browsers
  })
)

// Fullscreen selector
let prefixFullscreen = __nccwpck_require__(99086)

f(prefixFullscreen, browsers =>
  prefix([':fullscreen'], {
    selector: true,
    feature: 'fullscreen',
    browsers
  })
)

f(prefixFullscreen, { match: /x(\s#2|$)/ }, browsers =>
  prefix(['::backdrop'], {
    selector: true,
    feature: 'fullscreen',
    browsers
  })
)

// File selector button
let prefixFileSelectorButton = __nccwpck_require__(23619)

f(prefixFileSelectorButton, browsers =>
  prefix(['::file-selector-button'], {
    selector: true,
    feature: 'file-selector-button',
    browsers
  })
)

// :autofill
let prefixAutofill = __nccwpck_require__(71327)

f(prefixAutofill, browsers =>
  prefix([':autofill'], {
    selector: true,
    feature: 'css-autofill',
    browsers
  })
)

// Tab size
let prefixTabsize = __nccwpck_require__(87604)

f(prefixTabsize, browsers =>
  prefix(['tab-size'], {
    feature: 'css3-tabsize',
    browsers
  })
)

// Intrinsic & extrinsic sizing
let prefixIntrinsic = __nccwpck_require__(56835)

let sizeProps = [
  'width',
  'min-width',
  'max-width',
  'height',
  'min-height',
  'max-height',
  'inline-size',
  'min-inline-size',
  'max-inline-size',
  'block-size',
  'min-block-size',
  'max-block-size',
  'grid',
  'grid-template',
  'grid-template-rows',
  'grid-template-columns',
  'grid-auto-columns',
  'grid-auto-rows'
]

f(prefixIntrinsic, browsers =>
  prefix(['max-content', 'min-content'], {
    props: sizeProps,
    feature: 'intrinsic-width',
    browsers
  })
)

f(prefixIntrinsic, { match: /x|\s#4/ }, browsers =>
  prefix(['fill', 'fill-available'], {
    props: sizeProps,
    feature: 'intrinsic-width',
    browsers
  })
)

f(prefixIntrinsic, { match: /x|\s#5/ }, browsers =>
  prefix(['fit-content'], {
    props: sizeProps,
    feature: 'intrinsic-width',
    browsers
  })
)

// Stretch value

let prefixStretch = __nccwpck_require__(80847)

f(prefixStretch, browsers =>
  prefix(['stretch'], {
    props: sizeProps,
    feature: 'css-width-stretch',
    browsers
  })
)

// Zoom cursors
let prefixCursorsNewer = __nccwpck_require__(70800)

f(prefixCursorsNewer, browsers =>
  prefix(['zoom-in', 'zoom-out'], {
    props: ['cursor'],
    feature: 'css3-cursors-newer',
    browsers
  })
)

// Grab cursors
let prefixCursorsGrab = __nccwpck_require__(63355)

f(prefixCursorsGrab, browsers =>
  prefix(['grab', 'grabbing'], {
    props: ['cursor'],
    feature: 'css3-cursors-grab',
    browsers
  })
)

// Sticky position
let prefixSticky = __nccwpck_require__(67425)

f(prefixSticky, browsers =>
  prefix(['sticky'], {
    props: ['position'],
    feature: 'css-sticky',
    browsers
  })
)

// Pointer Events
let prefixPointer = __nccwpck_require__(27252)

f(prefixPointer, browsers =>
  prefix(['touch-action'], {
    feature: 'pointer',
    browsers
  })
)

// Text decoration
let prefixDecoration = __nccwpck_require__(6866)

f(prefixDecoration, { match: /x.*#[235]/ }, browsers =>
  prefix(['text-decoration-skip', 'text-decoration-skip-ink'], {
    feature: 'text-decoration',
    browsers
  })
)

let prefixDecorationShorthand = __nccwpck_require__(2644)

f(prefixDecorationShorthand, browsers =>
  prefix(['text-decoration'], {
    feature: 'text-decoration',
    browsers
  })
)

let prefixDecorationColor = __nccwpck_require__(83460)

f(prefixDecorationColor, browsers =>
  prefix(['text-decoration-color'], {
    feature: 'text-decoration',
    browsers
  })
)

let prefixDecorationLine = __nccwpck_require__(42320)

f(prefixDecorationLine, browsers =>
  prefix(['text-decoration-line'], {
    feature: 'text-decoration',
    browsers
  })
)

let prefixDecorationStyle = __nccwpck_require__(73110)

f(prefixDecorationStyle, browsers =>
  prefix(['text-decoration-style'], {
    feature: 'text-decoration',
    browsers
  })
)

// Text Size Adjust
let prefixTextSizeAdjust = __nccwpck_require__(2368)

f(prefixTextSizeAdjust, browsers =>
  prefix(['text-size-adjust'], {
    feature: 'text-size-adjust',
    browsers
  })
)

// CSS Masks
let prefixCssMasks = __nccwpck_require__(15592)

f(prefixCssMasks, browsers => {
  prefix(
    [
      'mask-clip',
      'mask-composite',
      'mask-image',
      'mask-origin',
      'mask-repeat',
      'mask-border-repeat',
      'mask-border-source'
    ],
    {
      feature: 'css-masks',
      browsers
    }
  )
  prefix(
    [
      'mask',
      'mask-position',
      'mask-size',
      'mask-border',
      'mask-border-outset',
      'mask-border-width',
      'mask-border-slice'
    ],
    {
      feature: 'css-masks',
      browsers
    }
  )
})

// CSS clip-path property
let prefixClipPath = __nccwpck_require__(37028)

f(prefixClipPath, browsers =>
  prefix(['clip-path'], {
    feature: 'css-clip-path',
    browsers
  })
)

// Fragmented Borders and Backgrounds
let prefixBoxdecoration = __nccwpck_require__(81371)

f(prefixBoxdecoration, browsers =>
  prefix(['box-decoration-break'], {
    feature: 'css-boxdecorationbreak',
    browsers
  })
)

// CSS3 object-fit/object-position
let prefixObjectFit = __nccwpck_require__(6228)

f(prefixObjectFit, browsers =>
  prefix(['object-fit', 'object-position'], {
    feature: 'object-fit',
    browsers
  })
)

// CSS Shapes
let prefixShapes = __nccwpck_require__(56938)

f(prefixShapes, browsers =>
  prefix(['shape-margin', 'shape-outside', 'shape-image-threshold'], {
    feature: 'css-shapes',
    browsers
  })
)

// CSS3 text-overflow
let prefixTextOverflow = __nccwpck_require__(73033)

f(prefixTextOverflow, browsers =>
  prefix(['text-overflow'], {
    feature: 'text-overflow',
    browsers
  })
)

// Viewport at-rule
let prefixDeviceadaptation = __nccwpck_require__(83318)

f(prefixDeviceadaptation, browsers =>
  prefix(['@viewport'], {
    feature: 'css-deviceadaptation',
    browsers
  })
)

// Resolution Media Queries
let prefixResolut = __nccwpck_require__(79494)

f(prefixResolut, { match: /( x($| )|a #2)/ }, browsers =>
  prefix(['@resolution'], {
    feature: 'css-media-resolution',
    browsers
  })
)

// CSS text-align-last
let prefixTextAlignLast = __nccwpck_require__(68887)

f(prefixTextAlignLast, browsers =>
  prefix(['text-align-last'], {
    feature: 'css-text-align-last',
    browsers
  })
)

// Crisp Edges Image Rendering Algorithm
let prefixCrispedges = __nccwpck_require__(36717)

f(prefixCrispedges, { match: /y x|a x #1/ }, browsers =>
  prefix(['pixelated'], {
    props: ['image-rendering'],
    feature: 'css-crisp-edges',
    browsers
  })
)

f(prefixCrispedges, { match: /a x #2/ }, browsers =>
  prefix(['image-rendering'], {
    feature: 'css-crisp-edges',
    browsers
  })
)

// Logical Properties
let prefixLogicalProps = __nccwpck_require__(23871)

f(prefixLogicalProps, browsers =>
  prefix(
    [
      'border-inline-start',
      'border-inline-end',
      'margin-inline-start',
      'margin-inline-end',
      'padding-inline-start',
      'padding-inline-end'
    ],
    {
      feature: 'css-logical-props',
      browsers
    }
  )
)

f(prefixLogicalProps, { match: /x\s#2/ }, browsers =>
  prefix(
    [
      'border-block-start',
      'border-block-end',
      'margin-block-start',
      'margin-block-end',
      'padding-block-start',
      'padding-block-end'
    ],
    {
      feature: 'css-logical-props',
      browsers
    }
  )
)

// CSS appearance
let prefixAppearance = __nccwpck_require__(3599)

f(prefixAppearance, { match: /#2|x/ }, browsers =>
  prefix(['appearance'], {
    feature: 'css-appearance',
    browsers
  })
)

// CSS Scroll snap points
let prefixSnappoints = __nccwpck_require__(82776)

f(prefixSnappoints, browsers =>
  prefix(
    [
      'scroll-snap-type',
      'scroll-snap-coordinate',
      'scroll-snap-destination',
      'scroll-snap-points-x',
      'scroll-snap-points-y'
    ],
    {
      feature: 'css-snappoints',
      browsers
    }
  )
)

// CSS Regions
let prefixRegions = __nccwpck_require__(32598)

f(prefixRegions, browsers =>
  prefix(['flow-into', 'flow-from', 'region-fragment'], {
    feature: 'css-regions',
    browsers
  })
)

// CSS image-set
let prefixImageSet = __nccwpck_require__(2762)

f(prefixImageSet, browsers =>
  prefix(['image-set'], {
    props: [
      'background',
      'background-image',
      'border-image',
      'cursor',
      'mask',
      'mask-image',
      'list-style',
      'list-style-image',
      'content'
    ],
    feature: 'css-image-set',
    browsers
  })
)

// Writing Mode
let prefixWritingMode = __nccwpck_require__(47816)

f(prefixWritingMode, { match: /a|x/ }, browsers =>
  prefix(['writing-mode'], {
    feature: 'css-writing-mode',
    browsers
  })
)

// Cross-Fade Function
let prefixCrossFade = __nccwpck_require__(90831)

f(prefixCrossFade, browsers =>
  prefix(['cross-fade'], {
    props: [
      'background',
      'background-image',
      'border-image',
      'mask',
      'list-style',
      'list-style-image',
      'content',
      'mask-image'
    ],
    feature: 'css-cross-fade',
    browsers
  })
)

// Read Only selector
let prefixReadOnly = __nccwpck_require__(17667)

f(prefixReadOnly, browsers =>
  prefix([':read-only', ':read-write'], {
    selector: true,
    feature: 'css-read-only-write',
    browsers
  })
)

// Text Emphasize
let prefixTextEmphasis = __nccwpck_require__(76001)

f(prefixTextEmphasis, browsers =>
  prefix(
    [
      'text-emphasis',
      'text-emphasis-position',
      'text-emphasis-style',
      'text-emphasis-color'
    ],
    {
      feature: 'text-emphasis',
      browsers
    }
  )
)

// CSS Grid Layout
let prefixGrid = __nccwpck_require__(19330)

f(prefixGrid, browsers => {
  prefix(['display-grid', 'inline-grid'], {
    props: ['display'],
    feature: 'css-grid',
    browsers
  })
  prefix(
    [
      'grid-template-columns',
      'grid-template-rows',
      'grid-row-start',
      'grid-column-start',
      'grid-row-end',
      'grid-column-end',
      'grid-row',
      'grid-column',
      'grid-area',
      'grid-template',
      'grid-template-areas',
      'place-self'
    ],
    {
      feature: 'css-grid',
      browsers
    }
  )
})

f(prefixGrid, { match: /a x/ }, browsers =>
  prefix(['grid-column-align', 'grid-row-align'], {
    feature: 'css-grid',
    browsers
  })
)

// CSS text-spacing
let prefixTextSpacing = __nccwpck_require__(75688)

f(prefixTextSpacing, browsers =>
  prefix(['text-spacing'], {
    feature: 'css-text-spacing',
    browsers
  })
)

// :any-link selector
let prefixAnyLink = __nccwpck_require__(2031)

f(prefixAnyLink, browsers =>
  prefix([':any-link'], {
    selector: true,
    feature: 'css-any-link',
    browsers
  })
)

// unicode-bidi

let bidiIsolate = __nccwpck_require__(55195)

f(bidiIsolate, browsers =>
  prefix(['isolate'], {
    props: ['unicode-bidi'],
    feature: 'css-unicode-bidi',
    browsers
  })
)

let bidiPlaintext = __nccwpck_require__(27489)

f(bidiPlaintext, browsers =>
  prefix(['plaintext'], {
    props: ['unicode-bidi'],
    feature: 'css-unicode-bidi',
    browsers
  })
)

let bidiOverride = __nccwpck_require__(19567)

f(bidiOverride, { match: /y x/ }, browsers =>
  prefix(['isolate-override'], {
    props: ['unicode-bidi'],
    feature: 'css-unicode-bidi',
    browsers
  })
)

// overscroll-behavior selector
let prefixOverscroll = __nccwpck_require__(50237)

f(prefixOverscroll, { match: /a #1/ }, browsers =>
  prefix(['overscroll-behavior'], {
    feature: 'css-overscroll-behavior',
    browsers
  })
)

// text-orientation
let prefixTextOrientation = __nccwpck_require__(80045)

f(prefixTextOrientation, browsers =>
  prefix(['text-orientation'], {
    feature: 'css-text-orientation',
    browsers
  })
)

// print-color-adjust
let prefixPrintAdjust = __nccwpck_require__(51055)

f(prefixPrintAdjust, browsers =>
  prefix(['print-color-adjust', 'color-adjust'], {
    feature: 'css-print-color-adjust',
    browsers
  })
)


/***/ }),

/***/ 87170:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Prefixer = __nccwpck_require__(26579)

class AtRule extends Prefixer {
  /**
   * Clone and add prefixes for at-rule
   */
  add(rule, prefix) {
    let prefixed = prefix + rule.name

    let already = rule.parent.some(
      i => i.name === prefixed && i.params === rule.params
    )
    if (already) {
      return undefined
    }

    let cloned = this.clone(rule, { name: prefixed })
    return rule.parent.insertBefore(rule, cloned)
  }

  /**
   * Clone node with prefixes
   */
  process(node) {
    let parent = this.parentPrefix(node)

    for (let prefix of this.prefixes) {
      if (!parent || parent === prefix) {
        this.add(node, prefix)
      }
    }
  }
}

module.exports = AtRule


/***/ }),

/***/ 1376:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let browserslist = __nccwpck_require__(55478)
let { agents } = __nccwpck_require__(64006)
let pico = __nccwpck_require__(37023)

let Browsers = __nccwpck_require__(50931)
let Prefixes = __nccwpck_require__(25396)
let dataPrefixes = __nccwpck_require__(79659)
let getInfo = __nccwpck_require__(83028)

let autoprefixerData = { browsers: agents, prefixes: dataPrefixes }

const WARNING =
  '\n' +
  '  Replace Autoprefixer `browsers` option to Browserslist config.\n' +
  '  Use `browserslist` key in `package.json` or `.browserslistrc` file.\n' +
  '\n' +
  '  Using `browsers` option can cause errors. Browserslist config can\n' +
  '  be used for Babel, Autoprefixer, postcss-normalize and other tools.\n' +
  '\n' +
  '  If you really need to use option, rename it to `overrideBrowserslist`.\n' +
  '\n' +
  '  Learn more at:\n' +
  '  https://github.com/browserslist/browserslist#readme\n' +
  '  https://twitter.com/browserslist\n' +
  '\n'

function isPlainObject(obj) {
  return Object.prototype.toString.apply(obj) === '[object Object]'
}

let cache = new Map()

function timeCapsule(result, prefixes) {
  if (prefixes.browsers.selected.length === 0) {
    return
  }
  if (prefixes.add.selectors.length > 0) {
    return
  }
  if (Object.keys(prefixes.add).length > 2) {
    return
  }
  /* c8 ignore next 11 */
  result.warn(
    'Autoprefixer target browsers do not need any prefixes.' +
      'You do not need Autoprefixer anymore.\n' +
      'Check your Browserslist config to be sure that your targets ' +
      'are set up correctly.\n' +
      '\n' +
      '  Learn more at:\n' +
      '  https://github.com/postcss/autoprefixer#readme\n' +
      '  https://github.com/browserslist/browserslist#readme\n' +
      '\n'
  )
}

module.exports = plugin

function plugin(...reqs) {
  let options
  if (reqs.length === 1 && isPlainObject(reqs[0])) {
    options = reqs[0]
    reqs = undefined
  } else if (reqs.length === 0 || (reqs.length === 1 && !reqs[0])) {
    reqs = undefined
  } else if (reqs.length <= 2 && (Array.isArray(reqs[0]) || !reqs[0])) {
    options = reqs[1]
    reqs = reqs[0]
  } else if (typeof reqs[reqs.length - 1] === 'object') {
    options = reqs.pop()
  }

  if (!options) {
    options = {}
  }

  if (options.browser) {
    throw new Error(
      'Change `browser` option to `overrideBrowserslist` in Autoprefixer'
    )
  } else if (options.browserslist) {
    throw new Error(
      'Change `browserslist` option to `overrideBrowserslist` in Autoprefixer'
    )
  }

  if (options.overrideBrowserslist) {
    reqs = options.overrideBrowserslist
  } else if (options.browsers) {
    if (typeof console !== 'undefined' && console.warn) {
      console.warn(
        pico.red(WARNING.replace(/`[^`]+`/g, i => pico.yellow(i.slice(1, -1))))
      )
    }
    reqs = options.browsers
  }

  let brwlstOpts = {
    ignoreUnknownVersions: options.ignoreUnknownVersions,
    stats: options.stats,
    env: options.env
  }

  function loadPrefixes(opts) {
    let d = autoprefixerData
    let browsers = new Browsers(d.browsers, reqs, opts, brwlstOpts)
    let key = browsers.selected.join(', ') + JSON.stringify(options)

    if (!cache.has(key)) {
      cache.set(key, new Prefixes(d.prefixes, browsers, options))
    }

    return cache.get(key)
  }

  return {
    postcssPlugin: 'autoprefixer',

    prepare(result) {
      let prefixes = loadPrefixes({
        from: result.opts.from,
        env: options.env
      })

      return {
        OnceExit(root) {
          timeCapsule(result, prefixes)
          if (options.remove !== false) {
            prefixes.processor.remove(root, result)
          }
          if (options.add !== false) {
            prefixes.processor.add(root, result)
          }
        }
      }
    },

    info(opts) {
      opts = opts || {}
      opts.from = opts.from || process.cwd()
      return getInfo(loadPrefixes(opts))
    },

    options,
    browsers: reqs
  }
}

plugin.postcss = true

/**
 * Autoprefixer data
 */
plugin.data = autoprefixerData

/**
 * Autoprefixer default browsers
 */
plugin.defaults = browserslist.defaults

/**
 * Inspect with default Autoprefixer
 */
plugin.info = () => plugin().info()


/***/ }),

/***/ 59137:
/***/ ((module) => {

function last(array) {
  return array[array.length - 1]
}

let brackets = {
  /**
   * Parse string to nodes tree
   */
  parse(str) {
    let current = ['']
    let stack = [current]

    for (let sym of str) {
      if (sym === '(') {
        current = ['']
        last(stack).push(current)
        stack.push(current)
        continue
      }

      if (sym === ')') {
        stack.pop()
        current = last(stack)
        current.push('')
        continue
      }

      current[current.length - 1] += sym
    }

    return stack[0]
  },

  /**
   * Generate output string by nodes tree
   */
  stringify(ast) {
    let result = ''
    for (let i of ast) {
      if (typeof i === 'object') {
        result += `(${brackets.stringify(i)})`
        continue
      }

      result += i
    }
    return result
  }
}

module.exports = brackets


/***/ }),

/***/ 50931:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let browserslist = __nccwpck_require__(55478)
let agents = (__nccwpck_require__(64006).agents)

let utils = __nccwpck_require__(96584)

class Browsers {
  /**
   * Return all prefixes for default browser data
   */
  static prefixes() {
    if (this.prefixesCache) {
      return this.prefixesCache
    }

    this.prefixesCache = []
    for (let name in agents) {
      this.prefixesCache.push(`-${agents[name].prefix}-`)
    }

    this.prefixesCache = utils
      .uniq(this.prefixesCache)
      .sort((a, b) => b.length - a.length)

    return this.prefixesCache
  }

  /**
   * Check is value contain any possible prefix
   */
  static withPrefix(value) {
    if (!this.prefixesRegexp) {
      this.prefixesRegexp = new RegExp(this.prefixes().join('|'))
    }

    return this.prefixesRegexp.test(value)
  }

  constructor(data, requirements, options, browserslistOpts) {
    this.data = data
    this.options = options || {}
    this.browserslistOpts = browserslistOpts || {}
    this.selected = this.parse(requirements)
  }

  /**
   * Return browsers selected by requirements
   */
  parse(requirements) {
    let opts = {}
    for (let i in this.browserslistOpts) {
      opts[i] = this.browserslistOpts[i]
    }
    opts.path = this.options.from
    return browserslist(requirements, opts)
  }

  /**
   * Return prefix for selected browser
   */
  prefix(browser) {
    let [name, version] = browser.split(' ')
    let data = this.data[name]

    let prefix = data.prefix_exceptions && data.prefix_exceptions[version]
    if (!prefix) {
      prefix = data.prefix
    }
    return `-${prefix}-`
  }

  /**
   * Is browser is selected by requirements
   */
  isSelected(browser) {
    return this.selected.includes(browser)
  }
}

module.exports = Browsers


/***/ }),

/***/ 69011:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Prefixer = __nccwpck_require__(26579)
let Browsers = __nccwpck_require__(50931)
let utils = __nccwpck_require__(96584)

class Declaration extends Prefixer {
  /**
   * Always true, because we already get prefixer by property name
   */
  check(/* decl */) {
    return true
  }

  /**
   * Return prefixed version of property
   */
  prefixed(prop, prefix) {
    return prefix + prop
  }

  /**
   * Return unprefixed version of property
   */
  normalize(prop) {
    return prop
  }

  /**
   * Check `value`, that it contain other prefixes, rather than `prefix`
   */
  otherPrefixes(value, prefix) {
    for (let other of Browsers.prefixes()) {
      if (other === prefix) {
        continue
      }
      if (value.includes(other)) {
        return value.replace(/var\([^)]+\)/, '').includes(other)
      }
    }
    return false
  }

  /**
   * Set prefix to declaration
   */
  set(decl, prefix) {
    decl.prop = this.prefixed(decl.prop, prefix)
    return decl
  }

  /**
   * Should we use visual cascade for prefixes
   */
  needCascade(decl) {
    if (!decl._autoprefixerCascade) {
      decl._autoprefixerCascade =
        this.all.options.cascade !== false && decl.raw('before').includes('\n')
    }
    return decl._autoprefixerCascade
  }

  /**
   * Return maximum length of possible prefixed property
   */
  maxPrefixed(prefixes, decl) {
    if (decl._autoprefixerMax) {
      return decl._autoprefixerMax
    }

    let max = 0
    for (let prefix of prefixes) {
      prefix = utils.removeNote(prefix)
      if (prefix.length > max) {
        max = prefix.length
      }
    }
    decl._autoprefixerMax = max

    return decl._autoprefixerMax
  }

  /**
   * Calculate indentation to create visual cascade
   */
  calcBefore(prefixes, decl, prefix = '') {
    let max = this.maxPrefixed(prefixes, decl)
    let diff = max - utils.removeNote(prefix).length

    let before = decl.raw('before')
    if (diff > 0) {
      before += Array(diff).fill(' ').join('')
    }

    return before
  }

  /**
   * Remove visual cascade
   */
  restoreBefore(decl) {
    let lines = decl.raw('before').split('\n')
    let min = lines[lines.length - 1]

    this.all.group(decl).up(prefixed => {
      let array = prefixed.raw('before').split('\n')
      let last = array[array.length - 1]
      if (last.length < min.length) {
        min = last
      }
    })

    lines[lines.length - 1] = min
    decl.raws.before = lines.join('\n')
  }

  /**
   * Clone and insert new declaration
   */
  insert(decl, prefix, prefixes) {
    let cloned = this.set(this.clone(decl), prefix)
    if (!cloned) return undefined

    let already = decl.parent.some(
      i => i.prop === cloned.prop && i.value === cloned.value
    )
    if (already) {
      return undefined
    }

    if (this.needCascade(decl)) {
      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)
    }
    return decl.parent.insertBefore(decl, cloned)
  }

  /**
   * Did this declaration has this prefix above
   */
  isAlready(decl, prefixed) {
    let already = this.all.group(decl).up(i => i.prop === prefixed)
    if (!already) {
      already = this.all.group(decl).down(i => i.prop === prefixed)
    }
    return already
  }

  /**
   * Clone and add prefixes for declaration
   */
  add(decl, prefix, prefixes, result) {
    let prefixed = this.prefixed(decl.prop, prefix)
    if (
      this.isAlready(decl, prefixed) ||
      this.otherPrefixes(decl.value, prefix)
    ) {
      return undefined
    }
    return this.insert(decl, prefix, prefixes, result)
  }

  /**
   * Add spaces for visual cascade
   */
  process(decl, result) {
    if (!this.needCascade(decl)) {
      super.process(decl, result)
      return
    }

    let prefixes = super.process(decl, result)

    if (!prefixes || !prefixes.length) {
      return
    }

    this.restoreBefore(decl)
    decl.raws.before = this.calcBefore(prefixes, decl)
  }

  /**
   * Return list of prefixed properties to clean old prefixes
   */
  old(prop, prefix) {
    return [this.prefixed(prop, prefix)]
  }
}

module.exports = Declaration


/***/ }),

/***/ 46788:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class AlignContent extends Declaration {
  /**
   * Change property name for 2012 spec
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2012) {
      return prefix + 'flex-line-pack'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Return property name by final spec
   */
  normalize() {
    return 'align-content'
  }

  /**
   * Change value for 2012 spec and ignore prefix for 2009
   */
  set(decl, prefix) {
    let spec = flexSpec(prefix)[0]
    if (spec === 2012) {
      decl.value = AlignContent.oldValues[decl.value] || decl.value
      return super.set(decl, prefix)
    }
    if (spec === 'final') {
      return super.set(decl, prefix)
    }
    return undefined
  }
}

AlignContent.names = ['align-content', 'flex-line-pack']

AlignContent.oldValues = {
  'flex-end': 'end',
  'flex-start': 'start',
  'space-between': 'justify',
  'space-around': 'distribute'
}

module.exports = AlignContent


/***/ }),

/***/ 92478:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class AlignItems extends Declaration {
  /**
   * Change property name for 2009 and 2012 specs
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2009) {
      return prefix + 'box-align'
    }
    if (spec === 2012) {
      return prefix + 'flex-align'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Return property name by final spec
   */
  normalize() {
    return 'align-items'
  }

  /**
   * Change value for 2009 and 2012 specs
   */
  set(decl, prefix) {
    let spec = flexSpec(prefix)[0]
    if (spec === 2009 || spec === 2012) {
      decl.value = AlignItems.oldValues[decl.value] || decl.value
    }
    return super.set(decl, prefix)
  }
}

AlignItems.names = ['align-items', 'flex-align', 'box-align']

AlignItems.oldValues = {
  'flex-end': 'end',
  'flex-start': 'start'
}

module.exports = AlignItems


/***/ }),

/***/ 70119:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class AlignSelf extends Declaration {
  check(decl) {
    return (
      decl.parent &&
      !decl.parent.some(i => {
        return i.prop && i.prop.startsWith('grid-')
      })
    )
  }

  /**
   * Change property name for 2012 specs
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2012) {
      return prefix + 'flex-item-align'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Return property name by final spec
   */
  normalize() {
    return 'align-self'
  }

  /**
   * Change value for 2012 spec and ignore prefix for 2009
   */
  set(decl, prefix) {
    let spec = flexSpec(prefix)[0]
    if (spec === 2012) {
      decl.value = AlignSelf.oldValues[decl.value] || decl.value
      return super.set(decl, prefix)
    }
    if (spec === 'final') {
      return super.set(decl, prefix)
    }
    return undefined
  }
}

AlignSelf.names = ['align-self', 'flex-item-align']

AlignSelf.oldValues = {
  'flex-end': 'end',
  'flex-start': 'start'
}

module.exports = AlignSelf


/***/ }),

/***/ 57508:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class Animation extends Declaration {
  /**
   * Don’t add prefixes for modern values.
   */
  check(decl) {
    return !decl.value.split(/\s+/).some(i => {
      let lower = i.toLowerCase()
      return lower === 'reverse' || lower === 'alternate-reverse'
    })
  }
}

Animation.names = ['animation', 'animation-direction']

module.exports = Animation


/***/ }),

/***/ 53397:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let utils = __nccwpck_require__(96584)

class Appearance extends Declaration {
  constructor(name, prefixes, all) {
    super(name, prefixes, all)

    if (this.prefixes) {
      this.prefixes = utils.uniq(
        this.prefixes.map(i => {
          if (i === '-ms-') {
            return '-webkit-'
          }
          return i
        })
      )
    }
  }
}

Appearance.names = ['appearance']

module.exports = Appearance


/***/ }),

/***/ 31242:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Selector = __nccwpck_require__(52098)
let utils = __nccwpck_require__(96584)

class Autofill extends Selector {
  constructor(name, prefixes, all) {
    super(name, prefixes, all)

    if (this.prefixes) {
      this.prefixes = utils.uniq(this.prefixes.map(() => '-webkit-'))
    }
  }

  /**
   * Return different selectors depend on prefix
   */
  prefixed(prefix) {
    if (prefix === '-webkit-') {
      return ':-webkit-autofill'
    }
    return `:${prefix}autofill`
  }
}

Autofill.names = [':autofill']

module.exports = Autofill


/***/ }),

/***/ 46667:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let utils = __nccwpck_require__(96584)

class BackdropFilter extends Declaration {
  constructor(name, prefixes, all) {
    super(name, prefixes, all)

    if (this.prefixes) {
      this.prefixes = utils.uniq(
        this.prefixes.map(i => {
          return i === '-ms-' ? '-webkit-' : i
        })
      )
    }
  }
}

BackdropFilter.names = ['backdrop-filter']

module.exports = BackdropFilter


/***/ }),

/***/ 32781:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let utils = __nccwpck_require__(96584)

class BackgroundClip extends Declaration {
  constructor(name, prefixes, all) {
    super(name, prefixes, all)

    if (this.prefixes) {
      this.prefixes = utils.uniq(
        this.prefixes.map(i => {
          return i === '-ms-' ? '-webkit-' : i
        })
      )
    }
  }

  check(decl) {
    return decl.value.toLowerCase() === 'text'
  }
}

BackgroundClip.names = ['background-clip']

module.exports = BackgroundClip


/***/ }),

/***/ 17397:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class BackgroundSize extends Declaration {
  /**
   * Duplication parameter for -webkit- browsers
   */
  set(decl, prefix) {
    let value = decl.value.toLowerCase()
    if (
      prefix === '-webkit-' &&
      !value.includes(' ') &&
      value !== 'contain' &&
      value !== 'cover'
    ) {
      decl.value = decl.value + ' ' + decl.value
    }
    return super.set(decl, prefix)
  }
}

BackgroundSize.names = ['background-size']

module.exports = BackgroundSize


/***/ }),

/***/ 51447:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class BlockLogical extends Declaration {
  /**
   * Use old syntax for -moz- and -webkit-
   */
  prefixed(prop, prefix) {
    if (prop.includes('-start')) {
      return prefix + prop.replace('-block-start', '-before')
    }
    return prefix + prop.replace('-block-end', '-after')
  }

  /**
   * Return property name by spec
   */
  normalize(prop) {
    if (prop.includes('-before')) {
      return prop.replace('-before', '-block-start')
    }
    return prop.replace('-after', '-block-end')
  }
}

BlockLogical.names = [
  'border-block-start',
  'border-block-end',
  'margin-block-start',
  'margin-block-end',
  'padding-block-start',
  'padding-block-end',
  'border-before',
  'border-after',
  'margin-before',
  'margin-after',
  'padding-before',
  'padding-after'
]

module.exports = BlockLogical


/***/ }),

/***/ 92212:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class BorderImage extends Declaration {
  /**
   * Remove fill parameter for prefixed declarations
   */
  set(decl, prefix) {
    decl.value = decl.value.replace(/\s+fill(\s)/, '$1')
    return super.set(decl, prefix)
  }
}

BorderImage.names = ['border-image']

module.exports = BorderImage


/***/ }),

/***/ 80189:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class BorderRadius extends Declaration {
  /**
   * Change syntax, when add Mozilla prefix
   */
  prefixed(prop, prefix) {
    if (prefix === '-moz-') {
      return prefix + (BorderRadius.toMozilla[prop] || prop)
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Return unprefixed version of property
   */
  normalize(prop) {
    return BorderRadius.toNormal[prop] || prop
  }
}

BorderRadius.names = ['border-radius']

BorderRadius.toMozilla = {}
BorderRadius.toNormal = {}

for (let ver of ['top', 'bottom']) {
  for (let hor of ['left', 'right']) {
    let normal = `border-${ver}-${hor}-radius`
    let mozilla = `border-radius-${ver}${hor}`

    BorderRadius.names.push(normal)
    BorderRadius.names.push(mozilla)

    BorderRadius.toMozilla[normal] = mozilla
    BorderRadius.toNormal[mozilla] = normal
  }
}

module.exports = BorderRadius


/***/ }),

/***/ 26946:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class BreakProps extends Declaration {
  /**
   * Change name for -webkit- and -moz- prefix
   */
  prefixed(prop, prefix) {
    return `${prefix}column-${prop}`
  }

  /**
   * Return property name by final spec
   */
  normalize(prop) {
    if (prop.includes('inside')) {
      return 'break-inside'
    }
    if (prop.includes('before')) {
      return 'break-before'
    }
    return 'break-after'
  }

  /**
   * Change prefixed value for avoid-column and avoid-page
   */
  set(decl, prefix) {
    if (
      (decl.prop === 'break-inside' && decl.value === 'avoid-column') ||
      decl.value === 'avoid-page'
    ) {
      decl.value = 'avoid'
    }
    return super.set(decl, prefix)
  }

  /**
   * Don’t prefix some values
   */
  insert(decl, prefix, prefixes) {
    if (decl.prop !== 'break-inside') {
      return super.insert(decl, prefix, prefixes)
    }
    if (/region/i.test(decl.value) || /page/i.test(decl.value)) {
      return undefined
    }
    return super.insert(decl, prefix, prefixes)
  }
}

BreakProps.names = [
  'break-inside',
  'page-break-inside',
  'column-break-inside',
  'break-before',
  'page-break-before',
  'column-break-before',
  'break-after',
  'page-break-after',
  'column-break-after'
]

module.exports = BreakProps


/***/ }),

/***/ 52315:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let list = (__nccwpck_require__(77001).list)

let Value = __nccwpck_require__(52530)

class CrossFade extends Value {
  replace(string, prefix) {
    return list
      .space(string)
      .map(value => {
        if (value.slice(0, +this.name.length + 1) !== this.name + '(') {
          return value
        }

        let close = value.lastIndexOf(')')
        let after = value.slice(close + 1)
        let args = value.slice(this.name.length + 1, close)

        if (prefix === '-webkit-') {
          let match = args.match(/\d*.?\d+%?/)
          if (match) {
            args = args.slice(match[0].length).trim()
            args += `, ${match[0]}`
          } else {
            args += ', 0.5'
          }
        }
        return prefix + this.name + '(' + args + ')' + after
      })
      .join(' ')
  }
}

CrossFade.names = ['cross-fade']

module.exports = CrossFade


/***/ }),

/***/ 69470:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let OldValue = __nccwpck_require__(86029)
let Value = __nccwpck_require__(52530)

class DisplayFlex extends Value {
  constructor(name, prefixes) {
    super(name, prefixes)
    if (name === 'display-flex') {
      this.name = 'flex'
    }
  }

  /**
   * Faster check for flex value
   */
  check(decl) {
    return decl.prop === 'display' && decl.value === this.name
  }

  /**
   * Return value by spec
   */
  prefixed(prefix) {
    let spec, value
    ;[spec, prefix] = flexSpec(prefix)

    if (spec === 2009) {
      if (this.name === 'flex') {
        value = 'box'
      } else {
        value = 'inline-box'
      }
    } else if (spec === 2012) {
      if (this.name === 'flex') {
        value = 'flexbox'
      } else {
        value = 'inline-flexbox'
      }
    } else if (spec === 'final') {
      value = this.name
    }

    return prefix + value
  }

  /**
   * Add prefix to value depend on flebox spec version
   */
  replace(string, prefix) {
    return this.prefixed(prefix)
  }

  /**
   * Change value for old specs
   */
  old(prefix) {
    let prefixed = this.prefixed(prefix)
    if (!prefixed) return undefined
    return new OldValue(this.name, prefixed)
  }
}

DisplayFlex.names = ['display-flex', 'inline-flex']

module.exports = DisplayFlex


/***/ }),

/***/ 35643:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Value = __nccwpck_require__(52530)

class DisplayGrid extends Value {
  constructor(name, prefixes) {
    super(name, prefixes)
    if (name === 'display-grid') {
      this.name = 'grid'
    }
  }

  /**
   * Faster check for flex value
   */
  check(decl) {
    return decl.prop === 'display' && decl.value === this.name
  }
}

DisplayGrid.names = ['display-grid', 'inline-grid']

module.exports = DisplayGrid


/***/ }),

/***/ 35407:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Selector = __nccwpck_require__(52098)
let utils = __nccwpck_require__(96584)

class FileSelectorButton extends Selector {
  constructor(name, prefixes, all) {
    super(name, prefixes, all)

    if (this.prefixes) {
      this.prefixes = utils.uniq(this.prefixes.map(() => '-webkit-'))
    }
  }

  /**
   * Return different selectors depend on prefix
   */
  prefixed(prefix) {
    if (prefix === '-webkit-') {
      return '::-webkit-file-upload-button'
    }
    return `::${prefix}file-selector-button`
  }
}

FileSelectorButton.names = ['::file-selector-button']

module.exports = FileSelectorButton


/***/ }),

/***/ 56122:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Value = __nccwpck_require__(52530)

class FilterValue extends Value {
  constructor(name, prefixes) {
    super(name, prefixes)
    if (name === 'filter-function') {
      this.name = 'filter'
    }
  }
}

FilterValue.names = ['filter', 'filter-function']

module.exports = FilterValue


/***/ }),

/***/ 46437:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class Filter extends Declaration {
  /**
   * Check is it Internet Explorer filter
   */
  check(decl) {
    let v = decl.value
    return (
      !v.toLowerCase().includes('alpha(') &&
      !v.includes('DXImageTransform.Microsoft') &&
      !v.includes('data:image/svg+xml')
    )
  }
}

Filter.names = ['filter']

module.exports = Filter


/***/ }),

/***/ 33962:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class FlexBasis extends Declaration {
  /**
   * Return property name by final spec
   */
  normalize() {
    return 'flex-basis'
  }

  /**
   * Return flex property for 2012 spec
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2012) {
      return prefix + 'flex-preferred-size'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Ignore 2009 spec and use flex property for 2012
   */
  set(decl, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2012 || spec === 'final') {
      return super.set(decl, prefix)
    }
    return undefined
  }
}

FlexBasis.names = ['flex-basis', 'flex-preferred-size']

module.exports = FlexBasis


/***/ }),

/***/ 58440:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class FlexDirection extends Declaration {
  /**
   * Return property name by final spec
   */
  normalize() {
    return 'flex-direction'
  }

  /**
   * Use two properties for 2009 spec
   */
  insert(decl, prefix, prefixes) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec !== 2009) {
      return super.insert(decl, prefix, prefixes)
    }
    let already = decl.parent.some(
      i =>
        i.prop === prefix + 'box-orient' || i.prop === prefix + 'box-direction'
    )
    if (already) {
      return undefined
    }

    let v = decl.value
    let orient, dir
    if (v === 'inherit' || v === 'initial' || v === 'unset') {
      orient = v
      dir = v
    } else {
      orient = v.includes('row') ? 'horizontal' : 'vertical'
      dir = v.includes('reverse') ? 'reverse' : 'normal'
    }

    let cloned = this.clone(decl)
    cloned.prop = prefix + 'box-orient'
    cloned.value = orient
    if (this.needCascade(decl)) {
      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)
    }
    decl.parent.insertBefore(decl, cloned)

    cloned = this.clone(decl)
    cloned.prop = prefix + 'box-direction'
    cloned.value = dir
    if (this.needCascade(decl)) {
      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)
    }
    return decl.parent.insertBefore(decl, cloned)
  }

  /**
   * Clean two properties for 2009 spec
   */
  old(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2009) {
      return [prefix + 'box-orient', prefix + 'box-direction']
    } else {
      return super.old(prop, prefix)
    }
  }
}

FlexDirection.names = ['flex-direction', 'box-direction', 'box-orient']

module.exports = FlexDirection


/***/ }),

/***/ 99225:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class FlexFlow extends Declaration {
  /**
   * Use two properties for 2009 spec
   */
  insert(decl, prefix, prefixes) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec !== 2009) {
      return super.insert(decl, prefix, prefixes)
    }
    let values = decl.value
      .split(/\s+/)
      .filter(i => i !== 'wrap' && i !== 'nowrap' && 'wrap-reverse')
    if (values.length === 0) {
      return undefined
    }

    let already = decl.parent.some(
      i =>
        i.prop === prefix + 'box-orient' || i.prop === prefix + 'box-direction'
    )
    if (already) {
      return undefined
    }

    let value = values[0]
    let orient = value.includes('row') ? 'horizontal' : 'vertical'
    let dir = value.includes('reverse') ? 'reverse' : 'normal'

    let cloned = this.clone(decl)
    cloned.prop = prefix + 'box-orient'
    cloned.value = orient
    if (this.needCascade(decl)) {
      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)
    }
    decl.parent.insertBefore(decl, cloned)

    cloned = this.clone(decl)
    cloned.prop = prefix + 'box-direction'
    cloned.value = dir
    if (this.needCascade(decl)) {
      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)
    }
    return decl.parent.insertBefore(decl, cloned)
  }
}

FlexFlow.names = ['flex-flow', 'box-direction', 'box-orient']

module.exports = FlexFlow


/***/ }),

/***/ 11708:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class Flex extends Declaration {
  /**
   * Return property name by final spec
   */
  normalize() {
    return 'flex'
  }

  /**
   * Return flex property for 2009 and 2012 specs
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2009) {
      return prefix + 'box-flex'
    }
    if (spec === 2012) {
      return prefix + 'flex-positive'
    }
    return super.prefixed(prop, prefix)
  }
}

Flex.names = ['flex-grow', 'flex-positive']

module.exports = Flex


/***/ }),

/***/ 61945:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class FlexShrink extends Declaration {
  /**
   * Return property name by final spec
   */
  normalize() {
    return 'flex-shrink'
  }

  /**
   * Return flex property for 2012 spec
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2012) {
      return prefix + 'flex-negative'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Ignore 2009 spec and use flex property for 2012
   */
  set(decl, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2012 || spec === 'final') {
      return super.set(decl, prefix)
    }
    return undefined
  }
}

FlexShrink.names = ['flex-shrink', 'flex-negative']

module.exports = FlexShrink


/***/ }),

/***/ 43713:
/***/ ((module) => {

/**
 * Return flexbox spec versions by prefix
 */
module.exports = function (prefix) {
  let spec
  if (prefix === '-webkit- 2009' || prefix === '-moz-') {
    spec = 2009
  } else if (prefix === '-ms-') {
    spec = 2012
  } else if (prefix === '-webkit-') {
    spec = 'final'
  }

  if (prefix === '-webkit- 2009') {
    prefix = '-webkit-'
  }

  return [spec, prefix]
}


/***/ }),

/***/ 44910:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class FlexWrap extends Declaration {
  /**
   * Don't add prefix for 2009 spec
   */
  set(decl, prefix) {
    let spec = flexSpec(prefix)[0]
    if (spec !== 2009) {
      return super.set(decl, prefix)
    }
    return undefined
  }
}

FlexWrap.names = ['flex-wrap']

module.exports = FlexWrap


/***/ }),

/***/ 84190:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let list = (__nccwpck_require__(77001).list)

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class Flex extends Declaration {
  /**
   * Change property name for 2009 spec
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2009) {
      return prefix + 'box-flex'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Return property name by final spec
   */
  normalize() {
    return 'flex'
  }

  /**
   * Spec 2009 supports only first argument
   * Spec 2012 disallows unitless basis
   */
  set(decl, prefix) {
    let spec = flexSpec(prefix)[0]
    if (spec === 2009) {
      decl.value = list.space(decl.value)[0]
      decl.value = Flex.oldValues[decl.value] || decl.value
      return super.set(decl, prefix)
    }
    if (spec === 2012) {
      let components = list.space(decl.value)
      if (components.length === 3 && components[2] === '0') {
        decl.value = components.slice(0, 2).concat('0px').join(' ')
      }
    }
    return super.set(decl, prefix)
  }
}

Flex.names = ['flex', 'box-flex']

Flex.oldValues = {
  auto: '1',
  none: '0'
}

module.exports = Flex


/***/ }),

/***/ 55233:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Selector = __nccwpck_require__(52098)

class Fullscreen extends Selector {
  /**
   * Return different selectors depend on prefix
   */
  prefixed(prefix) {
    if (prefix === '-webkit-') {
      return ':-webkit-full-screen'
    }
    if (prefix === '-moz-') {
      return ':-moz-full-screen'
    }
    return `:${prefix}fullscreen`
  }
}

Fullscreen.names = [':fullscreen']

module.exports = Fullscreen


/***/ }),

/***/ 29864:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let parser = __nccwpck_require__(19285)
let range = __nccwpck_require__(24251)

let OldValue = __nccwpck_require__(86029)
let Value = __nccwpck_require__(52530)
let utils = __nccwpck_require__(96584)

let IS_DIRECTION = /top|left|right|bottom/gi

class Gradient extends Value {
  /**
   * Change degrees for webkit prefix
   */
  replace(string, prefix) {
    let ast = parser(string)
    for (let node of ast.nodes) {
      let gradientName = this.name // gradient name
      if (node.type === 'function' && node.value === gradientName) {
        node.nodes = this.newDirection(node.nodes)
        node.nodes = this.normalize(node.nodes, gradientName)
        if (prefix === '-webkit- old') {
          let changes = this.oldWebkit(node)
          if (!changes) {
            return false
          }
        } else {
          node.nodes = this.convertDirection(node.nodes)
          node.value = prefix + node.value
        }
      }
    }
    return ast.toString()
  }

  /**
   * Replace first token
   */
  replaceFirst(params, ...words) {
    let prefix = words.map(i => {
      if (i === ' ') {
        return { type: 'space', value: i }
      }
      return { type: 'word', value: i }
    })
    return prefix.concat(params.slice(1))
  }

  /**
   * Convert angle unit to deg
   */
  normalizeUnit(str, full) {
    let num = parseFloat(str)
    let deg = (num / full) * 360
    return `${deg}deg`
  }

  /**
   * Normalize angle
   */
  normalize(nodes, gradientName) {
    if (!nodes[0]) return nodes

    if (/-?\d+(.\d+)?grad/.test(nodes[0].value)) {
      nodes[0].value = this.normalizeUnit(nodes[0].value, 400)
    } else if (/-?\d+(.\d+)?rad/.test(nodes[0].value)) {
      nodes[0].value = this.normalizeUnit(nodes[0].value, 2 * Math.PI)
    } else if (/-?\d+(.\d+)?turn/.test(nodes[0].value)) {
      nodes[0].value = this.normalizeUnit(nodes[0].value, 1)
    } else if (nodes[0].value.includes('deg')) {
      let num = parseFloat(nodes[0].value)
      num = range.wrap(0, 360, num)
      nodes[0].value = `${num}deg`
    }

    if (
      gradientName === 'linear-gradient' ||
      gradientName === 'repeating-linear-gradient'
    ) {
      let direction = nodes[0].value

      // Unitless zero for `<angle>` values are allowed in CSS gradients and transforms.
      // Spec: https://github.com/w3c/csswg-drafts/commit/602789171429b2231223ab1e5acf8f7f11652eb3
      if (direction === '0deg' || direction === '0') {
        nodes = this.replaceFirst(nodes, 'to', ' ', 'top')
      } else if (direction === '90deg') {
        nodes = this.replaceFirst(nodes, 'to', ' ', 'right')
      } else if (direction === '180deg') {
        nodes = this.replaceFirst(nodes, 'to', ' ', 'bottom') // default value
      } else if (direction === '270deg') {
        nodes = this.replaceFirst(nodes, 'to', ' ', 'left')
      }
    }

    return nodes
  }

  /**
   * Replace old direction to new
   */
  newDirection(params) {
    if (params[0].value === 'to') {
      return params
    }
    IS_DIRECTION.lastIndex = 0 // reset search index of global regexp
    if (!IS_DIRECTION.test(params[0].value)) {
      return params
    }

    params.unshift(
      {
        type: 'word',
        value: 'to'
      },
      {
        type: 'space',
        value: ' '
      }
    )

    for (let i = 2; i < params.length; i++) {
      if (params[i].type === 'div') {
        break
      }
      if (params[i].type === 'word') {
        params[i].value = this.revertDirection(params[i].value)
      }
    }

    return params
  }

  /**
   * Look for at word
   */
  isRadial(params) {
    let state = 'before'
    for (let param of params) {
      if (state === 'before' && param.type === 'space') {
        state = 'at'
      } else if (state === 'at' && param.value === 'at') {
        state = 'after'
      } else if (state === 'after' && param.type === 'space') {
        return true
      } else if (param.type === 'div') {
        break
      } else {
        state = 'before'
      }
    }
    return false
  }

  /**
   * Change new direction to old
   */
  convertDirection(params) {
    if (params.length > 0) {
      if (params[0].value === 'to') {
        this.fixDirection(params)
      } else if (params[0].value.includes('deg')) {
        this.fixAngle(params)
      } else if (this.isRadial(params)) {
        this.fixRadial(params)
      }
    }
    return params
  }

  /**
   * Replace `to top left` to `bottom right`
   */
  fixDirection(params) {
    params.splice(0, 2)

    for (let param of params) {
      if (param.type === 'div') {
        break
      }
      if (param.type === 'word') {
        param.value = this.revertDirection(param.value)
      }
    }
  }

  /**
   * Add 90 degrees
   */
  fixAngle(params) {
    let first = params[0].value
    first = parseFloat(first)
    first = Math.abs(450 - first) % 360
    first = this.roundFloat(first, 3)
    params[0].value = `${first}deg`
  }

  /**
   * Fix radial direction syntax
   */
  fixRadial(params) {
    let first = []
    let second = []
    let a, b, c, i, next

    for (i = 0; i < params.length - 2; i++) {
      a = params[i]
      b = params[i + 1]
      c = params[i + 2]
      if (a.type === 'space' && b.value === 'at' && c.type === 'space') {
        next = i + 3
        break
      } else {
        first.push(a)
      }
    }

    let div
    for (i = next; i < params.length; i++) {
      if (params[i].type === 'div') {
        div = params[i]
        break
      } else {
        second.push(params[i])
      }
    }

    params.splice(0, i, ...second, div, ...first)
  }

  revertDirection(word) {
    return Gradient.directions[word.toLowerCase()] || word
  }

  /**
   * Round float and save digits under dot
   */
  roundFloat(float, digits) {
    return parseFloat(float.toFixed(digits))
  }

  /**
   * Convert to old webkit syntax
   */
  oldWebkit(node) {
    let { nodes } = node
    let string = parser.stringify(node.nodes)

    if (this.name !== 'linear-gradient') {
      return false
    }
    if (nodes[0] && nodes[0].value.includes('deg')) {
      return false
    }
    if (
      string.includes('px') ||
      string.includes('-corner') ||
      string.includes('-side')
    ) {
      return false
    }

    let params = [[]]
    for (let i of nodes) {
      params[params.length - 1].push(i)
      if (i.type === 'div' && i.value === ',') {
        params.push([])
      }
    }

    this.oldDirection(params)
    this.colorStops(params)

    node.nodes = []
    for (let param of params) {
      node.nodes = node.nodes.concat(param)
    }

    node.nodes.unshift(
      { type: 'word', value: 'linear' },
      this.cloneDiv(node.nodes)
    )
    node.value = '-webkit-gradient'

    return true
  }

  /**
   * Change direction syntax to old webkit
   */
  oldDirection(params) {
    let div = this.cloneDiv(params[0])

    if (params[0][0].value !== 'to') {
      return params.unshift([
        { type: 'word', value: Gradient.oldDirections.bottom },
        div
      ])
    } else {
      let words = []
      for (let node of params[0].slice(2)) {
        if (node.type === 'word') {
          words.push(node.value.toLowerCase())
        }
      }

      words = words.join(' ')
      let old = Gradient.oldDirections[words] || words

      params[0] = [{ type: 'word', value: old }, div]
      return params[0]
    }
  }

  /**
   * Get div token from exists parameters
   */
  cloneDiv(params) {
    for (let i of params) {
      if (i.type === 'div' && i.value === ',') {
        return i
      }
    }
    return { type: 'div', value: ',', after: ' ' }
  }

  /**
   * Change colors syntax to old webkit
   */
  colorStops(params) {
    let result = []
    for (let i = 0; i < params.length; i++) {
      let pos
      let param = params[i]
      let item
      if (i === 0) {
        continue
      }

      let color = parser.stringify(param[0])
      if (param[1] && param[1].type === 'word') {
        pos = param[1].value
      } else if (param[2] && param[2].type === 'word') {
        pos = param[2].value
      }

      let stop
      if (i === 1 && (!pos || pos === '0%')) {
        stop = `from(${color})`
      } else if (i === params.length - 1 && (!pos || pos === '100%')) {
        stop = `to(${color})`
      } else if (pos) {
        stop = `color-stop(${pos}, ${color})`
      } else {
        stop = `color-stop(${color})`
      }

      let div = param[param.length - 1]
      params[i] = [{ type: 'word', value: stop }]
      if (div.type === 'div' && div.value === ',') {
        item = params[i].push(div)
      }
      result.push(item)
    }
    return result
  }

  /**
   * Remove old WebKit gradient too
   */
  old(prefix) {
    if (prefix === '-webkit-') {
      let type
      if (this.name === 'linear-gradient') {
        type = 'linear'
      } else if (this.name === 'repeating-linear-gradient') {
        type = 'repeating-linear'
      } else if (this.name === 'repeating-radial-gradient') {
        type = 'repeating-radial'
      } else {
        type = 'radial'
      }
      let string = '-gradient'
      let regexp = utils.regexp(
        `-webkit-(${type}-gradient|gradient\\(\\s*${type})`,
        false
      )

      return new OldValue(this.name, prefix + this.name, string, regexp)
    } else {
      return super.old(prefix)
    }
  }

  /**
   * Do not add non-webkit prefixes for list-style and object
   */
  add(decl, prefix) {
    let p = decl.prop
    if (p.includes('mask')) {
      if (prefix === '-webkit-' || prefix === '-webkit- old') {
        return super.add(decl, prefix)
      }
    } else if (
      p === 'list-style' ||
      p === 'list-style-image' ||
      p === 'content'
    ) {
      if (prefix === '-webkit-' || prefix === '-webkit- old') {
        return super.add(decl, prefix)
      }
    } else {
      return super.add(decl, prefix)
    }
    return undefined
  }
}

Gradient.names = [
  'linear-gradient',
  'repeating-linear-gradient',
  'radial-gradient',
  'repeating-radial-gradient'
]

Gradient.directions = {
  top: 'bottom', // default value
  left: 'right',
  bottom: 'top',
  right: 'left'
}

// Direction to replace
Gradient.oldDirections = {
  'top': 'left bottom, left top',
  'left': 'right top, left top',
  'bottom': 'left top, left bottom',
  'right': 'left top, right top',

  'top right': 'left bottom, right top',
  'top left': 'right bottom, left top',
  'right top': 'left bottom, right top',
  'right bottom': 'left top, right bottom',
  'bottom right': 'left top, right bottom',
  'bottom left': 'right top, left bottom',
  'left top': 'right bottom, left top',
  'left bottom': 'right top, left bottom'
}

module.exports = Gradient


/***/ }),

/***/ 85159:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let utils = __nccwpck_require__(73398)

class GridArea extends Declaration {
  /**
   * Translate grid-area to separate -ms- prefixed properties
   */
  insert(decl, prefix, prefixes, result) {
    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

    let values = utils.parse(decl)

    let [rowStart, rowSpan] = utils.translate(values, 0, 2)
    let [columnStart, columnSpan] = utils.translate(values, 1, 3)

    ;[
      ['grid-row', rowStart],
      ['grid-row-span', rowSpan],
      ['grid-column', columnStart],
      ['grid-column-span', columnSpan]
    ].forEach(([prop, value]) => {
      utils.insertDecl(decl, prop, value)
    })

    utils.warnTemplateSelectorNotFound(decl, result)
    utils.warnIfGridRowColumnExists(decl, result)

    return undefined
  }
}

GridArea.names = ['grid-area']

module.exports = GridArea


/***/ }),

/***/ 4621:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class GridColumnAlign extends Declaration {
  /**
   * Do not prefix flexbox values
   */
  check(decl) {
    return !decl.value.includes('flex-') && decl.value !== 'baseline'
  }

  /**
   * Change property name for IE
   */
  prefixed(prop, prefix) {
    return prefix + 'grid-column-align'
  }

  /**
   * Change IE property back
   */
  normalize() {
    return 'justify-self'
  }
}

GridColumnAlign.names = ['grid-column-align']

module.exports = GridColumnAlign


/***/ }),

/***/ 6307:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let { isPureNumber } = __nccwpck_require__(96584)

class GridEnd extends Declaration {
  /**
   * Change repeating syntax for IE
   */
  insert(decl, prefix, prefixes, result) {
    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

    let clonedDecl = this.clone(decl)

    let startProp = decl.prop.replace(/end$/, 'start')
    let spanProp = prefix + decl.prop.replace(/end$/, 'span')

    if (decl.parent.some(i => i.prop === spanProp)) {
      return undefined
    }

    clonedDecl.prop = spanProp

    if (decl.value.includes('span')) {
      clonedDecl.value = decl.value.replace(/span\s/i, '')
    } else {
      let startDecl
      decl.parent.walkDecls(startProp, d => {
        startDecl = d
      })
      if (startDecl) {
        if (isPureNumber(startDecl.value)) {
          let value = Number(decl.value) - Number(startDecl.value) + ''
          clonedDecl.value = value
        } else {
          return undefined
        }
      } else {
        decl.warn(
          result,
          `Can not prefix ${decl.prop} (${startProp} is not found)`
        )
      }
    }

    decl.cloneBefore(clonedDecl)

    return undefined
  }
}

GridEnd.names = ['grid-row-end', 'grid-column-end']

module.exports = GridEnd


/***/ }),

/***/ 85565:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class GridRowAlign extends Declaration {
  /**
   * Do not prefix flexbox values
   */
  check(decl) {
    return !decl.value.includes('flex-') && decl.value !== 'baseline'
  }

  /**
   * Change property name for IE
   */
  prefixed(prop, prefix) {
    return prefix + 'grid-row-align'
  }

  /**
   * Change IE property back
   */
  normalize() {
    return 'align-self'
  }
}

GridRowAlign.names = ['grid-row-align']

module.exports = GridRowAlign


/***/ }),

/***/ 99417:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let utils = __nccwpck_require__(73398)

class GridRowColumn extends Declaration {
  /**
   * Translate grid-row / grid-column to separate -ms- prefixed properties
   */
  insert(decl, prefix, prefixes) {
    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

    let values = utils.parse(decl)
    let [start, span] = utils.translate(values, 0, 1)

    let hasStartValueSpan = values[0] && values[0].includes('span')

    if (hasStartValueSpan) {
      span = values[0].join('').replace(/\D/g, '')
    }

    ;[
      [decl.prop, start],
      [`${decl.prop}-span`, span]
    ].forEach(([prop, value]) => {
      utils.insertDecl(decl, prop, value)
    })

    return undefined
  }
}

GridRowColumn.names = ['grid-row', 'grid-column']

module.exports = GridRowColumn


/***/ }),

/***/ 39572:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let {
  prefixTrackProp,
  prefixTrackValue,
  autoplaceGridItems,
  getGridGap,
  inheritGridGap
} = __nccwpck_require__(73398)
let Processor = __nccwpck_require__(54108)

class GridRowsColumns extends Declaration {
  /**
   * Change property name for IE
   */
  prefixed(prop, prefix) {
    if (prefix === '-ms-') {
      return prefixTrackProp({ prop, prefix })
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Change IE property back
   */
  normalize(prop) {
    return prop.replace(/^grid-(rows|columns)/, 'grid-template-$1')
  }

  insert(decl, prefix, prefixes, result) {
    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

    let { parent, prop, value } = decl
    let isRowProp = prop.includes('rows')
    let isColumnProp = prop.includes('columns')

    let hasGridTemplate = parent.some(
      i => i.prop === 'grid-template' || i.prop === 'grid-template-areas'
    )

    /**
     * Not to prefix rows declaration if grid-template(-areas) is present
     */
    if (hasGridTemplate && isRowProp) {
      return false
    }

    let processor = new Processor({ options: {} })
    let status = processor.gridStatus(parent, result)
    let gap = getGridGap(decl)
    gap = inheritGridGap(decl, gap) || gap

    let gapValue = isRowProp ? gap.row : gap.column

    if ((status === 'no-autoplace' || status === true) && !hasGridTemplate) {
      gapValue = null
    }

    let prefixValue = prefixTrackValue({
      value,
      gap: gapValue
    })

    /**
     * Insert prefixes
     */
    decl.cloneBefore({
      prop: prefixTrackProp({ prop, prefix }),
      value: prefixValue
    })

    let autoflow = parent.nodes.find(i => i.prop === 'grid-auto-flow')
    let autoflowValue = 'row'

    if (autoflow && !processor.disabled(autoflow, result)) {
      autoflowValue = autoflow.value.trim()
    }
    if (status === 'autoplace') {
      /**
       * Show warning if grid-template-rows decl is not found
       */
      let rowDecl = parent.nodes.find(i => i.prop === 'grid-template-rows')

      if (!rowDecl && hasGridTemplate) {
        return undefined
      } else if (!rowDecl && !hasGridTemplate) {
        decl.warn(
          result,
          'Autoplacement does not work without grid-template-rows property'
        )
        return undefined
      }

      /**
       * Show warning if grid-template-columns decl is not found
       */
      let columnDecl = parent.nodes.find(i => {
        return i.prop === 'grid-template-columns'
      })
      if (!columnDecl && !hasGridTemplate) {
        decl.warn(
          result,
          'Autoplacement does not work without grid-template-columns property'
        )
      }

      /**
       * Autoplace grid items
       */
      if (isColumnProp && !hasGridTemplate) {
        autoplaceGridItems(decl, result, gap, autoflowValue)
      }
    }

    return undefined
  }
}

GridRowsColumns.names = [
  'grid-template-rows',
  'grid-template-columns',
  'grid-rows',
  'grid-columns'
]

module.exports = GridRowsColumns


/***/ }),

/***/ 57526:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class GridStart extends Declaration {
  /**
   * Do not add prefix for unsupported value in IE
   */
  check(decl) {
    let value = decl.value
    return !value.includes('/') && !value.includes('span')
  }

  /**
   * Return a final spec property
   */
  normalize(prop) {
    return prop.replace('-start', '')
  }

  /**
   * Change property name for IE
   */
  prefixed(prop, prefix) {
    let result = super.prefixed(prop, prefix)
    if (prefix === '-ms-') {
      result = result.replace('-start', '')
    }
    return result
  }
}

GridStart.names = ['grid-row-start', 'grid-column-start']

module.exports = GridStart


/***/ }),

/***/ 10577:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let {
  parseGridAreas,
  warnMissedAreas,
  prefixTrackProp,
  prefixTrackValue,
  getGridGap,
  warnGridGap,
  inheritGridGap
} = __nccwpck_require__(73398)

function getGridRows(tpl) {
  return tpl
    .trim()
    .slice(1, -1)
    .split(/["']\s*["']?/g)
}

class GridTemplateAreas extends Declaration {
  /**
   * Translate grid-template-areas to separate -ms- prefixed properties
   */
  insert(decl, prefix, prefixes, result) {
    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

    let hasColumns = false
    let hasRows = false
    let parent = decl.parent
    let gap = getGridGap(decl)
    gap = inheritGridGap(decl, gap) || gap

    // remove already prefixed rows
    // to prevent doubling prefixes
    parent.walkDecls(/-ms-grid-rows/, i => i.remove())

    // add empty tracks to rows
    parent.walkDecls(/grid-template-(rows|columns)/, trackDecl => {
      if (trackDecl.prop === 'grid-template-rows') {
        hasRows = true
        let { prop, value } = trackDecl
        trackDecl.cloneBefore({
          prop: prefixTrackProp({ prop, prefix }),
          value: prefixTrackValue({ value, gap: gap.row })
        })
      } else {
        hasColumns = true
      }
    })

    let gridRows = getGridRows(decl.value)

    if (hasColumns && !hasRows && gap.row && gridRows.length > 1) {
      decl.cloneBefore({
        prop: '-ms-grid-rows',
        value: prefixTrackValue({
          value: `repeat(${gridRows.length}, auto)`,
          gap: gap.row
        }),
        raws: {}
      })
    }

    // warnings
    warnGridGap({
      gap,
      hasColumns,
      decl,
      result
    })

    let areas = parseGridAreas({
      rows: gridRows,
      gap
    })

    warnMissedAreas(areas, decl, result)

    return decl
  }
}

GridTemplateAreas.names = ['grid-template-areas']

module.exports = GridTemplateAreas


/***/ }),

/***/ 10304:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let {
  parseTemplate,
  warnMissedAreas,
  getGridGap,
  warnGridGap,
  inheritGridGap
} = __nccwpck_require__(73398)

class GridTemplate extends Declaration {
  /**
   * Translate grid-template to separate -ms- prefixed properties
   */
  insert(decl, prefix, prefixes, result) {
    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

    if (decl.parent.some(i => i.prop === '-ms-grid-rows')) {
      return undefined
    }

    let gap = getGridGap(decl)

    /**
     * we must insert inherited gap values in some cases:
     * if we are inside media query && if we have no grid-gap value
     */
    let inheritedGap = inheritGridGap(decl, gap)

    let { rows, columns, areas } = parseTemplate({
      decl,
      gap: inheritedGap || gap
    })

    let hasAreas = Object.keys(areas).length > 0
    let hasRows = Boolean(rows)
    let hasColumns = Boolean(columns)

    warnGridGap({
      gap,
      hasColumns,
      decl,
      result
    })

    warnMissedAreas(areas, decl, result)

    if ((hasRows && hasColumns) || hasAreas) {
      decl.cloneBefore({
        prop: '-ms-grid-rows',
        value: rows,
        raws: {}
      })
    }

    if (hasColumns) {
      decl.cloneBefore({
        prop: '-ms-grid-columns',
        value: columns,
        raws: {}
      })
    }

    return decl
  }
}

GridTemplate.names = ['grid-template']

module.exports = GridTemplate


/***/ }),

/***/ 73398:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

let parser = __nccwpck_require__(19285)
let list = (__nccwpck_require__(77001).list)

let uniq = (__nccwpck_require__(96584).uniq)
let escapeRegexp = (__nccwpck_require__(96584).escapeRegexp)
let splitSelector = (__nccwpck_require__(96584).splitSelector)

function convert(value) {
  if (
    value &&
    value.length === 2 &&
    value[0] === 'span' &&
    parseInt(value[1], 10) > 0
  ) {
    return [false, parseInt(value[1], 10)]
  }

  if (value && value.length === 1 && parseInt(value[0], 10) > 0) {
    return [parseInt(value[0], 10), false]
  }

  return [false, false]
}

exports.translate = translate

function translate(values, startIndex, endIndex) {
  let startValue = values[startIndex]
  let endValue = values[endIndex]

  if (!startValue) {
    return [false, false]
  }

  let [start, spanStart] = convert(startValue)
  let [end, spanEnd] = convert(endValue)

  if (start && !endValue) {
    return [start, false]
  }

  if (spanStart && end) {
    return [end - spanStart, spanStart]
  }

  if (start && spanEnd) {
    return [start, spanEnd]
  }

  if (start && end) {
    return [start, end - start]
  }

  return [false, false]
}

exports.parse = parse

function parse(decl) {
  let node = parser(decl.value)

  let values = []
  let current = 0
  values[current] = []

  for (let i of node.nodes) {
    if (i.type === 'div') {
      current += 1
      values[current] = []
    } else if (i.type === 'word') {
      values[current].push(i.value)
    }
  }

  return values
}

exports.insertDecl = insertDecl

function insertDecl(decl, prop, value) {
  if (value && !decl.parent.some(i => i.prop === `-ms-${prop}`)) {
    decl.cloneBefore({
      prop: `-ms-${prop}`,
      value: value.toString()
    })
  }
}

// Track transforms

exports.prefixTrackProp = prefixTrackProp

function prefixTrackProp({ prop, prefix }) {
  return prefix + prop.replace('template-', '')
}

function transformRepeat({ nodes }, { gap }) {
  let { count, size } = nodes.reduce(
    (result, node) => {
      if (node.type === 'div' && node.value === ',') {
        result.key = 'size'
      } else {
        result[result.key].push(parser.stringify(node))
      }
      return result
    },
    {
      key: 'count',
      size: [],
      count: []
    }
  )

  // insert gap values
  if (gap) {
    size = size.filter(i => i.trim())
    let val = []
    for (let i = 1; i <= count; i++) {
      size.forEach((item, index) => {
        if (index > 0 || i > 1) {
          val.push(gap)
        }
        val.push(item)
      })
    }

    return val.join(' ')
  }

  return `(${size.join('')})[${count.join('')}]`
}

exports.prefixTrackValue = prefixTrackValue

function prefixTrackValue({ value, gap }) {
  let result = parser(value).nodes.reduce((nodes, node) => {
    if (node.type === 'function' && node.value === 'repeat') {
      return nodes.concat({
        type: 'word',
        value: transformRepeat(node, { gap })
      })
    }
    if (gap && node.type === 'space') {
      return nodes.concat(
        {
          type: 'space',
          value: ' '
        },
        {
          type: 'word',
          value: gap
        },
        node
      )
    }
    return nodes.concat(node)
  }, [])

  return parser.stringify(result)
}

// Parse grid-template-areas

let DOTS = /^\.+$/

function track(start, end) {
  return { start, end, span: end - start }
}

function getColumns(line) {
  return line.trim().split(/\s+/g)
}

exports.parseGridAreas = parseGridAreas

function parseGridAreas({ rows, gap }) {
  return rows.reduce((areas, line, rowIndex) => {
    if (gap.row) rowIndex *= 2

    if (line.trim() === '') return areas

    getColumns(line).forEach((area, columnIndex) => {
      if (DOTS.test(area)) return

      if (gap.column) columnIndex *= 2

      if (typeof areas[area] === 'undefined') {
        areas[area] = {
          column: track(columnIndex + 1, columnIndex + 2),
          row: track(rowIndex + 1, rowIndex + 2)
        }
      } else {
        let { column, row } = areas[area]

        column.start = Math.min(column.start, columnIndex + 1)
        column.end = Math.max(column.end, columnIndex + 2)
        column.span = column.end - column.start

        row.start = Math.min(row.start, rowIndex + 1)
        row.end = Math.max(row.end, rowIndex + 2)
        row.span = row.end - row.start
      }
    })

    return areas
  }, {})
}

// Parse grid-template

function testTrack(node) {
  return node.type === 'word' && /^\[.+]$/.test(node.value)
}

function verifyRowSize(result) {
  if (result.areas.length > result.rows.length) {
    result.rows.push('auto')
  }
  return result
}

exports.parseTemplate = parseTemplate

function parseTemplate({ decl, gap }) {
  let gridTemplate = parser(decl.value).nodes.reduce(
    (result, node) => {
      let { type, value } = node

      if (testTrack(node) || type === 'space') return result

      // area
      if (type === 'string') {
        result = verifyRowSize(result)
        result.areas.push(value)
      }

      // values and function
      if (type === 'word' || type === 'function') {
        result[result.key].push(parser.stringify(node))
      }

      // divider(/)
      if (type === 'div' && value === '/') {
        result.key = 'columns'
        result = verifyRowSize(result)
      }

      return result
    },
    {
      key: 'rows',
      columns: [],
      rows: [],
      areas: []
    }
  )

  return {
    areas: parseGridAreas({
      rows: gridTemplate.areas,
      gap
    }),
    columns: prefixTrackValue({
      value: gridTemplate.columns.join(' '),
      gap: gap.column
    }),
    rows: prefixTrackValue({
      value: gridTemplate.rows.join(' '),
      gap: gap.row
    })
  }
}

// Insert parsed grid areas

/**
 * Get an array of -ms- prefixed props and values
 * @param  {Object} [area] area object with column and row data
 * @param  {Boolean} [addRowSpan] should we add grid-column-row value?
 * @param  {Boolean} [addColumnSpan] should we add grid-column-span value?
 * @return {Array<Object>}
 */
function getMSDecls(area, addRowSpan = false, addColumnSpan = false) {
  let result = [
    {
      prop: '-ms-grid-row',
      value: String(area.row.start)
    }
  ]
  if (area.row.span > 1 || addRowSpan) {
    result.push({
      prop: '-ms-grid-row-span',
      value: String(area.row.span)
    })
  }
  result.push({
    prop: '-ms-grid-column',
    value: String(area.column.start)
  })
  if (area.column.span > 1 || addColumnSpan) {
    result.push({
      prop: '-ms-grid-column-span',
      value: String(area.column.span)
    })
  }
  return result
}

function getParentMedia(parent) {
  if (parent.type === 'atrule' && parent.name === 'media') {
    return parent
  }
  if (!parent.parent) {
    return false
  }
  return getParentMedia(parent.parent)
}

/**
 * change selectors for rules with duplicate grid-areas.
 * @param  {Array<Rule>} rules
 * @param  {Array<String>} templateSelectors
 * @return {Array<Rule>} rules with changed selectors
 */
function changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) {
  ruleSelectors = ruleSelectors.map(selector => {
    let selectorBySpace = list.space(selector)
    let selectorByComma = list.comma(selector)

    if (selectorBySpace.length > selectorByComma.length) {
      selector = selectorBySpace.slice(-1).join('')
    }
    return selector
  })

  return ruleSelectors.map(ruleSelector => {
    let newSelector = templateSelectors.map((tplSelector, index) => {
      let space = index === 0 ? '' : ' '
      return `${space}${tplSelector} > ${ruleSelector}`
    })

    return newSelector
  })
}

/**
 * check if selector of rules are equal
 * @param  {Rule} ruleA
 * @param  {Rule} ruleB
 * @return {Boolean}
 */
function selectorsEqual(ruleA, ruleB) {
  return ruleA.selectors.some(sel => {
    return ruleB.selectors.includes(sel)
  })
}

/**
 * Parse data from all grid-template(-areas) declarations
 * @param  {Root} css css root
 * @return {Object} parsed data
 */
function parseGridTemplatesData(css) {
  let parsed = []

  // we walk through every grid-template(-areas) declaration and store
  // data with the same area names inside the item
  css.walkDecls(/grid-template(-areas)?$/, d => {
    let rule = d.parent
    let media = getParentMedia(rule)
    let gap = getGridGap(d)
    let inheritedGap = inheritGridGap(d, gap)
    let { areas } = parseTemplate({ decl: d, gap: inheritedGap || gap })
    let areaNames = Object.keys(areas)

    // skip node if it doesn't have areas
    if (areaNames.length === 0) {
      return true
    }

    // check parsed array for item that include the same area names
    // return index of that item
    let index = parsed.reduce((acc, { allAreas }, idx) => {
      let hasAreas = allAreas && areaNames.some(area => allAreas.includes(area))
      return hasAreas ? idx : acc
    }, null)

    if (index !== null) {
      // index is found, add the grid-template data to that item
      let { allAreas, rules } = parsed[index]

      // check if rule has no duplicate area names
      let hasNoDuplicates = rules.some(r => {
        return r.hasDuplicates === false && selectorsEqual(r, rule)
      })

      let duplicatesFound = false

      // check need to gather all duplicate area names
      let duplicateAreaNames = rules.reduce((acc, r) => {
        if (!r.params && selectorsEqual(r, rule)) {
          duplicatesFound = true
          return r.duplicateAreaNames
        }
        if (!duplicatesFound) {
          areaNames.forEach(name => {
            if (r.areas[name]) {
              acc.push(name)
            }
          })
        }
        return uniq(acc)
      }, [])

      // update grid-row/column-span values for areas with duplicate
      // area names. @see #1084 and #1146
      rules.forEach(r => {
        areaNames.forEach(name => {
          let area = r.areas[name]
          if (area && area.row.span !== areas[name].row.span) {
            areas[name].row.updateSpan = true
          }

          if (area && area.column.span !== areas[name].column.span) {
            areas[name].column.updateSpan = true
          }
        })
      })

      parsed[index].allAreas = uniq([...allAreas, ...areaNames])
      parsed[index].rules.push({
        hasDuplicates: !hasNoDuplicates,
        params: media.params,
        selectors: rule.selectors,
        node: rule,
        duplicateAreaNames,
        areas
      })
    } else {
      // index is NOT found, push the new item to the parsed array
      parsed.push({
        allAreas: areaNames,
        areasCount: 0,
        rules: [
          {
            hasDuplicates: false,
            duplicateRules: [],
            params: media.params,
            selectors: rule.selectors,
            node: rule,
            duplicateAreaNames: [],
            areas
          }
        ]
      })
    }

    return undefined
  })

  return parsed
}

/**
 * insert prefixed grid-area declarations
 * @param  {Root}  css css root
 * @param  {Function} isDisabled check if the rule is disabled
 * @return {void}
 */
exports.insertAreas = insertAreas

function insertAreas(css, isDisabled) {
  // parse grid-template declarations
  let gridTemplatesData = parseGridTemplatesData(css)

  // return undefined if no declarations found
  if (gridTemplatesData.length === 0) {
    return undefined
  }

  // we need to store the rules that we will insert later
  let rulesToInsert = {}

  css.walkDecls('grid-area', gridArea => {
    let gridAreaRule = gridArea.parent
    let hasPrefixedRow = gridAreaRule.first.prop === '-ms-grid-row'
    let gridAreaMedia = getParentMedia(gridAreaRule)

    if (isDisabled(gridArea)) {
      return undefined
    }

    let gridAreaRuleIndex = css.index(gridAreaMedia || gridAreaRule)

    let value = gridArea.value
    // found the data that matches grid-area identifier
    let data = gridTemplatesData.filter(d => d.allAreas.includes(value))[0]

    if (!data) {
      return true
    }

    let lastArea = data.allAreas[data.allAreas.length - 1]
    let selectorBySpace = list.space(gridAreaRule.selector)
    let selectorByComma = list.comma(gridAreaRule.selector)
    let selectorIsComplex =
      selectorBySpace.length > 1 &&
      selectorBySpace.length > selectorByComma.length

    // prevent doubling of prefixes
    if (hasPrefixedRow) {
      return false
    }

    // create the empty object with the key as the last area name
    // e.g if we have templates with "a b c" values, "c" will be the last area
    if (!rulesToInsert[lastArea]) {
      rulesToInsert[lastArea] = {}
    }

    let lastRuleIsSet = false

    // walk through every grid-template rule data
    for (let rule of data.rules) {
      let area = rule.areas[value]
      let hasDuplicateName = rule.duplicateAreaNames.includes(value)

      // if we can't find the area name, update lastRule and continue
      if (!area) {
        let lastRule = rulesToInsert[lastArea].lastRule
        let lastRuleIndex
        if (lastRule) {
          lastRuleIndex = css.index(lastRule)
        } else {
          /* c8 ignore next 2 */
          lastRuleIndex = -1
        }

        if (gridAreaRuleIndex > lastRuleIndex) {
          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule
        }
        continue
      }

      // for grid-templates inside media rule we need to create empty
      // array to push prefixed grid-area rules later
      if (rule.params && !rulesToInsert[lastArea][rule.params]) {
        rulesToInsert[lastArea][rule.params] = []
      }

      if ((!rule.hasDuplicates || !hasDuplicateName) && !rule.params) {
        // grid-template has no duplicates and not inside media rule

        getMSDecls(area, false, false)
          .reverse()
          .forEach(i =>
            gridAreaRule.prepend(
              Object.assign(i, {
                raws: {
                  between: gridArea.raws.between
                }
              })
            )
          )

        rulesToInsert[lastArea].lastRule = gridAreaRule
        lastRuleIsSet = true
      } else if (rule.hasDuplicates && !rule.params && !selectorIsComplex) {
        // grid-template has duplicates and not inside media rule
        let cloned = gridAreaRule.clone()
        cloned.removeAll()

        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)
          .reverse()
          .forEach(i =>
            cloned.prepend(
              Object.assign(i, {
                raws: {
                  between: gridArea.raws.between
                }
              })
            )
          )

        cloned.selectors = changeDuplicateAreaSelectors(
          cloned.selectors,
          rule.selectors
        )

        if (rulesToInsert[lastArea].lastRule) {
          rulesToInsert[lastArea].lastRule.after(cloned)
        }
        rulesToInsert[lastArea].lastRule = cloned
        lastRuleIsSet = true
      } else if (
        rule.hasDuplicates &&
        !rule.params &&
        selectorIsComplex &&
        gridAreaRule.selector.includes(rule.selectors[0])
      ) {
        // grid-template has duplicates and not inside media rule
        // and the selector is complex
        gridAreaRule.walkDecls(/-ms-grid-(row|column)/, d => d.remove())
        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)
          .reverse()
          .forEach(i =>
            gridAreaRule.prepend(
              Object.assign(i, {
                raws: {
                  between: gridArea.raws.between
                }
              })
            )
          )
      } else if (rule.params) {
        // grid-template is inside media rule
        // if we're inside media rule, we need to store prefixed rules
        // inside rulesToInsert object to be able to preserve the order of media
        // rules and merge them easily
        let cloned = gridAreaRule.clone()
        cloned.removeAll()

        getMSDecls(area, area.row.updateSpan, area.column.updateSpan)
          .reverse()
          .forEach(i =>
            cloned.prepend(
              Object.assign(i, {
                raws: {
                  between: gridArea.raws.between
                }
              })
            )
          )

        if (rule.hasDuplicates && hasDuplicateName) {
          cloned.selectors = changeDuplicateAreaSelectors(
            cloned.selectors,
            rule.selectors
          )
        }

        cloned.raws = rule.node.raws

        if (css.index(rule.node.parent) > gridAreaRuleIndex) {
          // append the prefixed rules right inside media rule
          // with grid-template
          rule.node.parent.append(cloned)
        } else {
          // store the rule to insert later
          rulesToInsert[lastArea][rule.params].push(cloned)
        }

        // set new rule as last rule ONLY if we didn't set lastRule for
        // this grid-area before
        if (!lastRuleIsSet) {
          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule
        }
      }
    }

    return undefined
  })

  // append stored rules inside the media rules
  Object.keys(rulesToInsert).forEach(area => {
    let data = rulesToInsert[area]
    let lastRule = data.lastRule
    Object.keys(data)
      .reverse()
      .filter(p => p !== 'lastRule')
      .forEach(params => {
        if (data[params].length > 0 && lastRule) {
          lastRule.after({ name: 'media', params })
          lastRule.next().append(data[params])
        }
      })
  })

  return undefined
}

/**
 * Warn user if grid area identifiers are not found
 * @param  {Object} areas
 * @param  {Declaration} decl
 * @param  {Result} result
 * @return {void}
 */
exports.warnMissedAreas = warnMissedAreas

function warnMissedAreas(areas, decl, result) {
  let missed = Object.keys(areas)

  decl.root().walkDecls('grid-area', gridArea => {
    missed = missed.filter(e => e !== gridArea.value)
  })

  if (missed.length > 0) {
    decl.warn(result, 'Can not find grid areas: ' + missed.join(', '))
  }

  return undefined
}

/**
 * compare selectors with grid-area rule and grid-template rule
 * show warning if grid-template selector is not found
 * (this function used for grid-area rule)
 * @param  {Declaration} decl
 * @param  {Result} result
 * @return {void}
 */
exports.warnTemplateSelectorNotFound = warnTemplateSelectorNotFound

function warnTemplateSelectorNotFound(decl, result) {
  let rule = decl.parent
  let root = decl.root()
  let duplicatesFound = false

  // slice selector array. Remove the last part (for comparison)
  let slicedSelectorArr = list
    .space(rule.selector)
    .filter(str => str !== '>')
    .slice(0, -1)

  // we need to compare only if selector is complex.
  // e.g '.grid-cell' is simple, but '.parent > .grid-cell' is complex
  if (slicedSelectorArr.length > 0) {
    let gridTemplateFound = false
    let foundAreaSelector = null

    root.walkDecls(/grid-template(-areas)?$/, d => {
      let parent = d.parent
      let templateSelectors = parent.selectors

      let { areas } = parseTemplate({ decl: d, gap: getGridGap(d) })
      let hasArea = areas[decl.value]

      // find the the matching selectors
      for (let tplSelector of templateSelectors) {
        if (gridTemplateFound) {
          break
        }
        let tplSelectorArr = list.space(tplSelector).filter(str => str !== '>')

        gridTemplateFound = tplSelectorArr.every(
          (item, idx) => item === slicedSelectorArr[idx]
        )
      }

      if (gridTemplateFound || !hasArea) {
        return true
      }

      if (!foundAreaSelector) {
        foundAreaSelector = parent.selector
      }

      // if we found the duplicate area with different selector
      if (foundAreaSelector && foundAreaSelector !== parent.selector) {
        duplicatesFound = true
      }

      return undefined
    })

    // warn user if we didn't find template
    if (!gridTemplateFound && duplicatesFound) {
      decl.warn(
        result,
        'Autoprefixer cannot find a grid-template ' +
          `containing the duplicate grid-area "${decl.value}" ` +
          `with full selector matching: ${slicedSelectorArr.join(' ')}`
      )
    }
  }
}

/**
 * warn user if both grid-area and grid-(row|column)
 * declarations are present in the same rule
 * @param  {Declaration} decl
 * @param  {Result} result
 * @return {void}
 */
exports.warnIfGridRowColumnExists = warnIfGridRowColumnExists

function warnIfGridRowColumnExists(decl, result) {
  let rule = decl.parent
  let decls = []
  rule.walkDecls(/^grid-(row|column)/, d => {
    if (
      !d.prop.endsWith('-end') &&
      !d.value.startsWith('span') &&
      !d.prop.endsWith('-gap')
    ) {
      decls.push(d)
    }
  })
  if (decls.length > 0) {
    decls.forEach(d => {
      d.warn(
        result,
        'You already have a grid-area declaration present in the rule. ' +
          `You should use either grid-area or ${d.prop}, not both`
      )
    })
  }

  return undefined
}

// Gap utils

exports.getGridGap = getGridGap

function getGridGap(decl) {
  let gap = {}

  // try to find gap
  let testGap = /^(grid-)?((row|column)-)?gap$/
  decl.parent.walkDecls(testGap, ({ prop, value }) => {
    if (/^(grid-)?gap$/.test(prop)) {
      let [row, , column] = parser(value).nodes

      gap.row = row && parser.stringify(row)
      gap.column = column ? parser.stringify(column) : gap.row
    }
    if (/^(grid-)?row-gap$/.test(prop)) gap.row = value
    if (/^(grid-)?column-gap$/.test(prop)) gap.column = value
  })

  return gap
}

/**
 * parse media parameters (for example 'min-width: 500px')
 * @param  {String} params parameter to parse
 * @return {}
 */
function parseMediaParams(params) {
  if (!params) {
    return []
  }
  let parsed = parser(params)
  let prop
  let value

  parsed.walk(node => {
    if (node.type === 'word' && /min|max/g.test(node.value)) {
      prop = node.value
    } else if (node.value.includes('px')) {
      value = parseInt(node.value.replace(/\D/g, ''))
    }
  })

  return [prop, value]
}

/**
 * Compare the selectors and decide if we
 * need to inherit gap from compared selector or not.
 * @type {String} selA
 * @type {String} selB
 * @return {Boolean}
 */
function shouldInheritGap(selA, selB) {
  let result

  // get arrays of selector split in 3-deep array
  let splitSelectorArrA = splitSelector(selA)
  let splitSelectorArrB = splitSelector(selB)

  if (splitSelectorArrA[0].length < splitSelectorArrB[0].length) {
    // abort if selectorA has lower descendant specificity then selectorB
    // (e.g '.grid' and '.hello .world .grid')
    return false
  } else if (splitSelectorArrA[0].length > splitSelectorArrB[0].length) {
    // if selectorA has higher descendant specificity then selectorB
    // (e.g '.foo .bar .grid' and '.grid')

    let idx = splitSelectorArrA[0].reduce((res, [item], index) => {
      let firstSelectorPart = splitSelectorArrB[0][0][0]
      if (item === firstSelectorPart) {
        return index
      }
      return false
    }, false)

    if (idx) {
      result = splitSelectorArrB[0].every((arr, index) => {
        return arr.every(
          (part, innerIndex) =>
            // because selectorA has more space elements, we need to slice
            // selectorA array by 'idx' number to compare them
            splitSelectorArrA[0].slice(idx)[index][innerIndex] === part
        )
      })
    }
  } else {
    // if selectorA has the same descendant specificity as selectorB
    // this condition covers cases such as: '.grid.foo.bar' and '.grid'
    result = splitSelectorArrB.some(byCommaArr => {
      return byCommaArr.every((bySpaceArr, index) => {
        return bySpaceArr.every(
          (part, innerIndex) => splitSelectorArrA[0][index][innerIndex] === part
        )
      })
    })
  }

  return result
}
/**
 * inherit grid gap values from the closest rule above
 * with the same selector
 * @param  {Declaration} decl
 * @param  {Object} gap gap values
 * @return {Object | Boolean} return gap values or false (if not found)
 */
exports.inheritGridGap = inheritGridGap

function inheritGridGap(decl, gap) {
  let rule = decl.parent
  let mediaRule = getParentMedia(rule)
  let root = rule.root()

  // get an array of selector split in 3-deep array
  let splitSelectorArr = splitSelector(rule.selector)

  // abort if the rule already has gaps
  if (Object.keys(gap).length > 0) {
    return false
  }

  // e.g ['min-width']
  let [prop] = parseMediaParams(mediaRule.params)

  let lastBySpace = splitSelectorArr[0]

  // get escaped value from the selector
  // if we have '.grid-2.foo.bar' selector, will be '\.grid\-2'
  let escaped = escapeRegexp(lastBySpace[lastBySpace.length - 1][0])

  let regexp = new RegExp(`(${escaped}$)|(${escaped}[,.])`)

  // find the closest rule with the same selector
  let closestRuleGap
  root.walkRules(regexp, r => {
    let gridGap

    // abort if are checking the same rule
    if (rule.toString() === r.toString()) {
      return false
    }

    // find grid-gap values
    r.walkDecls('grid-gap', d => (gridGap = getGridGap(d)))

    // skip rule without gaps
    if (!gridGap || Object.keys(gridGap).length === 0) {
      return true
    }

    // skip rules that should not be inherited from
    if (!shouldInheritGap(rule.selector, r.selector)) {
      return true
    }

    let media = getParentMedia(r)
    if (media) {
      // if we are inside media, we need to check that media props match
      // e.g ('min-width' === 'min-width')
      let propToCompare = parseMediaParams(media.params)[0]
      if (propToCompare === prop) {
        closestRuleGap = gridGap
        return true
      }
    } else {
      closestRuleGap = gridGap
      return true
    }

    return undefined
  })

  // if we find the closest gap object
  if (closestRuleGap && Object.keys(closestRuleGap).length > 0) {
    return closestRuleGap
  }
  return false
}

exports.warnGridGap = warnGridGap

function warnGridGap({ gap, hasColumns, decl, result }) {
  let hasBothGaps = gap.row && gap.column
  if (!hasColumns && (hasBothGaps || (gap.column && !gap.row))) {
    delete gap.column
    decl.warn(
      result,
      'Can not implement grid-gap without grid-template-columns'
    )
  }
}

/**
 * normalize the grid-template-rows/columns values
 * @param  {String} str grid-template-rows/columns value
 * @return {Array} normalized array with values
 * @example
 * let normalized = normalizeRowColumn('1fr repeat(2, 20px 50px) 1fr')
 * normalized // <= ['1fr', '20px', '50px', '20px', '50px', '1fr']
 */
function normalizeRowColumn(str) {
  let normalized = parser(str).nodes.reduce((result, node) => {
    if (node.type === 'function' && node.value === 'repeat') {
      let key = 'count'

      let [count, value] = node.nodes.reduce(
        (acc, n) => {
          if (n.type === 'word' && key === 'count') {
            acc[0] = Math.abs(parseInt(n.value))
            return acc
          }
          if (n.type === 'div' && n.value === ',') {
            key = 'value'
            return acc
          }
          if (key === 'value') {
            acc[1] += parser.stringify(n)
          }
          return acc
        },
        [0, '']
      )

      if (count) {
        for (let i = 0; i < count; i++) {
          result.push(value)
        }
      }

      return result
    }
    if (node.type === 'space') {
      return result
    }
    return result.concat(parser.stringify(node))
  }, [])

  return normalized
}

exports.autoplaceGridItems = autoplaceGridItems

/**
 * Autoplace grid items
 * @param {Declaration} decl
 * @param {Result} result
 * @param {Object} gap gap values
 * @param {String} autoflowValue grid-auto-flow value
 * @return {void}
 * @see https://github.com/postcss/autoprefixer/issues/1148
 */
function autoplaceGridItems(decl, result, gap, autoflowValue = 'row') {
  let { parent } = decl

  let rowDecl = parent.nodes.find(i => i.prop === 'grid-template-rows')
  let rows = normalizeRowColumn(rowDecl.value)
  let columns = normalizeRowColumn(decl.value)

  // Build array of area names with dummy values. If we have 3 columns and
  // 2 rows, filledRows will be equal to ['1 2 3', '4 5 6']
  let filledRows = rows.map((_, rowIndex) => {
    return Array.from(
      { length: columns.length },
      (v, k) => k + rowIndex * columns.length + 1
    ).join(' ')
  })

  let areas = parseGridAreas({ rows: filledRows, gap })
  let keys = Object.keys(areas)
  let items = keys.map(i => areas[i])

  // Change the order of cells if grid-auto-flow value is 'column'
  if (autoflowValue.includes('column')) {
    items = items.sort((a, b) => a.column.start - b.column.start)
  }

  // Insert new rules
  items.reverse().forEach((item, index) => {
    let { column, row } = item
    let nodeSelector = parent.selectors
      .map(sel => sel + ` > *:nth-child(${keys.length - index})`)
      .join(', ')

    // create new rule
    let node = parent.clone().removeAll()

    // change rule selector
    node.selector = nodeSelector

    // insert prefixed row/column values
    node.append({ prop: '-ms-grid-row', value: row.start })
    node.append({ prop: '-ms-grid-column', value: column.start })

    // insert rule
    parent.after(node)
  })

  return undefined
}


/***/ }),

/***/ 27453:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class ImageRendering extends Declaration {
  /**
   * Add hack only for crisp-edges
   */
  check(decl) {
    return decl.value === 'pixelated'
  }

  /**
   * Change property name for IE
   */
  prefixed(prop, prefix) {
    if (prefix === '-ms-') {
      return '-ms-interpolation-mode'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Change property and value for IE
   */
  set(decl, prefix) {
    if (prefix !== '-ms-') return super.set(decl, prefix)
    decl.prop = '-ms-interpolation-mode'
    decl.value = 'nearest-neighbor'
    return decl
  }

  /**
   * Return property name by spec
   */
  normalize() {
    return 'image-rendering'
  }

  /**
   * Warn on old value
   */
  process(node, result) {
    return super.process(node, result)
  }
}

ImageRendering.names = ['image-rendering', 'interpolation-mode']

module.exports = ImageRendering


/***/ }),

/***/ 93812:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Value = __nccwpck_require__(52530)

class ImageSet extends Value {
  /**
   * Use non-standard name for WebKit and Firefox
   */
  replace(string, prefix) {
    let fixed = super.replace(string, prefix)
    if (prefix === '-webkit-') {
      fixed = fixed.replace(/("[^"]+"|'[^']+')(\s+\d+\w)/gi, 'url($1)$2')
    }
    return fixed
  }
}

ImageSet.names = ['image-set']

module.exports = ImageSet


/***/ }),

/***/ 10330:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class InlineLogical extends Declaration {
  /**
   * Use old syntax for -moz- and -webkit-
   */
  prefixed(prop, prefix) {
    return prefix + prop.replace('-inline', '')
  }

  /**
   * Return property name by spec
   */
  normalize(prop) {
    return prop.replace(/(margin|padding|border)-(start|end)/, '$1-inline-$2')
  }
}

InlineLogical.names = [
  'border-inline-start',
  'border-inline-end',
  'margin-inline-start',
  'margin-inline-end',
  'padding-inline-start',
  'padding-inline-end',
  'border-start',
  'border-end',
  'margin-start',
  'margin-end',
  'padding-start',
  'padding-end'
]

module.exports = InlineLogical


/***/ }),

/***/ 10325:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let OldValue = __nccwpck_require__(86029)
let Value = __nccwpck_require__(52530)

function regexp(name) {
  return new RegExp(`(^|[\\s,(])(${name}($|[\\s),]))`, 'gi')
}

class Intrinsic extends Value {
  regexp() {
    if (!this.regexpCache) this.regexpCache = regexp(this.name)
    return this.regexpCache
  }

  isStretch() {
    return (
      this.name === 'stretch' ||
      this.name === 'fill' ||
      this.name === 'fill-available'
    )
  }

  replace(string, prefix) {
    if (prefix === '-moz-' && this.isStretch()) {
      return string.replace(this.regexp(), '$1-moz-available$3')
    }
    if (prefix === '-webkit-' && this.isStretch()) {
      return string.replace(this.regexp(), '$1-webkit-fill-available$3')
    }
    return super.replace(string, prefix)
  }

  old(prefix) {
    let prefixed = prefix + this.name
    if (this.isStretch()) {
      if (prefix === '-moz-') {
        prefixed = '-moz-available'
      } else if (prefix === '-webkit-') {
        prefixed = '-webkit-fill-available'
      }
    }
    return new OldValue(this.name, prefixed, prefixed, regexp(prefixed))
  }

  add(decl, prefix) {
    if (decl.prop.includes('grid') && prefix !== '-webkit-') {
      return undefined
    }
    return super.add(decl, prefix)
  }
}

Intrinsic.names = [
  'max-content',
  'min-content',
  'fit-content',
  'fill',
  'fill-available',
  'stretch'
]

module.exports = Intrinsic


/***/ }),

/***/ 82845:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class JustifyContent extends Declaration {
  /**
   * Change property name for 2009 and 2012 specs
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2009) {
      return prefix + 'box-pack'
    }
    if (spec === 2012) {
      return prefix + 'flex-pack'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Return property name by final spec
   */
  normalize() {
    return 'justify-content'
  }

  /**
   * Change value for 2009 and 2012 specs
   */
  set(decl, prefix) {
    let spec = flexSpec(prefix)[0]
    if (spec === 2009 || spec === 2012) {
      let value = JustifyContent.oldValues[decl.value] || decl.value
      decl.value = value
      if (spec !== 2009 || value !== 'distribute') {
        return super.set(decl, prefix)
      }
    } else if (spec === 'final') {
      return super.set(decl, prefix)
    }
    return undefined
  }
}

JustifyContent.names = ['justify-content', 'flex-pack', 'box-pack']

JustifyContent.oldValues = {
  'flex-end': 'end',
  'flex-start': 'start',
  'space-between': 'justify',
  'space-around': 'distribute'
}

module.exports = JustifyContent


/***/ }),

/***/ 28244:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class MaskBorder extends Declaration {
  /**
   * Return property name by final spec
   */
  normalize() {
    return this.name.replace('box-image', 'border')
  }

  /**
   * Return flex property for 2012 spec
   */
  prefixed(prop, prefix) {
    let result = super.prefixed(prop, prefix)
    if (prefix === '-webkit-') {
      result = result.replace('border', 'box-image')
    }
    return result
  }
}

MaskBorder.names = [
  'mask-border',
  'mask-border-source',
  'mask-border-slice',
  'mask-border-width',
  'mask-border-outset',
  'mask-border-repeat',
  'mask-box-image',
  'mask-box-image-source',
  'mask-box-image-slice',
  'mask-box-image-width',
  'mask-box-image-outset',
  'mask-box-image-repeat'
]

module.exports = MaskBorder


/***/ }),

/***/ 67491:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class MaskComposite extends Declaration {
  /**
   * Prefix mask-composite for webkit
   */
  insert(decl, prefix, prefixes) {
    let isCompositeProp = decl.prop === 'mask-composite'

    let compositeValues

    if (isCompositeProp) {
      compositeValues = decl.value.split(',')
    } else {
      compositeValues = decl.value.match(MaskComposite.regexp) || []
    }

    compositeValues = compositeValues.map(el => el.trim()).filter(el => el)
    let hasCompositeValues = compositeValues.length

    let compositeDecl

    if (hasCompositeValues) {
      compositeDecl = this.clone(decl)
      compositeDecl.value = compositeValues
        .map(value => MaskComposite.oldValues[value] || value)
        .join(', ')

      if (compositeValues.includes('intersect')) {
        compositeDecl.value += ', xor'
      }

      compositeDecl.prop = prefix + 'mask-composite'
    }

    if (isCompositeProp) {
      if (!hasCompositeValues) {
        return undefined
      }

      if (this.needCascade(decl)) {
        compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix)
      }

      return decl.parent.insertBefore(decl, compositeDecl)
    }

    let cloned = this.clone(decl)
    cloned.prop = prefix + cloned.prop

    if (hasCompositeValues) {
      cloned.value = cloned.value.replace(MaskComposite.regexp, '')
    }

    if (this.needCascade(decl)) {
      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)
    }

    decl.parent.insertBefore(decl, cloned)

    if (!hasCompositeValues) {
      return decl
    }

    if (this.needCascade(decl)) {
      compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix)
    }
    return decl.parent.insertBefore(decl, compositeDecl)
  }
}

MaskComposite.names = ['mask', 'mask-composite']

MaskComposite.oldValues = {
  add: 'source-over',
  subtract: 'source-out',
  intersect: 'source-in',
  exclude: 'xor'
}

MaskComposite.regexp = new RegExp(
  `\\s+(${Object.keys(MaskComposite.oldValues).join(
    '|'
  )})\\b(?!\\))\\s*(?=[,])`,
  'ig'
)

module.exports = MaskComposite


/***/ }),

/***/ 72844:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let flexSpec = __nccwpck_require__(43713)
let Declaration = __nccwpck_require__(69011)

class Order extends Declaration {
  /**
   * Change property name for 2009 and 2012 specs
   */
  prefixed(prop, prefix) {
    let spec
    ;[spec, prefix] = flexSpec(prefix)
    if (spec === 2009) {
      return prefix + 'box-ordinal-group'
    }
    if (spec === 2012) {
      return prefix + 'flex-order'
    }
    return super.prefixed(prop, prefix)
  }

  /**
   * Return property name by final spec
   */
  normalize() {
    return 'order'
  }

  /**
   * Fix value for 2009 spec
   */
  set(decl, prefix) {
    let spec = flexSpec(prefix)[0]
    if (spec === 2009 && /\d/.test(decl.value)) {
      decl.value = (parseInt(decl.value) + 1).toString()
      return super.set(decl, prefix)
    }
    return super.set(decl, prefix)
  }
}

Order.names = ['order', 'flex-order', 'box-ordinal-group']

module.exports = Order


/***/ }),

/***/ 27879:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class OverscrollBehavior extends Declaration {
  /**
   * Change property name for IE
   */
  prefixed(prop, prefix) {
    return prefix + 'scroll-chaining'
  }

  /**
   * Return property name by spec
   */
  normalize() {
    return 'overscroll-behavior'
  }

  /**
   * Change value for IE
   */
  set(decl, prefix) {
    if (decl.value === 'auto') {
      decl.value = 'chained'
    } else if (decl.value === 'none' || decl.value === 'contain') {
      decl.value = 'none'
    }
    return super.set(decl, prefix)
  }
}

OverscrollBehavior.names = ['overscroll-behavior', 'scroll-chaining']

module.exports = OverscrollBehavior


/***/ }),

/***/ 99683:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let OldValue = __nccwpck_require__(86029)
let Value = __nccwpck_require__(52530)

class Pixelated extends Value {
  /**
   * Use non-standard name for WebKit and Firefox
   */
  replace(string, prefix) {
    if (prefix === '-webkit-') {
      return string.replace(this.regexp(), '$1-webkit-optimize-contrast')
    }
    if (prefix === '-moz-') {
      return string.replace(this.regexp(), '$1-moz-crisp-edges')
    }
    return super.replace(string, prefix)
  }

  /**
   * Different name for WebKit and Firefox
   */
  old(prefix) {
    if (prefix === '-webkit-') {
      return new OldValue(this.name, '-webkit-optimize-contrast')
    }
    if (prefix === '-moz-') {
      return new OldValue(this.name, '-moz-crisp-edges')
    }
    return super.old(prefix)
  }
}

Pixelated.names = ['pixelated']

module.exports = Pixelated


/***/ }),

/***/ 99178:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)
let utils = __nccwpck_require__(73398)

class PlaceSelf extends Declaration {
  /**
   * Translate place-self to separate -ms- prefixed properties
   */
  insert(decl, prefix, prefixes) {
    if (prefix !== '-ms-') return super.insert(decl, prefix, prefixes)

    // prevent doubling of prefixes
    if (decl.parent.some(i => i.prop === '-ms-grid-row-align')) {
      return undefined
    }

    let [[first, second]] = utils.parse(decl)

    if (second) {
      utils.insertDecl(decl, 'grid-row-align', first)
      utils.insertDecl(decl, 'grid-column-align', second)
    } else {
      utils.insertDecl(decl, 'grid-row-align', first)
      utils.insertDecl(decl, 'grid-column-align', first)
    }

    return undefined
  }
}

PlaceSelf.names = ['place-self']

module.exports = PlaceSelf


/***/ }),

/***/ 69392:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Selector = __nccwpck_require__(52098)

class PlaceholderShown extends Selector {
  /**
   * Return different selectors depend on prefix
   */
  prefixed(prefix) {
    if (prefix === '-ms-') {
      return ':-ms-input-placeholder'
    }
    return `:${prefix}placeholder-shown`
  }
}

PlaceholderShown.names = [':placeholder-shown']

module.exports = PlaceholderShown


/***/ }),

/***/ 66470:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Selector = __nccwpck_require__(52098)

class Placeholder extends Selector {
  /**
   * Add old mozilla to possible prefixes
   */
  possible() {
    return super.possible().concat(['-moz- old', '-ms- old'])
  }

  /**
   * Return different selectors depend on prefix
   */
  prefixed(prefix) {
    if (prefix === '-webkit-') {
      return '::-webkit-input-placeholder'
    }
    if (prefix === '-ms-') {
      return '::-ms-input-placeholder'
    }
    if (prefix === '-ms- old') {
      return ':-ms-input-placeholder'
    }
    if (prefix === '-moz- old') {
      return ':-moz-placeholder'
    }
    return `::${prefix}placeholder`
  }
}

Placeholder.names = ['::placeholder']

module.exports = Placeholder


/***/ }),

/***/ 97899:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class PrintColorAdjust extends Declaration {
  /**
   * Change property name for WebKit-based browsers
   */
  prefixed(prop, prefix) {
    if (prefix === '-moz-') {
      return 'color-adjust'
    } else {
      return prefix + 'print-color-adjust'
    }
  }

  /**
   * Return property name by spec
   */
  normalize() {
    return 'print-color-adjust'
  }
}

PrintColorAdjust.names = ['print-color-adjust', 'color-adjust']

module.exports = PrintColorAdjust


/***/ }),

/***/ 12550:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class TextDecorationSkipInk extends Declaration {
  /**
   * Change prefix for ink value
   */
  set(decl, prefix) {
    if (decl.prop === 'text-decoration-skip-ink' && decl.value === 'auto') {
      decl.prop = prefix + 'text-decoration-skip'
      decl.value = 'ink'
      return decl
    } else {
      return super.set(decl, prefix)
    }
  }
}

TextDecorationSkipInk.names = [
  'text-decoration-skip-ink',
  'text-decoration-skip'
]

module.exports = TextDecorationSkipInk


/***/ }),

/***/ 43351:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

const BASIC = [
  'none',
  'underline',
  'overline',
  'line-through',
  'blink',
  'inherit',
  'initial',
  'unset'
]

class TextDecoration extends Declaration {
  /**
   * Do not add prefixes for basic values.
   */
  check(decl) {
    return decl.value.split(/\s+/).some(i => !BASIC.includes(i))
  }
}

TextDecoration.names = ['text-decoration']

module.exports = TextDecoration


/***/ }),

/***/ 60639:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class TextEmphasisPosition extends Declaration {
  set(decl, prefix) {
    if (prefix === '-webkit-') {
      decl.value = decl.value.replace(/\s*(right|left)\s*/i, '')
    }
    return super.set(decl, prefix)
  }
}

TextEmphasisPosition.names = ['text-emphasis-position']

module.exports = TextEmphasisPosition


/***/ }),

/***/ 2589:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class TransformDecl extends Declaration {
  /**
   * Recursively check all parents for @keyframes
   */
  keyframeParents(decl) {
    let { parent } = decl
    while (parent) {
      if (parent.type === 'atrule' && parent.name === 'keyframes') {
        return true
      }
      ;({ parent } = parent)
    }
    return false
  }

  /**
   * Is transform contain 3D commands
   */
  contain3d(decl) {
    if (decl.prop === 'transform-origin') {
      return false
    }

    for (let func of TransformDecl.functions3d) {
      if (decl.value.includes(`${func}(`)) {
        return true
      }
    }

    return false
  }

  /**
   * Replace rotateZ to rotate for IE 9
   */
  set(decl, prefix) {
    decl = super.set(decl, prefix)
    if (prefix === '-ms-') {
      decl.value = decl.value.replace(/rotatez/gi, 'rotate')
    }
    return decl
  }

  /**
   * Don't add prefix for IE in keyframes
   */
  insert(decl, prefix, prefixes) {
    if (prefix === '-ms-') {
      if (!this.contain3d(decl) && !this.keyframeParents(decl)) {
        return super.insert(decl, prefix, prefixes)
      }
    } else if (prefix === '-o-') {
      if (!this.contain3d(decl)) {
        return super.insert(decl, prefix, prefixes)
      }
    } else {
      return super.insert(decl, prefix, prefixes)
    }
    return undefined
  }
}

TransformDecl.names = ['transform', 'transform-origin']

TransformDecl.functions3d = [
  'matrix3d',
  'translate3d',
  'translateZ',
  'scale3d',
  'scaleZ',
  'rotate3d',
  'rotateX',
  'rotateY',
  'perspective'
]

module.exports = TransformDecl


/***/ }),

/***/ 60797:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class UserSelect extends Declaration {
  /**
   * Change prefixed value for IE
   */
  set(decl, prefix) {
    if (prefix === '-ms-' && decl.value === 'contain') {
      decl.value = 'element'
    }
    return super.set(decl, prefix)
  }

  /**
   * Avoid prefixing all in IE
   */
  insert(decl, prefix, prefixes) {
    if (decl.value === 'all' && prefix === '-ms-') {
      return undefined
    } else {
      return super.insert(decl, prefix, prefixes)
    }
  }
}

UserSelect.names = ['user-select']

module.exports = UserSelect


/***/ }),

/***/ 99051:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Declaration = __nccwpck_require__(69011)

class WritingMode extends Declaration {
  insert(decl, prefix, prefixes) {
    if (prefix === '-ms-') {
      let cloned = this.set(this.clone(decl), prefix)

      if (this.needCascade(decl)) {
        cloned.raws.before = this.calcBefore(prefixes, decl, prefix)
      }
      let direction = 'ltr'

      decl.parent.nodes.forEach(i => {
        if (i.prop === 'direction') {
          if (i.value === 'rtl' || i.value === 'ltr') direction = i.value
        }
      })

      cloned.value = WritingMode.msValues[direction][decl.value] || decl.value
      return decl.parent.insertBefore(decl, cloned)
    }

    return super.insert(decl, prefix, prefixes)
  }
}

WritingMode.names = ['writing-mode']

WritingMode.msValues = {
  ltr: {
    'horizontal-tb': 'lr-tb',
    'vertical-rl': 'tb-rl',
    'vertical-lr': 'tb-lr'
  },
  rtl: {
    'horizontal-tb': 'rl-tb',
    'vertical-rl': 'bt-rl',
    'vertical-lr': 'bt-lr'
  }
}

module.exports = WritingMode


/***/ }),

/***/ 83028:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let browserslist = __nccwpck_require__(55478)

function capitalize(str) {
  return str.slice(0, 1).toUpperCase() + str.slice(1)
}

const NAMES = {
  ie: 'IE',
  ie_mob: 'IE Mobile',
  ios_saf: 'iOS Safari',
  op_mini: 'Opera Mini',
  op_mob: 'Opera Mobile',
  and_chr: 'Chrome for Android',
  and_ff: 'Firefox for Android',
  and_uc: 'UC for Android',
  and_qq: 'QQ Browser',
  kaios: 'KaiOS Browser',
  baidu: 'Baidu Browser',
  samsung: 'Samsung Internet'
}

function prefix(name, prefixes, note) {
  let out = `  ${name}`
  if (note) out += ' *'
  out += ': '
  out += prefixes.map(i => i.replace(/^-(.*)-$/g, '$1')).join(', ')
  out += '\n'
  return out
}

module.exports = function (prefixes) {
  if (prefixes.browsers.selected.length === 0) {
    return 'No browsers selected'
  }

  let versions = {}
  for (let browser of prefixes.browsers.selected) {
    let parts = browser.split(' ')
    let name = parts[0]
    let version = parts[1]

    name = NAMES[name] || capitalize(name)
    if (versions[name]) {
      versions[name].push(version)
    } else {
      versions[name] = [version]
    }
  }

  let out = 'Browsers:\n'
  for (let browser in versions) {
    let list = versions[browser]
    list = list.sort((a, b) => parseFloat(b) - parseFloat(a))
    out += `  ${browser}: ${list.join(', ')}\n`
  }

  let coverage = browserslist.coverage(prefixes.browsers.selected)
  let round = Math.round(coverage * 100) / 100.0
  out += `\nThese browsers account for ${round}% of all users globally\n`

  let atrules = []
  for (let name in prefixes.add) {
    let data = prefixes.add[name]
    if (name[0] === '@' && data.prefixes) {
      atrules.push(prefix(name, data.prefixes))
    }
  }
  if (atrules.length > 0) {
    out += `\nAt-Rules:\n${atrules.sort().join('')}`
  }

  let selectors = []
  for (let selector of prefixes.add.selectors) {
    if (selector.prefixes) {
      selectors.push(prefix(selector.name, selector.prefixes))
    }
  }
  if (selectors.length > 0) {
    out += `\nSelectors:\n${selectors.sort().join('')}`
  }

  let values = []
  let props = []
  let hadGrid = false
  for (let name in prefixes.add) {
    let data = prefixes.add[name]
    if (name[0] !== '@' && data.prefixes) {
      let grid = name.indexOf('grid-') === 0
      if (grid) hadGrid = true
      props.push(prefix(name, data.prefixes, grid))
    }

    if (!Array.isArray(data.values)) {
      continue
    }
    for (let value of data.values) {
      let grid = value.name.includes('grid')
      if (grid) hadGrid = true
      let string = prefix(value.name, value.prefixes, grid)
      if (!values.includes(string)) {
        values.push(string)
      }
    }
  }

  if (props.length > 0) {
    out += `\nProperties:\n${props.sort().join('')}`
  }
  if (values.length > 0) {
    out += `\nValues:\n${values.sort().join('')}`
  }
  if (hadGrid) {
    out += '\n* - Prefixes will be added only on grid: true option.\n'
  }

  if (!atrules.length && !selectors.length && !props.length && !values.length) {
    out +=
      "\nAwesome! Your browsers don't require any vendor prefixes." +
      '\nNow you can remove Autoprefixer from build steps.'
  }

  return out
}


/***/ }),

/***/ 87964:
/***/ ((module) => {

class OldSelector {
  constructor(selector, prefix) {
    this.prefix = prefix
    this.prefixed = selector.prefixed(this.prefix)
    this.regexp = selector.regexp(this.prefix)

    this.prefixeds = selector
      .possible()
      .map(x => [selector.prefixed(x), selector.regexp(x)])

    this.unprefixed = selector.name
    this.nameRegexp = selector.regexp()
  }

  /**
   * Is rule a hack without unprefixed version bottom
   */
  isHack(rule) {
    let index = rule.parent.index(rule) + 1
    let rules = rule.parent.nodes

    while (index < rules.length) {
      let before = rules[index].selector
      if (!before) {
        return true
      }

      if (before.includes(this.unprefixed) && before.match(this.nameRegexp)) {
        return false
      }

      let some = false
      for (let [string, regexp] of this.prefixeds) {
        if (before.includes(string) && before.match(regexp)) {
          some = true
          break
        }
      }

      if (!some) {
        return true
      }

      index += 1
    }

    return true
  }

  /**
   * Does rule contain an unnecessary prefixed selector
   */
  check(rule) {
    if (!rule.selector.includes(this.prefixed)) {
      return false
    }
    if (!rule.selector.match(this.regexp)) {
      return false
    }
    if (this.isHack(rule)) {
      return false
    }
    return true
  }
}

module.exports = OldSelector


/***/ }),

/***/ 86029:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let utils = __nccwpck_require__(96584)

class OldValue {
  constructor(unprefixed, prefixed, string, regexp) {
    this.unprefixed = unprefixed
    this.prefixed = prefixed
    this.string = string || prefixed
    this.regexp = regexp || utils.regexp(prefixed)
  }

  /**
   * Check, that value contain old value
   */
  check(value) {
    if (value.includes(this.string)) {
      return !!value.match(this.regexp)
    }
    return false
  }
}

module.exports = OldValue


/***/ }),

/***/ 26579:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Browsers = __nccwpck_require__(50931)
let vendor = __nccwpck_require__(62667)
let utils = __nccwpck_require__(96584)

/**
 * Recursively clone objects
 */
function clone(obj, parent) {
  let cloned = new obj.constructor()

  for (let i of Object.keys(obj || {})) {
    let value = obj[i]
    if (i === 'parent' && typeof value === 'object') {
      if (parent) {
        cloned[i] = parent
      }
    } else if (i === 'source' || i === null) {
      cloned[i] = value
    } else if (Array.isArray(value)) {
      cloned[i] = value.map(x => clone(x, cloned))
    } else if (
      i !== '_autoprefixerPrefix' &&
      i !== '_autoprefixerValues' &&
      i !== 'proxyCache'
    ) {
      if (typeof value === 'object' && value !== null) {
        value = clone(value, cloned)
      }
      cloned[i] = value
    }
  }

  return cloned
}

class Prefixer {
  /**
   * Add hack to selected names
   */
  static hack(klass) {
    if (!this.hacks) {
      this.hacks = {}
    }
    return klass.names.map(name => {
      this.hacks[name] = klass
      return this.hacks[name]
    })
  }

  /**
   * Load hacks for some names
   */
  static load(name, prefixes, all) {
    let Klass = this.hacks && this.hacks[name]
    if (Klass) {
      return new Klass(name, prefixes, all)
    } else {
      return new this(name, prefixes, all)
    }
  }

  /**
   * Clone node and clean autprefixer custom caches
   */
  static clone(node, overrides) {
    let cloned = clone(node)
    for (let name in overrides) {
      cloned[name] = overrides[name]
    }
    return cloned
  }

  constructor(name, prefixes, all) {
    this.prefixes = prefixes
    this.name = name
    this.all = all
  }

  /**
   * Find prefix in node parents
   */
  parentPrefix(node) {
    let prefix

    if (typeof node._autoprefixerPrefix !== 'undefined') {
      prefix = node._autoprefixerPrefix
    } else if (node.type === 'decl' && node.prop[0] === '-') {
      prefix = vendor.prefix(node.prop)
    } else if (node.type === 'root') {
      prefix = false
    } else if (
      node.type === 'rule' &&
      node.selector.includes(':-') &&
      /:(-\w+-)/.test(node.selector)
    ) {
      prefix = node.selector.match(/:(-\w+-)/)[1]
    } else if (node.type === 'atrule' && node.name[0] === '-') {
      prefix = vendor.prefix(node.name)
    } else {
      prefix = this.parentPrefix(node.parent)
    }

    if (!Browsers.prefixes().includes(prefix)) {
      prefix = false
    }

    node._autoprefixerPrefix = prefix

    return node._autoprefixerPrefix
  }

  /**
   * Clone node with prefixes
   */
  process(node, result) {
    if (!this.check(node)) {
      return undefined
    }

    let parent = this.parentPrefix(node)

    let prefixes = this.prefixes.filter(
      prefix => !parent || parent === utils.removeNote(prefix)
    )

    let added = []
    for (let prefix of prefixes) {
      if (this.add(node, prefix, added.concat([prefix]), result)) {
        added.push(prefix)
      }
    }

    return added
  }

  /**
   * Shortcut for Prefixer.clone
   */
  clone(node, overrides) {
    return Prefixer.clone(node, overrides)
  }
}

module.exports = Prefixer


/***/ }),

/***/ 25396:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let vendor = __nccwpck_require__(62667)
let Declaration = __nccwpck_require__(69011)
let Resolution = __nccwpck_require__(21675)
let Transition = __nccwpck_require__(20960)
let Processor = __nccwpck_require__(54108)
let Supports = __nccwpck_require__(56689)
let Browsers = __nccwpck_require__(50931)
let Selector = __nccwpck_require__(52098)
let AtRule = __nccwpck_require__(87170)
let Value = __nccwpck_require__(52530)
let utils = __nccwpck_require__(96584)
let hackFullscreen = __nccwpck_require__(55233)
let hackPlaceholder = __nccwpck_require__(66470)
let hackPlaceholderShown = __nccwpck_require__(69392)
let hackFileSelectorButton = __nccwpck_require__(35407)
let hackFlex = __nccwpck_require__(84190)
let hackOrder = __nccwpck_require__(72844)
let hackFilter = __nccwpck_require__(46437)
let hackGridEnd = __nccwpck_require__(6307)
let hackAnimation = __nccwpck_require__(57508)
let hackFlexFlow = __nccwpck_require__(99225)
let hackFlexGrow = __nccwpck_require__(11708)
let hackFlexWrap = __nccwpck_require__(44910)
let hackGridArea = __nccwpck_require__(85159)
let hackPlaceSelf = __nccwpck_require__(99178)
let hackGridStart = __nccwpck_require__(57526)
let hackAlignSelf = __nccwpck_require__(70119)
let hackAppearance = __nccwpck_require__(53397)
let hackFlexBasis = __nccwpck_require__(33962)
let hackMaskBorder = __nccwpck_require__(28244)
let hackMaskComposite = __nccwpck_require__(67491)
let hackAlignItems = __nccwpck_require__(92478)
let hackUserSelect = __nccwpck_require__(60797)
let hackFlexShrink = __nccwpck_require__(61945)
let hackBreakProps = __nccwpck_require__(26946)
let hackWritingMode = __nccwpck_require__(99051)
let hackBorderImage = __nccwpck_require__(92212)
let hackAlignContent = __nccwpck_require__(46788)
let hackBorderRadius = __nccwpck_require__(80189)
let hackBlockLogical = __nccwpck_require__(51447)
let hackGridTemplate = __nccwpck_require__(10304)
let hackInlineLogical = __nccwpck_require__(10330)
let hackGridRowAlign = __nccwpck_require__(85565)
let hackTransformDecl = __nccwpck_require__(2589)
let hackFlexDirection = __nccwpck_require__(58440)
let hackImageRendering = __nccwpck_require__(27453)
let hackBackdropFilter = __nccwpck_require__(46667)
let hackBackgroundClip = __nccwpck_require__(32781)
let hackTextDecoration = __nccwpck_require__(43351)
let hackJustifyContent = __nccwpck_require__(82845)
let hackBackgroundSize = __nccwpck_require__(17397)
let hackGridRowColumn = __nccwpck_require__(99417)
let hackGridRowsColumns = __nccwpck_require__(39572)
let hackGridColumnAlign = __nccwpck_require__(4621)
let hackPrintColorAdjust = __nccwpck_require__(97899)
let hackOverscrollBehavior = __nccwpck_require__(27879)
let hackGridTemplateAreas = __nccwpck_require__(10577)
let hackTextEmphasisPosition = __nccwpck_require__(60639)
let hackTextDecorationSkipInk = __nccwpck_require__(12550)
let hackGradient = __nccwpck_require__(29864)
let hackIntrinsic = __nccwpck_require__(10325)
let hackPixelated = __nccwpck_require__(99683)
let hackImageSet = __nccwpck_require__(93812)
let hackCrossFade = __nccwpck_require__(52315)
let hackDisplayFlex = __nccwpck_require__(69470)
let hackDisplayGrid = __nccwpck_require__(35643)
let hackFilterValue = __nccwpck_require__(56122)
let hackAutofill = __nccwpck_require__(31242)

Selector.hack(hackAutofill)
Selector.hack(hackFullscreen)
Selector.hack(hackPlaceholder)
Selector.hack(hackPlaceholderShown)
Selector.hack(hackFileSelectorButton)
Declaration.hack(hackFlex)
Declaration.hack(hackOrder)
Declaration.hack(hackFilter)
Declaration.hack(hackGridEnd)
Declaration.hack(hackAnimation)
Declaration.hack(hackFlexFlow)
Declaration.hack(hackFlexGrow)
Declaration.hack(hackFlexWrap)
Declaration.hack(hackGridArea)
Declaration.hack(hackPlaceSelf)
Declaration.hack(hackGridStart)
Declaration.hack(hackAlignSelf)
Declaration.hack(hackAppearance)
Declaration.hack(hackFlexBasis)
Declaration.hack(hackMaskBorder)
Declaration.hack(hackMaskComposite)
Declaration.hack(hackAlignItems)
Declaration.hack(hackUserSelect)
Declaration.hack(hackFlexShrink)
Declaration.hack(hackBreakProps)
Declaration.hack(hackWritingMode)
Declaration.hack(hackBorderImage)
Declaration.hack(hackAlignContent)
Declaration.hack(hackBorderRadius)
Declaration.hack(hackBlockLogical)
Declaration.hack(hackGridTemplate)
Declaration.hack(hackInlineLogical)
Declaration.hack(hackGridRowAlign)
Declaration.hack(hackTransformDecl)
Declaration.hack(hackFlexDirection)
Declaration.hack(hackImageRendering)
Declaration.hack(hackBackdropFilter)
Declaration.hack(hackBackgroundClip)
Declaration.hack(hackTextDecoration)
Declaration.hack(hackJustifyContent)
Declaration.hack(hackBackgroundSize)
Declaration.hack(hackGridRowColumn)
Declaration.hack(hackGridRowsColumns)
Declaration.hack(hackGridColumnAlign)
Declaration.hack(hackOverscrollBehavior)
Declaration.hack(hackGridTemplateAreas)
Declaration.hack(hackPrintColorAdjust)
Declaration.hack(hackTextEmphasisPosition)
Declaration.hack(hackTextDecorationSkipInk)
Value.hack(hackGradient)
Value.hack(hackIntrinsic)
Value.hack(hackPixelated)
Value.hack(hackImageSet)
Value.hack(hackCrossFade)
Value.hack(hackDisplayFlex)
Value.hack(hackDisplayGrid)
Value.hack(hackFilterValue)

let declsCache = new Map()

class Prefixes {
  constructor(data, browsers, options = {}) {
    this.data = data
    this.browsers = browsers
    this.options = options
    ;[this.add, this.remove] = this.preprocess(this.select(this.data))
    this.transition = new Transition(this)
    this.processor = new Processor(this)
  }

  /**
   * Return clone instance to remove all prefixes
   */
  cleaner() {
    if (this.cleanerCache) {
      return this.cleanerCache
    }

    if (this.browsers.selected.length) {
      let empty = new Browsers(this.browsers.data, [])
      this.cleanerCache = new Prefixes(this.data, empty, this.options)
    } else {
      return this
    }

    return this.cleanerCache
  }

  /**
   * Select prefixes from data, which is necessary for selected browsers
   */
  select(list) {
    let selected = { add: {}, remove: {} }

    for (let name in list) {
      let data = list[name]
      let add = data.browsers.map(i => {
        let params = i.split(' ')
        return {
          browser: `${params[0]} ${params[1]}`,
          note: params[2]
        }
      })

      let notes = add
        .filter(i => i.note)
        .map(i => `${this.browsers.prefix(i.browser)} ${i.note}`)
      notes = utils.uniq(notes)

      add = add
        .filter(i => this.browsers.isSelected(i.browser))
        .map(i => {
          let prefix = this.browsers.prefix(i.browser)
          if (i.note) {
            return `${prefix} ${i.note}`
          } else {
            return prefix
          }
        })
      add = this.sort(utils.uniq(add))

      if (this.options.flexbox === 'no-2009') {
        add = add.filter(i => !i.includes('2009'))
      }

      let all = data.browsers.map(i => this.browsers.prefix(i))
      if (data.mistakes) {
        all = all.concat(data.mistakes)
      }
      all = all.concat(notes)
      all = utils.uniq(all)

      if (add.length) {
        selected.add[name] = add
        if (add.length < all.length) {
          selected.remove[name] = all.filter(i => !add.includes(i))
        }
      } else {
        selected.remove[name] = all
      }
    }

    return selected
  }

  /**
   * Sort vendor prefixes
   */
  sort(prefixes) {
    return prefixes.sort((a, b) => {
      let aLength = utils.removeNote(a).length
      let bLength = utils.removeNote(b).length

      if (aLength === bLength) {
        return b.length - a.length
      } else {
        return bLength - aLength
      }
    })
  }

  /**
   * Cache prefixes data to fast CSS processing
   */
  preprocess(selected) {
    let add = {
      'selectors': [],
      '@supports': new Supports(Prefixes, this)
    }
    for (let name in selected.add) {
      let prefixes = selected.add[name]
      if (name === '@keyframes' || name === '@viewport') {
        add[name] = new AtRule(name, prefixes, this)
      } else if (name === '@resolution') {
        add[name] = new Resolution(name, prefixes, this)
      } else if (this.data[name].selector) {
        add.selectors.push(Selector.load(name, prefixes, this))
      } else {
        let props = this.data[name].props

        if (props) {
          let value = Value.load(name, prefixes, this)
          for (let prop of props) {
            if (!add[prop]) {
              add[prop] = { values: [] }
            }
            add[prop].values.push(value)
          }
        } else {
          let values = (add[name] && add[name].values) || []
          add[name] = Declaration.load(name, prefixes, this)
          add[name].values = values
        }
      }
    }

    let remove = { selectors: [] }
    for (let name in selected.remove) {
      let prefixes = selected.remove[name]
      if (this.data[name].selector) {
        let selector = Selector.load(name, prefixes)
        for (let prefix of prefixes) {
          remove.selectors.push(selector.old(prefix))
        }
      } else if (name === '@keyframes' || name === '@viewport') {
        for (let prefix of prefixes) {
          let prefixed = `@${prefix}${name.slice(1)}`
          remove[prefixed] = { remove: true }
        }
      } else if (name === '@resolution') {
        remove[name] = new Resolution(name, prefixes, this)
      } else {
        let props = this.data[name].props
        if (props) {
          let value = Value.load(name, [], this)
          for (let prefix of prefixes) {
            let old = value.old(prefix)
            if (old) {
              for (let prop of props) {
                if (!remove[prop]) {
                  remove[prop] = {}
                }
                if (!remove[prop].values) {
                  remove[prop].values = []
                }
                remove[prop].values.push(old)
              }
            }
          }
        } else {
          for (let p of prefixes) {
            let olds = this.decl(name).old(name, p)
            if (name === 'align-self') {
              let a = add[name] && add[name].prefixes
              if (a) {
                if (p === '-webkit- 2009' && a.includes('-webkit-')) {
                  continue
                } else if (p === '-webkit-' && a.includes('-webkit- 2009')) {
                  continue
                }
              }
            }
            for (let prefixed of olds) {
              if (!remove[prefixed]) {
                remove[prefixed] = {}
              }
              remove[prefixed].remove = true
            }
          }
        }
      }
    }

    return [add, remove]
  }

  /**
   * Declaration loader with caching
   */
  decl(prop) {
    if (!declsCache.has(prop)) {
      declsCache.set(prop, Declaration.load(prop))
    }

    return declsCache.get(prop)
  }

  /**
   * Return unprefixed version of property
   */
  unprefixed(prop) {
    let value = this.normalize(vendor.unprefixed(prop))
    if (value === 'flex-direction') {
      value = 'flex-flow'
    }
    return value
  }

  /**
   * Normalize prefix for remover
   */
  normalize(prop) {
    return this.decl(prop).normalize(prop)
  }

  /**
   * Return prefixed version of property
   */
  prefixed(prop, prefix) {
    prop = vendor.unprefixed(prop)
    return this.decl(prop).prefixed(prop, prefix)
  }

  /**
   * Return values, which must be prefixed in selected property
   */
  values(type, prop) {
    let data = this[type]

    let global = data['*'] && data['*'].values
    let values = data[prop] && data[prop].values

    if (global && values) {
      return utils.uniq(global.concat(values))
    } else {
      return global || values || []
    }
  }

  /**
   * Group declaration by unprefixed property to check them
   */
  group(decl) {
    let rule = decl.parent
    let index = rule.index(decl)
    let { length } = rule.nodes
    let unprefixed = this.unprefixed(decl.prop)

    let checker = (step, callback) => {
      index += step
      while (index >= 0 && index < length) {
        let other = rule.nodes[index]
        if (other.type === 'decl') {
          if (step === -1 && other.prop === unprefixed) {
            if (!Browsers.withPrefix(other.value)) {
              break
            }
          }

          if (this.unprefixed(other.prop) !== unprefixed) {
            break
          } else if (callback(other) === true) {
            return true
          }

          if (step === +1 && other.prop === unprefixed) {
            if (!Browsers.withPrefix(other.value)) {
              break
            }
          }
        }

        index += step
      }
      return false
    }

    return {
      up(callback) {
        return checker(-1, callback)
      },
      down(callback) {
        return checker(+1, callback)
      }
    }
  }
}

module.exports = Prefixes


/***/ }),

/***/ 54108:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let parser = __nccwpck_require__(19285)

let Value = __nccwpck_require__(52530)
let insertAreas = (__nccwpck_require__(73398).insertAreas)

const OLD_LINEAR = /(^|[^-])linear-gradient\(\s*(top|left|right|bottom)/i
const OLD_RADIAL = /(^|[^-])radial-gradient\(\s*\d+(\w*|%)\s+\d+(\w*|%)\s*,/i
const IGNORE_NEXT = /(!\s*)?autoprefixer:\s*ignore\s+next/i
const GRID_REGEX = /(!\s*)?autoprefixer\s*grid:\s*(on|off|(no-)?autoplace)/i

const SIZES = [
  'width',
  'height',
  'min-width',
  'max-width',
  'min-height',
  'max-height',
  'inline-size',
  'min-inline-size',
  'max-inline-size',
  'block-size',
  'min-block-size',
  'max-block-size'
]

function hasGridTemplate(decl) {
  return decl.parent.some(
    i => i.prop === 'grid-template' || i.prop === 'grid-template-areas'
  )
}

function hasRowsAndColumns(decl) {
  let hasRows = decl.parent.some(i => i.prop === 'grid-template-rows')
  let hasColumns = decl.parent.some(i => i.prop === 'grid-template-columns')
  return hasRows && hasColumns
}

class Processor {
  constructor(prefixes) {
    this.prefixes = prefixes
  }

  /**
   * Add necessary prefixes
   */
  add(css, result) {
    // At-rules
    let resolution = this.prefixes.add['@resolution']
    let keyframes = this.prefixes.add['@keyframes']
    let viewport = this.prefixes.add['@viewport']
    let supports = this.prefixes.add['@supports']

    css.walkAtRules(rule => {
      if (rule.name === 'keyframes') {
        if (!this.disabled(rule, result)) {
          return keyframes && keyframes.process(rule)
        }
      } else if (rule.name === 'viewport') {
        if (!this.disabled(rule, result)) {
          return viewport && viewport.process(rule)
        }
      } else if (rule.name === 'supports') {
        if (
          this.prefixes.options.supports !== false &&
          !this.disabled(rule, result)
        ) {
          return supports.process(rule)
        }
      } else if (rule.name === 'media' && rule.params.includes('-resolution')) {
        if (!this.disabled(rule, result)) {
          return resolution && resolution.process(rule)
        }
      }

      return undefined
    })

    // Selectors
    css.walkRules(rule => {
      if (this.disabled(rule, result)) return undefined

      return this.prefixes.add.selectors.map(selector => {
        return selector.process(rule, result)
      })
    })

    function insideGrid(decl) {
      return decl.parent.nodes.some(node => {
        if (node.type !== 'decl') return false
        let displayGrid =
          node.prop === 'display' && /(inline-)?grid/.test(node.value)
        let gridTemplate = node.prop.startsWith('grid-template')
        let gridGap = /^grid-([A-z]+-)?gap/.test(node.prop)
        return displayGrid || gridTemplate || gridGap
      })
    }
    function insideFlex(decl) {
      return decl.parent.some(node => {
        return node.prop === 'display' && /(inline-)?flex/.test(node.value)
      })
    }

    let gridPrefixes =
      this.gridStatus(css, result) &&
      this.prefixes.add['grid-area'] &&
      this.prefixes.add['grid-area'].prefixes

    css.walkDecls(decl => {
      if (this.disabledDecl(decl, result)) return undefined

      let parent = decl.parent
      let prop = decl.prop
      let value = decl.value

      if (prop === 'color-adjust') {
        if (parent.every(i => i.prop !== 'print-color-adjust')) {
          result.warn(
            'Replace color-adjust to print-color-adjust. ' +
              'The color-adjust shorthand is currently deprecated.',
            { node: decl }
          )
        }
      } else if (prop === 'grid-row-span') {
        result.warn(
          'grid-row-span is not part of final Grid Layout. Use grid-row.',
          { node: decl }
        )
        return undefined
      } else if (prop === 'grid-column-span') {
        result.warn(
          'grid-column-span is not part of final Grid Layout. Use grid-column.',
          { node: decl }
        )
        return undefined
      } else if (prop === 'display' && value === 'box') {
        result.warn(
          'You should write display: flex by final spec ' +
            'instead of display: box',
          { node: decl }
        )
        return undefined
      } else if (prop === 'text-emphasis-position') {
        if (value === 'under' || value === 'over') {
          result.warn(
            'You should use 2 values for text-emphasis-position ' +
              'For example, `under left` instead of just `under`.',
            { node: decl }
          )
        }
      } else if (
        /^(align|justify|place)-(items|content)$/.test(prop) &&
        insideFlex(decl)
      ) {
        if (value === 'start' || value === 'end') {
          result.warn(
            `${value} value has mixed support, consider using ` +
              `flex-${value} instead`,
            { node: decl }
          )
        }
      } else if (prop === 'text-decoration-skip' && value === 'ink') {
        result.warn(
          'Replace text-decoration-skip: ink to ' +
            'text-decoration-skip-ink: auto, because spec had been changed',
          { node: decl }
        )
      } else {
        if (gridPrefixes && this.gridStatus(decl, result)) {
          if (decl.value === 'subgrid') {
            result.warn('IE does not support subgrid', { node: decl })
          }
          if (/^(align|justify|place)-items$/.test(prop) && insideGrid(decl)) {
            let fixed = prop.replace('-items', '-self')
            result.warn(
              `IE does not support ${prop} on grid containers. ` +
                `Try using ${fixed} on child elements instead: ` +
                `${decl.parent.selector} > * { ${fixed}: ${decl.value} }`,
              { node: decl }
            )
          } else if (
            /^(align|justify|place)-content$/.test(prop) &&
            insideGrid(decl)
          ) {
            result.warn(`IE does not support ${decl.prop} on grid containers`, {
              node: decl
            })
          } else if (prop === 'display' && decl.value === 'contents') {
            result.warn(
              'Please do not use display: contents; ' +
                'if you have grid setting enabled',
              { node: decl }
            )
            return undefined
          } else if (decl.prop === 'grid-gap') {
            let status = this.gridStatus(decl, result)
            if (
              status === 'autoplace' &&
              !hasRowsAndColumns(decl) &&
              !hasGridTemplate(decl)
            ) {
              result.warn(
                'grid-gap only works if grid-template(-areas) is being ' +
                  'used or both rows and columns have been declared ' +
                  'and cells have not been manually ' +
                  'placed inside the explicit grid',
                { node: decl }
              )
            } else if (
              (status === true || status === 'no-autoplace') &&
              !hasGridTemplate(decl)
            ) {
              result.warn(
                'grid-gap only works if grid-template(-areas) is being used',
                { node: decl }
              )
            }
          } else if (prop === 'grid-auto-columns') {
            result.warn('grid-auto-columns is not supported by IE', {
              node: decl
            })
            return undefined
          } else if (prop === 'grid-auto-rows') {
            result.warn('grid-auto-rows is not supported by IE', { node: decl })
            return undefined
          } else if (prop === 'grid-auto-flow') {
            let hasRows = parent.some(i => i.prop === 'grid-template-rows')
            let hasCols = parent.some(i => i.prop === 'grid-template-columns')

            if (hasGridTemplate(decl)) {
              result.warn('grid-auto-flow is not supported by IE', {
                node: decl
              })
            } else if (value.includes('dense')) {
              result.warn('grid-auto-flow: dense is not supported by IE', {
                node: decl
              })
            } else if (!hasRows && !hasCols) {
              result.warn(
                'grid-auto-flow works only if grid-template-rows and ' +
                  'grid-template-columns are present in the same rule',
                { node: decl }
              )
            }
            return undefined
          } else if (value.includes('auto-fit')) {
            result.warn('auto-fit value is not supported by IE', {
              node: decl,
              word: 'auto-fit'
            })
            return undefined
          } else if (value.includes('auto-fill')) {
            result.warn('auto-fill value is not supported by IE', {
              node: decl,
              word: 'auto-fill'
            })
            return undefined
          } else if (prop.startsWith('grid-template') && value.includes('[')) {
            result.warn(
              'Autoprefixer currently does not support line names. ' +
                'Try using grid-template-areas instead.',
              { node: decl, word: '[' }
            )
          }
        }
        if (value.includes('radial-gradient')) {
          if (OLD_RADIAL.test(decl.value)) {
            result.warn(
              'Gradient has outdated direction syntax. ' +
                'New syntax is like `closest-side at 0 0` ' +
                'instead of `0 0, closest-side`.',
              { node: decl }
            )
          } else {
            let ast = parser(value)

            for (let i of ast.nodes) {
              if (i.type === 'function' && i.value === 'radial-gradient') {
                for (let word of i.nodes) {
                  if (word.type === 'word') {
                    if (word.value === 'cover') {
                      result.warn(
                        'Gradient has outdated direction syntax. ' +
                          'Replace `cover` to `farthest-corner`.',
                        { node: decl }
                      )
                    } else if (word.value === 'contain') {
                      result.warn(
                        'Gradient has outdated direction syntax. ' +
                          'Replace `contain` to `closest-side`.',
                        { node: decl }
                      )
                    }
                  }
                }
              }
            }
          }
        }
        if (value.includes('linear-gradient')) {
          if (OLD_LINEAR.test(value)) {
            result.warn(
              'Gradient has outdated direction syntax. ' +
                'New syntax is like `to left` instead of `right`.',
              { node: decl }
            )
          }
        }
      }

      if (SIZES.includes(decl.prop)) {
        if (!decl.value.includes('-fill-available')) {
          if (decl.value.includes('fill-available')) {
            result.warn(
              'Replace fill-available to stretch, ' +
                'because spec had been changed',
              { node: decl }
            )
          } else if (decl.value.includes('fill')) {
            let ast = parser(value)
            if (ast.nodes.some(i => i.type === 'word' && i.value === 'fill')) {
              result.warn(
                'Replace fill to stretch, because spec had been changed',
                { node: decl }
              )
            }
          }
        }
      }

      let prefixer

      if (decl.prop === 'transition' || decl.prop === 'transition-property') {
        // Transition
        return this.prefixes.transition.add(decl, result)
      } else if (decl.prop === 'align-self') {
        // align-self flexbox or grid
        let display = this.displayType(decl)
        if (display !== 'grid' && this.prefixes.options.flexbox !== false) {
          prefixer = this.prefixes.add['align-self']
          if (prefixer && prefixer.prefixes) {
            prefixer.process(decl)
          }
        }
        if (this.gridStatus(decl, result) !== false) {
          prefixer = this.prefixes.add['grid-row-align']
          if (prefixer && prefixer.prefixes) {
            return prefixer.process(decl, result)
          }
        }
      } else if (decl.prop === 'justify-self') {
        // justify-self flexbox or grid
        if (this.gridStatus(decl, result) !== false) {
          prefixer = this.prefixes.add['grid-column-align']
          if (prefixer && prefixer.prefixes) {
            return prefixer.process(decl, result)
          }
        }
      } else if (decl.prop === 'place-self') {
        prefixer = this.prefixes.add['place-self']
        if (
          prefixer &&
          prefixer.prefixes &&
          this.gridStatus(decl, result) !== false
        ) {
          return prefixer.process(decl, result)
        }
      } else {
        // Properties
        prefixer = this.prefixes.add[decl.prop]
        if (prefixer && prefixer.prefixes) {
          return prefixer.process(decl, result)
        }
      }

      return undefined
    })

    // Insert grid-area prefixes. We need to be able to store the different
    // rules as a data and hack API is not enough for this
    if (this.gridStatus(css, result)) {
      insertAreas(css, this.disabled)
    }

    // Values
    return css.walkDecls(decl => {
      if (this.disabledValue(decl, result)) return

      let unprefixed = this.prefixes.unprefixed(decl.prop)
      let list = this.prefixes.values('add', unprefixed)
      if (Array.isArray(list)) {
        for (let value of list) {
          if (value.process) value.process(decl, result)
        }
      }
      Value.save(this.prefixes, decl)
    })
  }

  /**
   * Remove unnecessary pefixes
   */
  remove(css, result) {
    // At-rules
    let resolution = this.prefixes.remove['@resolution']

    css.walkAtRules((rule, i) => {
      if (this.prefixes.remove[`@${rule.name}`]) {
        if (!this.disabled(rule, result)) {
          rule.parent.removeChild(i)
        }
      } else if (
        rule.name === 'media' &&
        rule.params.includes('-resolution') &&
        resolution
      ) {
        resolution.clean(rule)
      }
    })

    // Selectors
    for (let checker of this.prefixes.remove.selectors) {
      css.walkRules((rule, i) => {
        if (checker.check(rule)) {
          if (!this.disabled(rule, result)) {
            rule.parent.removeChild(i)
          }
        }
      })
    }

    return css.walkDecls((decl, i) => {
      if (this.disabled(decl, result)) return

      let rule = decl.parent
      let unprefixed = this.prefixes.unprefixed(decl.prop)

      // Transition
      if (decl.prop === 'transition' || decl.prop === 'transition-property') {
        this.prefixes.transition.remove(decl)
      }

      // Properties
      if (
        this.prefixes.remove[decl.prop] &&
        this.prefixes.remove[decl.prop].remove
      ) {
        let notHack = this.prefixes.group(decl).down(other => {
          return this.prefixes.normalize(other.prop) === unprefixed
        })

        if (unprefixed === 'flex-flow') {
          notHack = true
        }

        if (decl.prop === '-webkit-box-orient') {
          let hacks = { 'flex-direction': true, 'flex-flow': true }
          if (!decl.parent.some(j => hacks[j.prop])) return
        }

        if (notHack && !this.withHackValue(decl)) {
          if (decl.raw('before').includes('\n')) {
            this.reduceSpaces(decl)
          }
          rule.removeChild(i)
          return
        }
      }

      // Values
      for (let checker of this.prefixes.values('remove', unprefixed)) {
        if (!checker.check) continue
        if (!checker.check(decl.value)) continue

        unprefixed = checker.unprefixed
        let notHack = this.prefixes.group(decl).down(other => {
          return other.value.includes(unprefixed)
        })

        if (notHack) {
          rule.removeChild(i)
          return
        }
      }
    })
  }

  /**
   * Some rare old values, which is not in standard
   */
  withHackValue(decl) {
    return decl.prop === '-webkit-background-clip' && decl.value === 'text'
  }

  /**
   * Check for grid/flexbox options.
   */
  disabledValue(node, result) {
    if (this.gridStatus(node, result) === false && node.type === 'decl') {
      if (node.prop === 'display' && node.value.includes('grid')) {
        return true
      }
    }
    if (this.prefixes.options.flexbox === false && node.type === 'decl') {
      if (node.prop === 'display' && node.value.includes('flex')) {
        return true
      }
    }
    if (node.type === 'decl' && node.prop === 'content') {
      return true
    }

    return this.disabled(node, result)
  }

  /**
   * Check for grid/flexbox options.
   */
  disabledDecl(node, result) {
    if (this.gridStatus(node, result) === false && node.type === 'decl') {
      if (node.prop.includes('grid') || node.prop === 'justify-items') {
        return true
      }
    }
    if (this.prefixes.options.flexbox === false && node.type === 'decl') {
      let other = ['order', 'justify-content', 'align-items', 'align-content']
      if (node.prop.includes('flex') || other.includes(node.prop)) {
        return true
      }
    }

    return this.disabled(node, result)
  }

  /**
   * Check for control comment and global options
   */
  disabled(node, result) {
    if (!node) return false

    if (node._autoprefixerDisabled !== undefined) {
      return node._autoprefixerDisabled
    }

    if (node.parent) {
      let p = node.prev()
      if (p && p.type === 'comment' && IGNORE_NEXT.test(p.text)) {
        node._autoprefixerDisabled = true
        node._autoprefixerSelfDisabled = true
        return true
      }
    }

    let value = null
    if (node.nodes) {
      let status
      node.each(i => {
        if (i.type !== 'comment') return
        if (/(!\s*)?autoprefixer:\s*(off|on)/i.test(i.text)) {
          if (typeof status !== 'undefined') {
            result.warn(
              'Second Autoprefixer control comment ' +
                'was ignored. Autoprefixer applies control ' +
                'comment to whole block, not to next rules.',
              { node: i }
            )
          } else {
            status = /on/i.test(i.text)
          }
        }
      })

      if (status !== undefined) {
        value = !status
      }
    }
    if (!node.nodes || value === null) {
      if (node.parent) {
        let isParentDisabled = this.disabled(node.parent, result)
        if (node.parent._autoprefixerSelfDisabled === true) {
          value = false
        } else {
          value = isParentDisabled
        }
      } else {
        value = false
      }
    }
    node._autoprefixerDisabled = value
    return value
  }

  /**
   * Normalize spaces in cascade declaration group
   */
  reduceSpaces(decl) {
    let stop = false
    this.prefixes.group(decl).up(() => {
      stop = true
      return true
    })
    if (stop) {
      return
    }

    let parts = decl.raw('before').split('\n')
    let prevMin = parts[parts.length - 1].length
    let diff = false

    this.prefixes.group(decl).down(other => {
      parts = other.raw('before').split('\n')
      let last = parts.length - 1

      if (parts[last].length > prevMin) {
        if (diff === false) {
          diff = parts[last].length - prevMin
        }

        parts[last] = parts[last].slice(0, -diff)
        other.raws.before = parts.join('\n')
      }
    })
  }

  /**
   * Is it flebox or grid rule
   */
  displayType(decl) {
    for (let i of decl.parent.nodes) {
      if (i.prop !== 'display') {
        continue
      }

      if (i.value.includes('flex')) {
        return 'flex'
      }

      if (i.value.includes('grid')) {
        return 'grid'
      }
    }

    return false
  }

  /**
   * Set grid option via control comment
   */
  gridStatus(node, result) {
    if (!node) return false

    if (node._autoprefixerGridStatus !== undefined) {
      return node._autoprefixerGridStatus
    }

    let value = null
    if (node.nodes) {
      let status
      node.each(i => {
        if (i.type !== 'comment') return
        if (GRID_REGEX.test(i.text)) {
          let hasAutoplace = /:\s*autoplace/i.test(i.text)
          let noAutoplace = /no-autoplace/i.test(i.text)
          if (typeof status !== 'undefined') {
            result.warn(
              'Second Autoprefixer grid control comment was ' +
                'ignored. Autoprefixer applies control comments to the whole ' +
                'block, not to the next rules.',
              { node: i }
            )
          } else if (hasAutoplace) {
            status = 'autoplace'
          } else if (noAutoplace) {
            status = true
          } else {
            status = /on/i.test(i.text)
          }
        }
      })

      if (status !== undefined) {
        value = status
      }
    }

    if (node.type === 'atrule' && node.name === 'supports') {
      let params = node.params
      if (params.includes('grid') && params.includes('auto')) {
        value = false
      }
    }

    if (!node.nodes || value === null) {
      if (node.parent) {
        let isParentGrid = this.gridStatus(node.parent, result)
        if (node.parent._autoprefixerSelfDisabled === true) {
          value = false
        } else {
          value = isParentGrid
        }
      } else if (typeof this.prefixes.options.grid !== 'undefined') {
        value = this.prefixes.options.grid
      } else if (typeof process.env.AUTOPREFIXER_GRID !== 'undefined') {
        if (process.env.AUTOPREFIXER_GRID === 'autoplace') {
          value = 'autoplace'
        } else {
          value = true
        }
      } else {
        value = false
      }
    }

    node._autoprefixerGridStatus = value
    return value
  }
}

module.exports = Processor


/***/ }),

/***/ 21675:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let FractionJs = __nccwpck_require__(85729)

let Prefixer = __nccwpck_require__(26579)
let utils = __nccwpck_require__(96584)

const REGEXP = /(min|max)-resolution\s*:\s*\d*\.?\d+(dppx|dpcm|dpi|x)/gi
const SPLIT = /(min|max)-resolution(\s*:\s*)(\d*\.?\d+)(dppx|dpcm|dpi|x)/i

class Resolution extends Prefixer {
  /**
   * Return prefixed query name
   */
  prefixName(prefix, name) {
    if (prefix === '-moz-') {
      return name + '--moz-device-pixel-ratio'
    } else {
      return prefix + name + '-device-pixel-ratio'
    }
  }

  /**
   * Return prefixed query
   */
  prefixQuery(prefix, name, colon, value, units) {
    value = new FractionJs(value)

    // 1dpcm = 2.54dpi
    // 1dppx = 96dpi
    if (units === 'dpi') {
      value = value.div(96)
    } else if (units === 'dpcm') {
      value = value.mul(2.54).div(96)
    }
    value = value.simplify()

    if (prefix === '-o-') {
      value = value.n + '/' + value.d
    }
    return this.prefixName(prefix, name) + colon + value
  }

  /**
   * Remove prefixed queries
   */
  clean(rule) {
    if (!this.bad) {
      this.bad = []
      for (let prefix of this.prefixes) {
        this.bad.push(this.prefixName(prefix, 'min'))
        this.bad.push(this.prefixName(prefix, 'max'))
      }
    }

    rule.params = utils.editList(rule.params, queries => {
      return queries.filter(query => this.bad.every(i => !query.includes(i)))
    })
  }

  /**
   * Add prefixed queries
   */
  process(rule) {
    let parent = this.parentPrefix(rule)
    let prefixes = parent ? [parent] : this.prefixes

    rule.params = utils.editList(rule.params, (origin, prefixed) => {
      for (let query of origin) {
        if (
          !query.includes('min-resolution') &&
          !query.includes('max-resolution')
        ) {
          prefixed.push(query)
          continue
        }

        for (let prefix of prefixes) {
          let processed = query.replace(REGEXP, str => {
            let parts = str.match(SPLIT)
            return this.prefixQuery(
              prefix,
              parts[1],
              parts[2],
              parts[3],
              parts[4]
            )
          })
          prefixed.push(processed)
        }
        prefixed.push(query)
      }

      return utils.uniq(prefixed)
    })
  }
}

module.exports = Resolution


/***/ }),

/***/ 52098:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let { list } = __nccwpck_require__(77001)

let OldSelector = __nccwpck_require__(87964)
let Prefixer = __nccwpck_require__(26579)
let Browsers = __nccwpck_require__(50931)
let utils = __nccwpck_require__(96584)

class Selector extends Prefixer {
  constructor(name, prefixes, all) {
    super(name, prefixes, all)
    this.regexpCache = new Map()
  }

  /**
   * Is rule selectors need to be prefixed
   */
  check(rule) {
    if (rule.selector.includes(this.name)) {
      return !!rule.selector.match(this.regexp())
    }

    return false
  }

  /**
   * Return prefixed version of selector
   */
  prefixed(prefix) {
    return this.name.replace(/^(\W*)/, `$1${prefix}`)
  }

  /**
   * Lazy loadRegExp for name
   */
  regexp(prefix) {
    if (!this.regexpCache.has(prefix)) {
      let name = prefix ? this.prefixed(prefix) : this.name
      this.regexpCache.set(
        prefix,
        new RegExp(`(^|[^:"'=])${utils.escapeRegexp(name)}`, 'gi')
      )
    }

    return this.regexpCache.get(prefix)
  }

  /**
   * All possible prefixes
   */
  possible() {
    return Browsers.prefixes()
  }

  /**
   * Return all possible selector prefixes
   */
  prefixeds(rule) {
    if (rule._autoprefixerPrefixeds) {
      if (rule._autoprefixerPrefixeds[this.name]) {
        return rule._autoprefixerPrefixeds
      }
    } else {
      rule._autoprefixerPrefixeds = {}
    }

    let prefixeds = {}
    if (rule.selector.includes(',')) {
      let ruleParts = list.comma(rule.selector)
      let toProcess = ruleParts.filter(el => el.includes(this.name))

      for (let prefix of this.possible()) {
        prefixeds[prefix] = toProcess
          .map(el => this.replace(el, prefix))
          .join(', ')
      }
    } else {
      for (let prefix of this.possible()) {
        prefixeds[prefix] = this.replace(rule.selector, prefix)
      }
    }

    rule._autoprefixerPrefixeds[this.name] = prefixeds
    return rule._autoprefixerPrefixeds
  }

  /**
   * Is rule already prefixed before
   */
  already(rule, prefixeds, prefix) {
    let index = rule.parent.index(rule) - 1

    while (index >= 0) {
      let before = rule.parent.nodes[index]

      if (before.type !== 'rule') {
        return false
      }

      let some = false
      for (let key in prefixeds[this.name]) {
        let prefixed = prefixeds[this.name][key]
        if (before.selector === prefixed) {
          if (prefix === key) {
            return true
          } else {
            some = true
            break
          }
        }
      }
      if (!some) {
        return false
      }

      index -= 1
    }

    return false
  }

  /**
   * Replace selectors by prefixed one
   */
  replace(selector, prefix) {
    return selector.replace(this.regexp(), `$1${this.prefixed(prefix)}`)
  }

  /**
   * Clone and add prefixes for at-rule
   */
  add(rule, prefix) {
    let prefixeds = this.prefixeds(rule)

    if (this.already(rule, prefixeds, prefix)) {
      return
    }

    let cloned = this.clone(rule, { selector: prefixeds[this.name][prefix] })
    rule.parent.insertBefore(rule, cloned)
  }

  /**
   * Return function to fast find prefixed selector
   */
  old(prefix) {
    return new OldSelector(this, prefix)
  }
}

module.exports = Selector


/***/ }),

/***/ 56689:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let featureQueries = __nccwpck_require__(53231)
let { feature } = __nccwpck_require__(64006)
let { parse } = __nccwpck_require__(77001)

let Browsers = __nccwpck_require__(50931)
let brackets = __nccwpck_require__(59137)
let Value = __nccwpck_require__(52530)
let utils = __nccwpck_require__(96584)

let data = feature(featureQueries)

let supported = []
for (let browser in data.stats) {
  let versions = data.stats[browser]
  for (let version in versions) {
    let support = versions[version]
    if (/y/.test(support)) {
      supported.push(browser + ' ' + version)
    }
  }
}

class Supports {
  constructor(Prefixes, all) {
    this.Prefixes = Prefixes
    this.all = all
  }

  /**
   * Return prefixer only with @supports supported browsers
   */
  prefixer() {
    if (this.prefixerCache) {
      return this.prefixerCache
    }

    let filtered = this.all.browsers.selected.filter(i => {
      return supported.includes(i)
    })

    let browsers = new Browsers(
      this.all.browsers.data,
      filtered,
      this.all.options
    )
    this.prefixerCache = new this.Prefixes(
      this.all.data,
      browsers,
      this.all.options
    )
    return this.prefixerCache
  }

  /**
   * Parse string into declaration property and value
   */
  parse(str) {
    let parts = str.split(':')
    let prop = parts[0]
    let value = parts[1]
    if (!value) value = ''
    return [prop.trim(), value.trim()]
  }

  /**
   * Create virtual rule to process it by prefixer
   */
  virtual(str) {
    let [prop, value] = this.parse(str)
    let rule = parse('a{}').first
    rule.append({ prop, value, raws: { before: '' } })
    return rule
  }

  /**
   * Return array of Declaration with all necessary prefixes
   */
  prefixed(str) {
    let rule = this.virtual(str)
    if (this.disabled(rule.first)) {
      return rule.nodes
    }

    let result = { warn: () => null }

    let prefixer = this.prefixer().add[rule.first.prop]
    prefixer && prefixer.process && prefixer.process(rule.first, result)

    for (let decl of rule.nodes) {
      for (let value of this.prefixer().values('add', rule.first.prop)) {
        value.process(decl)
      }
      Value.save(this.all, decl)
    }

    return rule.nodes
  }

  /**
   * Return true if brackets node is "not" word
   */
  isNot(node) {
    return typeof node === 'string' && /not\s*/i.test(node)
  }

  /**
   * Return true if brackets node is "or" word
   */
  isOr(node) {
    return typeof node === 'string' && /\s*or\s*/i.test(node)
  }

  /**
   * Return true if brackets node is (prop: value)
   */
  isProp(node) {
    return (
      typeof node === 'object' &&
      node.length === 1 &&
      typeof node[0] === 'string'
    )
  }

  /**
   * Return true if prefixed property has no unprefixed
   */
  isHack(all, unprefixed) {
    let check = new RegExp(`(\\(|\\s)${utils.escapeRegexp(unprefixed)}:`)
    return !check.test(all)
  }

  /**
   * Return true if we need to remove node
   */
  toRemove(str, all) {
    let [prop, value] = this.parse(str)
    let unprefixed = this.all.unprefixed(prop)

    let cleaner = this.all.cleaner()

    if (
      cleaner.remove[prop] &&
      cleaner.remove[prop].remove &&
      !this.isHack(all, unprefixed)
    ) {
      return true
    }

    for (let checker of cleaner.values('remove', unprefixed)) {
      if (checker.check(value)) {
        return true
      }
    }

    return false
  }

  /**
   * Remove all unnecessary prefixes
   */
  remove(nodes, all) {
    let i = 0
    while (i < nodes.length) {
      if (
        !this.isNot(nodes[i - 1]) &&
        this.isProp(nodes[i]) &&
        this.isOr(nodes[i + 1])
      ) {
        if (this.toRemove(nodes[i][0], all)) {
          nodes.splice(i, 2)
          continue
        }

        i += 2
        continue
      }

      if (typeof nodes[i] === 'object') {
        nodes[i] = this.remove(nodes[i], all)
      }

      i += 1
    }
    return nodes
  }

  /**
   * Clean brackets with one child
   */
  cleanBrackets(nodes) {
    return nodes.map(i => {
      if (typeof i !== 'object') {
        return i
      }

      if (i.length === 1 && typeof i[0] === 'object') {
        return this.cleanBrackets(i[0])
      }

      return this.cleanBrackets(i)
    })
  }

  /**
   * Add " or " between properties and convert it to brackets format
   */
  convert(progress) {
    let result = ['']
    for (let i of progress) {
      result.push([`${i.prop}: ${i.value}`])
      result.push(' or ')
    }
    result[result.length - 1] = ''
    return result
  }

  /**
   * Compress value functions into a string nodes
   */
  normalize(nodes) {
    if (typeof nodes !== 'object') {
      return nodes
    }

    nodes = nodes.filter(i => i !== '')

    if (typeof nodes[0] === 'string') {
      let firstNode = nodes[0].trim()

      if (
        firstNode.includes(':') ||
        firstNode === 'selector' ||
        firstNode === 'not selector'
      ) {
        return [brackets.stringify(nodes)]
      }
    }
    return nodes.map(i => this.normalize(i))
  }

  /**
   * Add prefixes
   */
  add(nodes, all) {
    return nodes.map(i => {
      if (this.isProp(i)) {
        let prefixed = this.prefixed(i[0])
        if (prefixed.length > 1) {
          return this.convert(prefixed)
        }

        return i
      }

      if (typeof i === 'object') {
        return this.add(i, all)
      }

      return i
    })
  }

  /**
   * Add prefixed declaration
   */
  process(rule) {
    let ast = brackets.parse(rule.params)
    ast = this.normalize(ast)
    ast = this.remove(ast, rule.params)
    ast = this.add(ast, rule.params)
    ast = this.cleanBrackets(ast)
    rule.params = brackets.stringify(ast)
  }

  /**
   * Check global options
   */
  disabled(node) {
    if (!this.all.options.grid) {
      if (node.prop === 'display' && node.value.includes('grid')) {
        return true
      }
      if (node.prop.includes('grid') || node.prop === 'justify-items') {
        return true
      }
    }

    if (this.all.options.flexbox === false) {
      if (node.prop === 'display' && node.value.includes('flex')) {
        return true
      }
      let other = ['order', 'justify-content', 'align-items', 'align-content']
      if (node.prop.includes('flex') || other.includes(node.prop)) {
        return true
      }
    }

    return false
  }
}

module.exports = Supports


/***/ }),

/***/ 20960:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let { list } = __nccwpck_require__(77001)
let parser = __nccwpck_require__(19285)

let Browsers = __nccwpck_require__(50931)
let vendor = __nccwpck_require__(62667)

class Transition {
  constructor(prefixes) {
    this.props = ['transition', 'transition-property']
    this.prefixes = prefixes
  }

  /**
   * Process transition and add prefixes for all necessary properties
   */
  add(decl, result) {
    let prefix, prop
    let add = this.prefixes.add[decl.prop]
    let vendorPrefixes = this.ruleVendorPrefixes(decl)
    let declPrefixes = vendorPrefixes || (add && add.prefixes) || []

    let params = this.parse(decl.value)
    let names = params.map(i => this.findProp(i))
    let added = []

    if (names.some(i => i[0] === '-')) {
      return
    }

    for (let param of params) {
      prop = this.findProp(param)
      if (prop[0] === '-') continue

      let prefixer = this.prefixes.add[prop]
      if (!prefixer || !prefixer.prefixes) continue

      for (prefix of prefixer.prefixes) {
        if (vendorPrefixes && !vendorPrefixes.some(p => prefix.includes(p))) {
          continue
        }

        let prefixed = this.prefixes.prefixed(prop, prefix)
        if (prefixed !== '-ms-transform' && !names.includes(prefixed)) {
          if (!this.disabled(prop, prefix)) {
            added.push(this.clone(prop, prefixed, param))
          }
        }
      }
    }

    params = params.concat(added)
    let value = this.stringify(params)

    let webkitClean = this.stringify(
      this.cleanFromUnprefixed(params, '-webkit-')
    )
    if (declPrefixes.includes('-webkit-')) {
      this.cloneBefore(decl, `-webkit-${decl.prop}`, webkitClean)
    }
    this.cloneBefore(decl, decl.prop, webkitClean)
    if (declPrefixes.includes('-o-')) {
      let operaClean = this.stringify(this.cleanFromUnprefixed(params, '-o-'))
      this.cloneBefore(decl, `-o-${decl.prop}`, operaClean)
    }

    for (prefix of declPrefixes) {
      if (prefix !== '-webkit-' && prefix !== '-o-') {
        let prefixValue = this.stringify(
          this.cleanOtherPrefixes(params, prefix)
        )
        this.cloneBefore(decl, prefix + decl.prop, prefixValue)
      }
    }

    if (value !== decl.value && !this.already(decl, decl.prop, value)) {
      this.checkForWarning(result, decl)
      decl.cloneBefore()
      decl.value = value
    }
  }

  /**
   * Find property name
   */
  findProp(param) {
    let prop = param[0].value
    if (/^\d/.test(prop)) {
      for (let [i, token] of param.entries()) {
        if (i !== 0 && token.type === 'word') {
          return token.value
        }
      }
    }
    return prop
  }

  /**
   * Does we already have this declaration
   */
  already(decl, prop, value) {
    return decl.parent.some(i => i.prop === prop && i.value === value)
  }

  /**
   * Add declaration if it is not exist
   */
  cloneBefore(decl, prop, value) {
    if (!this.already(decl, prop, value)) {
      decl.cloneBefore({ prop, value })
    }
  }

  /**
   * Show transition-property warning
   */
  checkForWarning(result, decl) {
    if (decl.prop !== 'transition-property') {
      return
    }

    let isPrefixed = false
    let hasAssociatedProp = false

    decl.parent.each(i => {
      if (i.type !== 'decl') {
        return undefined
      }
      if (i.prop.indexOf('transition-') !== 0) {
        return undefined
      }
      let values = list.comma(i.value)
      // check if current Rule's transition-property comma separated value list needs prefixes
      if (i.prop === 'transition-property') {
        values.forEach(value => {
          let lookup = this.prefixes.add[value]
          if (lookup && lookup.prefixes && lookup.prefixes.length > 0) {
            isPrefixed = true
          }
        })
        return undefined
      }
      // check if another transition-* prop in current Rule has comma separated value list
      hasAssociatedProp = hasAssociatedProp || values.length > 1
      return false
    })

    if (isPrefixed && hasAssociatedProp) {
      decl.warn(
        result,
        'Replace transition-property to transition, ' +
          'because Autoprefixer could not support ' +
          'any cases of transition-property ' +
          'and other transition-*'
      )
    }
  }

  /**
   * Process transition and remove all unnecessary properties
   */
  remove(decl) {
    let params = this.parse(decl.value)
    params = params.filter(i => {
      let prop = this.prefixes.remove[this.findProp(i)]
      return !prop || !prop.remove
    })
    let value = this.stringify(params)

    if (decl.value === value) {
      return
    }

    if (params.length === 0) {
      decl.remove()
      return
    }

    let double = decl.parent.some(i => {
      return i.prop === decl.prop && i.value === value
    })
    let smaller = decl.parent.some(i => {
      return i !== decl && i.prop === decl.prop && i.value.length > value.length
    })

    if (double || smaller) {
      decl.remove()
      return
    }

    decl.value = value
  }

  /**
   * Parse properties list to array
   */
  parse(value) {
    let ast = parser(value)
    let result = []
    let param = []
    for (let node of ast.nodes) {
      param.push(node)
      if (node.type === 'div' && node.value === ',') {
        result.push(param)
        param = []
      }
    }
    result.push(param)
    return result.filter(i => i.length > 0)
  }

  /**
   * Return properties string from array
   */
  stringify(params) {
    if (params.length === 0) {
      return ''
    }
    let nodes = []
    for (let param of params) {
      if (param[param.length - 1].type !== 'div') {
        param.push(this.div(params))
      }
      nodes = nodes.concat(param)
    }
    if (nodes[0].type === 'div') {
      nodes = nodes.slice(1)
    }
    if (nodes[nodes.length - 1].type === 'div') {
      nodes = nodes.slice(0, +-2 + 1 || 0)
    }
    return parser.stringify({ nodes })
  }

  /**
   * Return new param array with different name
   */
  clone(origin, name, param) {
    let result = []
    let changed = false
    for (let i of param) {
      if (!changed && i.type === 'word' && i.value === origin) {
        result.push({ type: 'word', value: name })
        changed = true
      } else {
        result.push(i)
      }
    }
    return result
  }

  /**
   * Find or create separator
   */
  div(params) {
    for (let param of params) {
      for (let node of param) {
        if (node.type === 'div' && node.value === ',') {
          return node
        }
      }
    }
    return { type: 'div', value: ',', after: ' ' }
  }

  cleanOtherPrefixes(params, prefix) {
    return params.filter(param => {
      let current = vendor.prefix(this.findProp(param))
      return current === '' || current === prefix
    })
  }

  /**
   * Remove all non-webkit prefixes and unprefixed params if we have prefixed
   */
  cleanFromUnprefixed(params, prefix) {
    let remove = params
      .map(i => this.findProp(i))
      .filter(i => i.slice(0, prefix.length) === prefix)
      .map(i => this.prefixes.unprefixed(i))

    let result = []
    for (let param of params) {
      let prop = this.findProp(param)
      let p = vendor.prefix(prop)
      if (!remove.includes(prop) && (p === prefix || p === '')) {
        result.push(param)
      }
    }
    return result
  }

  /**
   * Check property for disabled by option
   */
  disabled(prop, prefix) {
    let other = ['order', 'justify-content', 'align-self', 'align-content']
    if (prop.includes('flex') || other.includes(prop)) {
      if (this.prefixes.options.flexbox === false) {
        return true
      }

      if (this.prefixes.options.flexbox === 'no-2009') {
        return prefix.includes('2009')
      }
    }
    return undefined
  }

  /**
   * Check if transition prop is inside vendor specific rule
   */
  ruleVendorPrefixes(decl) {
    let { parent } = decl

    if (parent.type !== 'rule') {
      return false
    } else if (!parent.selector.includes(':-')) {
      return false
    }

    let selectors = Browsers.prefixes().filter(s =>
      parent.selector.includes(':' + s)
    )

    return selectors.length > 0 ? selectors : false
  }
}

module.exports = Transition


/***/ }),

/***/ 96584:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let { list } = __nccwpck_require__(77001)

/**
 * Throw special error, to tell beniary,
 * that this error is from Autoprefixer.
 */
module.exports.error = function (text) {
  let err = new Error(text)
  err.autoprefixer = true
  throw err
}

/**
 * Return array, that doesn’t contain duplicates.
 */
module.exports.uniq = function (array) {
  return [...new Set(array)]
}

/**
 * Return "-webkit-" on "-webkit- old"
 */
module.exports.removeNote = function (string) {
  if (!string.includes(' ')) {
    return string
  }

  return string.split(' ')[0]
}

/**
 * Escape RegExp symbols
 */
module.exports.escapeRegexp = function (string) {
  return string.replace(/[$()*+-.?[\\\]^{|}]/g, '\\$&')
}

/**
 * Return regexp to check, that CSS string contain word
 */
module.exports.regexp = function (word, escape = true) {
  if (escape) {
    word = this.escapeRegexp(word)
  }
  return new RegExp(`(^|[\\s,(])(${word}($|[\\s(,]))`, 'gi')
}

/**
 * Change comma list
 */
module.exports.editList = function (value, callback) {
  let origin = list.comma(value)
  let changed = callback(origin, [])

  if (origin === changed) {
    return value
  }

  let join = value.match(/,\s*/)
  join = join ? join[0] : ', '
  return changed.join(join)
}

/**
 * Split the selector into parts.
 * It returns 3 level deep array because selectors can be comma
 * separated (1), space separated (2), and combined (3)
 * @param {String} selector selector string
 * @return {Array<Array<Array>>} 3 level deep array of split selector
 * @see utils.test.js for examples
 */
module.exports.splitSelector = function (selector) {
  return list.comma(selector).map(i => {
    return list.space(i).map(k => {
      return k.split(/(?=\.|#)/g)
    })
  })
}

/**
 * Return true if a given value only contains numbers.
 * @param {*} value
 * @returns {boolean}
 */
module.exports.isPureNumber = function (value) {
  if (typeof value === 'number') {
    return true
  }
  if (typeof value === 'string') {
    return /^[0-9]+$/.test(value)
  }
  return false
}


/***/ }),

/***/ 52530:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let Prefixer = __nccwpck_require__(26579)
let OldValue = __nccwpck_require__(86029)
let vendor = __nccwpck_require__(62667)
let utils = __nccwpck_require__(96584)

class Value extends Prefixer {
  /**
   * Clone decl for each prefixed values
   */
  static save(prefixes, decl) {
    let prop = decl.prop
    let result = []

    for (let prefix in decl._autoprefixerValues) {
      let value = decl._autoprefixerValues[prefix]

      if (value === decl.value) {
        continue
      }

      let item
      let propPrefix = vendor.prefix(prop)

      if (propPrefix === '-pie-') {
        continue
      }

      if (propPrefix === prefix) {
        item = decl.value = value
        result.push(item)
        continue
      }

      let prefixed = prefixes.prefixed(prop, prefix)
      let rule = decl.parent

      if (!rule.every(i => i.prop !== prefixed)) {
        result.push(item)
        continue
      }

      let trimmed = value.replace(/\s+/, ' ')
      let already = rule.some(
        i => i.prop === decl.prop && i.value.replace(/\s+/, ' ') === trimmed
      )

      if (already) {
        result.push(item)
        continue
      }

      let cloned = this.clone(decl, { value })
      item = decl.parent.insertBefore(decl, cloned)

      result.push(item)
    }

    return result
  }

  /**
   * Is declaration need to be prefixed
   */
  check(decl) {
    let value = decl.value
    if (!value.includes(this.name)) {
      return false
    }

    return !!value.match(this.regexp())
  }

  /**
   * Lazy regexp loading
   */
  regexp() {
    return this.regexpCache || (this.regexpCache = utils.regexp(this.name))
  }

  /**
   * Add prefix to values in string
   */
  replace(string, prefix) {
    return string.replace(this.regexp(), `$1${prefix}$2`)
  }

  /**
   * Get value with comments if it was not changed
   */
  value(decl) {
    if (decl.raws.value && decl.raws.value.value === decl.value) {
      return decl.raws.value.raw
    } else {
      return decl.value
    }
  }

  /**
   * Save values with next prefixed token
   */
  add(decl, prefix) {
    if (!decl._autoprefixerValues) {
      decl._autoprefixerValues = {}
    }
    let value = decl._autoprefixerValues[prefix] || this.value(decl)

    let before
    do {
      before = value
      value = this.replace(value, prefix)
      if (value === false) return
    } while (value !== before)

    decl._autoprefixerValues[prefix] = value
  }

  /**
   * Return function to fast find prefixed value
   */
  old(prefix) {
    return new OldValue(this.name, prefix + this.name)
  }
}

module.exports = Value


/***/ }),

/***/ 62667:
/***/ ((module) => {

module.exports = {
  prefix(prop) {
    let match = prop.match(/^(-\w+-)/)
    if (match) {
      return match[0]
    }

    return ''
  },

  unprefixed(prop) {
    return prop.replace(/^-\w+-/, '')
  }
}


/***/ }),

/***/ 50610:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const stringify = __nccwpck_require__(38750);
const compile = __nccwpck_require__(79434);
const expand = __nccwpck_require__(35873);
const parse = __nccwpck_require__(96477);

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

const braces = (input, options = {}) => {
  let output = [];

  if (Array.isArray(input)) {
    for (let pattern of input) {
      let result = braces.create(pattern, options);
      if (Array.isArray(result)) {
        output.push(...result);
      } else {
        output.push(result);
      }
    }
  } else {
    output = [].concat(braces.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
    output = [...new Set(output)];
  }
  return output;
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */

braces.parse = (input, options = {}) => parse(input, options);

/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.stringify = (input, options = {}) => {
  if (typeof input === 'string') {
    return stringify(braces.parse(input, options), options);
  }
  return stringify(input, options);
};

/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.compile = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }
  return compile(input, options);
};

/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.expand = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }

  let result = expand(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) {
    result = result.filter(Boolean);
  }

  // filter out duplicates if specified
  if (options.nodupes === true) {
    result = [...new Set(result)];
  }

  return result;
};

/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.create = (input, options = {}) => {
  if (input === '' || input.length < 3) {
    return [input];
  }

 return options.expand !== true
    ? braces.compile(input, options)
    : braces.expand(input, options);
};

/**
 * Expose "braces"
 */

module.exports = braces;


/***/ }),

/***/ 79434:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const fill = __nccwpck_require__(6330);
const utils = __nccwpck_require__(45207);

const compile = (ast, options = {}) => {
  let walk = (node, parent = {}) => {
    let invalidBlock = utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let invalid = invalidBlock === true || invalidNode === true;
    let prefix = options.escapeInvalid === true ? '\\' : '';
    let output = '';

    if (node.isOpen === true) {
      return prefix + node.value;
    }
    if (node.isClose === true) {
      return prefix + node.value;
    }

    if (node.type === 'open') {
      return invalid ? (prefix + node.value) : '(';
    }

    if (node.type === 'close') {
      return invalid ? (prefix + node.value) : ')';
    }

    if (node.type === 'comma') {
      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);
      let range = fill(...args, { ...options, wrap: false, toRegex: true });

      if (range.length !== 0) {
        return args.length > 1 && range.length > 1 ? `(${range})` : range;
      }
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += walk(child, node);
      }
    }
    return output;
  };

  return walk(ast);
};

module.exports = compile;


/***/ }),

/***/ 18774:
/***/ ((module) => {

"use strict";


module.exports = {
  MAX_LENGTH: 1024 * 64,

  // Digits
  CHAR_0: '0', /* 0 */
  CHAR_9: '9', /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 'A', /* A */
  CHAR_LOWERCASE_A: 'a', /* a */
  CHAR_UPPERCASE_Z: 'Z', /* Z */
  CHAR_LOWERCASE_Z: 'z', /* z */

  CHAR_LEFT_PARENTHESES: '(', /* ( */
  CHAR_RIGHT_PARENTHESES: ')', /* ) */

  CHAR_ASTERISK: '*', /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: '&', /* & */
  CHAR_AT: '@', /* @ */
  CHAR_BACKSLASH: '\\', /* \ */
  CHAR_BACKTICK: '`', /* ` */
  CHAR_CARRIAGE_RETURN: '\r', /* \r */
  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */
  CHAR_COLON: ':', /* : */
  CHAR_COMMA: ',', /* , */
  CHAR_DOLLAR: '$', /* . */
  CHAR_DOT: '.', /* . */
  CHAR_DOUBLE_QUOTE: '"', /* " */
  CHAR_EQUAL: '=', /* = */
  CHAR_EXCLAMATION_MARK: '!', /* ! */
  CHAR_FORM_FEED: '\f', /* \f */
  CHAR_FORWARD_SLASH: '/', /* / */
  CHAR_HASH: '#', /* # */
  CHAR_HYPHEN_MINUS: '-', /* - */
  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */
  CHAR_LEFT_CURLY_BRACE: '{', /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */
  CHAR_LINE_FEED: '\n', /* \n */
  CHAR_NO_BREAK_SPACE: '\u00A0', /* \u00A0 */
  CHAR_PERCENT: '%', /* % */
  CHAR_PLUS: '+', /* + */
  CHAR_QUESTION_MARK: '?', /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */
  CHAR_RIGHT_CURLY_BRACE: '}', /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */
  CHAR_SEMICOLON: ';', /* ; */
  CHAR_SINGLE_QUOTE: '\'', /* ' */
  CHAR_SPACE: ' ', /*   */
  CHAR_TAB: '\t', /* \t */
  CHAR_UNDERSCORE: '_', /* _ */
  CHAR_VERTICAL_LINE: '|', /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */
};


/***/ }),

/***/ 35873:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const fill = __nccwpck_require__(6330);
const stringify = __nccwpck_require__(38750);
const utils = __nccwpck_require__(45207);

const append = (queue = '', stash = '', enclose = false) => {
  let result = [];

  queue = [].concat(queue);
  stash = [].concat(stash);

  if (!stash.length) return queue;
  if (!queue.length) {
    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;
  }

  for (let item of queue) {
    if (Array.isArray(item)) {
      for (let value of item) {
        result.push(append(value, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));
      }
    }
  }
  return utils.flatten(result);
};

const expand = (ast, options = {}) => {
  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

  let walk = (node, parent = {}) => {
    node.queue = [];

    let p = parent;
    let q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
      p = p.parent;
      q = p.queue;
    }

    if (node.invalid || node.dollar) {
      q.push(append(q.pop(), stringify(node, options)));
      return;
    }

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
      q.push(append(q.pop(), ['{}']));
      return;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);

      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
      }

      let range = fill(...args, options);
      if (range.length === 0) {
        range = stringify(node, options);
      }

      q.push(append(q.pop(), range));
      node.nodes = [];
      return;
    }

    let enclose = utils.encloseBrace(node);
    let queue = node.queue;
    let block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
      block = block.parent;
      queue = block.queue;
    }

    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') {
        if (i === 1) queue.push('');
        queue.push('');
        continue;
      }

      if (child.type === 'close') {
        q.push(append(q.pop(), queue, enclose));
        continue;
      }

      if (child.value && child.type !== 'open') {
        queue.push(append(queue.pop(), child.value));
        continue;
      }

      if (child.nodes) {
        walk(child, node);
      }
    }

    return queue;
  };

  return utils.flatten(walk(ast));
};

module.exports = expand;


/***/ }),

/***/ 96477:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const stringify = __nccwpck_require__(38750);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  CHAR_BACKSLASH, /* \ */
  CHAR_BACKTICK, /* ` */
  CHAR_COMMA, /* , */
  CHAR_DOT, /* . */
  CHAR_LEFT_PARENTHESES, /* ( */
  CHAR_RIGHT_PARENTHESES, /* ) */
  CHAR_LEFT_CURLY_BRACE, /* { */
  CHAR_RIGHT_CURLY_BRACE, /* } */
  CHAR_LEFT_SQUARE_BRACKET, /* [ */
  CHAR_RIGHT_SQUARE_BRACKET, /* ] */
  CHAR_DOUBLE_QUOTE, /* " */
  CHAR_SINGLE_QUOTE, /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = __nccwpck_require__(18774);

/**
 * parse
 */

const parse = (input, options = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  let opts = options || {};
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }

  let ast = { type: 'root', input, nodes: [] };
  let stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index = 0;
  let depth = 0;
  let value;
  let memo = {};

  /**
   * Helpers
   */

  const advance = () => input[index++];
  const push = node => {
    if (node.type === 'text' && prev.type === 'dot') {
      prev.type = 'text';
    }

    if (prev && prev.type === 'text' && node.type === 'text') {
      prev.value += node.value;
      return;
    }

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
  };

  push({ type: 'bos' });

  while (index < length) {
    block = stack[stack.length - 1];
    value = advance();

    /**
     * Invalid chars
     */

    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
      continue;
    }

    /**
     * Escaped chars
     */

    if (value === CHAR_BACKSLASH) {
      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });
      continue;
    }

    /**
     * Right square bracket (literal): ']'
     */

    if (value === CHAR_RIGHT_SQUARE_BRACKET) {
      push({ type: 'text', value: '\\' + value });
      continue;
    }

    /**
     * Left square bracket: '['
     */

    if (value === CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;

      let closed = true;
      let next;

      while (index < length && (next = advance())) {
        value += next;

        if (next === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          continue;
        }

        if (next === CHAR_BACKSLASH) {
          value += advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          brackets--;

          if (brackets === 0) {
            break;
          }
        }
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Parentheses
     */

    if (value === CHAR_LEFT_PARENTHESES) {
      block = push({ type: 'paren', nodes: [] });
      stack.push(block);
      push({ type: 'text', value });
      continue;
    }

    if (value === CHAR_RIGHT_PARENTHESES) {
      if (block.type !== 'paren') {
        push({ type: 'text', value });
        continue;
      }
      block = stack.pop();
      push({ type: 'text', value });
      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Quotes: '|"|`
     */

    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
      let open = value;
      let next;

      if (options.keepQuotes !== true) {
        value = '';
      }

      while (index < length && (next = advance())) {
        if (next === CHAR_BACKSLASH) {
          value += next + advance();
          continue;
        }

        if (next === open) {
          if (options.keepQuotes === true) value += next;
          break;
        }

        value += next;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Left curly brace: '{'
     */

    if (value === CHAR_LEFT_CURLY_BRACE) {
      depth++;

      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      let brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar,
        depth,
        commas: 0,
        ranges: 0,
        nodes: []
      };

      block = push(brace);
      stack.push(block);
      push({ type: 'open', value });
      continue;
    }

    /**
     * Right curly brace: '}'
     */

    if (value === CHAR_RIGHT_CURLY_BRACE) {
      if (block.type !== 'brace') {
        push({ type: 'text', value });
        continue;
      }

      let type = 'close';
      block = stack.pop();
      block.close = true;

      push({ type, value });
      depth--;

      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Comma: ','
     */

    if (value === CHAR_COMMA && depth > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;
        let open = block.nodes.shift();
        block.nodes = [open, { type: 'text', value: stringify(block) }];
      }

      push({ type: 'comma', value });
      block.commas++;
      continue;
    }

    /**
     * Dot: '.'
     */

    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
      let siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) {
        push({ type: 'text', value });
        continue;
      }

      if (prev.type === 'dot') {
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
        }

        block.ranges++;
        block.args = [];
        continue;
      }

      if (prev.type === 'range') {
        siblings.pop();

        let before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
      }

      push({ type: 'dot', value });
      continue;
    }

    /**
     * Text
     */

    push({ type: 'text', value });
  }

  // Mark imbalanced braces and brackets as invalid
  do {
    block = stack.pop();

    if (block.type !== 'root') {
      block.nodes.forEach(node => {
        if (!node.nodes) {
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
        }
      });

      // get the location of the block on parent.nodes (block's siblings)
      let parent = stack[stack.length - 1];
      let index = parent.nodes.indexOf(block);
      // replace the (invalid) block with it's nodes
      parent.nodes.splice(index, 1, ...block.nodes);
    }
  } while (stack.length > 0);

  push({ type: 'eos' });
  return ast;
};

module.exports = parse;


/***/ }),

/***/ 38750:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const utils = __nccwpck_require__(45207);

module.exports = (ast, options = {}) => {
  let stringify = (node, parent = {}) => {
    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let output = '';

    if (node.value) {
      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
        return '\\' + node.value;
      }
      return node.value;
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += stringify(child);
      }
    }
    return output;
  };

  return stringify(ast);
};



/***/ }),

/***/ 45207:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.isInteger = num => {
  if (typeof num === 'number') {
    return Number.isInteger(num);
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isInteger(Number(num));
  }
  return false;
};

/**
 * Find a node of the given type
 */

exports.find = (node, type) => node.nodes.find(node => node.type === type);

/**
 * Find a node of the given type
 */

exports.exceedsLimit = (min, max, step = 1, limit) => {
  if (limit === false) return false;
  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
  return ((Number(max) - Number(min)) / Number(step)) >= limit;
};

/**
 * Escape the given node with '\\' before node.value
 */

exports.escapeNode = (block, n = 0, type) => {
  let node = block.nodes[n];
  if (!node) return;

  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
    if (node.escaped !== true) {
      node.value = '\\' + node.value;
      node.escaped = true;
    }
  }
};

/**
 * Returns true if the given brace node should be enclosed in literal braces
 */

exports.encloseBrace = node => {
  if (node.type !== 'brace') return false;
  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
    node.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a brace node is invalid.
 */

exports.isInvalidBrace = block => {
  if (block.type !== 'brace') return false;
  if (block.invalid === true || block.dollar) return true;
  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
    block.invalid = true;
    return true;
  }
  if (block.open !== true || block.close !== true) {
    block.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a node is an open or close node
 */

exports.isOpenOrClose = node => {
  if (node.type === 'open' || node.type === 'close') {
    return true;
  }
  return node.open === true || node.close === true;
};

/**
 * Reduce an array of text nodes.
 */

exports.reduce = nodes => nodes.reduce((acc, node) => {
  if (node.type === 'text') acc.push(node.value);
  if (node.type === 'range') node.type = 'text';
  return acc;
}, []);

/**
 * Flatten an array
 */

exports.flatten = (...args) => {
  const result = [];
  const flat = arr => {
    for (let i = 0; i < arr.length; i++) {
      let ele = arr[i];
      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
    }
    return result;
  };
  flat(args);
  return result;
};


/***/ }),

/***/ 92498:
/***/ ((module) => {

function BrowserslistError(message) {
  this.name = 'BrowserslistError'
  this.message = message
  this.browserslist = true
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, BrowserslistError)
  }
}

BrowserslistError.prototype = Error.prototype

module.exports = BrowserslistError


/***/ }),

/***/ 55478:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var jsReleases = __nccwpck_require__(76052)
var agents = (__nccwpck_require__(87462).agents)
var jsEOL = __nccwpck_require__(78864)
var path = __nccwpck_require__(71017)
var e2c = __nccwpck_require__(46719)

var BrowserslistError = __nccwpck_require__(92498)
var parse = __nccwpck_require__(88046)
var env = __nccwpck_require__(20486) // Will load browser.js in webpack

var YEAR = 365.259641 * 24 * 60 * 60 * 1000
var ANDROID_EVERGREEN_FIRST = 37

// Helpers

function isVersionsMatch(versionA, versionB) {
  return (versionA + '.').indexOf(versionB + '.') === 0
}

function isEolReleased(name) {
  var version = name.slice(1)
  return browserslist.nodeVersions.some(function (i) {
    return isVersionsMatch(i, version)
  })
}

function normalize(versions) {
  return versions.filter(function (version) {
    return typeof version === 'string'
  })
}

function normalizeElectron(version) {
  var versionToUse = version
  if (version.split('.').length === 3) {
    versionToUse = version.split('.').slice(0, -1).join('.')
  }
  return versionToUse
}

function nameMapper(name) {
  return function mapName(version) {
    return name + ' ' + version
  }
}

function getMajor(version) {
  return parseInt(version.split('.')[0])
}

function getMajorVersions(released, number) {
  if (released.length === 0) return []
  var majorVersions = uniq(released.map(getMajor))
  var minimum = majorVersions[majorVersions.length - number]
  if (!minimum) {
    return released
  }
  var selected = []
  for (var i = released.length - 1; i >= 0; i--) {
    if (minimum > getMajor(released[i])) break
    selected.unshift(released[i])
  }
  return selected
}

function uniq(array) {
  var filtered = []
  for (var i = 0; i < array.length; i++) {
    if (filtered.indexOf(array[i]) === -1) filtered.push(array[i])
  }
  return filtered
}

function fillUsage(result, name, data) {
  for (var i in data) {
    result[name + ' ' + i] = data[i]
  }
}

function generateFilter(sign, version) {
  version = parseFloat(version)
  if (sign === '>') {
    return function (v) {
      return parseFloat(v) > version
    }
  } else if (sign === '>=') {
    return function (v) {
      return parseFloat(v) >= version
    }
  } else if (sign === '<') {
    return function (v) {
      return parseFloat(v) < version
    }
  } else {
    return function (v) {
      return parseFloat(v) <= version
    }
  }
}

function generateSemverFilter(sign, version) {
  version = version.split('.').map(parseSimpleInt)
  version[1] = version[1] || 0
  version[2] = version[2] || 0
  if (sign === '>') {
    return function (v) {
      v = v.split('.').map(parseSimpleInt)
      return compareSemver(v, version) > 0
    }
  } else if (sign === '>=') {
    return function (v) {
      v = v.split('.').map(parseSimpleInt)
      return compareSemver(v, version) >= 0
    }
  } else if (sign === '<') {
    return function (v) {
      v = v.split('.').map(parseSimpleInt)
      return compareSemver(version, v) > 0
    }
  } else {
    return function (v) {
      v = v.split('.').map(parseSimpleInt)
      return compareSemver(version, v) >= 0
    }
  }
}

function parseSimpleInt(x) {
  return parseInt(x)
}

function compare(a, b) {
  if (a < b) return -1
  if (a > b) return +1
  return 0
}

function compareSemver(a, b) {
  return (
    compare(parseInt(a[0]), parseInt(b[0])) ||
    compare(parseInt(a[1] || '0'), parseInt(b[1] || '0')) ||
    compare(parseInt(a[2] || '0'), parseInt(b[2] || '0'))
  )
}

// this follows the npm-like semver behavior
function semverFilterLoose(operator, range) {
  range = range.split('.').map(parseSimpleInt)
  if (typeof range[1] === 'undefined') {
    range[1] = 'x'
  }
  // ignore any patch version because we only return minor versions
  // range[2] = 'x'
  switch (operator) {
    case '<=':
      return function (version) {
        version = version.split('.').map(parseSimpleInt)
        return compareSemverLoose(version, range) <= 0
      }
    case '>=':
    default:
      return function (version) {
        version = version.split('.').map(parseSimpleInt)
        return compareSemverLoose(version, range) >= 0
      }
  }
}

// this follows the npm-like semver behavior
function compareSemverLoose(version, range) {
  if (version[0] !== range[0]) {
    return version[0] < range[0] ? -1 : +1
  }
  if (range[1] === 'x') {
    return 0
  }
  if (version[1] !== range[1]) {
    return version[1] < range[1] ? -1 : +1
  }
  return 0
}

function resolveVersion(data, version) {
  if (data.versions.indexOf(version) !== -1) {
    return version
  } else if (browserslist.versionAliases[data.name][version]) {
    return browserslist.versionAliases[data.name][version]
  } else {
    return false
  }
}

function normalizeVersion(data, version) {
  var resolved = resolveVersion(data, version)
  if (resolved) {
    return resolved
  } else if (data.versions.length === 1) {
    return data.versions[0]
  } else {
    return false
  }
}

function filterByYear(since, context) {
  since = since / 1000
  return Object.keys(agents).reduce(function (selected, name) {
    var data = byName(name, context)
    if (!data) return selected
    var versions = Object.keys(data.releaseDate).filter(function (v) {
      var date = data.releaseDate[v]
      return date !== null && date >= since
    })
    return selected.concat(versions.map(nameMapper(data.name)))
  }, [])
}

function cloneData(data) {
  return {
    name: data.name,
    versions: data.versions,
    released: data.released,
    releaseDate: data.releaseDate
  }
}

function mapVersions(data, map) {
  data.versions = data.versions.map(function (i) {
    return map[i] || i
  })
  data.released = data.released.map(function (i) {
    return map[i] || i
  })
  var fixedDate = {}
  for (var i in data.releaseDate) {
    fixedDate[map[i] || i] = data.releaseDate[i]
  }
  data.releaseDate = fixedDate
  return data
}

function byName(name, context) {
  name = name.toLowerCase()
  name = browserslist.aliases[name] || name
  if (context.mobileToDesktop && browserslist.desktopNames[name]) {
    var desktop = browserslist.data[browserslist.desktopNames[name]]
    if (name === 'android') {
      return normalizeAndroidData(cloneData(browserslist.data[name]), desktop)
    } else {
      var cloned = cloneData(desktop)
      cloned.name = name
      if (name === 'op_mob') {
        cloned = mapVersions(cloned, { '10.0-10.1': '10' })
      }
      return cloned
    }
  }
  return browserslist.data[name]
}

function normalizeAndroidVersions(androidVersions, chromeVersions) {
  var firstEvergreen = ANDROID_EVERGREEN_FIRST
  var last = chromeVersions[chromeVersions.length - 1]
  return androidVersions
    .filter(function (version) {
      return /^(?:[2-4]\.|[34]$)/.test(version)
    })
    .concat(chromeVersions.slice(firstEvergreen - last - 1))
}

function normalizeAndroidData(android, chrome) {
  android.released = normalizeAndroidVersions(android.released, chrome.released)
  android.versions = normalizeAndroidVersions(android.versions, chrome.versions)
  return android
}

function checkName(name, context) {
  var data = byName(name, context)
  if (!data) throw new BrowserslistError('Unknown browser ' + name)
  return data
}

function unknownQuery(query) {
  return new BrowserslistError(
    'Unknown browser query `' +
      query +
      '`. ' +
      'Maybe you are using old Browserslist or made typo in query.'
  )
}

function filterAndroid(list, versions, context) {
  if (context.mobileToDesktop) return list
  var released = browserslist.data.android.released
  var last = released[released.length - 1]
  var diff = last - ANDROID_EVERGREEN_FIRST - versions
  if (diff > 0) {
    return list.slice(-1)
  } else {
    return list.slice(diff - 1)
  }
}

function resolve(queries, context) {
  return parse(QUERIES, queries).reduce(function (result, node, index) {
    if (node.not && index === 0) {
      throw new BrowserslistError(
        'Write any browsers query (for instance, `defaults`) ' +
          'before `' +
          node.query +
          '`'
      )
    }
    var type = QUERIES[node.type]
    var array = type.select.call(browserslist, context, node).map(function (j) {
      var parts = j.split(' ')
      if (parts[1] === '0') {
        return parts[0] + ' ' + byName(parts[0], context).versions[0]
      } else {
        return j
      }
    })

    if (node.compose === 'and') {
      if (node.not) {
        return result.filter(function (j) {
          return array.indexOf(j) === -1
        })
      } else {
        return result.filter(function (j) {
          return array.indexOf(j) !== -1
        })
      }
    } else {
      if (node.not) {
        var filter = {}
        array.forEach(function (j) {
          filter[j] = true
        })
        return result.filter(function (j) {
          return !filter[j]
        })
      }
      return result.concat(array)
    }
  }, [])
}

function prepareOpts(opts) {
  if (typeof opts === 'undefined') opts = {}

  if (typeof opts.path === 'undefined') {
    opts.path = path.resolve ? path.resolve('.') : '.'
  }

  return opts
}

function prepareQueries(queries, opts) {
  if (typeof queries === 'undefined' || queries === null) {
    var config = browserslist.loadConfig(opts)
    if (config) {
      queries = config
    } else {
      queries = browserslist.defaults
    }
  }

  return queries
}

function checkQueries(queries) {
  if (!(typeof queries === 'string' || Array.isArray(queries))) {
    throw new BrowserslistError(
      'Browser queries must be an array or string. Got ' + typeof queries + '.'
    )
  }
}

var cache = {}

function browserslist(queries, opts) {
  opts = prepareOpts(opts)
  queries = prepareQueries(queries, opts)
  checkQueries(queries)

  var context = {
    ignoreUnknownVersions: opts.ignoreUnknownVersions,
    dangerousExtend: opts.dangerousExtend,
    mobileToDesktop: opts.mobileToDesktop,
    path: opts.path,
    env: opts.env
  }

  env.oldDataWarning(browserslist.data)
  var stats = env.getStat(opts, browserslist.data)
  if (stats) {
    context.customUsage = {}
    for (var browser in stats) {
      fillUsage(context.customUsage, browser, stats[browser])
    }
  }

  var cacheKey = JSON.stringify([queries, context])
  if (cache[cacheKey]) return cache[cacheKey]

  var result = uniq(resolve(queries, context)).sort(function (name1, name2) {
    name1 = name1.split(' ')
    name2 = name2.split(' ')
    if (name1[0] === name2[0]) {
      // assumptions on caniuse data
      // 1) version ranges never overlaps
      // 2) if version is not a range, it never contains `-`
      var version1 = name1[1].split('-')[0]
      var version2 = name2[1].split('-')[0]
      return compareSemver(version2.split('.'), version1.split('.'))
    } else {
      return compare(name1[0], name2[0])
    }
  })
  if (!env.env.BROWSERSLIST_DISABLE_CACHE) {
    cache[cacheKey] = result
  }
  return result
}

browserslist.parse = function (queries, opts) {
  opts = prepareOpts(opts)
  queries = prepareQueries(queries, opts)
  checkQueries(queries)
  return parse(QUERIES, queries)
}

// Will be filled by Can I Use data below
browserslist.cache = {}
browserslist.data = {}
browserslist.usage = {
  global: {},
  custom: null
}

// Default browsers query
browserslist.defaults = ['> 0.5%', 'last 2 versions', 'Firefox ESR', 'not dead']

// Browser names aliases
browserslist.aliases = {
  fx: 'firefox',
  ff: 'firefox',
  ios: 'ios_saf',
  explorer: 'ie',
  blackberry: 'bb',
  explorermobile: 'ie_mob',
  operamini: 'op_mini',
  operamobile: 'op_mob',
  chromeandroid: 'and_chr',
  firefoxandroid: 'and_ff',
  ucandroid: 'and_uc',
  qqandroid: 'and_qq'
}

// Can I Use only provides a few versions for some browsers (e.g. and_chr).
// Fallback to a similar browser for unknown versions
browserslist.desktopNames = {
  and_chr: 'chrome',
  and_ff: 'firefox',
  ie_mob: 'ie',
  op_mob: 'opera',
  android: 'chrome' // has extra processing logic
}

// Aliases to work with joined versions like `ios_saf 7.0-7.1`
browserslist.versionAliases = {}

browserslist.clearCaches = env.clearCaches
browserslist.parseConfig = env.parseConfig
browserslist.readConfig = env.readConfig
browserslist.findConfig = env.findConfig
browserslist.loadConfig = env.loadConfig

browserslist.coverage = function (browsers, stats) {
  var data
  if (typeof stats === 'undefined') {
    data = browserslist.usage.global
  } else if (stats === 'my stats') {
    var opts = {}
    opts.path = path.resolve ? path.resolve('.') : '.'
    var customStats = env.getStat(opts)
    if (!customStats) {
      throw new BrowserslistError('Custom usage statistics was not provided')
    }
    data = {}
    for (var browser in customStats) {
      fillUsage(data, browser, customStats[browser])
    }
  } else if (typeof stats === 'string') {
    if (stats.length > 2) {
      stats = stats.toLowerCase()
    } else {
      stats = stats.toUpperCase()
    }
    env.loadCountry(browserslist.usage, stats, browserslist.data)
    data = browserslist.usage[stats]
  } else {
    if ('dataByBrowser' in stats) {
      stats = stats.dataByBrowser
    }
    data = {}
    for (var name in stats) {
      for (var version in stats[name]) {
        data[name + ' ' + version] = stats[name][version]
      }
    }
  }

  return browsers.reduce(function (all, i) {
    var usage = data[i]
    if (usage === undefined) {
      usage = data[i.replace(/ \S+$/, ' 0')]
    }
    return all + (usage || 0)
  }, 0)
}

function nodeQuery(context, node) {
  var matched = browserslist.nodeVersions.filter(function (i) {
    return isVersionsMatch(i, node.version)
  })
  if (matched.length === 0) {
    if (context.ignoreUnknownVersions) {
      return []
    } else {
      throw new BrowserslistError(
        'Unknown version ' + node.version + ' of Node.js'
      )
    }
  }
  return ['node ' + matched[matched.length - 1]]
}

function sinceQuery(context, node) {
  var year = parseInt(node.year)
  var month = parseInt(node.month || '01') - 1
  var day = parseInt(node.day || '01')
  return filterByYear(Date.UTC(year, month, day, 0, 0, 0), context)
}

function coverQuery(context, node) {
  var coverage = parseFloat(node.coverage)
  var usage = browserslist.usage.global
  if (node.place) {
    if (node.place.match(/^my\s+stats$/i)) {
      if (!context.customUsage) {
        throw new BrowserslistError('Custom usage statistics was not provided')
      }
      usage = context.customUsage
    } else {
      var place
      if (node.place.length === 2) {
        place = node.place.toUpperCase()
      } else {
        place = node.place.toLowerCase()
      }
      env.loadCountry(browserslist.usage, place, browserslist.data)
      usage = browserslist.usage[place]
    }
  }
  var versions = Object.keys(usage).sort(function (a, b) {
    return usage[b] - usage[a]
  })
  var coveraged = 0
  var result = []
  var version
  for (var i = 0; i < versions.length; i++) {
    version = versions[i]
    if (usage[version] === 0) break
    coveraged += usage[version]
    result.push(version)
    if (coveraged >= coverage) break
  }
  return result
}

var QUERIES = {
  last_major_versions: {
    matches: ['versions'],
    regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
    select: function (context, node) {
      return Object.keys(agents).reduce(function (selected, name) {
        var data = byName(name, context)
        if (!data) return selected
        var list = getMajorVersions(data.released, node.versions)
        list = list.map(nameMapper(data.name))
        if (data.name === 'android') {
          list = filterAndroid(list, node.versions, context)
        }
        return selected.concat(list)
      }, [])
    }
  },
  last_versions: {
    matches: ['versions'],
    regexp: /^last\s+(\d+)\s+versions?$/i,
    select: function (context, node) {
      return Object.keys(agents).reduce(function (selected, name) {
        var data = byName(name, context)
        if (!data) return selected
        var list = data.released.slice(-node.versions)
        list = list.map(nameMapper(data.name))
        if (data.name === 'android') {
          list = filterAndroid(list, node.versions, context)
        }
        return selected.concat(list)
      }, [])
    }
  },
  last_electron_major_versions: {
    matches: ['versions'],
    regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
    select: function (context, node) {
      var validVersions = getMajorVersions(Object.keys(e2c), node.versions)
      return validVersions.map(function (i) {
        return 'chrome ' + e2c[i]
      })
    }
  },
  last_node_major_versions: {
    matches: ['versions'],
    regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
    select: function (context, node) {
      return getMajorVersions(browserslist.nodeVersions, node.versions).map(
        function (version) {
          return 'node ' + version
        }
      )
    }
  },
  last_browser_major_versions: {
    matches: ['versions', 'browser'],
    regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
    select: function (context, node) {
      var data = checkName(node.browser, context)
      var validVersions = getMajorVersions(data.released, node.versions)
      var list = validVersions.map(nameMapper(data.name))
      if (data.name === 'android') {
        list = filterAndroid(list, node.versions, context)
      }
      return list
    }
  },
  last_electron_versions: {
    matches: ['versions'],
    regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
    select: function (context, node) {
      return Object.keys(e2c)
        .slice(-node.versions)
        .map(function (i) {
          return 'chrome ' + e2c[i]
        })
    }
  },
  last_node_versions: {
    matches: ['versions'],
    regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
    select: function (context, node) {
      return browserslist.nodeVersions
        .slice(-node.versions)
        .map(function (version) {
          return 'node ' + version
        })
    }
  },
  last_browser_versions: {
    matches: ['versions', 'browser'],
    regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
    select: function (context, node) {
      var data = checkName(node.browser, context)
      var list = data.released.slice(-node.versions).map(nameMapper(data.name))
      if (data.name === 'android') {
        list = filterAndroid(list, node.versions, context)
      }
      return list
    }
  },
  unreleased_versions: {
    matches: [],
    regexp: /^unreleased\s+versions$/i,
    select: function (context) {
      return Object.keys(agents).reduce(function (selected, name) {
        var data = byName(name, context)
        if (!data) return selected
        var list = data.versions.filter(function (v) {
          return data.released.indexOf(v) === -1
        })
        list = list.map(nameMapper(data.name))
        return selected.concat(list)
      }, [])
    }
  },
  unreleased_electron_versions: {
    matches: [],
    regexp: /^unreleased\s+electron\s+versions?$/i,
    select: function () {
      return []
    }
  },
  unreleased_browser_versions: {
    matches: ['browser'],
    regexp: /^unreleased\s+(\w+)\s+versions?$/i,
    select: function (context, node) {
      var data = checkName(node.browser, context)
      return data.versions
        .filter(function (v) {
          return data.released.indexOf(v) === -1
        })
        .map(nameMapper(data.name))
    }
  },
  last_years: {
    matches: ['years'],
    regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
    select: function (context, node) {
      return filterByYear(Date.now() - YEAR * node.years, context)
    }
  },
  since_y: {
    matches: ['year'],
    regexp: /^since (\d+)$/i,
    select: sinceQuery
  },
  since_y_m: {
    matches: ['year', 'month'],
    regexp: /^since (\d+)-(\d+)$/i,
    select: sinceQuery
  },
  since_y_m_d: {
    matches: ['year', 'month', 'day'],
    regexp: /^since (\d+)-(\d+)-(\d+)$/i,
    select: sinceQuery
  },
  popularity: {
    matches: ['sign', 'popularity'],
    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
    select: function (context, node) {
      var popularity = parseFloat(node.popularity)
      var usage = browserslist.usage.global
      return Object.keys(usage).reduce(function (result, version) {
        if (node.sign === '>') {
          if (usage[version] > popularity) {
            result.push(version)
          }
        } else if (node.sign === '<') {
          if (usage[version] < popularity) {
            result.push(version)
          }
        } else if (node.sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version)
          }
        } else if (usage[version] >= popularity) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  popularity_in_my_stats: {
    matches: ['sign', 'popularity'],
    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
    select: function (context, node) {
      var popularity = parseFloat(node.popularity)
      if (!context.customUsage) {
        throw new BrowserslistError('Custom usage statistics was not provided')
      }
      var usage = context.customUsage
      return Object.keys(usage).reduce(function (result, version) {
        var percentage = usage[version]
        if (percentage == null) {
          return result
        }

        if (node.sign === '>') {
          if (percentage > popularity) {
            result.push(version)
          }
        } else if (node.sign === '<') {
          if (percentage < popularity) {
            result.push(version)
          }
        } else if (node.sign === '<=') {
          if (percentage <= popularity) {
            result.push(version)
          }
        } else if (percentage >= popularity) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  popularity_in_config_stats: {
    matches: ['sign', 'popularity', 'config'],
    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
    select: function (context, node) {
      var popularity = parseFloat(node.popularity)
      var stats = env.loadStat(context, node.config, browserslist.data)
      if (stats) {
        context.customUsage = {}
        for (var browser in stats) {
          fillUsage(context.customUsage, browser, stats[browser])
        }
      }
      if (!context.customUsage) {
        throw new BrowserslistError('Custom usage statistics was not provided')
      }
      var usage = context.customUsage
      return Object.keys(usage).reduce(function (result, version) {
        var percentage = usage[version]
        if (percentage == null) {
          return result
        }

        if (node.sign === '>') {
          if (percentage > popularity) {
            result.push(version)
          }
        } else if (node.sign === '<') {
          if (percentage < popularity) {
            result.push(version)
          }
        } else if (node.sign === '<=') {
          if (percentage <= popularity) {
            result.push(version)
          }
        } else if (percentage >= popularity) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  popularity_in_place: {
    matches: ['sign', 'popularity', 'place'],
    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
    select: function (context, node) {
      var popularity = parseFloat(node.popularity)
      var place = node.place
      if (place.length === 2) {
        place = place.toUpperCase()
      } else {
        place = place.toLowerCase()
      }
      env.loadCountry(browserslist.usage, place, browserslist.data)
      var usage = browserslist.usage[place]
      return Object.keys(usage).reduce(function (result, version) {
        var percentage = usage[version]
        if (percentage == null) {
          return result
        }

        if (node.sign === '>') {
          if (percentage > popularity) {
            result.push(version)
          }
        } else if (node.sign === '<') {
          if (percentage < popularity) {
            result.push(version)
          }
        } else if (node.sign === '<=') {
          if (percentage <= popularity) {
            result.push(version)
          }
        } else if (percentage >= popularity) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  cover: {
    matches: ['coverage'],
    regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i,
    select: coverQuery
  },
  cover_in: {
    matches: ['coverage', 'place'],
    regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
    select: coverQuery
  },
  supports: {
    matches: ['feature'],
    regexp: /^supports\s+([\w-]+)$/,
    select: function (context, node) {
      env.loadFeature(browserslist.cache, node.feature)
      var features = browserslist.cache[node.feature]
      return Object.keys(features).reduce(function (result, version) {
        var flags = features[version]
        if (flags.indexOf('y') >= 0 || flags.indexOf('a') >= 0) {
          result.push(version)
        }
        return result
      }, [])
    }
  },
  electron_range: {
    matches: ['from', 'to'],
    regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function (context, node) {
      var fromToUse = normalizeElectron(node.from)
      var toToUse = normalizeElectron(node.to)
      var from = parseFloat(node.from)
      var to = parseFloat(node.to)
      if (!e2c[fromToUse]) {
        throw new BrowserslistError('Unknown version ' + from + ' of electron')
      }
      if (!e2c[toToUse]) {
        throw new BrowserslistError('Unknown version ' + to + ' of electron')
      }
      return Object.keys(e2c)
        .filter(function (i) {
          var parsed = parseFloat(i)
          return parsed >= from && parsed <= to
        })
        .map(function (i) {
          return 'chrome ' + e2c[i]
        })
    }
  },
  node_range: {
    matches: ['from', 'to'],
    regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function (context, node) {
      return browserslist.nodeVersions
        .filter(semverFilterLoose('>=', node.from))
        .filter(semverFilterLoose('<=', node.to))
        .map(function (v) {
          return 'node ' + v
        })
    }
  },
  browser_range: {
    matches: ['browser', 'from', 'to'],
    regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function (context, node) {
      var data = checkName(node.browser, context)
      var from = parseFloat(normalizeVersion(data, node.from) || node.from)
      var to = parseFloat(normalizeVersion(data, node.to) || node.to)
      function filter(v) {
        var parsed = parseFloat(v)
        return parsed >= from && parsed <= to
      }
      return data.released.filter(filter).map(nameMapper(data.name))
    }
  },
  electron_ray: {
    matches: ['sign', 'version'],
    regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
    select: function (context, node) {
      var versionToUse = normalizeElectron(node.version)
      return Object.keys(e2c)
        .filter(generateFilter(node.sign, versionToUse))
        .map(function (i) {
          return 'chrome ' + e2c[i]
        })
    }
  },
  node_ray: {
    matches: ['sign', 'version'],
    regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
    select: function (context, node) {
      return browserslist.nodeVersions
        .filter(generateSemverFilter(node.sign, node.version))
        .map(function (v) {
          return 'node ' + v
        })
    }
  },
  browser_ray: {
    matches: ['browser', 'sign', 'version'],
    regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
    select: function (context, node) {
      var version = node.version
      var data = checkName(node.browser, context)
      var alias = browserslist.versionAliases[data.name][version]
      if (alias) version = alias
      return data.released
        .filter(generateFilter(node.sign, version))
        .map(function (v) {
          return data.name + ' ' + v
        })
    }
  },
  firefox_esr: {
    matches: [],
    regexp: /^(firefox|ff|fx)\s+esr$/i,
    select: function () {
      return ['firefox 102']
    }
  },
  opera_mini_all: {
    matches: [],
    regexp: /(operamini|op_mini)\s+all/i,
    select: function () {
      return ['op_mini all']
    }
  },
  electron_version: {
    matches: ['version'],
    regexp: /^electron\s+([\d.]+)$/i,
    select: function (context, node) {
      var versionToUse = normalizeElectron(node.version)
      var chrome = e2c[versionToUse]
      if (!chrome) {
        throw new BrowserslistError(
          'Unknown version ' + node.version + ' of electron'
        )
      }
      return ['chrome ' + chrome]
    }
  },
  node_major_version: {
    matches: ['version'],
    regexp: /^node\s+(\d+)$/i,
    select: nodeQuery
  },
  node_minor_version: {
    matches: ['version'],
    regexp: /^node\s+(\d+\.\d+)$/i,
    select: nodeQuery
  },
  node_patch_version: {
    matches: ['version'],
    regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
    select: nodeQuery
  },
  current_node: {
    matches: [],
    regexp: /^current\s+node$/i,
    select: function (context) {
      return [env.currentNode(resolve, context)]
    }
  },
  maintained_node: {
    matches: [],
    regexp: /^maintained\s+node\s+versions$/i,
    select: function (context) {
      var now = Date.now()
      var queries = Object.keys(jsEOL)
        .filter(function (key) {
          return (
            now < Date.parse(jsEOL[key].end) &&
            now > Date.parse(jsEOL[key].start) &&
            isEolReleased(key)
          )
        })
        .map(function (key) {
          return 'node ' + key.slice(1)
        })
      return resolve(queries, context)
    }
  },
  phantomjs_1_9: {
    matches: [],
    regexp: /^phantomjs\s+1.9$/i,
    select: function () {
      return ['safari 5']
    }
  },
  phantomjs_2_1: {
    matches: [],
    regexp: /^phantomjs\s+2.1$/i,
    select: function () {
      return ['safari 6']
    }
  },
  browser_version: {
    matches: ['browser', 'version'],
    regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
    select: function (context, node) {
      var version = node.version
      if (/^tp$/i.test(version)) version = 'TP'
      var data = checkName(node.browser, context)
      var alias = normalizeVersion(data, version)
      if (alias) {
        version = alias
      } else {
        if (version.indexOf('.') === -1) {
          alias = version + '.0'
        } else {
          alias = version.replace(/\.0$/, '')
        }
        alias = normalizeVersion(data, alias)
        if (alias) {
          version = alias
        } else if (context.ignoreUnknownVersions) {
          return []
        } else {
          throw new BrowserslistError(
            'Unknown version ' + version + ' of ' + node.browser
          )
        }
      }
      return [data.name + ' ' + version]
    }
  },
  browserslist_config: {
    matches: [],
    regexp: /^browserslist config$/i,
    select: function (context) {
      return browserslist(undefined, context)
    }
  },
  extends: {
    matches: ['config'],
    regexp: /^extends (.+)$/i,
    select: function (context, node) {
      return resolve(env.loadQueries(context, node.config), context)
    }
  },
  defaults: {
    matches: [],
    regexp: /^defaults$/i,
    select: function (context) {
      return resolve(browserslist.defaults, context)
    }
  },
  dead: {
    matches: [],
    regexp: /^dead$/i,
    select: function (context) {
      var dead = [
        'Baidu >= 0',
        'ie <= 11',
        'ie_mob <= 11',
        'bb <= 10',
        'op_mob <= 12.1',
        'samsung 4'
      ]
      return resolve(dead, context)
    }
  },
  unknown: {
    matches: [],
    regexp: /^(\w+)$/i,
    select: function (context, node) {
      if (byName(node.query, context)) {
        throw new BrowserslistError(
          'Specify versions in Browserslist query for browser ' + node.query
        )
      } else {
        throw unknownQuery(node.query)
      }
    }
  }
}

// Get and convert Can I Use data

;(function () {
  for (var name in agents) {
    var browser = agents[name]
    browserslist.data[name] = {
      name: name,
      versions: normalize(agents[name].versions),
      released: normalize(agents[name].versions.slice(0, -3)),
      releaseDate: agents[name].release_date
    }
    fillUsage(browserslist.usage.global, name, browser.usage_global)

    browserslist.versionAliases[name] = {}
    for (var i = 0; i < browser.versions.length; i++) {
      var full = browser.versions[i]
      if (!full) continue

      if (full.indexOf('-') !== -1) {
        var interval = full.split('-')
        for (var j = 0; j < interval.length; j++) {
          browserslist.versionAliases[name][interval[j]] = full
        }
      }
    }
  }

  browserslist.versionAliases.op_mob['59'] = '58'

  browserslist.nodeVersions = jsReleases.map(function (release) {
    return release.version
  })
})()

module.exports = browserslist


/***/ }),

/***/ 20486:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var feature = (__nccwpck_require__(13206)["default"])
var region = (__nccwpck_require__(53506)["default"])
var path = __nccwpck_require__(71017)
var fs = __nccwpck_require__(57147)

var BrowserslistError = __nccwpck_require__(92498)

var IS_SECTION = /^\s*\[(.+)]\s*$/
var CONFIG_PATTERN = /^browserslist-config-/
var SCOPED_CONFIG__PATTERN = /@[^/]+\/browserslist-config(-|$|\/)/
var TIME_TO_UPDATE_CANIUSE = 6 * 30 * 24 * 60 * 60 * 1000
var FORMAT =
  'Browserslist config should be a string or an array ' +
  'of strings with browser queries'

var dataTimeChecked = false
var filenessCache = {}
var configCache = {}
function checkExtend(name) {
  var use = ' Use `dangerousExtend` option to disable.'
  if (!CONFIG_PATTERN.test(name) && !SCOPED_CONFIG__PATTERN.test(name)) {
    throw new BrowserslistError(
      'Browserslist config needs `browserslist-config-` prefix. ' + use
    )
  }
  if (name.replace(/^@[^/]+\//, '').indexOf('.') !== -1) {
    throw new BrowserslistError(
      '`.` not allowed in Browserslist config name. ' + use
    )
  }
  if (name.indexOf('node_modules') !== -1) {
    throw new BrowserslistError(
      '`node_modules` not allowed in Browserslist config.' + use
    )
  }
}

function isFile(file) {
  if (file in filenessCache) {
    return filenessCache[file]
  }
  var result = fs.existsSync(file) && fs.statSync(file).isFile()
  if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
    filenessCache[file] = result
  }
  return result
}

function eachParent(file, callback) {
  var dir = isFile(file) ? path.dirname(file) : file
  var loc = path.resolve(dir)
  do {
    var result = callback(loc)
    if (typeof result !== 'undefined') return result
  } while (loc !== (loc = path.dirname(loc)))
  return undefined
}

function check(section) {
  if (Array.isArray(section)) {
    for (var i = 0; i < section.length; i++) {
      if (typeof section[i] !== 'string') {
        throw new BrowserslistError(FORMAT)
      }
    }
  } else if (typeof section !== 'string') {
    throw new BrowserslistError(FORMAT)
  }
}

function pickEnv(config, opts) {
  if (typeof config !== 'object') return config

  var name
  if (typeof opts.env === 'string') {
    name = opts.env
  } else if (process.env.BROWSERSLIST_ENV) {
    name = process.env.BROWSERSLIST_ENV
  } else if (process.env.NODE_ENV) {
    name = process.env.NODE_ENV
  } else {
    name = 'production'
  }

  if (opts.throwOnMissing) {
    if (name && name !== 'defaults' && !config[name]) {
      throw new BrowserslistError(
        'Missing config for Browserslist environment `' + name + '`'
      )
    }
  }

  return config[name] || config.defaults
}

function parsePackage(file) {
  var config = JSON.parse(
    fs
      .readFileSync(file)
      .toString()
      .replace(/^\uFEFF/m, '')
  )
  if (config.browserlist && !config.browserslist) {
    throw new BrowserslistError(
      '`browserlist` key instead of `browserslist` in ' + file
    )
  }
  var list = config.browserslist
  if (Array.isArray(list) || typeof list === 'string') {
    list = { defaults: list }
  }
  for (var i in list) {
    check(list[i])
  }

  return list
}

function latestReleaseTime(agents) {
  var latest = 0
  for (var name in agents) {
    var dates = agents[name].releaseDate || {}
    for (var key in dates) {
      if (latest < dates[key]) {
        latest = dates[key]
      }
    }
  }
  return latest * 1000
}

function normalizeStats(data, stats) {
  if (!data) {
    data = {}
  }
  if (stats && 'dataByBrowser' in stats) {
    stats = stats.dataByBrowser
  }

  if (typeof stats !== 'object') return undefined

  var normalized = {}
  for (var i in stats) {
    var versions = Object.keys(stats[i])
    if (versions.length === 1 && data[i] && data[i].versions.length === 1) {
      var normal = data[i].versions[0]
      normalized[i] = {}
      normalized[i][normal] = stats[i][versions[0]]
    } else {
      normalized[i] = stats[i]
    }
  }

  return normalized
}

function normalizeUsageData(usageData, data) {
  for (var browser in usageData) {
    var browserUsage = usageData[browser]
    // eslint-disable-next-line max-len
    // https://github.com/browserslist/browserslist/issues/431#issuecomment-565230615
    // caniuse-db returns { 0: "percentage" } for `and_*` regional stats
    if ('0' in browserUsage) {
      var versions = data[browser].versions
      browserUsage[versions[versions.length - 1]] = browserUsage[0]
      delete browserUsage[0]
    }
  }
}

module.exports = {
  loadQueries: function loadQueries(ctx, name) {
    if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {
      checkExtend(name)
    }
    var queries = require(__nccwpck_require__(28440).resolve(name, { paths: ['.', ctx.path] }))
    if (queries) {
      if (Array.isArray(queries)) {
        return queries
      } else if (typeof queries === 'object') {
        if (!queries.defaults) queries.defaults = []
        return pickEnv(queries, ctx, name)
      }
    }
    throw new BrowserslistError(
      '`' +
        name +
        '` config exports not an array of queries' +
        ' or an object of envs'
    )
  },

  loadStat: function loadStat(ctx, name, data) {
    if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {
      checkExtend(name)
    }
    var stats = require(__nccwpck_require__(28440).resolve(
      path.join(name, 'browserslist-stats.json'),
      { paths: ['.'] }
    ))
    return normalizeStats(data, stats)
  },

  getStat: function getStat(opts, data) {
    var stats
    if (opts.stats) {
      stats = opts.stats
    } else if (process.env.BROWSERSLIST_STATS) {
      stats = process.env.BROWSERSLIST_STATS
    } else if (opts.path && path.resolve && fs.existsSync) {
      stats = eachParent(opts.path, function (dir) {
        var file = path.join(dir, 'browserslist-stats.json')
        return isFile(file) ? file : undefined
      })
    }
    if (typeof stats === 'string') {
      try {
        stats = JSON.parse(fs.readFileSync(stats))
      } catch (e) {
        throw new BrowserslistError("Can't read " + stats)
      }
    }
    return normalizeStats(data, stats)
  },

  loadConfig: function loadConfig(opts) {
    if (process.env.BROWSERSLIST) {
      return process.env.BROWSERSLIST
    } else if (opts.config || process.env.BROWSERSLIST_CONFIG) {
      var file = opts.config || process.env.BROWSERSLIST_CONFIG
      if (path.basename(file) === 'package.json') {
        return pickEnv(parsePackage(file), opts)
      } else {
        return pickEnv(module.exports.readConfig(file), opts)
      }
    } else if (opts.path) {
      return pickEnv(module.exports.findConfig(opts.path), opts)
    } else {
      return undefined
    }
  },

  loadCountry: function loadCountry(usage, country, data) {
    var code = country.replace(/[^\w-]/g, '')
    if (!usage[code]) {
      var compressed
      try {
        compressed = require('caniuse-lite/data/regions/' + code + '.js')
      } catch (e) {
        throw new BrowserslistError('Unknown region name `' + code + '`.')
      }
      var usageData = region(compressed)
      normalizeUsageData(usageData, data)
      usage[country] = {}
      for (var i in usageData) {
        for (var j in usageData[i]) {
          usage[country][i + ' ' + j] = usageData[i][j]
        }
      }
    }
  },

  loadFeature: function loadFeature(features, name) {
    name = name.replace(/[^\w-]/g, '')
    if (features[name]) return
    var compressed
    try {
      compressed = require('caniuse-lite/data/features/' + name + '.js')
    } catch (e) {
      throw new BrowserslistError('Unknown feature name `' + name + '`.')
    }
    var stats = feature(compressed).stats
    features[name] = {}
    for (var i in stats) {
      for (var j in stats[i]) {
        features[name][i + ' ' + j] = stats[i][j]
      }
    }
  },

  parseConfig: function parseConfig(string) {
    var result = { defaults: [] }
    var sections = ['defaults']

    string
      .toString()
      .replace(/#[^\n]*/g, '')
      .split(/\n|,/)
      .map(function (line) {
        return line.trim()
      })
      .filter(function (line) {
        return line !== ''
      })
      .forEach(function (line) {
        if (IS_SECTION.test(line)) {
          sections = line.match(IS_SECTION)[1].trim().split(' ')
          sections.forEach(function (section) {
            if (result[section]) {
              throw new BrowserslistError(
                'Duplicate section ' + section + ' in Browserslist config'
              )
            }
            result[section] = []
          })
        } else {
          sections.forEach(function (section) {
            result[section].push(line)
          })
        }
      })

    return result
  },

  readConfig: function readConfig(file) {
    if (!isFile(file)) {
      throw new BrowserslistError("Can't read " + file + ' config')
    }
    return module.exports.parseConfig(fs.readFileSync(file))
  },

  findConfig: function findConfig(from) {
    from = path.resolve(from)

    var passed = []
    var resolved = eachParent(from, function (dir) {
      if (dir in configCache) {
        return configCache[dir]
      }

      passed.push(dir)

      var config = path.join(dir, 'browserslist')
      var pkg = path.join(dir, 'package.json')
      var rc = path.join(dir, '.browserslistrc')

      var pkgBrowserslist
      if (isFile(pkg)) {
        try {
          pkgBrowserslist = parsePackage(pkg)
        } catch (e) {
          if (e.name === 'BrowserslistError') throw e
          console.warn(
            '[Browserslist] Could not parse ' + pkg + '. Ignoring it.'
          )
        }
      }

      if (isFile(config) && pkgBrowserslist) {
        throw new BrowserslistError(
          dir + ' contains both browserslist and package.json with browsers'
        )
      } else if (isFile(rc) && pkgBrowserslist) {
        throw new BrowserslistError(
          dir + ' contains both .browserslistrc and package.json with browsers'
        )
      } else if (isFile(config) && isFile(rc)) {
        throw new BrowserslistError(
          dir + ' contains both .browserslistrc and browserslist'
        )
      } else if (isFile(config)) {
        return module.exports.readConfig(config)
      } else if (isFile(rc)) {
        return module.exports.readConfig(rc)
      } else {
        return pkgBrowserslist
      }
    })
    if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
      passed.forEach(function (dir) {
        configCache[dir] = resolved
      })
    }
    return resolved
  },

  clearCaches: function clearCaches() {
    dataTimeChecked = false
    filenessCache = {}
    configCache = {}

    this.cache = {}
  },

  oldDataWarning: function oldDataWarning(agentsObj) {
    if (dataTimeChecked) return
    dataTimeChecked = true
    if (process.env.BROWSERSLIST_IGNORE_OLD_DATA) return

    var latest = latestReleaseTime(agentsObj)
    var halfYearAgo = Date.now() - TIME_TO_UPDATE_CANIUSE

    if (latest !== 0 && latest < halfYearAgo) {
      console.warn(
        'Browserslist: caniuse-lite is outdated. Please run:\n' +
          '  npx update-browserslist-db@latest\n' +
          '  Why you should do it regularly: ' +
          'https://github.com/browserslist/update-db#readme'
      )
    }
  },

  currentNode: function currentNode() {
    return 'node ' + process.versions.node
  },

  env: process.env
}


/***/ }),

/***/ 88046:
/***/ ((module) => {

var AND_REGEXP = /^\s+and\s+(.*)/i
var OR_REGEXP = /^(?:,\s*|\s+or\s+)(.*)/i

function flatten(array) {
  if (!Array.isArray(array)) return [array]
  return array.reduce(function (a, b) {
    return a.concat(flatten(b))
  }, [])
}

function find(string, predicate) {
  for (var n = 1, max = string.length; n <= max; n++) {
    var parsed = string.substr(-n, n)
    if (predicate(parsed, n, max)) {
      return string.slice(0, -n)
    }
  }
  return ''
}

function matchQuery(all, query) {
  var node = { query: query }
  if (query.indexOf('not ') === 0) {
    node.not = true
    query = query.slice(4)
  }

  for (var name in all) {
    var type = all[name]
    var match = query.match(type.regexp)
    if (match) {
      node.type = name
      for (var i = 0; i < type.matches.length; i++) {
        node[type.matches[i]] = match[i + 1]
      }
      return node
    }
  }

  node.type = 'unknown'
  return node
}

function matchBlock(all, string, qs) {
  var node
  return find(string, function (parsed, n, max) {
    if (AND_REGEXP.test(parsed)) {
      node = matchQuery(all, parsed.match(AND_REGEXP)[1])
      node.compose = 'and'
      qs.unshift(node)
      return true
    } else if (OR_REGEXP.test(parsed)) {
      node = matchQuery(all, parsed.match(OR_REGEXP)[1])
      node.compose = 'or'
      qs.unshift(node)
      return true
    } else if (n === max) {
      node = matchQuery(all, parsed.trim())
      node.compose = 'or'
      qs.unshift(node)
      return true
    }
    return false
  })
}

module.exports = function parse(all, queries) {
  if (!Array.isArray(queries)) queries = [queries]
  return flatten(
    queries.map(function (block) {
      var qs = []
      do {
        block = matchBlock(all, block, qs)
      } while (block)
      return qs
    })
  )
}


/***/ }),

/***/ 69227:
/***/ ((module) => {

"use strict";

const pattern = /-(\w|$)/g;

const callback = (dashChar, char) => char.toUpperCase();



const camelCaseCSS = property =>
{
	property = property.toLowerCase();

	// NOTE :: IE8's "styleFloat" is intentionally not supported
	if (property === "float")
	{
		return "cssFloat";
	}
	// Microsoft vendor-prefixes are uniquely cased
	else if (property.startsWith("-ms-"))
	{
		return property.substr(1).replace(pattern, callback);
	}
	else
	{
		return property.replace(pattern, callback);
	}
};



module.exports = camelCaseCSS;


/***/ }),

/***/ 306:
/***/ ((module) => {

module.exports={A:{A:{J:0.0131217,D:0.00621152,E:0.0530043,F:0.074206,A:0.0106009,B:0.508841,CC:0.009298},B:"ms",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","CC","J","D","E","F","A","B","","",""],E:"IE",F:{CC:962323200,J:998870400,D:1161129600,E:1237420800,F:1300060800,A:1346716800,B:1381968000}},B:{A:{C:0.007886,K:0.004267,L:0.004268,G:0.003943,M:0.003702,N:0.003943,O:0.015772,P:0,Q:0.004298,R:0.00944,S:0.004043,T:0.007886,U:0.007886,V:0.003943,W:0.003943,X:0.003943,Y:0.007886,Z:0.003943,a:0.003943,b:0.011829,c:0.004118,d:0.003939,e:0.003943,h:0.003943,i:0.003943,j:0.003929,k:0.003901,l:0.011829,m:0.007886,n:0.003943,o:0.011829,p:0.011829,q:0.011829,r:0.019715,s:0.102518,t:2.13316,f:1.95967,H:0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","C","K","L","G","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","h","i","j","k","l","m","n","o","p","q","r","s","t","f","H","","",""],E:"Edge",F:{C:1438128000,K:1447286400,L:1470096000,G:1491868800,M:1508198400,N:1525046400,O:1542067200,P:1579046400,Q:1581033600,R:1586736000,S:1590019200,T:1594857600,U:1598486400,V:1602201600,W:1605830400,X:1611360000,Y:1614816000,Z:1618358400,a:1622073600,b:1626912000,c:1630627200,d:1632441600,e:1634774400,h:1637539200,i:1641427200,j:1643932800,k:1646265600,l:1649635200,m:1651190400,n:1653955200,o:1655942400,p:1659657600,q:1661990400,r:1664755200,s:1666915200,t:1670198400,f:1673481600,H:1675900800},D:{C:"ms",K:"ms",L:"ms",G:"ms",M:"ms",N:"ms",O:"ms"}},C:{A:{"0":0.008786,"1":0.004118,"2":0.004317,"3":0.004393,"4":0.004418,"5":0.008834,"6":0.008322,"7":0.008928,"8":0.004471,"9":0.009284,DC:0.004118,tB:0.004271,I:0.011703,u:0.004879,J:0.020136,D:0.005725,E:0.004525,F:0.00533,A:0.004283,B:0.007886,C:0.004471,K:0.004486,L:0.00453,G:0.008322,M:0.004417,N:0.004425,O:0.004161,v:0.004443,w:0.004283,x:0.008322,y:0.013698,z:0.004161,AB:0.004707,BB:0.009076,CB:0.003943,DB:0.004783,EB:0.003929,FB:0.004783,GB:0.00487,HB:0.005029,IB:0.0047,JB:0.027601,KB:0.003943,LB:0.003867,MB:0.004525,NB:0.004293,OB:0.007886,PB:0.004538,QB:0.008282,RB:0.011601,SB:0.047316,TB:0.011601,UB:0.003929,VB:0.003974,WB:0.007886,XB:0.011601,YB:0.003939,uB:0.003943,ZB:0.003929,vB:0.004356,aB:0.004425,bB:0.008322,cB:0.00415,dB:0.004267,eB:0.003801,fB:0.004267,gB:0.003943,hB:0.00415,iB:0.004293,jB:0.004425,kB:0.003943,g:0.00415,lB:0.00415,mB:0.004318,nB:0.004356,oB:0.003974,pB:0.035487,P:0.003943,Q:0.003943,R:0.003943,wB:0.003943,S:0.003943,T:0.003929,U:0.004268,V:0.003801,W:0.011829,X:0.007886,Y:0.003943,Z:0.003943,a:0.011829,b:0.003801,c:0.003855,d:0.015772,e:0.003773,h:0.007886,i:0.003901,j:0.003901,k:0.003943,l:0.003943,m:0.003943,n:0.094632,o:0.043373,p:0.011829,q:0.023658,r:0.023658,s:0.047316,t:1.33668,f:0.760999,H:0.007886,xB:0,yB:0,EC:0.008786,FC:0.00487},B:"moz",C:["DC","tB","EC","FC","I","u","J","D","E","F","A","B","C","K","L","G","M","N","O","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9","AB","BB","CB","DB","EB","FB","GB","HB","IB","JB","KB","LB","MB","NB","OB","PB","QB","RB","SB","TB","UB","VB","WB","XB","YB","uB","ZB","vB","aB","bB","cB","dB","eB","fB","gB","hB","iB","jB","kB","g","lB","mB","nB","oB","pB","P","Q","R","wB","S","T","U","V","W","X","Y","Z","a","b","c","d","e","h","i","j","k","l","m","n","o","p","q","r","s","t","f","H","xB","yB",""],E:"Firefox",F:{"0":1375747200,"1":1379376000,"2":1386633600,"3":1391472000,"4":1395100800,"5":1398729600,"6":1402358400,"7":1405987200,"8":1409616000,"9":1413244800,DC:1161648000,tB:1213660800,EC:1246320000,FC:1264032000,I:1300752000,u:1308614400,J:1313452800,D:1317081600,E:1317081600,F:1320710400,A:1324339200,B:1327968000,C:1331596800,K:1335225600,L:1338854400,G:1342483200,M:1346112000,N:1349740800,O:1353628800,v:1357603200,w:1361232000,x:1364860800,y:1368489600,z:1372118400,AB:1417392000,BB:1421107200,CB:1424736000,DB:1428278400,EB:1431475200,FB:1435881600,GB:1439251200,HB:1442880000,IB:1446508800,JB:1450137600,KB:1453852800,LB:1457395200,MB:1461628800,NB:1465257600,OB:1470096000,PB:1474329600,QB:1479168000,RB:1485216000,SB:1488844800,TB:1492560000,UB:1497312000,VB:1502150400,WB:1506556800,XB:1510617600,YB:1516665600,uB:1520985600,ZB:1525824000,vB:1529971200,aB:1536105600,bB:1540252800,cB:1544486400,dB:1548720000,eB:1552953600,fB:1558396800,gB:1562630400,hB:1567468800,iB:1571788800,jB:1575331200,kB:1578355200,g:1581379200,lB:1583798400,mB:1586304000,nB:1588636800,oB:1591056000,pB:1593475200,P:1595894400,Q:1598313600,R:1600732800,wB:1603152000,S:1605571200,T:1607990400,U:1611619200,V:1614038400,W:1616457600,X:1618790400,Y:1622505600,Z:1626134400,a:1628553600,b:1630972800,c:1633392000,d:1635811200,e:1638835200,h:1641859200,i:1644364800,j:1646697600,k:1649116800,l:1651536000,m:1653955200,n:1656374400,o:1658793600,p:1661212800,q:1663632000,r:1666051200,s:1668470400,t:1670889600,f:1673913600,H:1676332800,xB:null,yB:null}},D:{A:{"0":0.003939,"1":0.004461,"2":0.004141,"3":0.004326,"4":0.0047,"5":0.004538,"6":0.008322,"7":0.008596,"8":0.004566,"9":0.004118,I:0.004706,u:0.004879,J:0.004879,D:0.005591,E:0.005591,F:0.005591,A:0.004534,B:0.004464,C:0.010424,K:0.0083,L:0.004706,G:0.015087,M:0.004393,N:0.004393,O:0.008652,v:0.008322,w:0.004393,x:0.004317,y:0.003901,z:0.008786,AB:0.007886,BB:0.007886,CB:0.004335,DB:0.004464,EB:0.015772,FB:0.003867,GB:0.015772,HB:0.003773,IB:0.003974,JB:0.003943,KB:0.007948,LB:0.003974,MB:0.003867,NB:0.007886,OB:0.019715,PB:0.043373,QB:0.003867,RB:0.003929,SB:0.007886,TB:0.007886,UB:0.003867,VB:0.003943,WB:0.086746,XB:0.003943,YB:0.015772,uB:0.003773,ZB:0.011829,vB:0.011319,aB:0.003773,bB:0.007886,cB:0.003943,dB:0.007886,eB:0.031544,fB:0.007886,gB:0.011829,hB:0.059145,iB:0.027601,jB:0.015772,kB:0.031544,g:0.011829,lB:0.043373,mB:0.047316,nB:0.031544,oB:0.015772,pB:0.027601,P:0.126176,Q:0.035487,R:0.03943,S:0.070974,T:0.043373,U:0.086746,V:0.074917,W:0.07886,X:0.027601,Y:0.043373,Z:0.051259,a:0.074917,b:0.063088,c:0.059145,d:0.051259,e:0.03943,h:0.067031,i:0.070974,j:0.126176,k:0.082803,l:0.094632,m:0.07886,n:0.110404,o:0.268124,p:0.11829,q:0.149834,r:0.138005,s:0.417958,t:11.2218,f:9.7471,H:0.019715,xB:0.019715,yB:0,GC:0},B:"webkit",C:["","","","","","I","u","J","D","E","F","A","B","C","K","L","G","M","N","O","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9","AB","BB","CB","DB","EB","FB","GB","HB","IB","JB","KB","LB","MB","NB","OB","PB","QB","RB","SB","TB","UB","VB","WB","XB","YB","uB","ZB","vB","aB","bB","cB","dB","eB","fB","gB","hB","iB","jB","kB","g","lB","mB","nB","oB","pB","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","h","i","j","k","l","m","n","o","p","q","r","s","t","f","H","xB","yB","GC"],E:"Chrome",F:{"0":1352246400,"1":1357862400,"2":1361404800,"3":1364428800,"4":1369094400,"5":1374105600,"6":1376956800,"7":1384214400,"8":1389657600,"9":1392940800,I:1264377600,u:1274745600,J:1283385600,D:1287619200,E:1291248000,F:1296777600,A:1299542400,B:1303862400,C:1307404800,K:1312243200,L:1316131200,G:1316131200,M:1319500800,N:1323734400,O:1328659200,v:1332892800,w:1337040000,x:1340668800,y:1343692800,z:1348531200,AB:1397001600,BB:1400544000,CB:1405468800,DB:1409011200,EB:1412640000,FB:1416268800,GB:1421798400,HB:1425513600,IB:1429401600,JB:1432080000,KB:1437523200,LB:1441152000,MB:1444780800,NB:1449014400,OB:1453248000,PB:1456963200,QB:1460592000,RB:1464134400,SB:1469059200,TB:1472601600,UB:1476230400,VB:1480550400,WB:1485302400,XB:1489017600,YB:1492560000,uB:1496707200,ZB:1500940800,vB:1504569600,aB:1508198400,bB:1512518400,cB:1516752000,dB:1520294400,eB:1523923200,fB:1527552000,gB:1532390400,hB:1536019200,iB:1539648000,jB:1543968000,kB:1548720000,g:1552348800,lB:1555977600,mB:1559606400,nB:1564444800,oB:1568073600,pB:1571702400,P:1575936000,Q:1580860800,R:1586304000,S:1589846400,T:1594684800,U:1598313600,V:1601942400,W:1605571200,X:1611014400,Y:1614556800,Z:1618272000,a:1621987200,b:1626739200,c:1630368000,d:1632268800,e:1634601600,h:1637020800,i:1641340800,j:1643673600,k:1646092800,l:1648512000,m:1650931200,n:1653350400,o:1655769600,p:1659398400,q:1661817600,r:1664236800,s:1666656000,t:1669680000,f:1673308800,H:1675728000,xB:null,yB:null,GC:null}},E:{A:{I:0,u:0.008322,J:0.004656,D:0.004465,E:0.003974,F:0.003929,A:0.004425,B:0.004318,C:0.003801,K:0.023658,L:0.098575,G:0.023658,HC:0,zB:0.008692,IC:0.007886,JC:0.00456,KC:0.004283,LC:0.047316,"0B":0.007802,qB:0.007886,rB:0.031544,"1B":0.177435,MC:0.252352,NC:0.03943,"2B":0.03943,"3B":0.090689,"4B":0.181378,"5B":1.13558,sB:0.126176,"6B":0.410072,"7B":0.808315,"8B":0.055202,"9B":0,OC:0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","HC","zB","I","u","IC","J","JC","D","KC","E","F","LC","A","0B","B","qB","C","rB","K","1B","L","MC","G","NC","2B","3B","4B","5B","sB","6B","7B","8B","9B","OC",""],E:"Safari",F:{HC:1205798400,zB:1226534400,I:1244419200,u:1275868800,IC:1311120000,J:1343174400,JC:1382400000,D:1382400000,KC:1410998400,E:1413417600,F:1443657600,LC:1458518400,A:1474329600,"0B":1490572800,B:1505779200,qB:1522281600,C:1537142400,rB:1553472000,K:1568851200,"1B":1585008000,L:1600214400,MC:1619395200,G:1632096000,NC:1635292800,"2B":1639353600,"3B":1647216000,"4B":1652745600,"5B":1658275200,sB:1662940800,"6B":1666569600,"7B":1670889600,"8B":1674432000,"9B":null,OC:null}},F:{A:{"0":0.006702,"1":0.006015,"2":0.005595,"3":0.004393,"4":0.007886,"5":0.004879,"6":0.004879,"7":0.003943,"8":0.005152,"9":0.005014,F:0.0082,B:0.016581,C:0.004317,G:0.00685,M:0.00685,N:0.00685,O:0.005014,v:0.006015,w:0.004879,x:0.006597,y:0.006597,z:0.013434,AB:0.009758,BB:0.004879,CB:0.007886,DB:0.004283,EB:0.004367,FB:0.004534,GB:0.007886,HB:0.004227,IB:0.004418,JB:0.004161,KB:0.004227,LB:0.004725,MB:0.011829,NB:0.008942,OB:0.004707,PB:0.004827,QB:0.004707,RB:0.004707,SB:0.004326,TB:0.008922,UB:0.014349,VB:0.004425,WB:0.00472,XB:0.004425,YB:0.004425,ZB:0.00472,aB:0.004532,bB:0.004566,cB:0.02283,dB:0.00867,eB:0.004656,fB:0.004642,gB:0.003929,hB:0.00944,iB:0.004293,jB:0.003929,kB:0.004298,g:0.096692,lB:0.004201,mB:0.004141,nB:0.004257,oB:0.003939,pB:0.008236,P:0.003855,Q:0.003939,R:0.008514,wB:0.003939,S:0.003939,T:0.003702,U:0.007886,V:0.003855,W:0.003855,X:0.003929,Y:0.003943,Z:0.011703,a:0.007546,b:0.011829,c:0.496818,d:0.690025,e:0,PC:0.00685,QC:0,RC:0.008392,SC:0.004706,qB:0.006229,AC:0.004879,TC:0.008786,rB:0.00472},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","F","PC","QC","RC","SC","B","qB","AC","TC","C","rB","G","M","N","O","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9","AB","BB","CB","DB","EB","FB","GB","HB","IB","JB","KB","LB","MB","NB","OB","PB","QB","RB","SB","TB","UB","VB","WB","XB","YB","ZB","aB","bB","cB","dB","eB","fB","gB","hB","iB","jB","kB","g","lB","mB","nB","oB","pB","P","Q","R","wB","S","T","U","V","W","X","Y","Z","a","b","c","d","e","","",""],E:"Opera",F:{"0":1409616000,"1":1413331200,"2":1417132800,"3":1422316800,"4":1425945600,"5":1430179200,"6":1433808000,"7":1438646400,"8":1442448000,"9":1445904000,F:1150761600,PC:1223424000,QC:1251763200,RC:1267488000,SC:1277942400,B:1292457600,qB:1302566400,AC:1309219200,TC:1323129600,C:1323129600,rB:1352073600,G:1372723200,M:1377561600,N:1381104000,O:1386288000,v:1390867200,w:1393891200,x:1399334400,y:1401753600,z:1405987200,AB:1449100800,BB:1454371200,CB:1457308800,DB:1462320000,EB:1465344000,FB:1470096000,GB:1474329600,HB:1477267200,IB:1481587200,JB:1486425600,KB:1490054400,LB:1494374400,MB:1498003200,NB:1502236800,OB:1506470400,PB:1510099200,QB:1515024000,RB:1517961600,SB:1521676800,TB:1525910400,UB:1530144000,VB:1534982400,WB:1537833600,XB:1543363200,YB:1548201600,ZB:1554768000,aB:1561593600,bB:1566259200,cB:1570406400,dB:1573689600,eB:1578441600,fB:1583971200,gB:1587513600,hB:1592956800,iB:1595894400,jB:1600128000,kB:1603238400,g:1613520000,lB:1612224000,mB:1616544000,nB:1619568000,oB:1623715200,pB:1627948800,P:1631577600,Q:1633392000,R:1635984000,wB:1638403200,S:1642550400,T:1644969600,U:1647993600,V:1650412800,W:1652745600,X:1654646400,Y:1657152000,Z:1660780800,a:1663113600,b:1668816000,c:1668643200,d:1671062400,e:1675209600},D:{F:"o",B:"o",C:"o",PC:"o",QC:"o",RC:"o",SC:"o",qB:"o",AC:"o",TC:"o",rB:"o"}},G:{A:{E:0,zB:0,UC:0,BC:0.00157571,VC:0.00315142,WC:0.00315142,XC:0.0126057,YC:0.00630284,ZC:0.0157571,aC:0.0583013,bC:0.00630284,cC:0.1103,dC:0.0267871,eC:0.0252114,fC:0.0220599,gC:0.395503,hC:0.0330899,iC:0.0236357,jC:0.0346656,kC:0.105573,lC:0.288355,mC:0.567256,nC:0.157571,"2B":0.207994,"3B":0.250538,"4B":0.472713,"5B":1.89085,sB:1.7837,"6B":4.8784,"7B":3.17191,"8B":0.237932,"9B":0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","zB","UC","BC","VC","WC","XC","E","YC","ZC","aC","bC","cC","dC","eC","fC","gC","hC","iC","jC","kC","lC","mC","nC","2B","3B","4B","5B","sB","6B","7B","8B","9B","",""],E:"Safari on iOS",F:{zB:1270252800,UC:1283904000,BC:1299628800,VC:1331078400,WC:1359331200,XC:1394409600,E:1410912000,YC:1413763200,ZC:1442361600,aC:1458518400,bC:1473724800,cC:1490572800,dC:1505779200,eC:1522281600,fC:1537142400,gC:1553472000,hC:1568851200,iC:1572220800,jC:1580169600,kC:1585008000,lC:1600214400,mC:1619395200,nC:1632096000,"2B":1639353600,"3B":1647216000,"4B":1652659200,"5B":1658275200,sB:1662940800,"6B":1666569600,"7B":1670889600,"8B":1674432000,"9B":null}},H:{A:{oC:1.01498},B:"o",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","oC","","",""],E:"Opera Mini",F:{oC:1426464000}},I:{A:{tB:0,I:0.0286543,f:0,pC:0,qC:0,rC:0,sC:0.0764114,BC:0.0764114,tC:0,uC:0.315197},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","pC","qC","rC","tB","I","sC","BC","tC","uC","f","","",""],E:"Android Browser",F:{pC:1256515200,qC:1274313600,rC:1291593600,tB:1298332800,I:1318896000,sC:1341792000,BC:1374624000,tC:1386547200,uC:1401667200,f:1673568000}},J:{A:{D:0,A:0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","D","A","","",""],E:"Blackberry Browser",F:{D:1325376000,A:1359504000}},K:{A:{A:0,B:0,C:0,g:0.0111391,qB:0,AC:0,rB:0},B:"o",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","A","B","qB","AC","C","rB","g","","",""],E:"Opera Mobile",F:{A:1287100800,B:1300752000,qB:1314835200,AC:1318291200,C:1330300800,rB:1349740800,g:1673827200},D:{g:"webkit"}},L:{A:{H:41.3632},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","H","","",""],E:"Chrome for Android",F:{H:1675728000}},M:{A:{H:0.30285},B:"moz",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","H","","",""],E:"Firefox for Android",F:{H:1676332800}},N:{A:{A:0.0115934,B:0.022664},B:"ms",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","A","B","","",""],E:"IE Mobile",F:{A:1340150400,B:1353456000}},O:{A:{vC:0.890379},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","vC","","",""],E:"UC Browser for Android",F:{vC:1634688000},D:{vC:"webkit"}},P:{A:{I:0.147734,wC:0.0103543,xC:0.010304,yC:0.0527621,zC:0.0103584,"0C":0.0104443,"0B":0.0105043,"1C":0.0211049,"2C":0.0105524,"3C":0.0316573,"4C":0.0316573,"5C":0.0211049,sB:0.073867,"6C":0.0844194,"7C":0.126629,"8C":2.09993},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","I","wC","xC","yC","zC","0C","0B","1C","2C","3C","4C","5C","sB","6C","7C","8C","","",""],E:"Samsung Internet",F:{I:1461024000,wC:1481846400,xC:1509408000,yC:1528329600,zC:1546128000,"0C":1554163200,"0B":1567900800,"1C":1582588800,"2C":1593475200,"3C":1605657600,"4C":1618531200,"5C":1629072000,sB:1640736000,"6C":1651708800,"7C":1659657600,"8C":1667260800}},Q:{A:{"1B":0.145368},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","1B","","",""],E:"QQ Browser",F:{"1B":1663718400}},R:{A:{"9C":0},B:"webkit",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","9C","","",""],E:"Baidu Browser",F:{"9C":1663027200}},S:{A:{AD:0.066627},B:"moz",C:["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","AD","","",""],E:"KaiOS Browser",F:{AD:1527811200}}};


/***/ }),

/***/ 95582:
/***/ ((module) => {

module.exports={"0":"24","1":"25","2":"26","3":"27","4":"28","5":"29","6":"30","7":"31","8":"32","9":"33",A:"10",B:"11",C:"12",D:"7",E:"8",F:"9",G:"15",H:"110",I:"4",J:"6",K:"13",L:"14",M:"16",N:"17",O:"18",P:"79",Q:"80",R:"81",S:"83",T:"84",U:"85",V:"86",W:"87",X:"88",Y:"89",Z:"90",a:"91",b:"92",c:"93",d:"94",e:"95",f:"109",g:"73",h:"96",i:"97",j:"98",k:"99",l:"100",m:"101",n:"102",o:"103",p:"104",q:"105",r:"106",s:"107",t:"108",u:"5",v:"19",w:"20",x:"21",y:"22",z:"23",AB:"34",BB:"35",CB:"36",DB:"37",EB:"38",FB:"39",GB:"40",HB:"41",IB:"42",JB:"43",KB:"44",LB:"45",MB:"46",NB:"47",OB:"48",PB:"49",QB:"50",RB:"51",SB:"52",TB:"53",UB:"54",VB:"55",WB:"56",XB:"57",YB:"58",ZB:"60",aB:"62",bB:"63",cB:"64",dB:"65",eB:"66",fB:"67",gB:"68",hB:"69",iB:"70",jB:"71",kB:"72",lB:"74",mB:"75",nB:"76",oB:"77",pB:"78",qB:"11.1",rB:"12.1",sB:"16.0",tB:"3",uB:"59",vB:"61",wB:"82",xB:"111",yB:"112",zB:"3.2","0B":"10.1","1B":"13.1","2B":"15.2-15.3","3B":"15.4","4B":"15.5","5B":"15.6","6B":"16.1","7B":"16.2","8B":"16.3","9B":"16.4",AC:"11.5",BC:"4.2-4.3",CC:"5.5",DC:"2",EC:"3.5",FC:"3.6",GC:"113",HC:"3.1",IC:"5.1",JC:"6.1",KC:"7.1",LC:"9.1",MC:"14.1",NC:"15.1",OC:"TP",PC:"9.5-9.6",QC:"10.0-10.1",RC:"10.5",SC:"10.6",TC:"11.6",UC:"4.0-4.1",VC:"5.0-5.1",WC:"6.0-6.1",XC:"7.0-7.1",YC:"8.1-8.4",ZC:"9.0-9.2",aC:"9.3",bC:"10.0-10.2",cC:"10.3",dC:"11.0-11.2",eC:"11.3-11.4",fC:"12.0-12.1",gC:"12.2-12.5",hC:"13.0-13.1",iC:"13.2",jC:"13.3",kC:"13.4-13.7",lC:"14.0-14.4",mC:"14.5-14.8",nC:"15.0-15.1",oC:"all",pC:"2.1",qC:"2.2",rC:"2.3",sC:"4.1",tC:"4.4",uC:"4.4.3-4.4.4",vC:"13.4",wC:"5.0-5.4",xC:"6.2-6.4",yC:"7.2-7.4",zC:"8.2","0C":"9.2","1C":"11.1-11.2","2C":"12.0","3C":"13.0","4C":"14.0","5C":"15.0","6C":"17.0","7C":"18.0","8C":"19.0","9C":"13.18",AD:"2.5"};


/***/ }),

/***/ 69178:
/***/ ((module) => {

module.exports={A:"ie",B:"edge",C:"firefox",D:"chrome",E:"safari",F:"opera",G:"ios_saf",H:"op_mini",I:"android",J:"bb",K:"op_mob",L:"and_chr",M:"and_ff",N:"ie_mob",O:"and_uc",P:"samsung",Q:"and_qq",R:"baidu",S:"kaios"};


/***/ }),

/***/ 28649:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports={"aac":__nccwpck_require__(22041),"abortcontroller":__nccwpck_require__(58633),"ac3-ec3":__nccwpck_require__(16821),"accelerometer":__nccwpck_require__(64181),"addeventlistener":__nccwpck_require__(31621),"alternate-stylesheet":__nccwpck_require__(18627),"ambient-light":__nccwpck_require__(12148),"apng":__nccwpck_require__(2312),"array-find-index":__nccwpck_require__(79271),"array-find":__nccwpck_require__(39299),"array-flat":__nccwpck_require__(38626),"array-includes":__nccwpck_require__(33189),"arrow-functions":__nccwpck_require__(72093),"asmjs":__nccwpck_require__(72303),"async-clipboard":__nccwpck_require__(40152),"async-functions":__nccwpck_require__(49000),"atob-btoa":__nccwpck_require__(37179),"audio-api":__nccwpck_require__(70873),"audio":__nccwpck_require__(6398),"audiotracks":__nccwpck_require__(77417),"autofocus":__nccwpck_require__(91333),"auxclick":__nccwpck_require__(638),"av1":__nccwpck_require__(14604),"avif":__nccwpck_require__(66762),"background-attachment":__nccwpck_require__(41394),"background-clip-text":__nccwpck_require__(13197),"background-img-opts":__nccwpck_require__(22115),"background-position-x-y":__nccwpck_require__(4414),"background-repeat-round-space":__nccwpck_require__(74678),"background-sync":__nccwpck_require__(99995),"battery-status":__nccwpck_require__(96576),"beacon":__nccwpck_require__(33903),"beforeafterprint":__nccwpck_require__(38484),"bigint":__nccwpck_require__(88210),"blobbuilder":__nccwpck_require__(43840),"bloburls":__nccwpck_require__(75394),"border-image":__nccwpck_require__(14915),"border-radius":__nccwpck_require__(72853),"broadcastchannel":__nccwpck_require__(35485),"brotli":__nccwpck_require__(67933),"calc":__nccwpck_require__(287),"canvas-blending":__nccwpck_require__(39321),"canvas-text":__nccwpck_require__(35888),"canvas":__nccwpck_require__(66710),"ch-unit":__nccwpck_require__(30814),"chacha20-poly1305":__nccwpck_require__(34099),"channel-messaging":__nccwpck_require__(610),"childnode-remove":__nccwpck_require__(40258),"classlist":__nccwpck_require__(33077),"client-hints-dpr-width-viewport":__nccwpck_require__(26164),"clipboard":__nccwpck_require__(28546),"colr-v1":__nccwpck_require__(97491),"colr":__nccwpck_require__(22303),"comparedocumentposition":__nccwpck_require__(2004),"console-basic":__nccwpck_require__(30695),"console-time":__nccwpck_require__(15498),"const":__nccwpck_require__(67727),"constraint-validation":__nccwpck_require__(92806),"contenteditable":__nccwpck_require__(46638),"contentsecuritypolicy":__nccwpck_require__(90370),"contentsecuritypolicy2":__nccwpck_require__(39564),"cookie-store-api":__nccwpck_require__(71369),"cors":__nccwpck_require__(96637),"createimagebitmap":__nccwpck_require__(25702),"credential-management":__nccwpck_require__(32011),"cryptography":__nccwpck_require__(91342),"css-all":__nccwpck_require__(55211),"css-animation":__nccwpck_require__(40083),"css-any-link":__nccwpck_require__(2031),"css-appearance":__nccwpck_require__(3599),"css-at-counter-style":__nccwpck_require__(2769),"css-autofill":__nccwpck_require__(71327),"css-backdrop-filter":__nccwpck_require__(74043),"css-background-offsets":__nccwpck_require__(29407),"css-backgroundblendmode":__nccwpck_require__(98732),"css-boxdecorationbreak":__nccwpck_require__(81371),"css-boxshadow":__nccwpck_require__(22004),"css-canvas":__nccwpck_require__(34651),"css-caret-color":__nccwpck_require__(3560),"css-cascade-layers":__nccwpck_require__(92931),"css-case-insensitive":__nccwpck_require__(4497),"css-clip-path":__nccwpck_require__(37028),"css-color-adjust":__nccwpck_require__(75747),"css-color-function":__nccwpck_require__(4008),"css-conic-gradients":__nccwpck_require__(31811),"css-container-queries-style":__nccwpck_require__(45652),"css-container-queries":__nccwpck_require__(61547),"css-container-query-units":__nccwpck_require__(54912),"css-containment":__nccwpck_require__(64484),"css-content-visibility":__nccwpck_require__(69511),"css-counters":__nccwpck_require__(11237),"css-crisp-edges":__nccwpck_require__(36717),"css-cross-fade":__nccwpck_require__(90831),"css-default-pseudo":__nccwpck_require__(99030),"css-descendant-gtgt":__nccwpck_require__(14942),"css-deviceadaptation":__nccwpck_require__(83318),"css-dir-pseudo":__nccwpck_require__(15902),"css-display-contents":__nccwpck_require__(45140),"css-element-function":__nccwpck_require__(21694),"css-env-function":__nccwpck_require__(21809),"css-exclusions":__nccwpck_require__(79991),"css-featurequeries":__nccwpck_require__(53231),"css-file-selector-button":__nccwpck_require__(23619),"css-filter-function":__nccwpck_require__(19533),"css-filters":__nccwpck_require__(35123),"css-first-letter":__nccwpck_require__(95006),"css-first-line":__nccwpck_require__(34624),"css-fixed":__nccwpck_require__(4787),"css-focus-visible":__nccwpck_require__(59934),"css-focus-within":__nccwpck_require__(1620),"css-font-palette":__nccwpck_require__(25680),"css-font-rendering-controls":__nccwpck_require__(80882),"css-font-stretch":__nccwpck_require__(6482),"css-gencontent":__nccwpck_require__(49718),"css-gradients":__nccwpck_require__(13657),"css-grid-animation":__nccwpck_require__(42734),"css-grid":__nccwpck_require__(19330),"css-hanging-punctuation":__nccwpck_require__(59804),"css-has":__nccwpck_require__(28790),"css-hyphens":__nccwpck_require__(89317),"css-image-orientation":__nccwpck_require__(38133),"css-image-set":__nccwpck_require__(2762),"css-in-out-of-range":__nccwpck_require__(88654),"css-indeterminate-pseudo":__nccwpck_require__(61436),"css-initial-letter":__nccwpck_require__(68010),"css-initial-value":__nccwpck_require__(52764),"css-lch-lab":__nccwpck_require__(50264),"css-letter-spacing":__nccwpck_require__(6661),"css-line-clamp":__nccwpck_require__(12931),"css-logical-props":__nccwpck_require__(23871),"css-marker-pseudo":__nccwpck_require__(35371),"css-masks":__nccwpck_require__(15592),"css-matches-pseudo":__nccwpck_require__(45820),"css-math-functions":__nccwpck_require__(15868),"css-media-interaction":__nccwpck_require__(22427),"css-media-range-syntax":__nccwpck_require__(55176),"css-media-resolution":__nccwpck_require__(79494),"css-media-scripting":__nccwpck_require__(78527),"css-mediaqueries":__nccwpck_require__(47055),"css-mixblendmode":__nccwpck_require__(93831),"css-motion-paths":__nccwpck_require__(46876),"css-namespaces":__nccwpck_require__(9028),"css-nesting":__nccwpck_require__(6355),"css-not-sel-list":__nccwpck_require__(92481),"css-nth-child-of":__nccwpck_require__(66492),"css-opacity":__nccwpck_require__(23375),"css-optional-pseudo":__nccwpck_require__(93492),"css-overflow-anchor":__nccwpck_require__(11721),"css-overflow-overlay":__nccwpck_require__(74065),"css-overflow":__nccwpck_require__(91764),"css-overscroll-behavior":__nccwpck_require__(50237),"css-page-break":__nccwpck_require__(88866),"css-paged-media":__nccwpck_require__(76098),"css-paint-api":__nccwpck_require__(10133),"css-placeholder-shown":__nccwpck_require__(70361),"css-placeholder":__nccwpck_require__(83448),"css-print-color-adjust":__nccwpck_require__(51055),"css-read-only-write":__nccwpck_require__(17667),"css-rebeccapurple":__nccwpck_require__(32723),"css-reflections":__nccwpck_require__(25056),"css-regions":__nccwpck_require__(32598),"css-repeating-gradients":__nccwpck_require__(62787),"css-resize":__nccwpck_require__(36660),"css-revert-value":__nccwpck_require__(47190),"css-rrggbbaa":__nccwpck_require__(87215),"css-scroll-behavior":__nccwpck_require__(58544),"css-scroll-timeline":__nccwpck_require__(52572),"css-scrollbar":__nccwpck_require__(37851),"css-sel2":__nccwpck_require__(92398),"css-sel3":__nccwpck_require__(40787),"css-selection":__nccwpck_require__(16302),"css-shapes":__nccwpck_require__(56938),"css-snappoints":__nccwpck_require__(82776),"css-sticky":__nccwpck_require__(67425),"css-subgrid":__nccwpck_require__(70836),"css-supports-api":__nccwpck_require__(43295),"css-table":__nccwpck_require__(57271),"css-text-align-last":__nccwpck_require__(68887),"css-text-indent":__nccwpck_require__(34715),"css-text-justify":__nccwpck_require__(83983),"css-text-orientation":__nccwpck_require__(80045),"css-text-spacing":__nccwpck_require__(75688),"css-textshadow":__nccwpck_require__(43548),"css-touch-action":__nccwpck_require__(8517),"css-transitions":__nccwpck_require__(61964),"css-unicode-bidi":__nccwpck_require__(45257),"css-unset-value":__nccwpck_require__(50750),"css-variables":__nccwpck_require__(32973),"css-when-else":__nccwpck_require__(77028),"css-widows-orphans":__nccwpck_require__(47477),"css-width-stretch":__nccwpck_require__(80847),"css-writing-mode":__nccwpck_require__(47816),"css-zoom":__nccwpck_require__(26061),"css3-attr":__nccwpck_require__(26203),"css3-boxsizing":__nccwpck_require__(47610),"css3-colors":__nccwpck_require__(91578),"css3-cursors-grab":__nccwpck_require__(63355),"css3-cursors-newer":__nccwpck_require__(70800),"css3-cursors":__nccwpck_require__(73281),"css3-tabsize":__nccwpck_require__(87604),"currentcolor":__nccwpck_require__(66010),"custom-elements":__nccwpck_require__(89306),"custom-elementsv1":__nccwpck_require__(68426),"customevent":__nccwpck_require__(96529),"datalist":__nccwpck_require__(61338),"dataset":__nccwpck_require__(80410),"datauri":__nccwpck_require__(57593),"date-tolocaledatestring":__nccwpck_require__(57488),"declarative-shadow-dom":__nccwpck_require__(96490),"decorators":__nccwpck_require__(27519),"details":__nccwpck_require__(55777),"deviceorientation":__nccwpck_require__(30111),"devicepixelratio":__nccwpck_require__(57084),"dialog":__nccwpck_require__(84530),"dispatchevent":__nccwpck_require__(63229),"dnssec":__nccwpck_require__(15381),"do-not-track":__nccwpck_require__(3481),"document-currentscript":__nccwpck_require__(88864),"document-evaluate-xpath":__nccwpck_require__(93781),"document-execcommand":__nccwpck_require__(24147),"document-policy":__nccwpck_require__(39985),"document-scrollingelement":__nccwpck_require__(55988),"documenthead":__nccwpck_require__(2001),"dom-manip-convenience":__nccwpck_require__(64198),"dom-range":__nccwpck_require__(3563),"domcontentloaded":__nccwpck_require__(38057),"dommatrix":__nccwpck_require__(31943),"download":__nccwpck_require__(49291),"dragndrop":__nccwpck_require__(625),"element-closest":__nccwpck_require__(54805),"element-from-point":__nccwpck_require__(25808),"element-scroll-methods":__nccwpck_require__(80674),"eme":__nccwpck_require__(21671),"eot":__nccwpck_require__(51180),"es5":__nccwpck_require__(62719),"es6-class":__nccwpck_require__(54682),"es6-generators":__nccwpck_require__(6483),"es6-module-dynamic-import":__nccwpck_require__(69972),"es6-module":__nccwpck_require__(33513),"es6-number":__nccwpck_require__(24785),"es6-string-includes":__nccwpck_require__(41908),"es6":__nccwpck_require__(76634),"eventsource":__nccwpck_require__(99513),"extended-system-fonts":__nccwpck_require__(29486),"feature-policy":__nccwpck_require__(6411),"fetch":__nccwpck_require__(80486),"fieldset-disabled":__nccwpck_require__(35953),"fileapi":__nccwpck_require__(61730),"filereader":__nccwpck_require__(92314),"filereadersync":__nccwpck_require__(80418),"filesystem":__nccwpck_require__(13394),"flac":__nccwpck_require__(37012),"flexbox-gap":__nccwpck_require__(2448),"flexbox":__nccwpck_require__(48976),"flow-root":__nccwpck_require__(37107),"focusin-focusout-events":__nccwpck_require__(3162),"font-family-system-ui":__nccwpck_require__(92562),"font-feature":__nccwpck_require__(26538),"font-kerning":__nccwpck_require__(88367),"font-loading":__nccwpck_require__(90792),"font-size-adjust":__nccwpck_require__(60647),"font-smooth":__nccwpck_require__(21936),"font-unicode-range":__nccwpck_require__(88108),"font-variant-alternates":__nccwpck_require__(90534),"font-variant-numeric":__nccwpck_require__(85199),"fontface":__nccwpck_require__(90829),"form-attribute":__nccwpck_require__(32662),"form-submit-attributes":__nccwpck_require__(37913),"form-validation":__nccwpck_require__(17644),"forms":__nccwpck_require__(68112),"fullscreen":__nccwpck_require__(99086),"gamepad":__nccwpck_require__(66952),"geolocation":__nccwpck_require__(64161),"getboundingclientrect":__nccwpck_require__(73165),"getcomputedstyle":__nccwpck_require__(43665),"getelementsbyclassname":__nccwpck_require__(85337),"getrandomvalues":__nccwpck_require__(26199),"gyroscope":__nccwpck_require__(49966),"hardwareconcurrency":__nccwpck_require__(89006),"hashchange":__nccwpck_require__(62563),"heif":__nccwpck_require__(56666),"hevc":__nccwpck_require__(64206),"hidden":__nccwpck_require__(6027),"high-resolution-time":__nccwpck_require__(88772),"history":__nccwpck_require__(81648),"html-media-capture":__nccwpck_require__(64940),"html5semantic":__nccwpck_require__(72753),"http-live-streaming":__nccwpck_require__(15638),"http2":__nccwpck_require__(16824),"http3":__nccwpck_require__(70549),"iframe-sandbox":__nccwpck_require__(76002),"iframe-seamless":__nccwpck_require__(82891),"iframe-srcdoc":__nccwpck_require__(72100),"imagecapture":__nccwpck_require__(16659),"ime":__nccwpck_require__(54606),"img-naturalwidth-naturalheight":__nccwpck_require__(35720),"import-maps":__nccwpck_require__(64548),"imports":__nccwpck_require__(72563),"indeterminate-checkbox":__nccwpck_require__(66518),"indexeddb":__nccwpck_require__(78797),"indexeddb2":__nccwpck_require__(11395),"inline-block":__nccwpck_require__(7354),"innertext":__nccwpck_require__(40674),"input-autocomplete-onoff":__nccwpck_require__(60328),"input-color":__nccwpck_require__(24411),"input-datetime":__nccwpck_require__(41858),"input-email-tel-url":__nccwpck_require__(65488),"input-event":__nccwpck_require__(56301),"input-file-accept":__nccwpck_require__(3024),"input-file-directory":__nccwpck_require__(77213),"input-file-multiple":__nccwpck_require__(64907),"input-inputmode":__nccwpck_require__(75178),"input-minlength":__nccwpck_require__(90453),"input-number":__nccwpck_require__(90754),"input-pattern":__nccwpck_require__(70620),"input-placeholder":__nccwpck_require__(45840),"input-range":__nccwpck_require__(19303),"input-search":__nccwpck_require__(86763),"input-selection":__nccwpck_require__(48804),"insert-adjacent":__nccwpck_require__(36404),"insertadjacenthtml":__nccwpck_require__(20379),"internationalization":__nccwpck_require__(558),"intersectionobserver-v2":__nccwpck_require__(16414),"intersectionobserver":__nccwpck_require__(93717),"intl-pluralrules":__nccwpck_require__(14130),"intrinsic-width":__nccwpck_require__(56835),"jpeg2000":__nccwpck_require__(99137),"jpegxl":__nccwpck_require__(58083),"jpegxr":__nccwpck_require__(70525),"js-regexp-lookbehind":__nccwpck_require__(91191),"json":__nccwpck_require__(92815),"justify-content-space-evenly":__nccwpck_require__(37001),"kerning-pairs-ligatures":__nccwpck_require__(82612),"keyboardevent-charcode":__nccwpck_require__(7891),"keyboardevent-code":__nccwpck_require__(39598),"keyboardevent-getmodifierstate":__nccwpck_require__(87626),"keyboardevent-key":__nccwpck_require__(98685),"keyboardevent-location":__nccwpck_require__(90035),"keyboardevent-which":__nccwpck_require__(82586),"lazyload":__nccwpck_require__(23230),"let":__nccwpck_require__(51884),"link-icon-png":__nccwpck_require__(42789),"link-icon-svg":__nccwpck_require__(4506),"link-rel-dns-prefetch":__nccwpck_require__(66458),"link-rel-modulepreload":__nccwpck_require__(36767),"link-rel-preconnect":__nccwpck_require__(67578),"link-rel-prefetch":__nccwpck_require__(31145),"link-rel-preload":__nccwpck_require__(7015),"link-rel-prerender":__nccwpck_require__(74778),"loading-lazy-attr":__nccwpck_require__(11394),"localecompare":__nccwpck_require__(89380),"magnetometer":__nccwpck_require__(19271),"matchesselector":__nccwpck_require__(71184),"matchmedia":__nccwpck_require__(66743),"mathml":__nccwpck_require__(35717),"maxlength":__nccwpck_require__(16924),"mdn-css-unicode-bidi-isolate-override":__nccwpck_require__(19567),"mdn-css-unicode-bidi-isolate":__nccwpck_require__(55195),"mdn-css-unicode-bidi-plaintext":__nccwpck_require__(27489),"mdn-text-decoration-color":__nccwpck_require__(83460),"mdn-text-decoration-line":__nccwpck_require__(42320),"mdn-text-decoration-shorthand":__nccwpck_require__(2644),"mdn-text-decoration-style":__nccwpck_require__(73110),"media-fragments":__nccwpck_require__(6277),"mediacapture-fromelement":__nccwpck_require__(84279),"mediarecorder":__nccwpck_require__(55997),"mediasource":__nccwpck_require__(32348),"menu":__nccwpck_require__(89056),"meta-theme-color":__nccwpck_require__(69895),"meter":__nccwpck_require__(44701),"midi":__nccwpck_require__(83250),"minmaxwh":__nccwpck_require__(55879),"mp3":__nccwpck_require__(59447),"mpeg-dash":__nccwpck_require__(374),"mpeg4":__nccwpck_require__(33463),"multibackgrounds":__nccwpck_require__(19069),"multicolumn":__nccwpck_require__(24233),"mutation-events":__nccwpck_require__(90072),"mutationobserver":__nccwpck_require__(98212),"namevalue-storage":__nccwpck_require__(80611),"native-filesystem-api":__nccwpck_require__(7576),"nav-timing":__nccwpck_require__(73272),"netinfo":__nccwpck_require__(1493),"notifications":__nccwpck_require__(54483),"object-entries":__nccwpck_require__(69577),"object-fit":__nccwpck_require__(6228),"object-observe":__nccwpck_require__(63008),"object-values":__nccwpck_require__(55480),"objectrtc":__nccwpck_require__(39611),"offline-apps":__nccwpck_require__(45884),"offscreencanvas":__nccwpck_require__(74509),"ogg-vorbis":__nccwpck_require__(77081),"ogv":__nccwpck_require__(18398),"ol-reversed":__nccwpck_require__(67096),"once-event-listener":__nccwpck_require__(79713),"online-status":__nccwpck_require__(11219),"opus":__nccwpck_require__(12205),"orientation-sensor":__nccwpck_require__(77294),"outline":__nccwpck_require__(28311),"pad-start-end":__nccwpck_require__(42502),"page-transition-events":__nccwpck_require__(72796),"pagevisibility":__nccwpck_require__(87772),"passive-event-listener":__nccwpck_require__(50754),"passwordrules":__nccwpck_require__(28403),"path2d":__nccwpck_require__(13066),"payment-request":__nccwpck_require__(36954),"pdf-viewer":__nccwpck_require__(31504),"permissions-api":__nccwpck_require__(98901),"permissions-policy":__nccwpck_require__(17093),"picture-in-picture":__nccwpck_require__(2610),"picture":__nccwpck_require__(85312),"ping":__nccwpck_require__(96744),"png-alpha":__nccwpck_require__(54659),"pointer-events":__nccwpck_require__(2224),"pointer":__nccwpck_require__(27252),"pointerlock":__nccwpck_require__(50221),"portals":__nccwpck_require__(72388),"prefers-color-scheme":__nccwpck_require__(93412),"prefers-reduced-motion":__nccwpck_require__(21506),"progress":__nccwpck_require__(31127),"promise-finally":__nccwpck_require__(22438),"promises":__nccwpck_require__(26044),"proximity":__nccwpck_require__(93871),"proxy":__nccwpck_require__(88321),"publickeypinning":__nccwpck_require__(29636),"push-api":__nccwpck_require__(39446),"queryselector":__nccwpck_require__(78361),"readonly-attr":__nccwpck_require__(21513),"referrer-policy":__nccwpck_require__(68504),"registerprotocolhandler":__nccwpck_require__(35575),"rel-noopener":__nccwpck_require__(67634),"rel-noreferrer":__nccwpck_require__(53615),"rellist":__nccwpck_require__(40764),"rem":__nccwpck_require__(49123),"requestanimationframe":__nccwpck_require__(10380),"requestidlecallback":__nccwpck_require__(28670),"resizeobserver":__nccwpck_require__(21994),"resource-timing":__nccwpck_require__(28286),"rest-parameters":__nccwpck_require__(42459),"rtcpeerconnection":__nccwpck_require__(17936),"ruby":__nccwpck_require__(35921),"run-in":__nccwpck_require__(88365),"same-site-cookie-attribute":__nccwpck_require__(87529),"screen-orientation":__nccwpck_require__(22474),"script-async":__nccwpck_require__(1522),"script-defer":__nccwpck_require__(13440),"scrollintoview":__nccwpck_require__(39781),"scrollintoviewifneeded":__nccwpck_require__(12228),"sdch":__nccwpck_require__(52531),"selection-api":__nccwpck_require__(60612),"server-timing":__nccwpck_require__(6978),"serviceworkers":__nccwpck_require__(65958),"setimmediate":__nccwpck_require__(87394),"shadowdom":__nccwpck_require__(29657),"shadowdomv1":__nccwpck_require__(32860),"sharedarraybuffer":__nccwpck_require__(71306),"sharedworkers":__nccwpck_require__(42568),"sni":__nccwpck_require__(18689),"spdy":__nccwpck_require__(35867),"speech-recognition":__nccwpck_require__(7773),"speech-synthesis":__nccwpck_require__(38623),"spellcheck-attribute":__nccwpck_require__(79418),"sql-storage":__nccwpck_require__(88502),"srcset":__nccwpck_require__(31740),"stream":__nccwpck_require__(83192),"streams":__nccwpck_require__(54664),"stricttransportsecurity":__nccwpck_require__(24046),"style-scoped":__nccwpck_require__(39846),"subresource-bundling":__nccwpck_require__(20198),"subresource-integrity":__nccwpck_require__(50847),"svg-css":__nccwpck_require__(52279),"svg-filters":__nccwpck_require__(24682),"svg-fonts":__nccwpck_require__(18443),"svg-fragment":__nccwpck_require__(32036),"svg-html":__nccwpck_require__(18617),"svg-html5":__nccwpck_require__(94098),"svg-img":__nccwpck_require__(86703),"svg-smil":__nccwpck_require__(91827),"svg":__nccwpck_require__(44087),"sxg":__nccwpck_require__(12832),"tabindex-attr":__nccwpck_require__(40960),"template-literals":__nccwpck_require__(7507),"template":__nccwpck_require__(52873),"temporal":__nccwpck_require__(85105),"testfeat":__nccwpck_require__(40831),"text-decoration":__nccwpck_require__(6866),"text-emphasis":__nccwpck_require__(76001),"text-overflow":__nccwpck_require__(73033),"text-size-adjust":__nccwpck_require__(2368),"text-stroke":__nccwpck_require__(10481),"textcontent":__nccwpck_require__(2846),"textencoder":__nccwpck_require__(96073),"tls1-1":__nccwpck_require__(76376),"tls1-2":__nccwpck_require__(99062),"tls1-3":__nccwpck_require__(5423),"touch":__nccwpck_require__(61653),"transforms2d":__nccwpck_require__(98415),"transforms3d":__nccwpck_require__(48912),"trusted-types":__nccwpck_require__(58552),"ttf":__nccwpck_require__(23126),"typedarrays":__nccwpck_require__(71426),"u2f":__nccwpck_require__(61405),"unhandledrejection":__nccwpck_require__(43287),"upgradeinsecurerequests":__nccwpck_require__(97798),"url-scroll-to-text-fragment":__nccwpck_require__(52411),"url":__nccwpck_require__(80081),"urlsearchparams":__nccwpck_require__(17586),"use-strict":__nccwpck_require__(33500),"user-select-none":__nccwpck_require__(85671),"user-timing":__nccwpck_require__(98345),"variable-fonts":__nccwpck_require__(56153),"vector-effect":__nccwpck_require__(18563),"vibration":__nccwpck_require__(78480),"video":__nccwpck_require__(69345),"videotracks":__nccwpck_require__(32495),"viewport-unit-variants":__nccwpck_require__(26571),"viewport-units":__nccwpck_require__(23396),"wai-aria":__nccwpck_require__(32102),"wake-lock":__nccwpck_require__(44534),"wasm":__nccwpck_require__(95495),"wav":__nccwpck_require__(22174),"wbr-element":__nccwpck_require__(91075),"web-animation":__nccwpck_require__(17713),"web-app-manifest":__nccwpck_require__(48215),"web-bluetooth":__nccwpck_require__(46475),"web-serial":__nccwpck_require__(86902),"web-share":__nccwpck_require__(1574),"webauthn":__nccwpck_require__(8423),"webcodecs":__nccwpck_require__(69174),"webgl":__nccwpck_require__(34889),"webgl2":__nccwpck_require__(75593),"webgpu":__nccwpck_require__(98935),"webhid":__nccwpck_require__(51706),"webkit-user-drag":__nccwpck_require__(27580),"webm":__nccwpck_require__(19936),"webnfc":__nccwpck_require__(57179),"webp":__nccwpck_require__(95001),"websockets":__nccwpck_require__(9648),"webtransport":__nccwpck_require__(14552),"webusb":__nccwpck_require__(75310),"webvr":__nccwpck_require__(28335),"webvtt":__nccwpck_require__(53707),"webworkers":__nccwpck_require__(82501),"webxr":__nccwpck_require__(85515),"will-change":__nccwpck_require__(70441),"woff":__nccwpck_require__(15216),"woff2":__nccwpck_require__(92249),"word-break":__nccwpck_require__(72383),"wordwrap":__nccwpck_require__(40133),"x-doc-messaging":__nccwpck_require__(3334),"x-frame-options":__nccwpck_require__(52711),"xhr2":__nccwpck_require__(94381),"xhtml":__nccwpck_require__(92605),"xhtmlsmil":__nccwpck_require__(7278),"xml-serializer":__nccwpck_require__(12227)};


/***/ }),

/***/ 22041:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"DC tB I u J D E F A B C K L G M N O v w x EC FC","132":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F","16":"A B"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB"},H:{"2":"oC"},I:{"1":"tB I f sC BC tC uC","2":"pC qC rC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"132":"H"},N:{"1":"A","2":"B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"132":"AD"}},B:6,C:"AAC audio file format"};


/***/ }),

/***/ 58633:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G"},C:{"1":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB EC FC"},D:{"1":"eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB"},E:{"1":"K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B HC zB IC JC KC LC 0B","130":"C qB"},F:{"1":"TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB PC QC RC SC qB AC TC rB"},G:{"1":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:1,C:"AbortController & AbortSignal"};


/***/ }),

/***/ 16821:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O","2":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC","132":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D","132":"A"},K:{"2":"A B C g qB AC","132":"rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:6,C:"AC-3 (Dolby Digital) and EC-3 (Dolby Digital Plus) codecs"};


/***/ }),

/***/ 64181:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB","194":"YB uB ZB vB aB bB cB dB eB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:4,C:"Accelerometer"};


/***/ }),

/***/ 31621:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","130":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","257":"DC tB I u J EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"EventTarget.addEventListener()"};


/***/ }),

/***/ 18627:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","2":"J D CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"F B C PC QC RC SC qB AC TC rB","16":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"16":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"16":"D A"},K:{"2":"g","16":"A B C qB AC rB"},L:{"16":"H"},M:{"16":"H"},N:{"16":"A B"},O:{"16":"vC"},P:{"16":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"16":"9C"},S:{"1":"AD"}},B:1,C:"Alternate stylesheet"};


/***/ }),

/***/ 12148:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K","132":"L G M N O","322":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"DC tB I u J D E F A B C K L G M N O v w x EC FC","132":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB","194":"ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB","322":"YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB PC QC RC SC qB AC TC rB","322":"g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"132":"AD"}},B:4,C:"Ambient Light Sensor"};


/***/ }),

/***/ 2312:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC"},D:{"1":"uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB"},E:{"1":"E F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D HC zB IC JC KC"},F:{"1":"B C MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","2":"0 1 2 3 4 5 6 7 8 9 F G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB"},G:{"1":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"Animated PNG (APNG)"};


/***/ }),

/***/ 79271:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB"},E:{"1":"E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D HC zB IC JC"},F:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D","16":"A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Array.prototype.findIndex"};


/***/ }),

/***/ 39299:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","16":"C K L"},C:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB"},E:{"1":"E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D HC zB IC JC"},F:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D","16":"A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Array.prototype.find"};


/***/ }),

/***/ 38626:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB EC FC"},D:{"1":"hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB"},E:{"1":"C K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B HC zB IC JC KC LC 0B qB"},F:{"1":"WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB PC QC RC SC qB AC TC rB"},G:{"1":"fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"flat & flatMap array methods"};


/***/ }),

/***/ 33189:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K"},C:{"1":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB EC FC"},D:{"1":"NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC"},F:{"1":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Array.prototype.includes"};


/***/ }),

/***/ 72093:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v w x EC FC"},D:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC"},F:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Arrow functions"};


/***/ }),

/***/ 72303:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"K L G M N O","132":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","322":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v w x EC FC"},D:{"2":"0 1 2 3 I u J D E F A B C K L G M N O v w x y z","132":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","132":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC tC uC","132":"f"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","132":"g"},L:{"132":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"132":"vC"},P:{"2":"I","132":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"132":"1B"},R:{"132":"9C"},S:{"1":"AD"}},B:6,C:"asm.js"};


/***/ }),

/***/ 40152:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB EC FC","132":"bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB","66":"YB uB ZB vB"},E:{"1":"L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K HC zB IC JC KC LC 0B qB rB"},F:{"1":"PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC","260":"lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC tC uC","260":"f"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"132":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"2":"I wC xC yC zC","260":"0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"Asynchronous Clipboard API"};


/***/ }),

/***/ 49000:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K","194":"L"},C:{"1":"SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB EC FC"},D:{"1":"VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC","514":"0B"},F:{"1":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB PC QC RC SC qB AC TC rB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC","514":"cC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"Async functions"};


/***/ }),

/***/ 37179:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e SC qB AC TC rB","2":"F PC QC","16":"RC"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","16":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Base64 encoding and decoding"};


/***/ }),

/***/ 70873:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K","33":"0 1 2 3 4 5 6 7 8 9 L G M N O v w x y z"},E:{"1":"G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC","33":"J D E F A B C K L JC KC LC 0B qB rB 1B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","33":"G M N O v w x"},G:{"1":"mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC","33":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"Web Audio API"};


/***/ }),

/***/ 6398:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB","132":"I u J D E F A B C K L G M N O v EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","2":"F","4":"PC QC"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB"},H:{"2":"oC"},I:{"1":"tB I f rC sC BC tC uC","2":"pC qC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Audio element"};


/***/ }),

/***/ 77417:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O","322":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","194":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB","322":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC"},F:{"2":"0 1 2 3 4 5 6 7 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","322":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","322":"g"},L:{"322":"H"},M:{"2":"H"},N:{"1":"A B"},O:{"322":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"322":"1B"},R:{"322":"9C"},S:{"194":"AD"}},B:1,C:"Audio Tracks"};


/***/ }),

/***/ 91333:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","2":"F"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I f sC BC tC uC","2":"pC qC rC"},J:{"1":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:1,C:"Autofocus attribute"};


/***/ }),

/***/ 638:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB EC FC","129":"TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"Auxclick"};


/***/ }),

/***/ 14604:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N","194":"O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB EC FC","66":"VB WB XB YB uB ZB vB aB bB cB","260":"dB","516":"eB"},D:{"1":"iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB","66":"fB gB hB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1090":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"AV1 video format"};


/***/ }),

/***/ 66762:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB EC FC","194":"oB pB P Q R wB S T U V W X Y Z a b","257":"c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB","1281":"9B OC","1796":"6B 7B 8B"},F:{"1":"jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B","1281":"sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"257":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"AVIF image format"};


/***/ }),

/***/ 41394:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","132":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","132":"0 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"u J D E F A B C IC JC KC LC 0B qB rB 3B 4B 5B sB 6B 7B 8B 9B OC","132":"I K HC zB 1B","2050":"L G MC NC 2B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","132":"F PC QC"},G:{"2":"zB UC BC","772":"E VC WC XC YC ZC aC bC cC dC eC fC gC","2050":"hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC tC uC","132":"sC BC"},J:{"260":"D A"},K:{"1":"B C g qB AC rB","132":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"2":"I","1028":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS background-attachment"};


/***/ }),

/***/ 13197:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"G M N O","33":"C K L P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB EC FC"},D:{"33":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"L G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"HC zB","33":"I u J D E F A B C K IC JC KC LC 0B qB rB 1B"},F:{"2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC VC","33":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC"},H:{"2":"oC"},I:{"16":"tB pC qC rC","33":"I f sC BC tC uC"},J:{"33":"D A"},K:{"16":"A B C qB AC rB","33":"g"},L:{"33":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"33":"vC"},P:{"33":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"33":"1B"},R:{"33":"9C"},S:{"1":"AD"}},B:7,C:"Background-clip: text"};


/***/ }),

/***/ 22115:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC","36":"FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","516":"I u J D E F A B C K L"},E:{"1":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","772":"I u J HC zB IC JC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","2":"F PC","36":"QC"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","4":"zB UC BC WC","516":"VC"},H:{"132":"oC"},I:{"1":"f tC uC","36":"pC","516":"tB I sC BC","548":"qC rC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS3 Background-image options"};


/***/ }),

/***/ 4414:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"background-position-x & background-position-y"};


/***/ }),

/***/ 74678:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E CC","132":"F"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB EC FC"},D:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC JC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","2":"F G M N O PC QC"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC"},H:{"1":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:4,C:"CSS background-repeat round and space"};


/***/ }),

/***/ 99995:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H EC FC","16":"xB yB"},D:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"Background Sync API"};


/***/ }),

/***/ 96576:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"JB KB LB MB NB OB PB QB RB","2":"DC tB I u J D E F SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","132":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB","164":"A B C K L G"},D:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB","66":"DB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"Battery Status API"};


/***/ }),

/***/ 33903:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K"},C:{"1":"7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB"},E:{"1":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B HC zB IC JC KC LC 0B"},F:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"Beacon API"};


/***/ }),

/***/ 38484:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","16":"CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u EC FC"},D:{"1":"bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB"},E:{"1":"K L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C HC zB IC JC KC LC 0B qB rB"},F:{"1":"QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB PC QC RC SC qB AC TC rB"},G:{"1":"hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"16":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"16":"A B"},O:{"1":"vC"},P:{"2":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","16":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Printing Events"};


/***/ }),

/***/ 88210:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB EC FC","194":"dB eB fB"},D:{"1":"fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB"},E:{"1":"L G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K HC zB IC JC KC LC 0B qB rB 1B"},F:{"1":"UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB PC QC RC SC qB AC TC rB"},G:{"1":"lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"BigInt"};


/***/ }),

/***/ 43840:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u EC FC","36":"J D E F A B C"},D:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D","36":"E F A B C K L G M N O v"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B C PC QC RC SC qB AC TC"},G:{"1":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC"},H:{"2":"oC"},I:{"1":"f","2":"pC qC rC","36":"tB I sC BC tC uC"},J:{"1":"A","2":"D"},K:{"1":"g rB","2":"A B C qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"Blob constructing"};


/***/ }),

/***/ 75394:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","129":"A B"},B:{"1":"G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","129":"C K L"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D","33":"E F A B C K L G M N O v w x y"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC","33":"J"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC","33":"WC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB pC qC rC","33":"I sC BC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"Blob URLs"};


/***/ }),

/***/ 14915:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A CC"},B:{"1":"L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","129":"C K"},C:{"1":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB","260":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB","804":"I u J D E F A B C K L EC FC"},D:{"1":"WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","260":"RB SB TB UB VB","388":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB","1412":"0 1 2 3 4 5 G M N O v w x y z","1956":"I u J D E F A B C K L"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B OC","129":"A B C K L G LC 0B qB rB 1B MC NC 2B","1412":"J D E F JC KC","1956":"I u HC zB IC"},F:{"1":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F PC QC","260":"EB FB GB HB IB","388":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB","1796":"RC SC","1828":"B C qB AC TC rB"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","129":"aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B","1412":"E WC XC YC ZC","1956":"zB UC BC VC"},H:{"1828":"oC"},I:{"1":"f","388":"tC uC","1956":"tB I pC qC rC sC BC"},J:{"1412":"A","1924":"D"},K:{"1":"g","2":"A","1828":"B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","260":"wC xC","388":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"260":"AD"}},B:4,C:"CSS3 Border images"};


/***/ }),

/***/ 72853:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","257":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB","289":"tB EC FC","292":"DC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","33":"I"},E:{"1":"u D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","33":"I HC zB","129":"J IC JC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","2":"F PC QC"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","33":"zB"},H:{"2":"oC"},I:{"1":"tB I f qC rC sC BC tC uC","33":"pC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"257":"AD"}},B:4,C:"CSS3 Border-radius (rounded corners)"};


/***/ }),

/***/ 35485:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EC FC"},D:{"1":"UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B"},F:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB PC QC RC SC qB AC TC rB"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"BroadcastChannel"};


/***/ }),

/***/ 67933:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L"},C:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB EC FC"},D:{"1":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB","194":"PB","257":"QB"},E:{"1":"K L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B","513":"B C qB rB"},F:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB PC QC RC SC qB AC TC rB","194":"CB DB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Brotli Accept-Encoding/Content-Encoding"};


/***/ }),

/***/ 287:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","260":"F","516":"A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","33":"I u J D E F A B C K L G"},D:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O","33":"0 1 v w x y z"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC","33":"J"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC","33":"WC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC","132":"tC uC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"calc() as CSS unit value"};


/***/ }),

/***/ 39321:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v EC FC"},D:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M PC QC RC SC qB AC TC rB"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"Canvas blend modes"};


/***/ }),

/***/ 35888:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"CC","8":"J D E"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","8":"DC tB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","8":"F PC QC"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","8":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Text API for Canvas"};


/***/ }),

/***/ 66710:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"CC","8":"J D E"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB FC","132":"DC tB EC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","132":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"260":"oC"},I:{"1":"tB I f sC BC tC uC","132":"pC qC rC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Canvas (basic support)"};


/***/ }),

/***/ 30814:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","132":"F A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC JC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"ch (character) unit"};


/***/ }),

/***/ 34099:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB EC FC"},D:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 I u J D E F A B C K L G M N O v w x y z","129":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB"},E:{"1":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B HC zB IC JC KC LC 0B"},F:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB PC QC RC SC qB AC TC rB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC","16":"uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"ChaCha20-Poly1305 cipher suites for TLS"};


/***/ }),

/***/ 610:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","194":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e SC qB AC TC rB","2":"F PC QC","16":"RC"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Channel messaging"};


/***/ }),

/***/ 40258:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","16":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v w x y EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O v w x y z"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC","16":"J"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"ChildNode.remove()"};


/***/ }),

/***/ 33077:
/***/ ((module) => {

module.exports={A:{A:{"8":"J D E F CC","1924":"A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","8":"DC tB EC","516":"0 1","772":"I u J D E F A B C K L G M N O v w x y z FC"},D:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","8":"I u J D","516":"0 1 2 3","772":"z","900":"E F A B C K L G M N O v w x y"},E:{"1":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"I u HC zB","900":"J IC JC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","8":"F B PC QC RC SC qB","900":"C AC TC rB"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","8":"zB UC BC","900":"VC WC"},H:{"900":"oC"},I:{"1":"f tC uC","8":"pC qC rC","900":"tB I sC BC"},J:{"1":"A","900":"D"},K:{"1":"g","8":"A B","900":"C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"900":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"classList (DOMTokenList)"};


/***/ }),

/***/ 26164:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"Client Hints: DPR, Width, Viewport-Width"};


/***/ }),

/***/ 28546:
/***/ ((module) => {

module.exports={A:{A:{"2436":"J D E F A B CC"},B:{"260":"N O","2436":"C K L G M","8196":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"DC tB I u J D E F A B C K L G M N O v w x EC FC","772":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB","4100":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"I u J D E F A B C","2564":"0 1 2 3 4 5 6 7 8 9 K L G M N O v w x y z AB BB CB DB EB FB GB HB IB","8196":"YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","10244":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},E:{"1":"C K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"HC zB","2308":"A B 0B qB","2820":"I u J D E F IC JC KC LC"},F:{"2":"F B PC QC RC SC qB AC TC","16":"C","516":"rB","2564":"0 1 2 3 4 5 G M N O v w x y z","8196":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","10244":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB"},G:{"1":"fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC","2820":"E VC WC XC YC ZC aC bC cC dC eC"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC","260":"f","2308":"tC uC"},J:{"2":"D","2308":"A"},K:{"2":"A B C qB AC","16":"rB","8196":"g"},L:{"8196":"H"},M:{"1028":"H"},N:{"2":"A B"},O:{"8196":"vC"},P:{"2052":"wC xC","2308":"I","8196":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"8196":"1B"},R:{"8196":"9C"},S:{"4100":"AD"}},B:5,C:"Synchronous Clipboard API"};


/***/ }),

/***/ 97491:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"j k l m n o p q r s t f H","2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i"},C:{"1":"s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i EC FC","258":"j k l m n o p","578":"q r"},D:{"1":"j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y","194":"Z a b c d e h i"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"16":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"16":"A B"},O:{"2":"vC"},P:{"1":"7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:6,C:"COLR/CPAL(v1) Font Formats"};


/***/ }),

/***/ 22303:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","257":"F A B"},B:{"1":"C K L G M N O","513":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB","513":"jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"L G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B","129":"B C K qB rB 1B"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB PC QC RC SC qB AC TC rB","513":"YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"16":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"16":"A B"},O:{"1":"vC"},P:{"1":"0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"COLR/CPAL(v0) Font Formats"};


/***/ }),

/***/ 2004:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","16":"DC tB EC FC"},D:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L","132":"0 1 2 3 4 5 G M N O v w x y z"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"I u J HC zB","132":"D E F JC KC LC","260":"IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","16":"F B PC QC RC SC qB AC","132":"G M"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB","132":"E UC BC VC WC XC YC ZC aC"},H:{"1":"oC"},I:{"1":"f tC uC","16":"pC qC","132":"tB I rC sC BC"},J:{"132":"D A"},K:{"1":"C g rB","16":"A B qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Node.compareDocumentPosition()"};


/***/ }),

/***/ 30695:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D CC","132":"E F"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e qB AC TC rB","2":"F PC QC RC SC"},G:{"1":"zB UC BC VC","513":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"4097":"oC"},I:{"1025":"tB I f pC qC rC sC BC tC uC"},J:{"258":"D A"},K:{"2":"A","258":"B C qB AC rB","1025":"g"},L:{"1025":"H"},M:{"2049":"H"},N:{"258":"A B"},O:{"258":"vC"},P:{"1025":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1025":"9C"},S:{"1":"AD"}},B:1,C:"Basic console logging functions"};


/***/ }),

/***/ 15498:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e qB AC TC rB","2":"F PC QC RC SC","16":"B"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"g","16":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"console.time and console.timeEnd"};


/***/ }),

/***/ 67727:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","2052":"B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","132":"DC tB I u J D E F A B C EC FC","260":"0 1 2 3 4 5 6 7 8 9 K L G M N O v w x y z AB BB"},D:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","260":"I u J D E F A B C K L G M N O v w","772":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB","1028":"HB IB JB KB LB MB NB OB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","260":"I u A HC zB 0B","772":"J D E F IC JC KC LC"},F:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F PC","132":"B QC RC SC qB AC","644":"C TC rB","772":"0 1 2 3 G M N O v w x y z","1028":"4 5 6 7 8 9 AB BB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","260":"zB UC BC bC cC","772":"E VC WC XC YC ZC aC"},H:{"644":"oC"},I:{"1":"f","16":"pC qC","260":"rC","772":"tB I sC BC tC uC"},J:{"772":"D A"},K:{"1":"g","132":"A B qB AC","644":"C rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","1028":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"const"};


/***/ }),

/***/ 92806:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","900":"A B"},B:{"1":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","388":"L G M","900":"C K"},C:{"1":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","260":"PB QB","388":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB","900":"0 1 2 3 4 I u J D E F A B C K L G M N O v w x y z"},D:{"1":"GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L","388":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB","900":"0 G M N O v w x y z"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"I u HC zB","388":"E F KC LC","900":"J D IC JC"},F:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","16":"F B PC QC RC SC qB AC","388":"0 1 2 G M N O v w x y z","900":"C TC rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC","388":"E XC YC ZC aC","900":"VC WC"},H:{"2":"oC"},I:{"1":"f","16":"tB pC qC rC","388":"tC uC","900":"I sC BC"},J:{"16":"D","388":"A"},K:{"1":"g","16":"A B qB AC","900":"C rB"},L:{"1":"H"},M:{"1":"H"},N:{"900":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"388":"AD"}},B:1,C:"Constraint Validation API"};


/***/ }),

/***/ 46638:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC","4":"tB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"2":"oC"},I:{"1":"tB I f sC BC tC uC","2":"pC qC rC"},J:{"1":"D A"},K:{"1":"g rB","2":"A B C qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"contenteditable attribute (basic support)"};


/***/ }),

/***/ 90370:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","132":"A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","129":"I u J D E F A B C K L G M N O v w x y"},D:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K","257":"0 L G M N O v w x y z"},E:{"1":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB","257":"J JC","260":"IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC","257":"WC","260":"VC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"2":"D","257":"A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"132":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"Content Security Policy 1.0"};


/***/ }),

/***/ 39564:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L","4100":"G M N O"},C:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","132":"7 8 9 AB","260":"BB","516":"CB DB EB FB GB HB IB JB KB"},D:{"1":"GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB","1028":"CB DB EB","2052":"FB"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC"},F:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w x y PC QC RC SC qB AC TC rB","1028":"0 1 z","2052":"2"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"Content Security Policy Level 2"};


/***/ }),

/***/ 71369:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O","194":"P Q R S T U V"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB","194":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB PC QC RC SC qB AC TC rB","194":"RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"Cookie Store API"};


/***/ }),

/***/ 96637:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D CC","132":"A","260":"E F"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC tB","1025":"vB aB bB cB dB eB fB gB hB iB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","132":"I u J D E F A B C"},E:{"2":"HC zB","513":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","644":"I u IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B PC QC RC SC qB AC TC"},G:{"513":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","644":"zB UC BC VC"},H:{"2":"oC"},I:{"1":"f tC uC","132":"tB I pC qC rC sC BC"},J:{"1":"A","132":"D"},K:{"1":"C g rB","2":"A B qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","132":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Cross-Origin Resource Sharing"};


/***/ }),

/***/ 25702:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB EC FC","1028":"c d e h i","3076":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b","8196":"j k l m n o p q r s t f H xB yB"},D:{"1":"uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB","132":"QB RB","260":"SB TB","516":"UB VB WB XB YB"},E:{"2":"I u J D E F A B C K L HC zB IC JC KC LC 0B qB rB 1B MC","4100":"G NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB PC QC RC SC qB AC TC rB","132":"DB EB","260":"FB GB","516":"HB IB JB KB LB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC","4100":"nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"8196":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","16":"I wC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"3076":"AD"}},B:1,C:"createImageBitmap"};


/***/ }),

/***/ 32011:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB","66":"OB PB QB","129":"RB SB TB UB VB WB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB PC QC RC SC qB AC TC rB"},G:{"1":"lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"Credential Management API"};


/***/ }),

/***/ 91342:
/***/ ((module) => {

module.exports={A:{A:{"2":"CC","8":"J D E F A","164":"B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","513":"C K L G M N O"},C:{"1":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","8":"0 1 2 3 4 5 6 7 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","66":"8 9"},D:{"1":"DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","8":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"I u J D HC zB IC JC","289":"E F A KC LC 0B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","8":"F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","8":"zB UC BC VC WC XC","289":"E YC ZC aC bC cC"},H:{"2":"oC"},I:{"1":"f","8":"tB I pC qC rC sC BC tC uC"},J:{"8":"D A"},K:{"1":"g","8":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"8":"A","164":"B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"Web Cryptography"};


/***/ }),

/***/ 55211:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB"},E:{"1":"A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC"},H:{"2":"oC"},I:{"1":"f uC","2":"tB I pC qC rC sC BC tC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS all property"};


/***/ }),

/***/ 40083:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I EC FC","33":"u J D E F A B C K L G"},D:{"1":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","33":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB","33":"J D E IC JC KC","292":"I u"},F:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B PC QC RC SC qB AC TC","33":"0 1 2 3 4 5 C G M N O v w x y z"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","33":"E WC XC YC","164":"zB UC BC VC"},H:{"2":"oC"},I:{"1":"f","33":"I sC BC tC uC","164":"tB pC qC rC"},J:{"33":"D A"},K:{"1":"g rB","2":"A B C qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"CSS Animation"};


/***/ }),

/***/ 2031:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","16":"DC","33":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB EC FC"},D:{"1":"dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"I u J HC zB IC","33":"D E JC KC"},F:{"1":"SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC VC","33":"E WC XC YC"},H:{"2":"oC"},I:{"1":"f","16":"tB I pC qC rC sC BC","33":"tC uC"},J:{"16":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","16":"I","33":"wC xC yC zC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"33":"AD"}},B:5,C:"CSS :any-link selector"};


/***/ }),

/***/ 3599:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","33":"S","164":"P Q R","388":"C K L G M N O"},C:{"1":"Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","164":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P","676":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB EC FC"},D:{"1":"T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","33":"S","164":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B OC","164":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B"},F:{"1":"g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","33":"iB jB kB","164":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","164":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B"},H:{"2":"oC"},I:{"1":"f","164":"tB I pC qC rC sC BC tC uC"},J:{"164":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A","388":"B"},O:{"164":"vC"},P:{"164":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"164":"1B"},R:{"1":"9C"},S:{"164":"AD"}},B:5,C:"CSS Appearance"};


/***/ }),

/***/ 2769:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z","132":"a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","132":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z","132":"a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB PC QC RC SC qB AC TC rB","132":"oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC tC uC","132":"f"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","132":"g"},L:{"132":"H"},M:{"132":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C","132":"sB 6C 7C 8C"},Q:{"2":"1B"},R:{"132":"9C"},S:{"132":"AD"}},B:4,C:"CSS Counter Styles"};


/***/ }),

/***/ 71327:
/***/ ((module) => {

module.exports={A:{D:{"33":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},L:{"33":"H"},B:{"2":"C K L G M N O","33":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U EC FC"},M:{"1":"H"},A:{"2":"J D E F A B CC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},K:{"2":"A B C qB AC rB","33":"g"},E:{"1":"G NC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"OC","33":"I u J D E F A B C K L HC zB IC JC KC LC 0B qB rB 1B MC"},G:{"1":"nC 2B 3B 4B 5B sB 6B 7B 8B 9B","33":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC"},P:{"33":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},I:{"2":"tB I pC qC rC sC BC","33":"f tC uC"}},B:6,C:":autofill CSS pseudo-class"};


/***/ }),

/***/ 74043:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M","257":"N O"},C:{"1":"o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB EC FC","578":"iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n"},D:{"1":"nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB","194":"NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB"},E:{"2":"I u J D E HC zB IC JC KC","33":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","194":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB"},G:{"2":"E zB UC BC VC WC XC YC","33":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"2C 3C 4C 5C sB 6C 7C 8C","2":"I","194":"wC xC yC zC 0C 0B 1C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"CSS Backdrop Filter"};


/***/ }),

/***/ 29407:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C EC FC"},D:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC JC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","2":"F PC QC"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC"},H:{"1":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS background-position edge offsets"};


/***/ }),

/***/ 98732:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"BB CB DB EB FB GB HB IB JB KB LB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB","260":"MB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D HC zB IC JC","132":"E F A KC LC"},F:{"1":"0 1 2 3 4 5 6 7 8 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w x PC QC RC SC qB AC TC rB","260":"9"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC","132":"E YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS background-blend-mode"};


/***/ }),

/***/ 81371:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","164":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"2":"I u J D E F A B C K L G M N O v w x","164":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J HC zB IC","164":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F PC QC RC SC","129":"B C qB AC TC rB","164":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"zB UC BC VC WC","164":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"132":"oC"},I:{"2":"tB I pC qC rC sC BC","164":"f tC uC"},J:{"2":"D","164":"A"},K:{"2":"A","129":"B C qB AC rB","164":"g"},L:{"164":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"164":"vC"},P:{"164":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"164":"1B"},R:{"164":"9C"},S:{"1":"AD"}},B:4,C:"CSS box-decoration-break"};


/***/ }),

/***/ 22004:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB","33":"EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","33":"I u J D E F"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","33":"u","164":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","2":"F PC QC"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","33":"UC BC","164":"zB"},H:{"2":"oC"},I:{"1":"I f sC BC tC uC","164":"tB pC qC rC"},J:{"1":"A","33":"D"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS3 Box-shadow"};


/***/ }),

/***/ 34651:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","33":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB"},E:{"2":"HC zB","33":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F B C BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB"},G:{"33":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"f","33":"tB I pC qC rC sC BC tC uC"},J:{"33":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","33":"I"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"CSS Canvas Drawings"};


/***/ }),

/***/ 3560:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB EC FC"},D:{"1":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB"},E:{"1":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B HC zB IC JC KC LC 0B"},F:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB PC QC RC SC qB AC TC rB"},G:{"1":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:2,C:"CSS caret-color"};


/***/ }),

/***/ 92931:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"k l m n o p q r s t f H","2":"C K L G M N O P Q R S T U V W X Y Z a b c d e","322":"h i j"},C:{"1":"i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c EC FC","194":"d e h"},D:{"1":"k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e","322":"h i j"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B"},F:{"1":"V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U PC QC RC SC qB AC TC rB"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:4,C:"CSS Cascade Layers"};


/***/ }),

/***/ 4497:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB EC FC"},D:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC"},F:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB PC QC RC SC qB AC TC rB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"Case-insensitive CSS attribute selectors"};


/***/ }),

/***/ 37028:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N","260":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","3138":"O"},C:{"1":"UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB","132":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB EC FC","644":"NB OB PB QB RB SB TB"},D:{"2":"I u J D E F A B C K L G M N O v w x y z","260":"VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","292":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB"},E:{"2":"I u J HC zB IC JC","260":"L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","292":"D E F A B C K KC LC 0B qB rB"},F:{"2":"F B C PC QC RC SC qB AC TC rB","260":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","292":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB"},G:{"2":"zB UC BC VC WC","260":"hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","292":"E XC YC ZC aC bC cC dC eC fC gC"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC","260":"f","292":"tC uC"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","260":"g"},L:{"260":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"260":"vC"},P:{"292":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"260":"1B"},R:{"260":"9C"},S:{"644":"AD"}},B:4,C:"CSS clip-path property (for HTML)"};


/***/ }),

/***/ 75747:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","33":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB EC FC"},D:{"16":"I u J D E F A B C K L G M N O","33":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC","33":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B"},F:{"2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","16":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B"},H:{"2":"oC"},I:{"16":"tB I pC qC rC sC BC tC uC","33":"f"},J:{"16":"D A"},K:{"2":"A B C qB AC rB","33":"g"},L:{"16":"H"},M:{"1":"H"},N:{"16":"A B"},O:{"16":"vC"},P:{"16":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"33":"1B"},R:{"16":"9C"},S:{"1":"AD"}},B:4,C:"CSS print-color-adjust"};


/***/ }),

/***/ 4008:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s","322":"t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s","322":"t f H"},E:{"1":"G NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC","132":"B C K L 0B qB rB 1B MC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d PC QC RC SC qB AC TC rB","322":"e"},G:{"1":"nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC","132":"cC dC eC fC gC hC iC jC kC lC mC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:4,C:"CSS color() function"};


/***/ }),

/***/ 31811:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB EC FC","578":"mB nB oB pB P Q R wB"},D:{"1":"hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB","194":"uB ZB vB aB bB cB dB eB fB gB"},E:{"1":"K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C HC zB IC JC KC LC 0B qB"},F:{"1":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB PC QC RC SC qB AC TC rB","194":"MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB"},G:{"1":"gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"CSS Conical Gradients"};


/***/ }),

/***/ 45652:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r","194":"s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r","194":"s t f H","260":"xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b PC QC RC SC qB AC TC rB","194":"c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","194":"g"},L:{"194":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"CSS Container Style Queries"};


/***/ }),

/***/ 61547:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"r s t f H","2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p","516":"q"},C:{"1":"H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f EC FC"},D:{"1":"r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a","194":"c d e h i j k l m n o p","450":"b","516":"q"},E:{"1":"sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B"},F:{"1":"d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB PC QC RC SC qB AC TC rB","194":"P Q R wB S T U V W X Y Z","516":"a b c"},G:{"1":"sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"CSS Container Queries (Size)"};


/***/ }),

/***/ 54912:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"q r s t f H","2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p"},C:{"1":"H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f EC FC"},D:{"1":"q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b","194":"m n o p","450":"c d e h i j k l"},E:{"1":"sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B"},F:{"1":"a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB PC QC RC SC qB AC TC rB","194":"P Q R wB S T U V W X Y Z"},G:{"1":"sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"CSS Container Query Units"};


/***/ }),

/***/ 64484:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB EC FC","194":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB"},D:{"1":"SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB","66":"RB"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B"},F:{"1":"GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB PC QC RC SC qB AC TC rB","66":"EB FB"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"194":"AD"}},B:2,C:"CSS Containment"};


/***/ }),

/***/ 69511:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O P Q R S T"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"CSS content-visibility"};


/***/ }),

/***/ 11237:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","2":"J D CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS Counters"};


/***/ }),

/***/ 36717:
/***/ ((module) => {

module.exports={A:{A:{"2":"J CC","2340":"D E F A B"},B:{"2":"C K L G M N O","1025":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC","513":"dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b","545":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB","1025":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC","164":"J","4644":"D E F JC KC LC"},F:{"2":"0 1 2 3 F B G M N O v w x y z PC QC RC SC qB AC","545":"C TC rB","1025":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC","4260":"VC WC","4644":"E XC YC ZC aC"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC tC uC","1025":"f"},J:{"2":"D","4260":"A"},K:{"2":"A B qB AC","545":"C rB","1025":"g"},L:{"1025":"H"},M:{"1":"H"},N:{"2340":"A B"},O:{"1025":"vC"},P:{"1025":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1025":"1B"},R:{"1025":"9C"},S:{"4097":"AD"}},B:4,C:"Crisp edges/pixelated images"};


/***/ }),

/***/ 90831:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","33":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"I u J D E F A B C K L G M","33":"0 1 2 3 4 5 6 7 8 9 N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB","33":"J D E F IC JC KC LC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC","33":"E VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC","33":"f tC uC"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","33":"g"},L:{"33":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"33":"vC"},P:{"33":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"33":"1B"},R:{"33":"9C"},S:{"2":"AD"}},B:4,C:"CSS Cross-Fade Function"};


/***/ }),

/***/ 99030:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","16":"DC tB EC FC"},D:{"1":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L","132":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"I u HC zB","132":"J D E F A IC JC KC LC"},F:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","16":"F B PC QC RC SC qB AC","132":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB","260":"C TC rB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC VC WC","132":"E XC YC ZC aC bC"},H:{"260":"oC"},I:{"1":"f","16":"tB pC qC rC","132":"I sC BC tC uC"},J:{"16":"D","132":"A"},K:{"1":"g","16":"A B C qB AC","260":"rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","132":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:":default CSS pseudo-class"};


/***/ }),

/***/ 14942:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","16":"P"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"B","2":"I u J D E F A C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"Explicit descendant combinator >>"};


/***/ }),

/***/ 83318:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","164":"A B"},B:{"66":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","164":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 I u J D E F A B C K L G M N O v w x y z","66":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB PC QC RC SC qB AC TC rB","66":"GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"292":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A g","292":"B C qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"164":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"66":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"CSS Device Adaptation"};


/***/ }),

/***/ 15902:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p","194":"q r s t f H"},C:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M EC FC","33":"0 1 2 3 4 5 6 7 8 9 N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z","194":"a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z PC QC RC SC qB AC TC rB","194":"a b c d e"},G:{"1":"9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"33":"AD"}},B:5,C:":dir() CSS pseudo-class"};


/***/ }),

/***/ 45140:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","132":"P Q R S T U V W X","260":"Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB EC FC","132":"DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB","260":"aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB","132":"dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X","194":"YB uB ZB vB aB bB cB","260":"Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B HC zB IC JC KC LC 0B","132":"C K L G qB rB 1B MC NC 2B 3B 4B 5B","516":"6B 7B 8B 9B OC","772":"sB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB PC QC RC SC qB AC TC rB","132":"SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB","260":"nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC","132":"eC fC gC hC iC jC","260":"kC lC mC nC 2B 3B 4B 5B","772":"sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC tC uC","260":"f"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","260":"g"},L:{"260":"H"},M:{"260":"H"},N:{"2":"A B"},O:{"132":"vC"},P:{"2":"I wC xC yC zC","132":"0C 0B 1C 2C 3C 4C","260":"5C sB 6C 7C 8C"},Q:{"132":"1B"},R:{"260":"9C"},S:{"132":"AD"}},B:4,C:"CSS display: contents"};


/***/ }),

/***/ 21694:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"33":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","164":"DC tB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"33":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"33":"AD"}},B:5,C:"CSS element() function"};


/***/ }),

/***/ 21809:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB EC FC"},D:{"1":"hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB"},E:{"1":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B","132":"B"},F:{"1":"WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB PC QC RC SC qB AC TC rB"},G:{"1":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC","132":"dC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"CSS Environment Variables env()"};


/***/ }),

/***/ 79991:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","33":"A B"},B:{"2":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","33":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"33":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"CSS Exclusions Level 1"};


/***/ }),

/***/ 53231:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v w x EC FC"},D:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B C PC QC RC SC qB AC TC"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC"},H:{"1":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS Feature Queries"};


/***/ }),

/***/ 23619:
/***/ ((module) => {

module.exports={A:{D:{"1":"Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","33":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X"},L:{"1":"H"},B:{"1":"Y Z a b c d e h i j k l m n o p q r s t f H","33":"C K L G M N O P Q R S T U V W X"},C:{"1":"wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R EC FC"},M:{"1":"H"},A:{"2":"J D E F CC","33":"A B"},F:{"1":"mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB"},K:{"1":"g","2":"A B C qB AC rB"},E:{"1":"G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"OC","33":"I u J D E F A B C K L HC zB IC JC KC LC 0B qB rB 1B"},G:{"1":"mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","33":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC"},P:{"1":"5C sB 6C 7C 8C","33":"I wC xC yC zC 0C 0B 1C 2C 3C 4C"},I:{"1":"f","2":"tB I pC qC rC sC BC","33":"tC uC"}},B:6,C:"::file-selector-button CSS pseudo-element"};


/***/ }),

/***/ 19533:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC","33":"F"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC","33":"ZC aC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"CSS filter() function"};


/***/ }),

/***/ 35123:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","1028":"K L G M N O","1346":"C"},C:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC","196":"AB","516":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z FC"},D:{"1":"TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N","33":"0 1 2 3 4 5 6 7 8 9 O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB"},E:{"1":"A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC","33":"J D E F JC KC"},F:{"1":"GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB"},G:{"1":"aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC","33":"E WC XC YC ZC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC","33":"tC uC"},J:{"2":"D","33":"A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","33":"I wC xC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"CSS Filter Effects"};


/***/ }),

/***/ 95006:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","16":"CC","516":"E","1540":"J D"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","132":"tB","260":"DC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"u J D E","132":"I"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"u HC","132":"I zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","16":"F PC","260":"B QC RC SC qB AC"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC"},H:{"1":"oC"},I:{"1":"tB I f sC BC tC uC","16":"pC qC","132":"rC"},J:{"1":"D A"},K:{"1":"C g rB","260":"A B qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"::first-letter CSS pseudo-element selector"};


/***/ }),

/***/ 34624:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","132":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS first-line pseudo-element"};


/***/ }),

/***/ 4787:
/***/ ((module) => {

module.exports={A:{A:{"1":"D E F A B","2":"CC","8":"J"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","1025":"LC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC","132":"VC WC XC"},H:{"2":"oC"},I:{"1":"tB f tC uC","260":"pC qC rC","513":"I sC BC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS position:fixed"};


/***/ }),

/***/ 59934:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O","328":"P Q R S T U"},C:{"1":"U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","161":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T"},D:{"1":"V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB","328":"fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L HC zB IC JC KC LC 0B qB rB 1B MC","578":"G NC 2B"},F:{"1":"kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB PC QC RC SC qB AC TC rB","328":"eB fB gB hB iB jB"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC","578":"nC 2B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"161":"AD"}},B:5,C:":focus-visible CSS pseudo-class"};


/***/ }),

/***/ 1620:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB EC FC"},D:{"1":"ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB","194":"uB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB PC QC RC SC qB AC TC rB","194":"MB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:":focus-within CSS pseudo-class"};


/***/ }),

/***/ 25680:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"q r s t f H","2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p"},C:{"1":"s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r EC FC"},D:{"1":"m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B"},F:{"1":"W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V PC QC RC SC qB AC TC rB"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"CSS font-palette"};


/***/ }),

/***/ 80882:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB EC FC","194":"MB NB OB PB QB RB SB TB UB VB WB XB"},D:{"1":"ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB","66":"PB QB RB SB TB UB VB WB XB YB uB"},E:{"1":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B HC zB IC JC KC LC 0B"},F:{"1":"NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB PC QC RC SC qB AC TC rB","66":"CB DB EB FB GB HB IB JB KB LB MB"},G:{"1":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I","66":"wC xC yC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"194":"AD"}},B:5,C:"CSS font-display"};


/***/ }),

/***/ 6482:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E EC FC"},D:{"1":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B"},F:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB PC QC RC SC qB AC TC rB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS font-stretch"};


/***/ }),

/***/ 49718:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D CC","132":"E"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS Generated content for pseudo-elements"};


/***/ }),

/***/ 13657:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC","260":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB","292":"I u J D E F A B C K L G FC"},D:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","33":"0 1 A B C K L G M N O v w x y z","548":"I u J D E F"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB","260":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B","292":"J IC","804":"I u"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B PC QC RC SC","33":"C TC","164":"qB AC"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","260":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B","292":"VC WC","804":"zB UC BC"},H:{"2":"oC"},I:{"1":"f tC uC","33":"I sC BC","548":"tB pC qC rC"},J:{"1":"A","548":"D"},K:{"1":"g rB","2":"A B","33":"C","164":"qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS Gradients"};


/***/ }),

/***/ 42734:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:4,C:"CSS Grid animation"};


/***/ }),

/***/ 19330:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","8":"F","292":"A B"},B:{"1":"M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","292":"C K L G"},C:{"1":"UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O EC FC","8":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB","584":"GB HB IB JB KB LB MB NB OB PB QB RB","1025":"SB TB"},D:{"1":"YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 I u J D E F A B C K L G M N O v w x y z","8":"1 2 3 4","200":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB","1025":"XB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC","8":"J D E F A JC KC LC"},F:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","200":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC","8":"E WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC","8":"BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"292":"A B"},O:{"1":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"wC","8":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS Grid Layout (level 1)"};


/***/ }),

/***/ 59804:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:4,C:"CSS hanging-punctuation"};


/***/ }),

/***/ 28790:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"q r s t f H","2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n EC FC","322":"o p q r s t f H xB yB"},D:{"1":"q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l","194":"m n o p"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B"},F:{"1":"a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z PC QC RC SC qB AC TC rB"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:":has() CSS relational pseudo-class"};


/***/ }),

/***/ 89317:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","33":"A B"},B:{"1":"q r s t f H","33":"C K L G M N O","132":"P Q R S T U V W","260":"X Y Z a b c d e h i j k l m n o p"},C:{"1":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u EC FC","33":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB"},D:{"1":"X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB","132":"VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W"},E:{"2":"I u HC zB","33":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB PC QC RC SC qB AC TC rB","132":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z"},G:{"2":"zB UC","33":"E BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"4":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I","132":"wC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS Hyphenation"};


/***/ }),

/***/ 38133:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O P Q","257":"R S T U V W X"},C:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q","257":"R S T U V W X"},E:{"1":"L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K HC zB IC JC KC LC 0B qB rB"},F:{"1":"oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB PC QC RC SC qB AC TC rB","257":"gB hB iB jB kB g lB mB nB"},G:{"1":"lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","132":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C","257":"3C 4C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS3 image-orientation"};


/***/ }),

/***/ 2762:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","164":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U EC FC","66":"V W","257":"Y Z a b c d e h i j k l m n o p q r s t f H xB yB","772":"X"},D:{"2":"I u J D E F A B C K L G M N O v w","132":"xB yB GC","164":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},E:{"2":"I u HC zB IC","132":"A B C K 0B qB rB 1B","164":"J D E F JC KC LC","516":"L G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","164":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"zB UC BC VC","132":"bC cC dC eC fC gC hC iC jC kC","164":"E WC XC YC ZC aC","516":"lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC","164":"f tC uC"},J:{"2":"D","164":"A"},K:{"2":"A B C qB AC rB","164":"g"},L:{"164":"H"},M:{"257":"H"},N:{"2":"A B"},O:{"164":"vC"},P:{"164":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"164":"1B"},R:{"164":"9C"},S:{"2":"AD"}},B:5,C:"CSS image-set"};


/***/ }),

/***/ 88654:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C","260":"K L G M N O"},C:{"1":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","516":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB"},D:{"1":"TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I","16":"u J D E F A B C K L","260":"SB","772":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","16":"u","772":"J D E F A IC JC KC LC"},F:{"1":"GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","16":"F PC","260":"B C FB QC RC SC qB AC TC rB","772":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC","772":"E VC WC XC YC ZC aC bC"},H:{"132":"oC"},I:{"1":"f","2":"tB pC qC rC","260":"I sC BC tC uC"},J:{"2":"D","260":"A"},K:{"1":"g","260":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","260":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"516":"AD"}},B:5,C:":in-range and :out-of-range CSS pseudo-classes"};


/***/ }),

/***/ 61436:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","132":"A B","388":"F"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","132":"C K L G M N O"},C:{"1":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","16":"DC tB EC FC","132":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB","388":"I u"},D:{"1":"FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L","132":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"I u J HC zB","132":"D E F A JC KC LC","388":"IC"},F:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","16":"F B PC QC RC SC qB AC","132":"0 1 G M N O v w x y z","516":"C TC rB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC VC WC","132":"E XC YC ZC aC bC"},H:{"516":"oC"},I:{"1":"f","16":"tB pC qC rC uC","132":"tC","388":"I sC BC"},J:{"16":"D","132":"A"},K:{"1":"g","16":"A B C qB AC","516":"rB"},L:{"1":"H"},M:{"1":"H"},N:{"132":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"132":"AD"}},B:5,C:":indeterminate CSS pseudo-class"};


/***/ }),

/***/ 68010:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f","260":"H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f","260":"H xB yB GC"},E:{"2":"I u J D E HC zB IC JC KC","4":"F","164":"A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC","164":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"260":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"CSS Initial Letter"};


/***/ }),

/***/ 52764:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","33":"I u J D E F A B C K L G M N O EC FC","164":"DC tB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"HC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB"},H:{"2":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS initial value"};


/***/ }),

/***/ 50264:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f","322":"H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H EC FC","194":"xB yB"},D:{"1":"xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f","322":"H"},E:{"1":"G NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L HC zB IC JC KC LC 0B qB rB 1B MC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:4,C:"LCH and Lab color values"};


/***/ }),

/***/ 6661:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","16":"CC","132":"J D E"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","132":"0 1 2 3 4 5 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"HC","132":"I u J zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","16":"F PC","132":"B C G M QC RC SC qB AC TC rB"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB"},H:{"2":"oC"},I:{"1":"f tC uC","16":"pC qC","132":"tB I rC sC BC"},J:{"132":"D A"},K:{"1":"g","132":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"letter-spacing CSS property"};


/***/ }),

/***/ 12931:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M","33":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","129":"N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB EC FC","33":"gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"16":"I u J D E F A B C K","33":"0 1 2 3 4 5 6 7 8 9 L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I HC zB","33":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"zB UC BC","33":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"16":"pC qC","33":"tB I f rC sC BC tC uC"},J:{"33":"D A"},K:{"2":"A B C qB AC rB","33":"g"},L:{"33":"H"},M:{"33":"H"},N:{"2":"A B"},O:{"33":"vC"},P:{"33":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"33":"1B"},R:{"33":"9C"},S:{"2":"AD"}},B:5,C:"CSS line-clamp"};


/***/ }),

/***/ 23871:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O","1028":"W X","1540":"P Q R S T U V"},C:{"1":"eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC","164":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB EC FC","1540":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB"},D:{"1":"Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","292":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB","1028":"W X","1540":"hB iB jB kB g lB mB nB oB pB P Q R S T U V"},E:{"1":"G NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","292":"I u J D E F A B C HC zB IC JC KC LC 0B qB","1540":"K L rB 1B","5124":"MC"},F:{"1":"nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","292":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB","1028":"lB mB","1540":"WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g"},G:{"1":"nC 2B 3B 4B 5B sB 6B 7B 8B 9B","292":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC","1540":"gC hC iC jC kC lC","5124":"mC"},H:{"2":"oC"},I:{"1":"f","292":"tB I pC qC rC sC BC tC uC"},J:{"292":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"292":"vC"},P:{"1":"5C sB 6C 7C 8C","292":"I wC xC yC zC 0C","1540":"0B 1C 2C 3C 4C"},Q:{"1540":"1B"},R:{"1":"9C"},S:{"1540":"AD"}},B:5,C:"CSS Logical Properties"};


/***/ }),

/***/ 35371:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O P Q R S T U"},C:{"1":"gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB EC FC"},D:{"1":"V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U"},E:{"1":"OC","2":"I u J D E F A B HC zB IC JC KC LC 0B","129":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B"},F:{"1":"kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB PC QC RC SC qB AC TC rB"},G:{"1":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"CSS ::marker pseudo-element"};


/***/ }),

/***/ 15592:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M","164":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","3138":"N","12292":"O"},C:{"1":"TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB","260":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB EC FC"},D:{"164":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB","164":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B"},F:{"2":"F B C PC QC RC SC qB AC TC rB","164":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","164":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B"},H:{"2":"oC"},I:{"164":"f tC uC","676":"tB I pC qC rC sC BC"},J:{"164":"D A"},K:{"2":"A B C qB AC rB","164":"g"},L:{"164":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"164":"vC"},P:{"164":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"164":"1B"},R:{"164":"9C"},S:{"260":"AD"}},B:4,C:"CSS Masks"};


/***/ }),

/***/ 45820:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O","1220":"P Q R S T U V W"},C:{"1":"pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","16":"DC tB EC FC","548":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB"},D:{"1":"X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L","164":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB","196":"dB eB fB","1220":"gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W"},E:{"1":"L G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","16":"u","164":"J D E IC JC KC","260":"F A B C K LC 0B qB rB 1B"},F:{"1":"mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","164":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB","196":"SB TB UB","1220":"VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB"},G:{"1":"lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC VC WC","164":"E XC YC","260":"ZC aC bC cC dC eC fC gC hC iC jC kC"},H:{"2":"oC"},I:{"1":"f","16":"tB pC qC rC","164":"I sC BC tC uC"},J:{"16":"D","164":"A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"164":"vC"},P:{"1":"5C sB 6C 7C 8C","164":"I wC xC yC zC 0C 0B 1C 2C 3C 4C"},Q:{"1220":"1B"},R:{"1":"9C"},S:{"548":"AD"}},B:5,C:":is() CSS pseudo-class"};


/***/ }),

/***/ 15868:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB EC FC"},D:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB"},E:{"1":"L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B HC zB IC JC KC LC 0B","132":"C K qB rB"},F:{"1":"eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB PC QC RC SC qB AC TC rB"},G:{"1":"kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC","132":"eC fC gC hC iC jC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"CSS math functions min(), max() and clamp()"};


/***/ }),

/***/ 22427:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB EC FC"},D:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC"},F:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:4,C:"Media Queries: interaction media features"};


/***/ }),

/***/ 55176:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"p q r s t f H","2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o"},C:{"1":"bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB EC FC"},D:{"1":"p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o"},E:{"1":"9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B"},F:{"1":"a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z PC QC RC SC qB AC TC rB"},G:{"1":"9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:4,C:"Media Queries: Range Syntax"};


/***/ }),

/***/ 79494:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","132":"F A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","1028":"C K L G M N O"},C:{"1":"aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB","260":"I u J D E F A B C K L G EC FC","1028":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB"},D:{"1":"gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","548":"0 1 2 3 4 I u J D E F A B C K L G M N O v w x y z","1028":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB"},E:{"1":"sB 6B 7B 8B 9B OC","2":"HC zB","548":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B"},F:{"1":"VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F","548":"B C PC QC RC SC qB AC TC","1028":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB"},G:{"1":"sB 6B 7B 8B 9B","16":"zB","548":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B"},H:{"132":"oC"},I:{"1":"f","16":"pC qC","548":"tB I rC sC BC","1028":"tC uC"},J:{"548":"D A"},K:{"1":"g rB","548":"A B C qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"132":"A B"},O:{"1":"vC"},P:{"1":"0B 1C 2C 3C 4C 5C sB 6C 7C 8C","1028":"I wC xC yC zC 0C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"Media Queries: resolution feature"};


/***/ }),

/***/ 78527:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"Media Queries: scripting media feature"};


/***/ }),

/***/ 47055:
/***/ ((module) => {

module.exports={A:{A:{"8":"J D E CC","129":"F A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC tB"},D:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","129":"0 1 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","129":"I u J IC","388":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","2":"F"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","129":"zB UC BC VC WC"},H:{"1":"oC"},I:{"1":"f tC uC","129":"tB I pC qC rC sC BC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"129":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS3 Media Queries"};


/***/ }),

/***/ 93831:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 I u J D E F A B C K L G M N O v w x y z","194":"5 6 7 8 9 AB BB CB DB EB FB GB"},E:{"2":"I u J D HC zB IC JC","260":"E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"2":"zB UC BC VC WC XC","260":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"Blending of HTML/SVG elements"};


/***/ }),

/***/ 46876:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB EC FC"},D:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB","194":"JB KB LB"},E:{"1":"sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B"},F:{"1":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","194":"6 7 8"},G:{"1":"sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"CSS Motion Path"};


/***/ }),

/***/ 9028:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS namespaces"};


/***/ }),

/***/ 6355:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t","194":"f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t","194":"f H xB"},E:{"1":"OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d PC QC RC SC qB AC TC rB","194":"e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"CSS Nesting"};


/***/ }),

/***/ 92481:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O Q R S T U V W","16":"P"},C:{"1":"T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S EC FC"},D:{"1":"X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC"},F:{"1":"mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB PC QC RC SC qB AC TC rB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"selector list argument of :not()"};


/***/ }),

/***/ 66492:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"selector list argument of :nth-child and :nth-last-child CSS pseudo-classes"};


/***/ }),

/***/ 23375:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","4":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS3 Opacity"};


/***/ }),

/***/ 93492:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","16":"F PC","132":"B C QC RC SC qB AC TC rB"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"132":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"g","132":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:":optional CSS pseudo-class"};


/***/ }),

/***/ 11721:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB EC FC"},D:{"1":"WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"CSS overflow-anchor (Scroll Anchoring)"};


/***/ }),

/***/ 74065:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L"},E:{"1":"I u J D E F A B IC JC KC LC 0B qB","16":"HC zB","130":"C K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC","16":"zB","130":"fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"16":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"CSS overflow: overlay"};


/***/ }),

/***/ 91764:
/***/ ((module) => {

module.exports={A:{A:{"388":"J D E F A B CC"},B:{"1":"Z a b c d e h i j k l m n o p q r s t f H","260":"P Q R S T U V W X Y","388":"C K L G M N O"},C:{"1":"R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","260":"vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q","388":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB EC FC"},D:{"1":"Z a b c d e h i j k l m n o p q r s t f H xB yB GC","260":"gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y","388":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB"},E:{"1":"sB 6B 7B 8B 9B OC","260":"L G 1B MC NC 2B 3B 4B 5B","388":"I u J D E F A B C K HC zB IC JC KC LC 0B qB rB"},F:{"1":"nB oB pB P Q R wB S T U V W X Y Z a b c d e","260":"VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB","388":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB PC QC RC SC qB AC TC rB"},G:{"1":"sB 6B 7B 8B 9B","260":"kC lC mC nC 2B 3B 4B 5B","388":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC"},H:{"388":"oC"},I:{"1":"f","388":"tB I pC qC rC sC BC tC uC"},J:{"388":"D A"},K:{"1":"g","388":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"388":"A B"},O:{"388":"vC"},P:{"1":"5C sB 6C 7C 8C","388":"I wC xC yC zC 0C 0B 1C 2C 3C 4C"},Q:{"388":"1B"},R:{"1":"9C"},S:{"388":"AD"}},B:5,C:"CSS overflow property"};


/***/ }),

/***/ 50237:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","132":"A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","132":"C K L G M N","516":"O"},C:{"1":"uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB EC FC"},D:{"1":"dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB","260":"bB cB"},E:{"1":"sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L HC zB IC JC KC LC 0B qB rB 1B","1090":"G MC NC 2B 3B 4B 5B"},F:{"1":"SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB PC QC RC SC qB AC TC rB","260":"QB RB"},G:{"1":"sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC","1090":"mC nC 2B 3B 4B 5B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"132":"A B"},O:{"1":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"CSS overscroll-behavior"};


/***/ }),

/***/ 88866:
/***/ ((module) => {

module.exports={A:{A:{"388":"A B","900":"J D E F CC"},B:{"388":"C K L G M N O","900":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"772":"dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","900":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB EC FC"},D:{"900":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"772":"A","900":"I u J D E F B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"16":"F PC","129":"B C QC RC SC qB AC TC rB","900":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"900":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"129":"oC"},I:{"900":"tB I f pC qC rC sC BC tC uC"},J:{"900":"D A"},K:{"129":"A B C qB AC rB","900":"g"},L:{"900":"H"},M:{"772":"H"},N:{"388":"A B"},O:{"900":"vC"},P:{"900":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"900":"1B"},R:{"900":"9C"},S:{"900":"AD"}},B:2,C:"CSS page-break properties"};


/***/ }),

/***/ 76098:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D CC","132":"E F A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","132":"C K L G M N O"},C:{"2":"DC tB I u J D E F A B C K L G M N O EC FC","132":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","132":"F B C PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"16":"oC"},I:{"16":"tB I f pC qC rC sC BC tC uC"},J:{"16":"D A"},K:{"1":"g","16":"A B C qB AC rB"},L:{"1":"H"},M:{"132":"H"},N:{"258":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"132":"AD"}},B:5,C:"CSS Paged Media (@page)"};


/***/ }),

/***/ 10133:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB"},E:{"2":"I u J D E F A B C HC zB IC JC KC LC 0B qB","194":"K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:4,C:"CSS Painting API"};


/***/ }),

/***/ 70361:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","292":"A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","164":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB"},D:{"1":"NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC"},F:{"1":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"164":"AD"}},B:5,C:":placeholder-shown CSS pseudo-class"};


/***/ }),

/***/ 83448:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","36":"C K L G M N O"},C:{"1":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O EC FC","33":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB"},D:{"1":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","36":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","36":"u J D E F A IC JC KC LC"},F:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","36":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC","36":"E BC VC WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f","36":"tB I pC qC rC sC BC tC uC"},J:{"36":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"36":"A B"},O:{"1":"vC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","36":"I wC xC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"33":"AD"}},B:5,C:"::placeholder CSS pseudo-element"};


/***/ }),

/***/ 51055:
/***/ ((module) => {

module.exports={A:{D:{"2":"I u J D E F A B C K L G M","33":"0 1 2 3 4 5 6 7 8 9 N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},L:{"33":"H"},B:{"2":"C K L G M N O","33":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB EC FC","33":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h"},M:{"1":"H"},A:{"2":"J D E F A B CC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},K:{"2":"A B C qB AC rB","33":"g"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B","2":"I u HC zB IC OC","33":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC","33":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B"},P:{"33":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},I:{"2":"tB I pC qC rC sC BC","33":"f tC uC"}},B:6,C:"print-color-adjust property"};


/***/ }),

/***/ 17667:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C"},C:{"1":"pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","16":"DC","33":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB EC FC"},D:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L","132":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"HC zB","132":"I u J D E IC JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","16":"F B PC QC RC SC qB","132":"C G M N O v w x y AC TC rB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC","132":"E BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"f","16":"pC qC","132":"tB I rC sC BC tC uC"},J:{"1":"A","132":"D"},K:{"1":"g","2":"A B qB","132":"C AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"33":"AD"}},B:1,C:"CSS :read-only and :read-write selectors"};


/***/ }),

/***/ 32723:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","132":"B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB"},E:{"1":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC","16":"JC"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"Rebeccapurple color"};


/***/ }),

/***/ 25056:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","33":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"33":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"HC zB","33":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"33":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"33":"tB I f pC qC rC sC BC tC uC"},J:{"33":"D A"},K:{"2":"A B C qB AC rB","33":"g"},L:{"33":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"33":"vC"},P:{"33":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"33":"1B"},R:{"33":"9C"},S:{"2":"AD"}},B:7,C:"CSS Reflections"};


/***/ }),

/***/ 32598:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","420":"A B"},B:{"2":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","420":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"I u J D E F A B C K L BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","36":"G M N O","66":"0 1 2 3 4 5 6 7 8 9 v w x y z AB"},E:{"2":"I u J C K L G HC zB IC qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","33":"D E F A B JC KC LC 0B"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"zB UC BC VC WC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","33":"E XC YC ZC aC bC cC dC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"420":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"CSS Regions"};


/***/ }),

/***/ 62787:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC","33":"I u J D E F A B C K L G FC"},D:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F","33":"0 1 A B C K L G M N O v w x y z"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB","33":"J IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B PC QC RC SC","33":"C TC","36":"qB AC"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC","33":"VC WC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB pC qC rC","33":"I sC BC"},J:{"1":"A","2":"D"},K:{"1":"g rB","2":"A B","33":"C","36":"qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS Repeating Gradients"};


/***/ }),

/***/ 36660:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","33":"I"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC","132":"rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:2,C:"CSS resize property"};


/***/ }),

/***/ 47190:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O P Q R S"},C:{"1":"fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB EC FC"},D:{"1":"T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S"},E:{"1":"A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC"},F:{"1":"g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB PC QC RC SC qB AC TC rB"},G:{"1":"aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:4,C:"CSS revert value"};


/***/ }),

/***/ 87215:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB EC FC"},D:{"1":"aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB","194":"SB TB UB VB WB XB YB uB ZB vB"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC"},F:{"1":"SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB PC QC RC SC qB AC TC rB","194":"FB GB HB IB JB KB LB MB NB OB PB QB RB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I","194":"wC xC yC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:4,C:"#rrggbbaa hex color notation"};


/***/ }),

/***/ 58544:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","129":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB","129":"vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","450":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K HC zB IC JC KC LC 0B qB rB 1B","578":"L G MC NC 2B"},F:{"2":"0 1 2 3 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","129":"OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","450":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC","578":"mC nC 2B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"129":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC"},Q:{"129":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"CSS Scroll-behavior"};


/***/ }),

/***/ 52572:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y","194":"Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T","194":"X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","322":"U V W"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB PC QC RC SC qB AC TC rB","194":"mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","322":"g lB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"CSS @scroll-timeline"};


/***/ }),

/***/ 37851:
/***/ ((module) => {

module.exports={A:{A:{"132":"J D E F A B CC"},B:{"2":"C K L G M N O","292":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB EC FC","3074":"bB","4100":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"292":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"16":"I u HC zB","292":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","292":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC VC WC","292":"XC","804":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC"},H:{"2":"oC"},I:{"16":"pC qC","292":"tB I f rC sC BC tC uC"},J:{"292":"D A"},K:{"2":"A B C qB AC rB","292":"g"},L:{"292":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"292":"vC"},P:{"292":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"292":"1B"},R:{"292":"9C"},S:{"2":"AD"}},B:7,C:"CSS scrollbar styling"};


/***/ }),

/***/ 92398:
/***/ ((module) => {

module.exports={A:{A:{"1":"D E F A B","2":"CC","8":"J"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS 2.1 selectors"};


/***/ }),

/***/ 40787:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"CC","8":"J","132":"D E"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC tB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","2":"F"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS3 selectors"};


/***/ }),

/***/ 16302:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","33":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","2":"F"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"C g AC rB","16":"A B qB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"33":"AD"}},B:5,C:"::selection CSS pseudo-element"};


/***/ }),

/***/ 56938:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB EC FC","322":"RB SB TB UB VB WB XB YB uB ZB vB"},D:{"1":"DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z","194":"AB BB CB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D HC zB IC JC","33":"E F A KC LC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC","33":"E YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:4,C:"CSS Shapes Level 1"};


/***/ }),

/***/ 82776:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","6308":"A","6436":"B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","6436":"C K L G M N O"},C:{"1":"gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB EC FC","2052":"FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB"},D:{"1":"hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB","8258":"eB fB gB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC","3108":"F A LC 0B"},F:{"1":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB PC QC RC SC qB AC TC rB","8258":"UB VB WB XB YB ZB aB bB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC","3108":"ZC aC bC cC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2052":"AD"}},B:4,C:"CSS Scroll Snap"};


/***/ }),

/***/ 67425:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"a b c d e h i j k l m n o p q r s t f H","2":"C K L G","1028":"P Q R S T U V W X Y Z","4100":"M N O"},C:{"1":"uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","194":"2 3 4 5 6 7","516":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB"},D:{"1":"a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O v w x y DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB","322":"0 1 2 3 4 5 6 7 8 9 z AB BB CB SB TB UB VB","1028":"WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z"},E:{"1":"K L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC","33":"E F A B C KC LC 0B qB rB","2084":"D JC"},F:{"1":"pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB PC QC RC SC qB AC TC rB","322":"FB GB HB","1028":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB"},G:{"1":"hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC","33":"E YC ZC aC bC cC dC eC fC gC","2084":"WC XC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1028":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC"},Q:{"1028":"1B"},R:{"1":"9C"},S:{"516":"AD"}},B:5,C:"CSS position:sticky"};


/***/ }),

/***/ 70836:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:4,C:"CSS Subgrid"};


/***/ }),

/***/ 43295:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","260":"C K L G M N O"},C:{"1":"VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v EC FC","66":"w x","260":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB"},D:{"1":"vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 I u J D E F A B C K L G M N O v w x y z","260":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC","132":"rB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC"},H:{"132":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC","132":"rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS.supports() API"};


/***/ }),

/***/ 57271:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","2":"J D CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","132":"DC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS Table display"};


/***/ }),

/***/ 68887:
/***/ ((module) => {

module.exports={A:{A:{"132":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","4":"C K L G M N O"},C:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B EC FC","33":"0 1 2 3 4 5 6 7 8 9 C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB"},D:{"1":"NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB","322":"BB CB DB EB FB GB HB IB JB KB LB MB"},E:{"1":"sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B"},F:{"1":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w x PC QC RC SC qB AC TC rB","578":"0 1 2 3 4 5 6 7 8 9 y z"},G:{"1":"sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"132":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"33":"AD"}},B:4,C:"CSS3 text-align-last"};


/***/ }),

/***/ 34715:
/***/ ((module) => {

module.exports={A:{A:{"132":"J D E F A B CC"},B:{"132":"C K L G M N O","388":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"132":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"132":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB","388":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"sB 6B 7B 8B 9B OC","132":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B"},F:{"132":"0 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","388":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"sB 6B 7B 8B 9B","132":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B"},H:{"132":"oC"},I:{"132":"tB I pC qC rC sC BC tC uC","388":"f"},J:{"132":"D A"},K:{"132":"A B C qB AC rB","388":"g"},L:{"388":"H"},M:{"132":"H"},N:{"132":"A B"},O:{"388":"vC"},P:{"132":"I","388":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"388":"1B"},R:{"388":"9C"},S:{"132":"AD"}},B:4,C:"CSS text-indent"};


/***/ }),

/***/ 83983:
/***/ ((module) => {

module.exports={A:{A:{"16":"J D CC","132":"E F A B"},B:{"132":"C K L G M N O","322":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB EC FC","1025":"VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","1602":"UB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB","322":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","322":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC tC uC","322":"f"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","322":"g"},L:{"322":"H"},M:{"1025":"H"},N:{"132":"A B"},O:{"322":"vC"},P:{"2":"I","322":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"322":"1B"},R:{"322":"9C"},S:{"2":"AD"}},B:4,C:"CSS text-justify"};


/***/ }),

/***/ 80045:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EC FC","194":"EB FB GB"},D:{"1":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB"},E:{"1":"L G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC","16":"A","33":"B C K 0B qB rB 1B"},F:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB PC QC RC SC qB AC TC rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS text-orientation"};


/***/ }),

/***/ 75688:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D CC","161":"E F A B"},B:{"2":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","161":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"16":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"CSS Text 4 text-spacing"};


/***/ }),

/***/ 43548:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","129":"A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","129":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC tB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","260":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","2":"F"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"4":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"A","4":"D"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"129":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS3 Text-shadow"};


/***/ }),

/***/ 8517:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F CC","289":"A"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","194":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB","1025":"SB TB UB VB WB"},D:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w x y PC QC RC SC qB AC TC rB"},G:{"1":"hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC","516":"aC bC cC dC eC fC gC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","289":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"194":"AD"}},B:2,C:"CSS touch-action property"};


/***/ }),

/***/ 61964:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","33":"u J D E F A B C K L G","164":"I"},D:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","33":"0 1 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","33":"J IC","164":"I u HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F PC QC","33":"C","164":"B RC SC qB AC TC"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","33":"WC","164":"zB UC BC VC"},H:{"2":"oC"},I:{"1":"f tC uC","33":"tB I pC qC rC sC BC"},J:{"1":"A","33":"D"},K:{"1":"g rB","33":"C","164":"A B qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"CSS3 Transitions"};


/***/ }),

/***/ 45257:
/***/ ((module) => {

module.exports={A:{A:{"132":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","132":"C K L G M N O"},C:{"1":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","33":"0 1 2 3 4 5 6 7 8 9 N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB","132":"DC tB I u J D E F EC FC","292":"A B C K L G M"},D:{"1":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","132":"I u J D E F A B C K L G M","548":"0 1 2 3 4 5 6 7 8 9 N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB"},E:{"132":"I u J D E HC zB IC JC KC","548":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"132":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"132":"E zB UC BC VC WC XC YC","548":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"16":"oC"},I:{"1":"f","16":"tB I pC qC rC sC BC tC uC"},J:{"16":"D A"},K:{"1":"g","16":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"132":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","16":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"33":"AD"}},B:4,C:"CSS unicode-bidi property"};


/***/ }),

/***/ 50750:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C"},C:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB"},E:{"1":"A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC"},F:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS unset value"};


/***/ }),

/***/ 32973:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L","260":"G"},C:{"1":"7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB","194":"OB"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC","260":"LC"},F:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB PC QC RC SC qB AC TC rB","194":"BB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC","260":"aC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS Variables (Custom Properties)"};


/***/ }),

/***/ 77028:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"CSS @when / @else conditional rules"};


/***/ }),

/***/ 47477:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D CC","129":"E F"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC JC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","129":"F B PC QC RC SC qB AC TC"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC"},H:{"1":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"2":"D A"},K:{"1":"g rB","2":"A B C qB AC"},L:{"1":"H"},M:{"2":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:2,C:"CSS widows & orphans"};


/***/ }),

/***/ 80847:
/***/ ((module) => {

module.exports={A:{D:{"2":"I u J D E F A B C K L G M N O v w x","33":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},L:{"33":"H"},B:{"2":"C K L G M N O","33":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"DC","33":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},M:{"33":"H"},A:{"2":"J D E F A B CC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},K:{"2":"A B C qB AC rB","33":"g"},E:{"2":"I u J HC zB IC JC OC","33":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B"},G:{"2":"zB UC BC VC WC","33":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},P:{"2":"I","33":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},I:{"2":"tB I pC qC rC sC BC","33":"f tC uC"}},B:6,C:"width: stretch property"};


/***/ }),

/***/ 47816:
/***/ ((module) => {

module.exports={A:{A:{"132":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB EC FC","322":"CB DB EB FB GB"},D:{"1":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J","16":"D","33":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","16":"u","33":"J D E F A IC JC KC LC 0B"},F:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC","33":"E VC WC XC YC ZC aC bC cC"},H:{"2":"oC"},I:{"1":"f","2":"pC qC rC","33":"tB I sC BC tC uC"},J:{"33":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"36":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","33":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS writing-mode property"};


/***/ }),

/***/ 26061:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D CC","129":"E F A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB"},H:{"2":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"129":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"CSS zoom"};


/***/ }),

/***/ 26203:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"CSS3 attr() function for all properties"};


/***/ }),

/***/ 47610:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","8":"J D CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","33":"0 1 2 3 4 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","33":"I u J D E F"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","33":"I u HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","2":"F"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","33":"zB UC BC"},H:{"1":"oC"},I:{"1":"I f sC BC tC uC","33":"tB pC qC rC"},J:{"1":"A","33":"D"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"CSS3 Box-sizing"};


/***/ }),

/***/ 91578:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","4":"DC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e QC RC SC qB AC TC rB","2":"F","4":"PC"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS3 Colors"};


/***/ }),

/***/ 63355:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L"},C:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","33":"0 1 2 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","33":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","33":"I u J D E F A HC zB IC JC KC LC 0B"},F:{"1":"C VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","2":"F B PC QC RC SC qB AC","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"33":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:2,C:"CSS grab & grabbing cursors"};


/***/ }),

/***/ 70800:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","33":"DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","33":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","33":"I u J D E HC zB IC JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","2":"F B PC QC RC SC qB AC","33":"G M N O v w x y z"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"33":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:2,C:"CSS3 Cursors: zoom-in & zoom-out"};


/***/ }),

/***/ 73281:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","132":"J D E CC"},B:{"1":"L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","260":"C K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","4":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","4":"I"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","4":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","260":"F B C PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D","16":"A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:2,C:"CSS3 Cursors (original values)"};


/***/ }),

/***/ 87604:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","33":"TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z","164":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB"},D:{"1":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O v w","132":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB"},E:{"1":"L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC","132":"D E F A B C K JC KC LC 0B qB rB"},F:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F PC QC RC","132":"0 1 2 3 4 G M N O v w x y z","164":"B C SC qB AC TC rB"},G:{"1":"kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC","132":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC"},H:{"164":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC","132":"tC uC"},J:{"132":"D A"},K:{"1":"g","2":"A","164":"B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"164":"AD"}},B:4,C:"CSS3 tab-size"};


/***/ }),

/***/ 66010:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","2":"F"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS currentColor value"};


/***/ }),

/***/ 89306:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","8":"A B"},B:{"1":"P","2":"Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","8":"C K L G M N O"},C:{"2":"DC tB I u J D E F A B C K L G M N O v w x y uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","66":"0 1 2 3 4 5 z","72":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB"},D:{"1":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P","2":"0 1 2 I u J D E F A B C K L G M N O v w x y z Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","66":"3 4 5 6 7 8"},E:{"2":"I u HC zB IC","8":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB","2":"F B C fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","66":"G M N O v"},G:{"2":"zB UC BC VC WC","8":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"uC","2":"tB I f pC qC rC sC BC tC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C","2":"3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"2":"9C"},S:{"72":"AD"}},B:7,C:"Custom Elements (deprecated V0 spec)"};


/***/ }),

/***/ 68426:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","8":"A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","8":"C K L G M N O"},C:{"1":"bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","8":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB","456":"QB RB SB TB UB VB WB XB YB","712":"uB ZB vB aB"},D:{"1":"fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB","8":"SB TB","132":"UB VB WB XB YB uB ZB vB aB bB cB dB eB"},E:{"2":"I u J D HC zB IC JC KC","8":"E F A LC","132":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB PC QC RC SC qB AC TC rB","132":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC","132":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I","132":"wC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"8":"AD"}},B:1,C:"Custom Elements (V1)"};


/***/ }),

/***/ 96529:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","132":"F A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u EC FC","132":"J D E F A"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I","16":"u J D E K L","388":"F A B C"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","16":"u J","388":"IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","2":"F PC QC RC SC","132":"B qB AC"},G:{"1":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"UC","16":"zB BC","388":"VC"},H:{"1":"oC"},I:{"1":"f tC uC","2":"pC qC rC","388":"tB I sC BC"},J:{"1":"A","388":"D"},K:{"1":"C g rB","2":"A","132":"B qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"132":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"CustomEvent"};


/***/ }),

/***/ 61338:
/***/ ((module) => {

module.exports={A:{A:{"2":"CC","8":"J D E F","260":"A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","260":"C K L G","1284":"M N O"},C:{"1":"H xB yB","8":"DC tB EC FC","516":"n o p q r s t f","4612":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m"},D:{"1":"hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","8":"I u J D E F A B C K L G M N O v","132":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB"},E:{"1":"K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"I u J D E F A B C HC zB IC JC KC LC 0B qB"},F:{"1":"F B C cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","132":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB"},G:{"8":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC","2049":"gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f uC","8":"tB I pC qC rC sC BC tC"},J:{"1":"A","8":"D"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"8":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:1,C:"Datalist element"};


/***/ }),

/***/ 80410:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","4":"J D E F A CC"},B:{"1":"C K L G M","129":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB","4":"DC tB I u EC FC","129":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"LB MB NB OB PB QB RB SB TB UB","4":"I u J","129":"0 1 2 3 4 5 6 7 8 9 D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"4":"I u HC zB","129":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"8 9 C AB BB CB DB EB FB GB HB qB AC TC rB","4":"F B PC QC RC SC","129":"0 1 2 3 4 5 6 7 G M N O v w x y z IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"4":"zB UC BC","129":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"4":"oC"},I:{"4":"pC qC rC","129":"tB I f sC BC tC uC"},J:{"129":"D A"},K:{"1":"C qB AC rB","4":"A B","129":"g"},L:{"129":"H"},M:{"129":"H"},N:{"1":"B","4":"A"},O:{"129":"vC"},P:{"129":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"129":"1B"},R:{"129":"9C"},S:{"1":"AD"}},B:1,C:"dataset & data-* attributes"};


/***/ }),

/***/ 57593:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D CC","132":"E","260":"F A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","260":"C K G M N O","772":"L"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"260":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Data URIs"};


/***/ }),

/***/ 57488:
/***/ ((module) => {

module.exports={A:{A:{"16":"CC","132":"J D E F A B"},B:{"1":"O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","132":"C K L G M N"},C:{"1":"WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","132":"0 1 2 3 4 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","260":"SB TB UB VB","772":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB"},D:{"1":"iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","132":"I u J D E F A B C K L G M N O v w x y z","260":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB","772":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB"},E:{"1":"C K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"I u HC zB","132":"J D E F A IC JC KC LC","260":"B 0B qB"},F:{"1":"XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","16":"F B C PC QC RC SC qB AC TC","132":"rB","260":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB","772":"0 G M N O v w x y z"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC VC","132":"E WC XC YC ZC aC bC"},H:{"132":"oC"},I:{"1":"f","16":"tB pC qC rC","132":"I sC BC","772":"tC uC"},J:{"132":"D A"},K:{"1":"g","16":"A B C qB AC","132":"rB"},L:{"1":"H"},M:{"1":"H"},N:{"132":"A B"},O:{"1":"vC"},P:{"1":"0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","260":"I wC xC yC zC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"132":"AD"}},B:6,C:"Date.prototype.toLocaleDateString"};


/***/ }),

/***/ 96490:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O P Q R S T U V W X Y"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T","66":"U V W X Y"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"OC"},F:{"1":"oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"Declarative Shadow DOM"};


/***/ }),

/***/ 27519:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"Decorators"};


/***/ }),

/***/ 55777:
/***/ ((module) => {

module.exports={A:{A:{"2":"F A B CC","8":"J D E"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC","8":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB EC FC","194":"NB OB"},D:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","8":"I u J D E F A B","257":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB","769":"C K L G M N O"},E:{"1":"C K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"I u HC zB IC","257":"J D E F A JC KC LC","1025":"B 0B qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"C qB AC TC rB","8":"F B PC QC RC SC"},G:{"1":"E WC XC YC ZC aC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","8":"zB UC BC VC","1025":"bC cC dC"},H:{"8":"oC"},I:{"1":"I f sC BC tC uC","8":"tB pC qC rC"},J:{"1":"A","8":"D"},K:{"1":"g","8":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Details & Summary elements"};


/***/ }),

/***/ 30111:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","132":"B"},B:{"1":"C K L G M N O","4":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"DC tB EC","4":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","8":"I u FC"},D:{"2":"I u J","4":"0 1 2 3 4 5 6 7 8 9 D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","4":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"zB UC","4":"E BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"pC qC rC","4":"tB I f sC BC tC uC"},J:{"2":"D","4":"A"},K:{"1":"C rB","2":"A B qB AC","4":"g"},L:{"4":"H"},M:{"4":"H"},N:{"1":"B","2":"A"},O:{"4":"vC"},P:{"4":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"4":"1B"},R:{"4":"9C"},S:{"4":"AD"}},B:4,C:"DeviceOrientation & DeviceMotion events"};


/***/ }),

/***/ 57084:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","2":"F B PC QC RC SC qB AC"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"C g rB","2":"A B qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"Window.devicePixelRatio"};


/***/ }),

/***/ 84530:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB EC FC","194":"TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P","1218":"Q R wB S T U V W X Y Z a b c d e h i"},D:{"1":"DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 I u J D E F A B C K L G M N O v w x y z","322":"8 9 AB BB CB"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O PC QC RC SC qB AC TC rB","578":"v w x y z"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:1,C:"Dialog element"};


/***/ }),

/***/ 63229:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","16":"CC","129":"F A","130":"J D E"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"HC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","16":"F"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB"},H:{"1":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","129":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"EventTarget.dispatchEvent"};


/***/ }),

/***/ 15381:
/***/ ((module) => {

module.exports={A:{A:{"132":"J D E F A B CC"},B:{"132":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"132":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"132":"7 8 9 I u AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","388":"0 1 2 3 4 5 6 J D E F A B C K L G M N O v w x y z"},E:{"132":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"132":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"132":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"132":"oC"},I:{"132":"tB I f pC qC rC sC BC tC uC"},J:{"132":"D A"},K:{"132":"A B C g qB AC rB"},L:{"132":"H"},M:{"132":"H"},N:{"132":"A B"},O:{"132":"vC"},P:{"132":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"132":"1B"},R:{"132":"9C"},S:{"132":"AD"}},B:6,C:"DNSSEC and DANE"};


/***/ }),

/***/ 3481:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","164":"F A","260":"B"},B:{"1":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","260":"C K L G M"},C:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E EC FC","516":"0 1 2 3 4 5 6 7 F A B C K L G M N O v w x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O v w x y"},E:{"1":"J A B C IC LC 0B qB","2":"I u K L G HC zB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","1028":"D E F JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B PC QC RC SC qB AC TC"},G:{"1":"ZC aC bC cC dC eC fC","2":"zB UC BC VC WC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","1028":"E XC YC"},H:{"1":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"16":"D","1028":"A"},K:{"1":"g rB","16":"A B C qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"164":"A","260":"B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:7,C:"Do Not Track API"};


/***/ }),

/***/ 88864:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"E F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D HC zB IC JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G PC QC RC SC qB AC TC rB"},G:{"1":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"document.currentScript"};


/***/ }),

/***/ 93781:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","16":"DC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","16":"F"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:7,C:"document.evaluate & XPath"};


/***/ }),

/***/ 24147:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"I u HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e QC RC SC qB AC TC rB","16":"F PC"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC","16":"BC VC WC"},H:{"2":"oC"},I:{"1":"f sC BC tC uC","2":"tB I pC qC rC"},J:{"1":"A","2":"D"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:7,C:"Document.execCommand()"};


/***/ }),

/***/ 39985:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T","132":"U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T","132":"U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB PC QC RC SC qB AC TC rB","132":"jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC tC uC","132":"f"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","132":"g"},L:{"132":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"132":"9C"},S:{"2":"AD"}},B:7,C:"Document Policy"};


/***/ }),

/***/ 55988:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","16":"C K"},C:{"1":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB EC FC"},D:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC"},F:{"1":"7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"document.scrollingElement"};


/***/ }),

/***/ 2001:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","16":"u"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e qB AC TC rB","2":"F PC QC RC SC"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB"},H:{"1":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"document.head"};


/***/ }),

/***/ 64198:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M"},C:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB EC FC"},D:{"1":"UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB","194":"SB TB"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC"},F:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB PC QC RC SC qB AC TC rB","194":"GB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:1,C:"DOM manipulation convenience methods"};


/***/ }),

/***/ 3563:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"CC","8":"J D E"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Document Object Model Range"};


/***/ }),

/***/ 38057:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"DOMContentLoaded"};


/***/ }),

/***/ 31943:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","132":"A B"},B:{"132":"C K L G M N O","1028":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","1028":"hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2564":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB","3076":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB"},D:{"16":"I u J D","132":"0 1 2 3 4 5 6 7 8 9 F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB","388":"E","1028":"vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"16":"I HC zB","132":"u J D E F A IC JC KC LC 0B","1028":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","132":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB","1028":"OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"16":"zB UC BC","132":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"132":"I sC BC tC uC","292":"tB pC qC rC","1028":"f"},J:{"16":"D","132":"A"},K:{"2":"A B C qB AC rB","1028":"g"},L:{"1028":"H"},M:{"1028":"H"},N:{"132":"A B"},O:{"1028":"vC"},P:{"132":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1028":"1B"},R:{"1028":"9C"},S:{"2564":"AD"}},B:4,C:"DOMMatrix"};


/***/ }),

/***/ 49291:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Download attribute"};


/***/ }),

/***/ 625:
/***/ ((module) => {

module.exports={A:{A:{"644":"J D E F CC","772":"A B"},B:{"1":"O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","260":"C K L G M N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","8":"DC tB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","8":"F B PC QC RC SC qB AC TC"},G:{"1":"nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC tC uC","1025":"f"},J:{"2":"D A"},K:{"1":"rB","8":"A B C qB AC","1025":"g"},L:{"1025":"H"},M:{"2":"H"},N:{"1":"A B"},O:{"1025":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:1,C:"Drag and Drop"};


/***/ }),

/***/ 54805:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L"},C:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB EC FC"},D:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC"},F:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Element.closest()"};


/***/ }),

/***/ 25808:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","16":"CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","16":"DC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e qB AC TC rB","16":"F PC QC RC SC"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB"},H:{"1":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"C g rB","16":"A B qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"document.elementFromPoint()"};


/***/ }),

/***/ 80674:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB EC FC"},D:{"1":"vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB"},E:{"1":"L G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC","132":"A B C K 0B qB rB 1B"},F:{"1":"OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB PC QC RC SC qB AC TC rB"},G:{"1":"mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC","132":"bC cC dC eC fC gC hC iC jC kC lC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"Scroll methods on elements (scroll, scrollTo, scrollBy)"};


/***/ }),

/***/ 21671:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","164":"B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EC FC"},D:{"1":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB","132":"BB CB DB EB FB GB HB"},E:{"1":"C K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC JC","164":"D E F A B KC LC 0B qB"},F:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w x PC QC RC SC qB AC TC rB","132":"0 1 2 3 4 y z"},G:{"1":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"Encrypted Media Extensions"};


/***/ }),

/***/ 51180:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","2":"CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"EOT - Embedded OpenType fonts"};


/***/ }),

/***/ 62719:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D CC","260":"F","1026":"E"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","4":"DC tB EC FC","132":"I u J D E F A B C K L G M N O v w"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","4":"I u J D E F A B C K L G M N O","132":"v w x y"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","4":"I u HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","4":"F B C PC QC RC SC qB AC TC","132":"rB"},G:{"1":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","4":"zB UC BC VC"},H:{"132":"oC"},I:{"1":"f tC uC","4":"tB pC qC rC","132":"sC BC","900":"I"},J:{"1":"A","4":"D"},K:{"1":"g","4":"A B C qB AC","132":"rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"ECMAScript 5"};


/***/ }),

/***/ 54682:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C"},C:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB EC FC"},D:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB","132":"IB JB KB LB MB NB OB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC"},F:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","132":"5 6 7 8 9 AB BB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"ES6 classes"};


/***/ }),

/***/ 6483:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C"},C:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC"},F:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"ES6 Generators"};


/***/ }),

/***/ 69972:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB EC FC","194":"eB"},D:{"1":"bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB"},E:{"1":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B HC zB IC JC KC LC 0B"},F:{"1":"QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB PC QC RC SC qB AC TC rB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"JavaScript modules: dynamic import()"};


/***/ }),

/***/ 33513:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L","4097":"M N O","4290":"G"},C:{"1":"ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB EC FC","322":"UB VB WB XB YB uB"},D:{"1":"vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB","194":"ZB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC","3076":"0B"},F:{"1":"OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB PC QC RC SC qB AC TC rB","194":"NB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC","3076":"cC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:1,C:"JavaScript modules via script tag"};


/***/ }),

/***/ 24785:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G EC FC","132":"0 M N O v w x y z","260":"1 2 3 4 5 6","516":"7"},D:{"1":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O","1028":"0 1 2 3 4 5 6 7 8 9 v w x y z"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","1028":"G M N O v w"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC","1028":"sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"ES6 Number"};


/***/ }),

/***/ 41908:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB EC FC"},D:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC"},F:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"String.prototype.includes"};


/***/ }),

/***/ 76634:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","388":"B"},B:{"257":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","260":"C K L","769":"G M N O"},C:{"2":"DC tB I u EC FC","4":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB","257":"UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"I u J D E F A B C K L G M N O v w","4":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB","257":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D HC zB IC JC","4":"E F KC LC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","4":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB","257":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC","4":"E XC YC ZC aC"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC","4":"tC uC","257":"f"},J:{"2":"D","4":"A"},K:{"2":"A B C qB AC rB","257":"g"},L:{"257":"H"},M:{"257":"H"},N:{"2":"A","388":"B"},O:{"257":"vC"},P:{"4":"I","257":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"257":"1B"},R:{"257":"9C"},S:{"4":"AD"}},B:6,C:"ECMAScript 2015 (ES6)"};


/***/ }),

/***/ 99513:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e qB AC TC rB","4":"F PC QC RC SC"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"D A"},K:{"1":"C g qB AC rB","4":"A B"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Server-sent events"};


/***/ }),

/***/ 29486:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K HC zB IC JC KC LC 0B qB rB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"ui-serif, ui-sans-serif, ui-monospace and ui-rounded values for font-family"};


/***/ }),

/***/ 6411:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W","2":"C K L G M N O","1025":"X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g EC FC","260":"lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"lB mB nB oB pB P Q R S T U V W","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB","132":"ZB vB aB bB cB dB eB fB gB hB iB jB kB g","1025":"X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B HC zB IC JC KC LC 0B","772":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"aB bB cB dB eB fB gB hB iB jB kB g lB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB PC QC RC SC qB AC TC rB","132":"NB OB PB QB RB SB TB UB VB WB XB YB ZB","1025":"mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC","772":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","1025":"g"},L:{"1025":"H"},M:{"260":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC","132":"zC 0C 0B"},Q:{"132":"1B"},R:{"1025":"9C"},S:{"2":"AD"}},B:7,C:"Feature Policy"};


/***/ }),

/***/ 80486:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K"},C:{"1":"GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","1025":"FB","1218":"AB BB CB DB EB"},D:{"1":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB","260":"GB","772":"HB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","260":"3","772":"4"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Fetch"};


/***/ }),

/***/ 35953:
/***/ ((module) => {

module.exports={A:{A:{"16":"CC","132":"E F","388":"J D A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G","16":"M N O v"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e QC RC SC qB AC TC rB","16":"F PC"},G:{"1":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC"},H:{"388":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A","260":"B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"disabled attribute of the fieldset element"};


/***/ }),

/***/ 61730:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","260":"A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","260":"C K L G M N O"},C:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC","260":"0 1 2 3 I u J D E F A B C K L G M N O v w x y z FC"},D:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u","260":"0 1 2 3 4 5 6 7 8 9 K L G M N O v w x y z AB BB CB DB","388":"J D E F A B C"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB","260":"J D E F JC KC LC","388":"IC"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B PC QC RC SC","260":"0 C G M N O v w x y z qB AC TC rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC","260":"E WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f uC","2":"pC qC rC","260":"tC","388":"tB I sC BC"},J:{"260":"A","388":"D"},K:{"1":"g","2":"A B","260":"C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A","260":"B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"File API"};


/***/ }),

/***/ 92314:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","132":"A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB FC","2":"DC tB EC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e qB AC TC rB","2":"F B PC QC RC SC"},G:{"1":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC"},H:{"2":"oC"},I:{"1":"tB I f sC BC tC uC","2":"pC qC rC"},J:{"1":"A","2":"D"},K:{"1":"C g qB AC rB","2":"A B"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"FileReader API"};


/***/ }),

/***/ 80418:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","2":"F PC QC","16":"B RC SC qB AC"},G:{"1":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"C g AC rB","2":"A","16":"B qB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"FileReaderSync"};


/***/ }),

/***/ 13394:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","33":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"I u J D","33":"0 1 2 3 4 5 6 7 8 9 K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","36":"E F A B C"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D","33":"A"},K:{"2":"A B C qB AC rB","33":"g"},L:{"33":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"33":"vC"},P:{"2":"I","33":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"33":"9C"},S:{"2":"AD"}},B:7,C:"Filesystem & FileWriter API"};


/***/ }),

/***/ 37012:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G"},C:{"1":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB EC FC"},D:{"1":"WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB","16":"KB LB MB","388":"NB OB PB QB RB SB TB UB VB"},E:{"1":"K L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B","516":"B C qB rB"},F:{"1":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB PC QC RC SC qB AC TC rB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC"},H:{"2":"oC"},I:{"1":"f","2":"pC qC rC","16":"tB I sC BC tC uC"},J:{"1":"A","2":"D"},K:{"1":"g rB","16":"A B C qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","129":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"FLAC audio format"};


/***/ }),

/***/ 2448:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O P Q R S"},C:{"1":"bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB EC FC"},D:{"1":"T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S"},E:{"1":"G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L HC zB IC JC KC LC 0B qB rB 1B"},F:{"1":"iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB PC QC RC SC qB AC TC rB"},G:{"1":"mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"gap property for Flexbox"};


/***/ }),

/***/ 48976:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","1028":"B","1316":"A"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","164":"DC tB I u J D E F A B C K L G M N O v w x EC FC","516":"0 1 2 3 y z"},D:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","33":"0 1 2 3 4 x y z","164":"I u J D E F A B C K L G M N O v w"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","33":"D E JC KC","164":"I u J HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B C PC QC RC SC qB AC TC","33":"G M"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","33":"E XC YC","164":"zB UC BC VC WC"},H:{"1":"oC"},I:{"1":"f tC uC","164":"tB I pC qC rC sC BC"},J:{"1":"A","164":"D"},K:{"1":"g rB","2":"A B C qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","292":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS Flexible Box Layout Module"};


/***/ }),

/***/ 37107:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB EC FC"},D:{"1":"YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB"},E:{"1":"K L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C HC zB IC JC KC LC 0B qB rB"},F:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB PC QC RC SC qB AC TC rB"},G:{"1":"hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:4,C:"display: flow-root"};


/***/ }),

/***/ 3162:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","2":"CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"I u HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","2":"F PC QC RC SC","16":"B qB AC"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"2":"oC"},I:{"1":"I f sC BC tC uC","2":"pC qC rC","16":"tB"},J:{"1":"D A"},K:{"1":"C g rB","2":"A","16":"B qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"focusin & focusout events"};


/***/ }),

/***/ 92562:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB EC FC","132":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a"},D:{"1":"WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB","260":"TB UB VB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC","16":"F","132":"A LC 0B"},F:{"1":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB PC QC RC SC qB AC TC rB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC","132":"ZC aC bC cC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"132":"AD"}},B:5,C:"system-ui value for font-family"};


/***/ }),

/***/ 26538:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z","164":"I u J D E F A B C K L"},D:{"1":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G","33":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB","292":"M N O v w"},E:{"1":"A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"D E F HC zB JC KC","4":"I u J IC"},F:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB"},G:{"1":"aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E XC YC ZC","4":"zB UC BC VC WC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC","33":"tC uC"},J:{"2":"D","33":"A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","33":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS font-feature-settings"};


/***/ }),

/***/ 88367:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v w x y z EC FC","194":"0 1 2 3 4 5 6 7 8 9"},D:{"1":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 I u J D E F A B C K L G M N O v w x y z","33":"5 6 7 8"},E:{"1":"A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC JC","33":"D E F KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G PC QC RC SC qB AC TC rB","33":"M N O v"},G:{"1":"fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC","33":"E YC ZC aC bC cC dC eC"},H:{"2":"oC"},I:{"1":"f uC","2":"tB I pC qC rC sC BC","33":"tC"},J:{"2":"D","33":"A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS3 font-kerning"};


/***/ }),

/***/ 90792:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB EC FC","194":"BB CB DB EB FB GB"},D:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w x PC QC RC SC qB AC TC rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"CSS Font Loading"};


/***/ }),

/***/ 60647:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","194":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB","194":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B"},F:{"2":"0 1 2 3 4 5 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","194":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"194":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:2,C:"CSS font-size-adjust"};


/***/ }),

/***/ 21936:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","676":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","804":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"I","676":"0 1 2 3 4 5 6 7 8 9 u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"HC zB","676":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","676":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"804":"AD"}},B:7,C:"CSS font-smooth"};


/***/ }),

/***/ 88108:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","4":"F A B"},B:{"1":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","4":"C K L G M"},C:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB EC FC","194":"CB DB EB FB GB HB IB JB"},D:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","4":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","4":"I u J D E F HC zB IC JC KC LC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","4":"G M N O v w x y"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","4":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f","4":"tB I pC qC rC sC BC tC uC"},J:{"2":"D","4":"A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"4":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","4":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"Font unicode-range subsetting"};


/***/ }),

/***/ 90534:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","130":"A B"},B:{"130":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","130":"I u J D E F A B C K L G M N O v w x y z","322":"0 1 2 3 4 5 6 7 8 9"},D:{"1":"xB yB GC","2":"I u J D E F A B C K L G","130":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},E:{"1":"A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"D E F HC zB JC KC","130":"I u J IC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","130":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB XC YC ZC","130":"UC BC VC WC"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC","130":"f tC uC"},J:{"2":"D","130":"A"},K:{"2":"A B C qB AC rB","130":"g"},L:{"130":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"130":"vC"},P:{"130":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"130":"1B"},R:{"130":"9C"},S:{"1":"AD"}},B:5,C:"CSS font-variant-alternates"};


/***/ }),

/***/ 85199:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB"},E:{"1":"A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC"},F:{"1":"FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB PC QC RC SC qB AC TC rB"},G:{"1":"aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D","16":"A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS font-variant-numeric"};


/***/ }),

/***/ 90829:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","132":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC tB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e QC RC SC qB AC TC rB","2":"F PC"},G:{"1":"E BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","260":"zB UC"},H:{"2":"oC"},I:{"1":"I f sC BC tC uC","2":"pC","4":"tB qC rC"},J:{"1":"A","4":"D"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"@font-face Web fonts"};


/***/ }),

/***/ 32662:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","16":"u"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","2":"F"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"1":"oC"},I:{"1":"tB I f sC BC tC uC","2":"pC qC rC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Form attribute"};


/***/ }),

/***/ 37913:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e SC qB AC TC rB","2":"F PC","16":"QC RC"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"1":"oC"},I:{"1":"I f sC BC tC uC","2":"pC qC rC","16":"tB"},J:{"1":"A","2":"D"},K:{"1":"B C g qB AC rB","16":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Attributes for form submission"};


/***/ }),

/***/ 17644:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","132":"u J D E F A IC JC KC LC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e QC RC SC qB AC TC rB","2":"F PC"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB","132":"E UC BC VC WC XC YC ZC aC bC"},H:{"516":"oC"},I:{"1":"f uC","2":"tB pC qC rC","132":"I sC BC tC"},J:{"1":"A","132":"D"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"260":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"132":"AD"}},B:1,C:"Form validation"};


/***/ }),

/***/ 68112:
/***/ ((module) => {

module.exports={A:{A:{"2":"CC","4":"A B","8":"J D E F"},B:{"1":"M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","4":"C K L G"},C:{"4":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","8":"DC tB EC FC"},D:{"1":"vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","4":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB"},E:{"4":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"HC zB"},F:{"1":"F B C SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","4":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB"},G:{"2":"zB","4":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC","4":"tC uC"},J:{"2":"D","4":"A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"4":"H"},N:{"4":"A B"},O:{"1":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","4":"I wC xC yC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"4":"AD"}},B:1,C:"HTML5 form features"};


/***/ }),

/***/ 99086:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","548":"B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","516":"C K L G M N O"},C:{"1":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F EC FC","676":"0 1 2 3 4 5 6 7 8 9 A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB","1700":"NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB"},D:{"1":"jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L","676":"G M N O v","804":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB"},E:{"1":"9B OC","2":"I u HC zB","548":"3B 4B 5B sB 6B 7B 8B","676":"IC","804":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B"},F:{"1":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B C PC QC RC SC qB AC TC","804":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC","2052":"fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D","292":"A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A","548":"B"},O:{"1":"vC"},P:{"1":"0B 1C 2C 3C 4C 5C sB 6C 7C 8C","804":"I wC xC yC zC 0C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Full Screen API"};


/***/ }),

/***/ 66952:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O v w","33":"0 x y z"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"Gamepad API"};


/***/ }),

/***/ 64161:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"CC","8":"J D E"},B:{"1":"C K L G M N O","129":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB EC FC","8":"DC tB","129":"VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB","4":"I","129":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"u J D E F B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"I HC zB","129":"A"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C M N O v w x y z AB BB CB DB EB SC qB AC TC rB","2":"F G PC","8":"QC RC","129":"FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"E zB UC BC VC WC XC YC ZC aC","129":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I pC qC rC sC BC tC uC","129":"f"},J:{"1":"D A"},K:{"1":"B C qB AC rB","8":"A","129":"g"},L:{"129":"H"},M:{"129":"H"},N:{"1":"A B"},O:{"129":"vC"},P:{"1":"I","129":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"129":"1B"},R:{"129":"9C"},S:{"1":"AD"}},B:2,C:"Geolocation"};


/***/ }),

/***/ 73165:
/***/ ((module) => {

module.exports={A:{A:{"644":"J D CC","2049":"F A B","2692":"E"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2049":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC","260":"I u J D E F A B","1156":"tB","1284":"EC","1796":"FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e SC qB AC TC rB","16":"F PC","132":"QC RC"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB"},H:{"1":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","132":"A"},L:{"1":"H"},M:{"1":"H"},N:{"2049":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"Element.getBoundingClientRect()"};


/***/ }),

/***/ 43665:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC","132":"tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","260":"I u J D E F A"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","260":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e SC qB AC TC rB","260":"F PC QC RC"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","260":"zB UC BC"},H:{"260":"oC"},I:{"1":"I f sC BC tC uC","260":"tB pC qC rC"},J:{"1":"A","260":"D"},K:{"1":"B C g qB AC rB","260":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"getComputedStyle"};


/***/ }),

/***/ 85337:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"CC","8":"J D E"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","8":"DC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","2":"F"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"getElementsByClassName"};


/***/ }),

/***/ 26199:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","33":"B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v w EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A","33":"B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"crypto.getRandomValues()"};


/***/ }),

/***/ 49966:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB","194":"YB uB ZB vB aB bB cB dB eB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:4,C:"Gyroscope"};


/***/ }),

/***/ 89006:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L"},C:{"1":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB EC FC"},D:{"1":"DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB"},E:{"2":"I u J D HC zB IC JC KC","129":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","194":"E F A LC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"2":"zB UC BC VC WC XC","129":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","194":"E YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"navigator.hardwareConcurrency"};


/***/ }),

/***/ 62563:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","8":"J D CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB FC","8":"DC tB EC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","8":"I"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e SC qB AC TC rB","8":"F PC QC RC"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB"},H:{"2":"oC"},I:{"1":"tB I f qC rC sC BC tC uC","2":"pC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","8":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Hashchange event"};


/***/ }),

/***/ 56666:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A HC zB IC JC KC LC 0B","130":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC","130":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:6,C:"HEIF/ISO Base Media File Format"};


/***/ }),

/***/ 64206:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","132":"B"},B:{"132":"C K L G M N O","1028":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r","2052":"s t f H xB yB GC"},E:{"1":"K L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B","516":"B C qB rB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c PC QC RC SC qB AC TC rB","2052":"d e"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC tC uC","2052":"f"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","258":"g"},L:{"2052":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I","258":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"HEVC/H.265 video format"};


/***/ }),

/***/ 6027:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e qB AC TC rB","2":"F B PC QC RC SC"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"1":"oC"},I:{"1":"I f sC BC tC uC","2":"tB pC qC rC"},J:{"1":"A","2":"D"},K:{"1":"C g qB AC rB","2":"A B"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"hidden attribute"};


/***/ }),

/***/ 88772:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O v","33":"w x y z"},E:{"1":"E F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D HC zB IC JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"High Resolution Time API"};


/***/ }),

/***/ 81648:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","4":"u IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e AC TC rB","2":"F B PC QC RC SC qB"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC","4":"BC"},H:{"2":"oC"},I:{"1":"f qC rC BC tC uC","2":"tB I pC sC"},J:{"1":"D A"},K:{"1":"C g qB AC rB","2":"A B"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Session history management"};


/***/ }),

/***/ 64940:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"zB UC BC VC","129":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I f sC BC tC uC","2":"pC","257":"qC rC"},J:{"1":"A","16":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"516":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"16":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:2,C:"HTML Media Capture"};


/***/ }),

/***/ 72753:
/***/ ((module) => {

module.exports={A:{A:{"2":"CC","8":"J D E","260":"F A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC","132":"tB EC FC","260":"I u J D E F A B C K L G M N O v w"},D:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","132":"I u","260":"0 1 J D E F A B C K L G M N O v w x y z"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","132":"I HC zB","260":"u J IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","132":"F B PC QC RC SC","260":"C qB AC TC rB"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","132":"zB","260":"UC BC VC WC"},H:{"132":"oC"},I:{"1":"f tC uC","132":"pC","260":"tB I qC rC sC BC"},J:{"260":"D A"},K:{"1":"g","132":"A","260":"B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"260":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"HTML5 semantic elements"};


/***/ }),

/***/ 15638:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O","2":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I f sC BC tC uC","2":"pC qC rC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"HTTP Live Streaming (HLS)"};


/***/ }),

/***/ 16824:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","132":"B"},B:{"1":"C K L G M N O","513":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB EC FC","513":"TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"HB IB JB KB LB MB NB OB PB QB","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB","513":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC","260":"F A LC 0B"},F:{"1":"4 5 6 7 8 9 AB BB CB DB","2":"0 1 2 3 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","513":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC tC uC","513":"f"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","513":"g"},L:{"513":"H"},M:{"513":"H"},N:{"2":"A B"},O:{"513":"vC"},P:{"1":"I","513":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"513":"1B"},R:{"513":"9C"},S:{"1":"AD"}},B:6,C:"HTTP/2 protocol"};


/***/ }),

/***/ 70549:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O","322":"P Q R S T","578":"U V"},C:{"1":"X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB EC FC","194":"kB g lB mB nB oB pB P Q R wB S T U V W"},D:{"1":"W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB","322":"P Q R S T","578":"U V"},E:{"2":"I u J D E F A B C K HC zB IC JC KC LC 0B qB rB 1B","1090":"L G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB PC QC RC SC qB AC TC rB","578":"g"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC","66":"lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"HTTP/3 protocol"};


/***/ }),

/***/ 76002:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M EC FC","4":"0 1 2 3 N O v w x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC"},H:{"2":"oC"},I:{"1":"tB I f qC rC sC BC tC uC","2":"pC"},J:{"1":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"sandbox attribute for iframes"};


/***/ }),

/***/ 82891:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","66":"0 1 2 w x y z"},E:{"2":"I u J E F A B C K L G HC zB IC JC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","130":"D KC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","130":"XC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"seamless attribute for iframes"};


/***/ }),

/***/ 72100:
/***/ ((module) => {

module.exports={A:{A:{"2":"CC","8":"J D E F A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","8":"C K L G M N O"},C:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC","8":"0 tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K","8":"L G M N O v"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB","8":"I u IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B PC QC RC SC","8":"C qB AC TC rB"},G:{"1":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB","8":"UC BC VC"},H:{"2":"oC"},I:{"1":"f tC uC","8":"tB I pC qC rC sC BC"},J:{"1":"A","8":"D"},K:{"1":"g","2":"A B","8":"C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"8":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"srcdoc attribute for iframes"};


/***/ }),

/***/ 16659:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB EC FC","194":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB","322":"TB UB VB WB XB YB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB PC QC RC SC qB AC TC rB","322":"GB HB IB JB KB LB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"194":"AD"}},B:5,C:"ImageCapture API"};


/***/ }),

/***/ 54606:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","161":"B"},B:{"2":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","161":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A","161":"B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"Input Method Editor API"};


/***/ }),

/***/ 35720:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"naturalWidth & naturalHeight image properties"};


/***/ }),

/***/ 64548:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O","194":"P Q R S T U V W X"},C:{"1":"t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m EC FC","322":"n o p q r s"},D:{"1":"Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g","194":"lB mB nB oB pB P Q R S T U V W X"},E:{"1":"9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B"},F:{"1":"nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB PC QC RC SC qB AC TC rB","194":"aB bB cB dB eB fB gB hB iB jB kB g lB mB"},G:{"1":"9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"Import maps"};


/***/ }),

/***/ 72563:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","8":"A B"},B:{"1":"P","2":"Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","8":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","8":"6 7 WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","72":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB"},D:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P","2":"0 1 2 3 4 5 I u J D E F A B C K L G M N O v w x y z Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","66":"6 7 8 9 AB","72":"BB"},E:{"2":"I u HC zB IC","8":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB","2":"F B C G M fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","66":"N O v w x","72":"y"},G:{"2":"zB UC BC VC WC","8":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"8":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C","2":"3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"2":"9C"},S:{"1":"AD"}},B:5,C:"HTML Imports"};


/***/ }),

/***/ 66518:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","16":"CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB FC","2":"DC tB","16":"EC"},D:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","2":"F B PC QC RC SC qB AC"},G:{"1":"gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"indeterminate checkbox"};


/***/ }),

/***/ 78797:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","132":"A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","132":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","33":"A B C K L G","36":"I u J D E F"},D:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"A","8":"I u J D E F","33":"z","36":"B C K L G M N O v w x y"},E:{"1":"A B C K L G 0B qB rB 1B NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"I u J D HC zB IC JC","260":"E F KC LC","516":"MC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F PC QC","8":"B C RC SC qB AC TC rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","8":"zB UC BC VC WC XC","260":"E YC ZC aC","516":"mC"},H:{"2":"oC"},I:{"1":"f tC uC","8":"tB I pC qC rC sC BC"},J:{"1":"A","8":"D"},K:{"1":"g","2":"A","8":"B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"132":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"IndexedDB"};


/***/ }),

/***/ 11395:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB EC FC","132":"KB LB MB","260":"NB OB PB QB"},D:{"1":"YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB","132":"OB PB QB RB","260":"SB TB UB VB WB XB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB PC QC RC SC qB AC TC rB","132":"BB CB DB EB","260":"FB GB HB IB JB KB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC","16":"bC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I","260":"wC xC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"260":"AD"}},B:2,C:"IndexedDB 2.0"};


/***/ }),

/***/ 7354:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","4":"CC","132":"J D"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","36":"DC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS inline-block"};


/***/ }),

/***/ 40674:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","16":"CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"HC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","16":"F"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB"},H:{"1":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"HTMLElement.innerText"};


/***/ }),

/***/ 60328:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A CC","132":"B"},B:{"132":"C K L G M N O","260":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","516":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"0 1 2 N O v w x y z","2":"I u J D E F A B C K L G M","132":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB","260":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"J IC JC","2":"I u HC zB","2052":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"zB UC BC","1025":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1025":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2052":"A B"},O:{"1025":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"260":"1B"},R:{"1":"9C"},S:{"516":"AD"}},B:1,C:"autocomplete attribute: on & off values"};


/***/ }),

/***/ 24411:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K"},C:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O v"},E:{"1":"K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C HC zB IC JC KC LC 0B qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e qB AC TC rB","2":"F G M PC QC RC SC"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC","129":"gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:1,C:"Color input type"};


/***/ }),

/***/ 41858:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","132":"C"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB EC FC","1090":"TB UB VB WB","2052":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b","4100":"c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O v","2052":"0 w x y z"},E:{"2":"I u J D E F A B C K L HC zB IC JC KC LC 0B qB rB 1B","4100":"G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"zB UC BC","260":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB pC qC rC","514":"I sC BC"},J:{"1":"A","2":"D"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"4100":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2052":"AD"}},B:1,C:"Date and time input types"};


/***/ }),

/***/ 65488:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","2":"F"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I f sC BC tC uC","132":"pC qC rC"},J:{"1":"A","132":"D"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Email, telephone & URL input types"};


/***/ }),

/***/ 56301:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","2561":"A B","2692":"F"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2561":"C K L G M N O"},C:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","16":"DC","1537":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB FC","1796":"tB EC"},D:{"1":"eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L","1025":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB","1537":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB"},E:{"1":"L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"I u J HC zB","1025":"D E F A B C JC KC LC 0B qB","1537":"IC","4097":"K rB"},F:{"1":"SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","16":"F B C PC QC RC SC qB AC","260":"TC","1025":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB","1537":"G M N O v w x"},G:{"1":"iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC","1025":"E YC ZC aC bC cC dC eC fC","1537":"VC WC XC","4097":"gC hC"},H:{"2":"oC"},I:{"16":"pC qC","1025":"f uC","1537":"tB I rC sC BC tC"},J:{"1025":"A","1537":"D"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2561":"A B"},O:{"1":"vC"},P:{"1025":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1537":"AD"}},B:1,C:"input event"};


/***/ }),

/***/ 3024:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","132":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB"},D:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I","16":"0 1 u J D E x y z","132":"F A B C K L G M N O v w"},E:{"1":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC","132":"J D E F A B JC KC LC 0B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"2":"WC XC","132":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","514":"zB UC BC VC"},H:{"2":"oC"},I:{"2":"pC qC rC","260":"tB I sC BC","514":"f tC uC"},J:{"132":"A","260":"D"},K:{"2":"A B C qB AC rB","514":"g"},L:{"260":"H"},M:{"2":"H"},N:{"514":"A","1028":"B"},O:{"2":"vC"},P:{"260":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"260":"1B"},R:{"260":"9C"},S:{"1":"AD"}},B:1,C:"accept attribute for file input"};


/***/ }),

/***/ 77213:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K"},C:{"1":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB EC FC"},D:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B HC zB IC JC KC LC 0B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"Directory selection from file input"};


/***/ }),

/***/ 64907:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB FC","2":"DC tB EC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e SC qB AC TC rB","2":"F PC QC RC"},G:{"1":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC"},H:{"130":"oC"},I:{"130":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"130":"A B C g qB AC rB"},L:{"132":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"130":"vC"},P:{"130":"I","132":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"132":"1B"},R:{"132":"9C"},S:{"2":"AD"}},B:1,C:"Multiple file selection"};


/***/ }),

/***/ 75178:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M EC FC","4":"N O v w","194":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d"},D:{"1":"eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB","66":"WB XB YB uB ZB vB aB bB cB dB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB PC QC RC SC qB AC TC rB","66":"JB KB LB MB NB OB PB QB RB SB"},G:{"1":"gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"194":"AD"}},B:1,C:"inputmode attribute"};


/***/ }),

/***/ 90453:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M"},C:{"1":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB EC FC"},D:{"1":"GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:1,C:"Minimum length attribute for input fields"};


/***/ }),

/***/ 90754:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","129":"A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","129":"C K","1025":"L G M N O"},C:{"2":"0 1 2 3 4 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","513":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"388":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB pC qC rC","388":"I f sC BC tC uC"},J:{"2":"D","388":"A"},K:{"1":"A B C qB AC rB","388":"g"},L:{"388":"H"},M:{"641":"H"},N:{"388":"A B"},O:{"388":"vC"},P:{"388":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"388":"1B"},R:{"388":"9C"},S:{"513":"AD"}},B:1,C:"Number input type"};


/***/ }),

/***/ 70620:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","16":"u","388":"J D E F A IC JC KC LC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","2":"F"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC","388":"E VC WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f uC","2":"tB I pC qC rC sC BC tC"},J:{"1":"A","2":"D"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"132":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Pattern attribute for input fields"};


/***/ }),

/***/ 45840:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","132":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e AC TC rB","2":"F PC QC RC SC","132":"B qB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB f pC qC rC BC tC uC","4":"I sC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"input placeholder attribute"};


/***/ }),

/***/ 19303:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v w x y EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"2":"oC"},I:{"1":"f BC tC uC","4":"tB I pC qC rC sC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Range input type"};


/***/ }),

/***/ 86763:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","129":"A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","129":"C K L G M N O"},C:{"2":"DC tB EC FC","129":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"0 1 I u J D E F A B C K L x y z","129":"G M N O v w"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"I u HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","2":"F PC QC RC SC","16":"B qB AC"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC"},H:{"129":"oC"},I:{"1":"f tC uC","16":"pC qC","129":"tB I rC sC BC"},J:{"1":"D","129":"A"},K:{"1":"C g","2":"A","16":"B qB AC","129":"rB"},L:{"1":"H"},M:{"129":"H"},N:{"129":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"129":"AD"}},B:1,C:"Search input type"};


/***/ }),

/***/ 48804:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e SC qB AC TC rB","16":"F PC QC RC"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB"},H:{"2":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Selection controls for input & textarea"};


/***/ }),

/***/ 36404:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","16":"CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","16":"F"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Element.insertAdjacentElement() & Element.insertAdjacentText()"};


/***/ }),

/***/ 20379:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","16":"CC","132":"J D E F"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e QC RC SC qB AC TC rB","16":"F PC"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB"},H:{"1":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"Element.insertAdjacentHTML()"};


/***/ }),

/***/ 558:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O v w x y z"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"Internationalization API"};


/***/ }),

/***/ 16414:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"IntersectionObserver V2"};


/***/ }),

/***/ 93717:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"M N O","2":"C K L","516":"G","1025":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB EC FC","194":"SB TB UB"},D:{"1":"YB uB ZB vB aB bB cB","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB","516":"RB SB TB UB VB WB XB","1025":"dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C HC zB IC JC KC LC 0B qB"},F:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB PC QC RC SC qB AC TC rB","516":"EB FB GB HB IB JB KB","1025":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC tC uC","1025":"f"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","1025":"g"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I","516":"wC xC"},Q:{"1025":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"IntersectionObserver"};


/***/ }),

/***/ 14130:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N","130":"O"},C:{"1":"YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB EC FC"},D:{"1":"bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB"},E:{"1":"K L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C HC zB IC JC KC LC 0B qB rB"},F:{"1":"QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB PC QC RC SC qB AC TC rB"},G:{"1":"hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"Intl.PluralRules API"};


/***/ }),

/***/ 56835:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","1025":"d e h i j k l m n o p q r s t f H","1537":"P Q R S T U V W X Y Z a b c"},C:{"2":"DC","932":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB EC FC","2308":"eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"I u J D E F A B C K L G M N O v w x","545":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB","1025":"d e h i j k l m n o p q r s t f H xB yB GC","1537":"MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c"},E:{"1":"sB 6B 7B 8B 9B OC","2":"I u J HC zB IC","516":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B","548":"F A LC 0B","676":"D E JC KC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","513":"AB","545":"0 1 2 3 4 5 6 7 8 G M N O v w x y z","1025":"e","1537":"9 BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d"},G:{"1":"sB 6B 7B 8B 9B","2":"zB UC BC VC WC","516":"lC mC nC 2B 3B 4B 5B","548":"ZC aC bC cC dC eC fC gC hC iC jC kC","676":"E XC YC"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC","545":"tC uC","1025":"f"},J:{"2":"D","545":"A"},K:{"2":"A B C qB AC rB","1025":"g"},L:{"1025":"H"},M:{"2308":"H"},N:{"2":"A B"},O:{"1537":"vC"},P:{"545":"I","1025":"6C 7C 8C","1537":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB"},Q:{"1537":"1B"},R:{"1537":"9C"},S:{"932":"AD"}},B:5,C:"Intrinsic & Extrinsic Sizing"};


/***/ }),

/***/ 99137:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","129":"u IC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:6,C:"JPEG 2000 image format"};


/***/ }),

/***/ 58083:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z H","578":"a b c d e h i j k l m n o p q r s t f"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y EC FC","322":"Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z H xB yB GC","194":"a b c d e h i j k l m n o p q r s t f"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB PC QC RC SC qB AC TC rB","194":"oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:6,C:"JPEG XL image format"};


/***/ }),

/***/ 70525:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O","2":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"1":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:6,C:"JPEG XR image format"};


/***/ }),

/***/ 91191:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB EC FC"},D:{"1":"aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB"},E:{"1":"9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B"},F:{"1":"PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PC QC RC SC qB AC TC rB"},G:{"1":"9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"Lookbehind in JS regular expressions"};


/***/ }),

/***/ 92815:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D CC","129":"E"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC tB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","2":"F PC QC"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"JSON parsing"};


/***/ }),

/***/ 37001:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G","132":"M N O"},C:{"1":"SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB EC FC"},D:{"1":"ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB","132":"XB YB uB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC","132":"0B"},F:{"1":"NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB PC QC RC SC qB AC TC rB","132":"KB LB MB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC","132":"cC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC","132":"yC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"132":"AD"}},B:5,C:"CSS justify-content: space-evenly"};


/***/ }),

/***/ 82612:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N"},C:{"1":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"pC qC rC","132":"tB I sC BC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:7,C:"High-quality kerning pairs & ligatures"};


/***/ }),

/***/ 7891:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","16":"DC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B PC QC RC SC qB AC TC","16":"C"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC"},H:{"2":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"g rB","2":"A B qB AC","16":"C"},L:{"1":"H"},M:{"130":"H"},N:{"130":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:7,C:"KeyboardEvent.charCode"};


/***/ }),

/***/ 39598:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EC FC"},D:{"1":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB","194":"IB JB KB LB MB NB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","194":"5 6 7 8 9 AB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"194":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I","194":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"194":"9C"},S:{"1":"AD"}},B:5,C:"KeyboardEvent.code"};


/***/ }),

/***/ 87626:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L EC FC"},D:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B G M PC QC RC SC qB AC TC","16":"C"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"2":"D A"},K:{"1":"g rB","2":"A B qB AC","16":"C"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"KeyboardEvent.getModifierState()"};


/***/ }),

/***/ 98685:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","260":"F A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","260":"C K L G M N O"},C:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v w x y EC FC","132":"0 1 2 3 4 z"},D:{"1":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"0 1 2 3 4 5 6 7 8 9 F B G M N O v w x y z AB BB CB DB PC QC RC SC qB AC TC","16":"C"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"1":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g rB","2":"A B qB AC","16":"C"},L:{"1":"H"},M:{"1":"H"},N:{"260":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"KeyboardEvent.key"};


/***/ }),

/***/ 90035:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L EC FC"},D:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","132":"0 1 2 3 4 5 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"J HC zB","132":"I u IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B PC QC RC SC qB AC TC","16":"C","132":"G M"},G:{"1":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC","132":"VC WC XC"},H:{"2":"oC"},I:{"1":"f tC uC","16":"pC qC","132":"tB I rC sC BC"},J:{"132":"D A"},K:{"1":"g rB","2":"A B qB AC","16":"C"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"KeyboardEvent.location"};


/***/ }),

/***/ 82586:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","16":"u"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e QC RC SC qB AC TC rB","16":"F PC"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC"},H:{"2":"oC"},I:{"1":"tB I f rC sC BC","16":"pC qC","132":"tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"132":"H"},M:{"132":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"2":"I","132":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"132":"9C"},S:{"1":"AD"}},B:7,C:"KeyboardEvent.which"};


/***/ }),

/***/ 23230:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A CC"},B:{"1":"C K L G M N O","2":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"1":"B","2":"A"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"Resource Hints: Lazyload"};


/***/ }),

/***/ 51884:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","2052":"B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","194":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB EC FC"},D:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O","322":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB","516":"HB IB JB KB LB MB NB OB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC","1028":"A 0B"},F:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","322":"0 1 2 3 G M N O v w x y z","516":"4 5 6 7 8 9 AB BB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC","1028":"bC cC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","516":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"let"};


/***/ }),

/***/ 42789:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","130":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC"},H:{"130":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D","130":"A"},K:{"1":"g","130":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"130":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"PNG favicons"};


/***/ }),

/***/ 4506:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P","1537":"Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"DC tB EC FC","260":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB","513":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P","1537":"Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"KB LB MB NB OB PB QB RB SB TB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB UB VB WB XB YB ZB aB bB cB dB eB PC QC RC SC qB AC TC rB","1537":"fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","130":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC"},H:{"130":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D","130":"A"},K:{"130":"A B C qB AC rB","1537":"g"},L:{"1537":"H"},M:{"2":"H"},N:{"130":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C","1537":"3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"1537":"9C"},S:{"513":"AD"}},B:1,C:"SVG favicons"};


/***/ }),

/***/ 66458:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E CC","132":"F"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"DC tB","260":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"16":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"16":"tB I f pC qC rC sC BC tC uC"},J:{"16":"D A"},K:{"1":"g","16":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","16":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"Resource Hints: dns-prefetch"};


/***/ }),

/***/ 36767:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:1,C:"Resource Hints: modulepreload"};


/***/ }),

/***/ 67578:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L","260":"G M N O"},C:{"1":"GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","129":"FB"},D:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB"},E:{"1":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B HC zB IC JC KC LC 0B"},F:{"1":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"16":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"Resource Hints: preconnect"};


/***/ }),

/***/ 31145:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D"},E:{"2":"I u J D E F A B C K HC zB IC JC KC LC 0B qB rB","194":"L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC","194":"kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"I f tC uC","2":"tB pC qC rC sC BC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"Resource Hints: prefetch"};


/***/ }),

/***/ 7015:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M","1028":"N O"},C:{"1":"U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB EC FC","132":"WB","578":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T"},D:{"1":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB"},E:{"1":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B","322":"B"},F:{"1":"DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB PC QC RC SC qB AC TC rB"},G:{"1":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC","322":"dC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:4,C:"Resource Hints: preload"};


/***/ }),

/***/ 74778:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"Resource Hints: prerender"};


/***/ }),

/***/ 11394:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB EC FC","132":"mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB","66":"mB nB"},E:{"1":"9B OC","2":"I u J D E F A B C K HC zB IC JC KC LC 0B qB rB","322":"L G 1B MC NC 2B","580":"3B 4B 5B sB 6B 7B 8B"},F:{"1":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB PC QC RC SC qB AC TC rB","66":"aB bB"},G:{"1":"9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC","322":"kC lC mC nC 2B","580":"3B 4B 5B sB 6B 7B 8B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"132":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:1,C:"Lazy loading via attribute for images & iframes"};


/***/ }),

/***/ 89380:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","16":"CC","132":"J D E F A"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","132":"0 1 2 3 4 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","132":"I u J D E F A B C K L G M N O v w x y z"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","132":"I u J D E F HC zB IC JC KC LC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","16":"F B C PC QC RC SC qB AC TC","132":"rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","132":"E zB UC BC VC WC XC YC ZC aC"},H:{"132":"oC"},I:{"1":"f tC uC","132":"tB I pC qC rC sC BC"},J:{"132":"D A"},K:{"1":"g","16":"A B C qB AC","132":"rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","132":"A"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","132":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"4":"AD"}},B:6,C:"localeCompare()"};


/***/ }),

/***/ 19271:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB","194":"YB uB ZB vB aB bB cB dB eB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"194":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:4,C:"Magnetometer"};


/***/ }),

/***/ 71184:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","36":"F A B"},B:{"1":"G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","36":"C K L"},C:{"1":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC","36":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z FC"},D:{"1":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","36":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","36":"u J D IC JC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B PC QC RC SC qB","36":"C G M N O v w AC TC rB"},G:{"1":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB","36":"UC BC VC WC XC"},H:{"2":"oC"},I:{"1":"f","2":"pC","36":"tB I qC rC sC BC tC uC"},J:{"36":"D A"},K:{"1":"g","2":"A B","36":"C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"36":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","36":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"matches() DOM method"};


/***/ }),

/***/ 66743:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B C PC QC RC SC qB AC TC"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"1":"oC"},I:{"1":"tB I f sC BC tC uC","2":"pC qC rC"},J:{"1":"A","2":"D"},K:{"1":"g rB","2":"A B C qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"matchMedia"};


/***/ }),

/***/ 35717:
/***/ ((module) => {

module.exports={A:{A:{"2":"F A B CC","8":"J D E"},B:{"2":"C K L G M N O","8":"P Q R S T U V W X Y Z a b c d e h","584":"i j k l m n o p q r s t","1025":"f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","129":"DC tB EC FC"},D:{"1":"0","8":"1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h","584":"i j k l m n o p q r s t","1025":"f H xB yB GC"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","260":"I u J D E F HC zB IC JC KC LC"},F:{"2":"F","8":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB","584":"S T U V W X Y Z a b c d","1025":"e","2052":"B C PC QC RC SC qB AC TC rB"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","8":"zB UC BC"},H:{"8":"oC"},I:{"8":"tB I pC qC rC sC BC tC uC","1025":"f"},J:{"1":"A","8":"D"},K:{"8":"A B C g qB AC rB"},L:{"1025":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"8":"vC"},P:{"8":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"8":"1B"},R:{"8":"9C"},S:{"1":"AD"}},B:2,C:"MathML"};


/***/ }),

/***/ 16924:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","16":"CC","900":"J D E F"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","1025":"C K L G M N O"},C:{"1":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","900":"DC tB EC FC","1025":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"u HC","900":"I zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","16":"F","132":"B C PC QC RC SC qB AC TC rB"},G:{"1":"UC BC VC WC XC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB","2052":"E YC"},H:{"132":"oC"},I:{"1":"tB I rC sC BC tC uC","16":"pC qC","4097":"f"},J:{"1":"D A"},K:{"132":"A B C qB AC rB","4097":"g"},L:{"4097":"H"},M:{"4097":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"4097":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1025":"AD"}},B:1,C:"maxlength attribute for input and textarea elements"};


/***/ }),

/***/ 19567:
/***/ ((module) => {

module.exports={A:{D:{"1":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB"},L:{"1":"H"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M EC FC","33":"0 1 2 3 4 5 6 7 8 9 N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB"},M:{"1":"H"},A:{"2":"J D E F A B CC"},F:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB PC QC RC SC qB AC TC rB"},K:{"1":"g","2":"A B C qB AC rB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"I u J HC zB IC JC OC","33":"D E F A KC LC 0B"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC","33":"E XC YC ZC aC bC cC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"}},B:6,C:"isolate-override from unicode-bidi"};


/***/ }),

/***/ 55195:
/***/ ((module) => {

module.exports={A:{D:{"1":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G","33":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB"},L:{"1":"H"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F EC FC","33":"0 1 2 3 4 5 6 7 8 9 A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB"},M:{"1":"H"},A:{"2":"J D E F A B CC"},F:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB"},K:{"1":"g","2":"A B C qB AC rB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"I u HC zB IC OC","33":"J D E F A JC KC LC 0B"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC","33":"E WC XC YC ZC aC bC cC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"}},B:6,C:"isolate from unicode-bidi"};


/***/ }),

/***/ 27489:
/***/ ((module) => {

module.exports={A:{D:{"1":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB"},L:{"1":"H"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F EC FC","33":"0 1 2 3 4 5 6 7 8 9 A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB"},M:{"1":"H"},A:{"2":"J D E F A B CC"},F:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB PC QC RC SC qB AC TC rB"},K:{"1":"g","2":"A B C qB AC rB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"I u HC zB IC OC","33":"J D E F A JC KC LC 0B"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC","33":"E WC XC YC ZC aC bC cC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"}},B:6,C:"plaintext from unicode-bidi"};


/***/ }),

/***/ 83460:
/***/ ((module) => {

module.exports={A:{D:{"1":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB"},L:{"1":"H"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u EC FC","33":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB"},M:{"1":"H"},A:{"2":"J D E F A B CC"},F:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB PC QC RC SC qB AC TC rB"},K:{"1":"g","2":"A B C qB AC rB"},E:{"1":"K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"I u J D HC zB IC JC KC OC","33":"E F A B C LC 0B qB"},G:{"1":"gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC","33":"E YC ZC aC bC cC dC eC fC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"}},B:6,C:"text-decoration-color property"};


/***/ }),

/***/ 42320:
/***/ ((module) => {

module.exports={A:{D:{"1":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB"},L:{"1":"H"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u EC FC","33":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB"},M:{"1":"H"},A:{"2":"J D E F A B CC"},F:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB PC QC RC SC qB AC TC rB"},K:{"1":"g","2":"A B C qB AC rB"},E:{"1":"K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"I u J D HC zB IC JC KC OC","33":"E F A B C LC 0B qB"},G:{"1":"gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC","33":"E YC ZC aC bC cC dC eC fC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"}},B:6,C:"text-decoration-line property"};


/***/ }),

/***/ 2644:
/***/ ((module) => {

module.exports={A:{D:{"1":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB"},L:{"1":"H"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u EC FC"},M:{"1":"H"},A:{"2":"J D E F A B CC"},F:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB PC QC RC SC qB AC TC rB"},K:{"1":"g","2":"A B C qB AC rB"},E:{"2":"I u J D HC zB IC JC KC OC","33":"E F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B"},G:{"2":"zB UC BC VC WC XC","33":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"}},B:6,C:"text-decoration shorthand property"};


/***/ }),

/***/ 73110:
/***/ ((module) => {

module.exports={A:{D:{"1":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB"},L:{"1":"H"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u EC FC","33":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB"},M:{"1":"H"},A:{"2":"J D E F A B CC"},F:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB PC QC RC SC qB AC TC rB"},K:{"1":"g","2":"A B C qB AC rB"},E:{"1":"K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"I u J D HC zB IC JC KC OC","33":"E F A B C LC 0B qB"},G:{"1":"gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC","33":"E YC ZC aC bC cC dC eC fC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"}},B:6,C:"text-decoration-style property"};


/***/ }),

/***/ 6277:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","132":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","132":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"I u J D E F A B C K L G M N","132":"0 1 2 3 4 5 6 7 8 9 O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u HC zB IC","132":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","132":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"zB UC BC VC WC XC","132":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC","132":"f tC uC"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","132":"g"},L:{"132":"H"},M:{"132":"H"},N:{"132":"A B"},O:{"132":"vC"},P:{"2":"I wC","132":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"132":"1B"},R:{"132":"9C"},S:{"132":"AD"}},B:2,C:"Media Fragments"};


/***/ }),

/***/ 84279:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB EC FC","260":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB","324":"RB SB TB UB VB WB XB YB uB ZB vB"},E:{"2":"I u J D E F A HC zB IC JC KC LC 0B","132":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB PC QC RC SC qB AC TC rB","324":"CB DB EB FB GB HB IB JB KB LB MB NB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"260":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I","132":"wC xC yC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"260":"AD"}},B:5,C:"Media Capture from DOM Elements API"};


/***/ }),

/***/ 55997:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB","194":"NB OB"},E:{"1":"G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C HC zB IC JC KC LC 0B qB","322":"K L rB 1B"},F:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","194":"AB BB"},G:{"1":"mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC","578":"fC gC hC iC jC kC lC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"MediaRecorder API"};


/***/ }),

/***/ 32348:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","132":"B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","66":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB"},D:{"1":"7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M","33":"0 1 2 3 4 5 6 z","66":"N O v w x y"},E:{"1":"E F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D HC zB IC JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC","260":"hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f uC","2":"tB I pC qC rC sC BC tC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"Media Source Extensions"};


/***/ }),

/***/ 89056:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"DC tB I u J D EC FC","132":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T","450":"U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","66":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","66":"BB CB DB EB FB GB HB IB JB KB LB MB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"450":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"Context menu item (menuitem element)"};


/***/ }),

/***/ 69895:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB","132":"g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","258":"FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB"},E:{"1":"G NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L HC zB IC JC KC LC 0B qB rB 1B MC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"513":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I","16":"wC"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:1,C:"theme-color Meta Tag"};


/***/ }),

/***/ 44701:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e qB AC TC rB","2":"F PC QC RC SC"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"1":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"meter element"};


/***/ }),

/***/ 83250:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s EC FC"},D:{"1":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"Web MIDI API"};


/***/ }),

/***/ 55879:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","8":"J CC","129":"D","257":"E"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS min/max-width/height"};


/***/ }),

/***/ 59447:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB","132":"I u J D E F A B C K L G M N O v w x EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB"},H:{"2":"oC"},I:{"1":"tB I f rC sC BC tC uC","2":"pC qC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"MP3 audio format"};


/***/ }),

/***/ 374:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O","2":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","386":"x y"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:6,C:"Dynamic Adaptive Streaming over HTTP (MPEG-DASH)"};


/***/ }),

/***/ 33463:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v w EC FC","4":"0 1 2 3 4 5 6 7 8 9 x y z AB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f tC uC","4":"tB I pC qC sC BC","132":"rC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"260":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"MPEG-4/H.264 video format"};


/***/ }),

/***/ 19069:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB FC","2":"DC tB EC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","2":"F PC QC"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS3 Multiple backgrounds"};


/***/ }),

/***/ 24233:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O","516":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"132":"SB TB UB VB WB XB YB uB ZB vB aB bB cB","164":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB EC FC","516":"dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a","1028":"b c d e h i j k l m n o p q r s t f H xB yB"},D:{"420":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB","516":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","132":"F LC","164":"D E KC","420":"I u J HC zB IC JC"},F:{"1":"C qB AC TC rB","2":"F B PC QC RC SC","420":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB","516":"DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","132":"ZC aC","164":"E XC YC","420":"zB UC BC VC WC"},H:{"1":"oC"},I:{"420":"tB I pC qC rC sC BC tC uC","516":"f"},J:{"420":"D A"},K:{"1":"C qB AC rB","2":"A B","516":"g"},L:{"516":"H"},M:{"1028":"H"},N:{"1":"A B"},O:{"516":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","420":"I"},Q:{"516":"1B"},R:{"516":"9C"},S:{"164":"AD"}},B:4,C:"CSS3 Multiple column layout"};


/***/ }),

/***/ 90072:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","260":"F A B"},B:{"132":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","260":"C K L G M N O"},C:{"2":"DC tB I u EC FC","260":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"16":"I u J D E F A B C K L","132":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"16":"HC zB","132":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"C TC rB","2":"F PC QC RC SC","16":"B qB AC","132":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"16":"zB UC","132":"E BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"16":"pC qC","132":"tB I f rC sC BC tC uC"},J:{"132":"D A"},K:{"1":"C rB","2":"A","16":"B qB AC","132":"g"},L:{"132":"H"},M:{"260":"H"},N:{"260":"A B"},O:{"132":"vC"},P:{"132":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"132":"1B"},R:{"132":"9C"},S:{"260":"AD"}},B:5,C:"Mutation events"};


/***/ }),

/***/ 98212:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E CC","8":"F A"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K EC FC"},D:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N","33":"0 1 2 O v w x y z"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC","33":"J"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC","33":"WC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB pC qC rC","8":"I sC BC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","8":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Mutation Observer"};


/***/ }),

/***/ 80611:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","2":"CC","8":"J D"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","4":"DC tB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","2":"F PC QC"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Web Storage - name/value pairs"};


/***/ }),

/***/ 7576:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","194":"P Q R S T U","260":"V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g","194":"lB mB nB oB pB P Q R S T U","260":"V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC","516":"2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB PC QC RC SC qB AC TC rB","194":"aB bB cB dB eB fB gB hB iB jB","260":"kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC","516":"2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"File System Access API"};


/***/ }),

/***/ 73272:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u","33":"J D E F A B C"},E:{"1":"E F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D HC zB IC JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"I f sC BC tC uC","2":"tB pC qC rC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"Navigation Timing API"};


/***/ }),

/***/ 1493:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","1028":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB","1028":"vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB PC QC RC SC qB AC TC rB","1028":"OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"pC tC uC","132":"tB I qC rC sC BC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","132":"I","516":"wC xC yC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"260":"AD"}},B:7,C:"Network Information API"};


/***/ }),

/***/ 54483:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v w x EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I","36":"u J D E F A B C K L G M N O v w x"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B","1028":"9B"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC","36":"f tC uC"},J:{"1":"A","2":"D"},K:{"2":"A B C qB AC rB","36":"g"},L:{"513":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"36":"I","258":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"258":"9C"},S:{"1":"AD"}},B:1,C:"Web Notifications"};


/***/ }),

/***/ 69577:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K"},C:{"1":"NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB EC FC"},D:{"1":"UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB PC QC RC SC qB AC TC rB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D","16":"A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Object.entries"};


/***/ }),

/***/ 6228:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G","260":"M N O"},C:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB EC FC"},D:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D HC zB IC JC","132":"E F KC LC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F G M N O PC QC RC","33":"B C SC qB AC TC rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC","132":"E YC ZC aC"},H:{"33":"oC"},I:{"1":"f uC","2":"tB I pC qC rC sC BC tC"},J:{"2":"D A"},K:{"1":"g","2":"A","33":"B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS3 object-fit/object-position"};


/***/ }),

/***/ 63008:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB","2":"F B C G M N O v w x y DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"I","2":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"Object.observe data binding"};


/***/ }),

/***/ 55480:
/***/ ((module) => {

module.exports={A:{A:{"8":"J D E F A B CC"},B:{"1":"L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K"},C:{"1":"NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","8":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB EC FC"},D:{"1":"UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","8":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","8":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB PC QC RC SC qB AC TC rB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","8":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"8":"oC"},I:{"1":"f","8":"tB I pC qC rC sC BC tC uC"},J:{"8":"D A"},K:{"1":"g","8":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"8":"A B"},O:{"1":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","8":"I wC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Object.values method"};


/***/ }),

/***/ 39611:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"K L G M N O","2":"C P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D","130":"A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:6,C:"Object RTC (ORTC) API for WebRTC"};


/***/ }),

/***/ 45884:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"F CC","8":"J D E"},B:{"1":"C K L G M N O P Q R S T","2":"U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S EC FC","2":"T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","4":"tB","8":"DC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T","2":"U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB SC qB AC TC rB","2":"F g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC","8":"QC RC"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I pC qC rC sC BC tC uC","2":"f"},J:{"1":"D A"},K:{"1":"B C qB AC rB","2":"A g"},L:{"2":"H"},M:{"2":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"2":"9C"},S:{"1":"AD"}},B:7,C:"Offline web applications"};


/***/ }),

/***/ 74509:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB EC FC","194":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p"},D:{"1":"hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB","322":"YB uB ZB vB aB bB cB dB eB fB gB"},E:{"1":"9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B"},F:{"1":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB PC QC RC SC qB AC TC rB","322":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB"},G:{"1":"9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"194":"AD"}},B:1,C:"OffscreenCanvas"};


/***/ }),

/***/ 77081:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC tB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L HC zB IC JC KC LC 0B qB rB 1B","132":"G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","2":"F PC QC"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"A","2":"D"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Ogg Vorbis audio format"};


/***/ }),

/***/ 18398:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","8":"F A B"},B:{"1":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","8":"C K L G M"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC tB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","2":"F PC QC"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"1":"H"},N:{"8":"A B"},O:{"1":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"2":"9C"},S:{"1":"AD"}},B:6,C:"Ogg/Theora video format"};


/***/ }),

/***/ 67096:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G","16":"M N O v"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC","16":"J"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B PC QC RC SC qB AC TC","16":"C"},G:{"1":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC"},H:{"1":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Reversed attribute of ordered lists"};


/***/ }),

/***/ 79713:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G"},C:{"1":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB EC FC"},D:{"1":"VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC"},F:{"1":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB PC QC RC SC qB AC TC rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:1,C:"\"once\" event listener option"};


/***/ }),

/***/ 11219:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D CC","260":"E"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC tB","516":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC","4":"rB"},G:{"1":"E BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC"},H:{"2":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"A","132":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Online/offline status"};


/***/ }),

/***/ 12205:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L EC FC"},D:{"1":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 I u J D E F A B C K L G M N O v w x y z"},E:{"2":"I u J D E F A HC zB IC JC KC LC 0B","132":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC","132":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Opus audio format"};


/***/ }),

/***/ 77294:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB","194":"YB uB ZB vB aB bB cB dB eB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:4,C:"Orientation Sensor"};


/***/ }),

/***/ 28311:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D CC","260":"E","388":"F A B"},B:{"1":"G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","388":"C K L"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC","129":"rB","260":"F B PC QC RC SC qB AC"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"C g rB","260":"A B qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"388":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS outline properties"};


/***/ }),

/***/ 42502:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L"},C:{"1":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB EC FC"},D:{"1":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC"},F:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB PC QC RC SC qB AC TC rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"String.prototype.padStart(), String.prototype.padEnd()"};


/***/ }),

/***/ 72796:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC"},H:{"2":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"PageTransitionEvent"};


/***/ }),

/***/ 87772:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F EC FC","33":"A B C K L G M N"},D:{"1":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K","33":"0 1 2 3 4 5 6 7 8 L G M N O v w x y z"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B C PC QC RC SC qB AC TC","33":"G M N O v"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC","33":"tC uC"},J:{"1":"A","2":"D"},K:{"1":"g rB","2":"A B C qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","33":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"Page Visibility"};


/***/ }),

/***/ 50754:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G"},C:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB EC FC"},D:{"1":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC"},F:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB PC QC RC SC qB AC TC rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:1,C:"Passive event listeners"};


/***/ }),

/***/ 28403:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","16":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H EC FC","16":"xB yB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","16":"xB yB GC"},E:{"1":"C K rB","2":"I u J D E F A B HC zB IC JC KC LC 0B qB","16":"L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB PC QC RC SC qB AC TC rB","16":"TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"16":"oC"},I:{"2":"tB I pC qC rC sC BC tC uC","16":"f"},J:{"2":"D","16":"A"},K:{"2":"A B C qB AC rB","16":"g"},L:{"16":"H"},M:{"16":"H"},N:{"2":"A","16":"B"},O:{"16":"vC"},P:{"2":"I wC xC","16":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"16":"1B"},R:{"16":"9C"},S:{"2":"AD"}},B:1,C:"Password Rules"};


/***/ }),

/***/ 13066:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K","132":"L G M N O"},C:{"1":"OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","132":"7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB"},D:{"1":"gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB","132":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB"},E:{"1":"A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D HC zB IC JC","132":"E F KC"},F:{"1":"VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w x y PC QC RC SC qB AC TC rB","132":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC","16":"E","132":"YC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"0B 1C 2C 3C 4C 5C sB 6C 7C 8C","132":"I wC xC yC zC 0C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Path2D"};


/***/ }),

/***/ 36954:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K","322":"L","8196":"G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB EC FC","4162":"VB WB XB YB uB ZB vB aB bB cB dB","16452":"eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB","194":"TB UB VB WB XB YB","1090":"uB ZB","8196":"vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB"},E:{"1":"K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC","514":"A B 0B","8196":"C qB"},F:{"1":"eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB PC QC RC SC qB AC TC rB","194":"GB HB IB JB KB LB MB NB","8196":"OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB"},G:{"1":"gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC","514":"bC cC dC","8196":"eC fC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"2049":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"2C 3C 4C 5C sB 6C 7C 8C","2":"I","8196":"wC xC yC zC 0C 0B 1C"},Q:{"8196":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:2,C:"Payment Request API"};


/***/ }),

/***/ 31504:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","132":"B"},B:{"1":"G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","16":"C K L"},C:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B PC QC RC SC qB AC TC"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"16":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"16":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:6,C:"Built-in PDF viewer"};


/***/ }),

/***/ 98901:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB EC FC"},D:{"1":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB"},E:{"1":"sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B"},F:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"Permissions API"};


/***/ }),

/***/ 17093:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","258":"P Q R S T U","322":"V W","388":"X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g EC FC","258":"lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB","258":"ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U","322":"V W","388":"X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B HC zB IC JC KC LC 0B","258":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB PC QC RC SC qB AC TC rB","258":"NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB","322":"kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d","388":"e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC","258":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC tC uC","258":"f"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","388":"g"},L:{"388":"H"},M:{"258":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC","258":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"258":"1B"},R:{"388":"9C"},S:{"2":"AD"}},B:5,C:"Permissions Policy"};


/***/ }),

/***/ 2610:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB EC FC","132":"kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","1090":"fB","1412":"jB","1668":"gB hB iB"},D:{"1":"iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB","2114":"hB"},E:{"1":"L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC","4100":"A B C K 0B qB rB"},F:{"1":"g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB PC QC RC SC qB AC TC rB","8196":"DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB"},G:{"1":"lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC","4100":"ZC aC bC cC dC eC fC gC hC iC jC kC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"16388":"H"},M:{"16388":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"Picture-in-Picture"};


/***/ }),

/***/ 85312:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C"},C:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","578":"AB BB CB DB"},D:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB","194":"DB"},E:{"1":"A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w x y z PC QC RC SC qB AC TC rB","322":"0"},G:{"1":"aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Picture element"};


/***/ }),

/***/ 96744:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M"},C:{"2":"DC","194":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"194":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"194":"AD"}},B:1,C:"Ping attribute"};


/***/ }),

/***/ 54659:
/***/ ((module) => {

module.exports={A:{A:{"1":"D E F A B","2":"CC","8":"J"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"PNG alpha transparency"};


/***/ }),

/***/ 2224:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB FC","2":"DC tB EC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:7,C:"CSS pointer-events (for HTML)"};


/***/ }),

/***/ 27252:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F CC","164":"A"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u EC FC","8":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB","328":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB"},D:{"1":"VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O v w x","8":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB","584":"SB TB UB"},E:{"1":"K L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC","8":"D E F A B C JC KC LC 0B qB","1096":"rB"},F:{"1":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","8":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB","584":"FB GB HB"},G:{"1":"iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","8":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC","6148":"hC"},H:{"2":"oC"},I:{"1":"f","8":"tB I pC qC rC sC BC tC uC"},J:{"8":"D A"},K:{"1":"g","2":"A","8":"B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","36":"A"},O:{"1":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"wC","8":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"328":"AD"}},B:2,C:"Pointer events"};


/***/ }),

/***/ 50221:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C"},C:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K EC FC","33":"0 1 2 3 4 5 6 7 8 9 L G M N O v w x y z AB BB CB DB EB FB GB"},D:{"1":"DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G","33":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB","66":"M N O v w x"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","33":"G M N O v w x y z"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"Pointer Lock API"};


/***/ }),

/***/ 72388:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T","322":"Z a b c d e h i j k l m n o p q r s t f H","450":"U V W X Y"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB","194":"mB nB oB pB P Q R S T","322":"V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","450":"U"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB PC QC RC SC qB AC TC rB","194":"aB bB cB dB eB fB gB hB iB jB kB","322":"g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"450":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"Portals"};


/***/ }),

/***/ 93412:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB EC FC"},D:{"1":"nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB"},E:{"1":"K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C HC zB IC JC KC LC 0B qB"},F:{"1":"aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB PC QC RC SC qB AC TC rB"},G:{"1":"hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"prefers-color-scheme media query"};


/***/ }),

/***/ 21506:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB EC FC"},D:{"1":"lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB PC QC RC SC qB AC TC rB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"prefers-reduced-motion media query"};


/***/ }),

/***/ 31127:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e qB AC TC rB","2":"F PC QC RC SC"},G:{"1":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC","132":"XC"},H:{"1":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"progress element"};


/***/ }),

/***/ 22438:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N"},C:{"1":"YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB EC FC"},D:{"1":"bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB"},E:{"1":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B HC zB IC JC KC LC 0B"},F:{"1":"QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB PC QC RC SC qB AC TC rB"},G:{"1":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"Promise.prototype.finally"};


/***/ }),

/***/ 26044:
/***/ ((module) => {

module.exports={A:{A:{"8":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","4":"3 4","8":"0 1 2 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","4":"8","8":"0 1 2 3 4 5 6 7 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"I u J D HC zB IC JC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","4":"v","8":"F B C G M N O PC QC RC SC qB AC TC rB"},G:{"1":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","8":"zB UC BC VC WC XC"},H:{"8":"oC"},I:{"1":"f uC","8":"tB I pC qC rC sC BC tC"},J:{"8":"D A"},K:{"1":"g","8":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"8":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Promises"};


/***/ }),

/***/ 93871:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"1":"AD"}},B:4,C:"Proximity API"};


/***/ }),

/***/ 88321:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N EC FC"},D:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O EB FB GB HB IB JB KB LB MB NB OB","66":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC"},F:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"1 2 3 4 5 6 7 8 9 F B C AB BB PC QC RC SC qB AC TC rB","66":"0 G M N O v w x y z"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Proxy object"};


/***/ }),

/***/ 29636:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB","2":"F B C G M N O v eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","4":"z","16":"0 w x y"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"I wC xC yC zC 0C 0B","2":"1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"1":"AD"}},B:6,C:"HTTP Public Key Pinning"};


/***/ }),

/***/ 39446:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"N O","2":"C K L G M","257":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB EC FC","257":"KB MB NB OB PB QB RB TB UB VB WB XB YB uB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","1281":"LB SB ZB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB","257":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","388":"KB LB MB NB OB PB"},E:{"2":"I u J HC zB IC JC","514":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB","4612":"6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB PC QC RC SC qB AC TC rB","16":"DB EB FB GB HB","257":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B","8196":"9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"2":"9C"},S:{"257":"AD"}},B:5,C:"Push API"};


/***/ }),

/***/ 78361:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"CC","8":"J D","132":"E"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","8":"DC tB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e QC RC SC qB AC TC rB","8":"F PC"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"querySelector/querySelectorAll"};


/***/ }),

/***/ 21513:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","16":"CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","16":"DC tB EC FC"},D:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"0 1 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"I u HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","16":"F PC","132":"B C QC RC SC qB AC TC rB"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC VC WC"},H:{"1":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"g","132":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"257":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"readonly attribute of input and textarea elements"};


/***/ }),

/***/ 68504:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","132":"B"},B:{"1":"P Q R S","132":"C K L G M N O","513":"T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB EC FC","513":"W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T","2":"I u J D E F A B C K L G M N O v w","260":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB","513":"U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"C qB rB","2":"I u J D HC zB IC JC","132":"E F A B KC LC 0B","1025":"K L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB","2":"F B C PC QC RC SC qB AC TC rB","513":"g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"fC gC hC iC","2":"zB UC BC VC WC XC","132":"E YC ZC aC bC cC dC eC","1025":"jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","513":"g"},L:{"513":"H"},M:{"513":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"513":"9C"},S:{"1":"AD"}},B:4,C:"Referrer Policy"};


/***/ }),

/***/ 35575:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","129":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC"},D:{"2":"I u J D E F A B C","129":"0 1 2 3 4 5 6 7 8 9 K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F B PC QC RC SC qB AC","129":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D","129":"A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:1,C:"Custom protocol handling"};


/***/ }),

/***/ 67634:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB EC FC"},D:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB PC QC RC SC qB AC TC rB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:1,C:"rel=noopener"};


/***/ }),

/***/ 53615:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","132":"B"},B:{"1":"K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","16":"C"},C:{"1":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L G"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB"},H:{"2":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Link type \"noreferrer\""};


/***/ }),

/***/ 40764:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M","132":"N"},C:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB","132":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E HC zB IC JC KC"},F:{"1":"SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB PC QC RC SC qB AC TC rB","132":"DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I","132":"wC xC yC zC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"relList (DOMTokenList)"};


/***/ }),

/***/ 49123:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E CC","132":"F A"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB FC","2":"DC tB EC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","2":"F B PC QC RC SC qB AC"},G:{"1":"E UC BC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB","260":"VC"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"C g rB","2":"A B qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"rem (root em) units"};


/***/ }),

/***/ 10380:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","33":"B C K L G M N O v w x y","164":"I u J D E F A"},D:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F","33":"y z","164":"O v w x","420":"A B C K L G M N"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC","33":"J"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC","33":"WC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"requestAnimationFrame"};


/***/ }),

/***/ 28670:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB EC FC","194":"TB UB"},D:{"1":"NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB"},E:{"2":"I u J D E F A B C K HC zB IC JC KC LC 0B qB rB","322":"L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC","322":"kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"requestIdleCallback"};


/***/ }),

/***/ 21994:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB EC FC"},D:{"1":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB","194":"UB VB WB XB YB uB ZB vB aB bB"},E:{"1":"L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C HC zB IC JC KC LC 0B qB rB","66":"K"},F:{"1":"SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB PC QC RC SC qB AC TC rB","194":"HB IB JB KB LB MB NB OB PB QB RB"},G:{"1":"kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"Resize Observer"};


/***/ }),

/***/ 28286:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","194":"7 8 9 AB"},D:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B","260":"B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"Resource Timing"};


/***/ }),

/***/ 42459:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L EC FC"},D:{"1":"NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB","194":"KB LB MB"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC"},F:{"1":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","194":"7 8 9"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Rest parameters"};


/***/ }),

/***/ 17936:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L","516":"G M N O"},C:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v w x EC FC","33":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB"},D:{"1":"WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O v w x y","33":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B"},F:{"1":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 O v w x y z AB BB CB DB EB FB GB HB IB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D","130":"A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"33":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"WebRTC Peer-to-peer connections"};


/***/ }),

/***/ 35921:
/***/ ((module) => {

module.exports={A:{A:{"4":"J D E F A B CC"},B:{"4":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","8":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EC FC"},D:{"4":"0 1 2 3 4 5 6 7 8 9 u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","8":"I"},E:{"4":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"I HC zB"},F:{"4":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","8":"F B C PC QC RC SC qB AC TC rB"},G:{"4":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","8":"zB UC BC"},H:{"8":"oC"},I:{"4":"tB I f sC BC tC uC","8":"pC qC rC"},J:{"4":"A","8":"D"},K:{"4":"g","8":"A B C qB AC rB"},L:{"4":"H"},M:{"1":"H"},N:{"4":"A B"},O:{"4":"vC"},P:{"4":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"4":"1B"},R:{"4":"9C"},S:{"1":"AD"}},B:1,C:"Ruby annotation"};


/***/ }),

/***/ 88365:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","2":"J D CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 I u J D E F A B C K L G M N O v w x y z","2":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"u J IC","2":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"JC","129":"I HC zB"},F:{"1":"F B C G M N O PC QC RC SC qB AC TC rB","2":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"UC BC VC WC XC","2":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","129":"zB"},H:{"1":"oC"},I:{"1":"tB I pC qC rC sC BC tC","2":"f uC"},J:{"1":"D A"},K:{"1":"A B C qB AC rB","2":"g"},L:{"2":"H"},M:{"2":"H"},N:{"1":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:4,C:"display: run-in"};


/***/ }),

/***/ 87529:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","388":"B"},B:{"1":"O P Q R S T U","2":"C K L G","129":"M N","513":"V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB EC FC"},D:{"1":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB","513":"Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"G NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B HC zB IC JC KC LC 0B qB","2052":"L MC","3076":"C K rB 1B"},F:{"1":"FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB PC QC RC SC qB AC TC rB","513":"jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC","2052":"fC gC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","513":"g"},L:{"513":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"16":"1B"},R:{"513":"9C"},S:{"2":"AD"}},B:6,C:"'SameSite' cookie attribute"};


/***/ }),

/***/ 22474:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","164":"B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","36":"C K L G M N O"},C:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N EC FC","36":"0 1 2 3 4 5 6 7 8 9 O v w x y z AB BB CB DB EB FB GB HB IB JB"},D:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB"},E:{"1":"9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A","36":"B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","16":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"Screen Orientation"};


/***/ }),

/***/ 1522:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB FC","2":"DC tB EC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","132":"u"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"2":"oC"},I:{"1":"tB I f sC BC tC uC","2":"pC qC rC"},J:{"1":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"async attribute for external scripts"};


/***/ }),

/***/ 13440:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","132":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB","257":"0 1 2 3 4 5 6 I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"2":"oC"},I:{"1":"tB I f sC BC tC uC","2":"pC qC rC"},J:{"1":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"defer attribute for external scripts"};


/***/ }),

/***/ 39781:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D CC","132":"E F A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","132":"C K L G M N O"},C:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","132":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB EC FC"},D:{"1":"vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","132":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB"},E:{"1":"sB 6B 7B 8B 9B OC","2":"I u HC zB","132":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B"},F:{"1":"OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F PC QC RC SC","16":"B qB AC","132":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB TC rB"},G:{"1":"sB 6B 7B 8B 9B","16":"zB UC BC","132":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B"},H:{"2":"oC"},I:{"1":"f","16":"pC qC","132":"tB I rC sC BC tC uC"},J:{"132":"D A"},K:{"1":"g","132":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"132":"A B"},O:{"1":"vC"},P:{"132":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"scrollIntoView"};


/***/ }),

/***/ 12228:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"I u HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC"},H:{"2":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"Element.scrollIntoViewIfNeeded()"};


/***/ }),

/***/ 52531:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB","2":"uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB","2":"F B C g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:6,C:"SDCH Accept-Encoding/Content-Encoding"};


/***/ }),

/***/ 60612:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","16":"CC","260":"J D E"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","132":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB EC FC","2180":"JB KB LB MB NB OB PB QB RB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"I u HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","132":"F B C PC QC RC SC qB AC TC rB"},G:{"16":"BC","132":"zB UC","516":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f tC uC","16":"tB I pC qC rC sC","1025":"BC"},J:{"1":"A","16":"D"},K:{"1":"g","16":"A B C qB AC","132":"rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","16":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2180":"AD"}},B:5,C:"Selection API"};


/***/ }),

/***/ 6978:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB EC FC"},D:{"1":"dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB","196":"ZB vB aB bB","324":"cB"},E:{"2":"I u J D E F A B C HC zB IC JC KC LC 0B qB","516":"K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"Server Timing"};


/***/ }),

/***/ 65958:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L","322":"G M"},C:{"1":"KB MB NB OB PB QB RB TB UB VB WB XB YB uB vB aB bB cB dB eB fB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","194":"9 AB BB CB DB EB FB GB HB IB JB","513":"LB SB ZB gB"},D:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB","4":"GB HB IB JB KB"},E:{"1":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B HC zB IC JC KC LC 0B"},F:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","4":"3 4 5 6 7"},G:{"1":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC tC uC","4":"f"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:4,C:"Service Workers"};


/***/ }),

/***/ 87394:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O","2":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"1":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"Efficient Script Yielding: setImmediate()"};


/***/ }),

/***/ 29657:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P","2":"C K L G M N O Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 DC tB I u J D E F A B C K L G M N O v w x y z vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","66":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB"},D:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P","2":"0 I u J D E F A B C K L G M N O v w x y z Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","33":"1 2 3 4 5 6 7 8 9 AB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB","2":"F B C fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","33":"G M N O v w x"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC","33":"tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C","2":"3C 4C 5C sB 6C 7C 8C","33":"I"},Q:{"1":"1B"},R:{"2":"9C"},S:{"1":"AD"}},B:7,C:"Shadow DOM (deprecated V0 spec)"};


/***/ }),

/***/ 32860:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB EC FC","322":"YB","578":"uB ZB vB aB"},D:{"1":"TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB"},E:{"1":"A B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC"},F:{"1":"GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB PC QC RC SC qB AC TC rB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC","132":"bC cC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I","4":"wC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"Shadow DOM (V1)"};


/***/ }),

/***/ 71306:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z","2":"C K L G","194":"M N O","513":"a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB EC FC","194":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g","450":"lB mB nB oB pB","513":"P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB","194":"ZB vB aB bB cB dB eB fB","513":"a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A HC zB IC JC KC LC","194":"B C K L G 0B qB rB 1B MC NC","513":"2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB PC QC RC SC qB AC TC rB","194":"NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC","194":"cC dC eC fC gC hC iC jC kC lC mC nC","513":"2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","513":"g"},L:{"513":"H"},M:{"513":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C","513":"5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"513":"9C"},S:{"2":"AD"}},B:6,C:"Shared Array Buffer"};


/***/ }),

/***/ 42568:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"u J IC sB 6B 7B 8B 9B OC","2":"I D E F A B C K L G HC zB JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e SC qB AC TC rB","2":"F PC QC RC"},G:{"1":"VC WC sB 6B 7B 8B 9B","2":"E zB UC BC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"B C qB AC rB","2":"g","16":"A"},L:{"2":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"I","2":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"1":"AD"}},B:1,C:"Shared Web Workers"};


/***/ }),

/***/ 18689:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J CC","132":"D E"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB"},H:{"1":"oC"},I:{"1":"tB I f sC BC tC uC","2":"pC qC rC"},J:{"1":"A","2":"D"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Server Name Indication"};


/***/ }),

/***/ 35867:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F A CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB","2":"DC tB I u J D E F A B C RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB","2":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"E F A B C LC 0B qB","2":"I u J D HC zB IC JC KC","129":"K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB IB KB rB","2":"F B C GB HB JB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC"},G:{"1":"E YC ZC aC bC cC dC eC fC","2":"zB UC BC VC WC XC","257":"gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I sC BC tC uC","2":"f pC qC rC"},J:{"2":"D A"},K:{"1":"rB","2":"A B C g qB AC"},L:{"2":"H"},M:{"2":"H"},N:{"1":"B","2":"A"},O:{"2":"vC"},P:{"1":"I","2":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"1":"AD"}},B:7,C:"SPDY protocol"};


/***/ }),

/***/ 7773:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","1026":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"DC tB I u J D E F A B C K L G M N O v w x EC FC","322":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"0 I u J D E F A B C K L G M N O v w x y z","164":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L HC zB IC JC KC LC 0B qB rB 1B","2084":"G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","1026":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC","2084":"mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","164":"g"},L:{"164":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"164":"vC"},P:{"164":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"164":"1B"},R:{"164":"9C"},S:{"322":"AD"}},B:7,C:"Speech Recognition API"};


/***/ }),

/***/ 38623:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"L G M N O","2":"C K","257":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","194":"7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB"},D:{"1":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB","2":"0 1 2 3 4 5 6 7 8 I u J D E F A B C K L G M N O v w x y z","257":"VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC JC"},F:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB","2":"0 1 2 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","257":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"2":"9C"},S:{"1":"AD"}},B:7,C:"Speech Synthesis API"};


/***/ }),

/***/ 79418:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","2":"F PC QC"},G:{"4":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"4":"oC"},I:{"4":"tB I f pC qC rC sC BC tC uC"},J:{"1":"A","4":"D"},K:{"4":"A B C g qB AC rB"},L:{"4":"H"},M:{"4":"H"},N:{"4":"A B"},O:{"4":"vC"},P:{"4":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"4":"9C"},S:{"2":"AD"}},B:1,C:"Spellcheck attribute"};


/***/ }),

/***/ 88502:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p","2":"C K L G M N O","129":"q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p","129":"q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C HC zB IC JC KC LC 0B qB rB","2":"K L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z RC SC qB AC TC rB","2":"F PC QC","129":"a b c d e"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC","2":"hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I pC qC rC sC BC tC uC","129":"f"},J:{"1":"D A"},K:{"1":"B C qB AC rB","2":"A","129":"g"},L:{"129":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"Web SQL Database"};


/***/ }),

/***/ 31740:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","260":"C","514":"K L G"},C:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","194":"8 9 AB BB CB DB"},D:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z","260":"AB BB CB DB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D HC zB IC JC","260":"E KC"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w PC QC RC SC qB AC TC rB","260":"0 x y z"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC","260":"E YC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Srcset and sizes attributes"};


/***/ }),

/***/ 83192:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M EC FC","129":"CB DB EB FB GB HB","420":"0 1 2 3 4 5 6 7 8 9 N O v w x y z AB BB"},D:{"1":"TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O v w","420":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B"},F:{"1":"GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B G M N PC QC RC SC qB AC TC","420":"0 1 2 3 4 5 6 7 8 9 C O v w x y z AB BB CB DB EB FB rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC","513":"kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","1537":"dC eC fC gC hC iC jC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D","420":"A"},K:{"1":"g","2":"A B qB AC","420":"C rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","420":"I wC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:4,C:"getUserMedia/Stream API"};


/***/ }),

/***/ 54664:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","130":"B"},B:{"1":"Y Z a b c d e h i j k l m n o p q r s t f H","16":"C K","260":"L G","1028":"P Q R S T U V W X","5124":"M N O"},C:{"1":"n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB EC FC","5124":"l m","7172":"dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k","7746":"XB YB uB ZB vB aB bB cB"},D:{"1":"Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB","260":"SB TB UB VB WB XB YB","1028":"uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X"},E:{"2":"I u J D E F HC zB IC JC KC LC","1028":"G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","3076":"A B C K L 0B qB rB 1B"},F:{"1":"nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB PC QC RC SC qB AC TC rB","260":"FB GB HB IB JB KB LB","1028":"MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC","16":"bC","1028":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1028":"vC"},P:{"1":"5C sB 6C 7C 8C","2":"I wC xC","1028":"yC zC 0C 0B 1C 2C 3C 4C"},Q:{"1028":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:1,C:"Streams"};


/***/ }),

/***/ 24046:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A CC","129":"B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC JC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B PC QC RC SC qB AC TC"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Strict Transport Security"};


/***/ }),

/***/ 39846:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB","2":"DC tB I u J D E F A B C K L G M N O v w vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","322":"VB WB XB YB uB ZB"},D:{"2":"I u J D E F A B C K L G M N O v DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","194":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"1":"AD"}},B:7,C:"Scoped CSS"};


/***/ }),

/***/ 20198:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"p q r s t f H","2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"Subresource Loading with Web Bundles"};


/***/ }),

/***/ 50847:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M"},C:{"1":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB EC FC"},D:{"1":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B"},F:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC","194":"dC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"Subresource Integrity"};


/***/ }),

/***/ 52279:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","516":"C K L G"},C:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","260":"I u J D E F A B C K L G M N O v w x y z"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","4":"I"},E:{"1":"u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC","132":"I zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","2":"F"},G:{"1":"E BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","132":"zB UC"},H:{"260":"oC"},I:{"1":"tB I f sC BC tC uC","2":"pC qC rC"},J:{"1":"D A"},K:{"1":"g","260":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"SVG in CSS backgrounds"};


/***/ }),

/***/ 24682:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I","4":"u J D"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC"},H:{"1":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"SVG filters"};


/***/ }),

/***/ 18443:
/***/ ((module) => {

module.exports={A:{A:{"2":"F A B CC","8":"J D E"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB","2":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","130":"EB FB GB HB IB JB KB LB MB NB OB PB QB"},E:{"1":"I u J D E F A B C K L G zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC"},F:{"1":"0 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","2":"DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","130":"1 2 3 4 5 6 7 8 9 AB BB CB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"258":"oC"},I:{"1":"tB I sC BC tC uC","2":"f pC qC rC"},J:{"1":"D A"},K:{"1":"A B C qB AC rB","2":"g"},L:{"130":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"I","130":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"130":"9C"},S:{"2":"AD"}},B:2,C:"SVG fonts"};


/***/ }),

/***/ 32036:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","260":"F A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L EC FC"},D:{"1":"QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB","132":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB"},E:{"1":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D F A B HC zB IC JC LC 0B","132":"E KC"},F:{"1":"DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"G M N O v w x y","4":"B C QC RC SC qB AC TC","16":"F PC","132":"0 1 2 3 4 5 6 7 8 9 z AB BB CB"},G:{"1":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC ZC aC bC cC dC","132":"E YC"},H:{"1":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D","132":"A"},K:{"1":"g rB","4":"A B C qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","132":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"SVG fragment identifiers"};


/***/ }),

/***/ 18617:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","388":"F A B"},B:{"4":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","260":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC","4":"tB"},D:{"4":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"HC zB","4":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"4":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"4":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC","4":"f tC uC"},J:{"1":"A","2":"D"},K:{"4":"A B C g qB AC rB"},L:{"4":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"4":"vC"},P:{"4":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"4":"1B"},R:{"4":"9C"},S:{"1":"AD"}},B:2,C:"SVG effects for HTML"};


/***/ }),

/***/ 94098:
/***/ ((module) => {

module.exports={A:{A:{"2":"CC","8":"J D E","129":"F A B"},B:{"1":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","129":"C K L G M"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","8":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","8":"I u J"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"I u HC zB","129":"J D E IC JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","2":"B SC qB AC","8":"F PC QC RC"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","8":"zB UC BC","129":"E VC WC XC YC"},H:{"1":"oC"},I:{"1":"f tC uC","2":"pC qC rC","129":"tB I sC BC"},J:{"1":"A","129":"D"},K:{"1":"C g rB","8":"A B qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"129":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Inline SVG in HTML5"};


/***/ }),

/***/ 86703:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","132":"0 1 2 3 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC","4":"zB","132":"I u J D E IC JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","132":"E zB UC BC VC WC XC YC"},H:{"1":"oC"},I:{"1":"f tC uC","2":"pC qC rC","132":"tB I sC BC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"SVG in HTML img element"};


/***/ }),

/***/ 91827:
/***/ ((module) => {

module.exports={A:{A:{"2":"CC","8":"J D E F A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","8":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","8":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","4":"I"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"HC zB","132":"I u IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","132":"zB UC BC VC"},H:{"2":"oC"},I:{"1":"tB I f sC BC tC uC","2":"pC qC rC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"8":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"SVG SMIL animation"};


/***/ }),

/***/ 44087:
/***/ ((module) => {

module.exports={A:{A:{"2":"CC","8":"J D E","772":"F A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","513":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","4":"DC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","4":"HC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"f tC uC","2":"pC qC rC","132":"tB I sC BC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"257":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"SVG (basic support)"};


/***/ }),

/***/ 12832:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB","132":"jB kB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"Signed HTTP Exchanges (SXG)"};


/***/ }),

/***/ 40960:
/***/ ((module) => {

module.exports={A:{A:{"1":"D E F A B","16":"J CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"16":"DC tB EC FC","129":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L"},E:{"16":"I u HC zB","257":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","16":"F"},G:{"769":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"16":"oC"},I:{"16":"tB I f pC qC rC sC BC tC uC"},J:{"16":"D A"},K:{"1":"g","16":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"16":"A B"},O:{"1":"vC"},P:{"16":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"129":"AD"}},B:1,C:"tabindex global attribute"};


/***/ }),

/***/ 7507:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","16":"C"},C:{"1":"AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB"},E:{"1":"A B K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC","129":"C"},F:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"ZC aC bC cC dC eC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC","129":"fC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"ES6 Template Literals (Template Strings)"};


/***/ }),

/***/ 52873:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C","388":"K L"},C:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v w x EC FC"},D:{"1":"BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 I u J D E F A B C K L G M N O v w x y z","132":"2 3 4 5 6 7 8 9 AB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D HC zB IC","388":"E KC","514":"JC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","132":"G M N O v w x"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC","388":"E YC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"HTML templates"};


/***/ }),

/***/ 85105:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:6,C:"Temporal"};


/***/ }),

/***/ 40831:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E A B CC","16":"F"},B:{"2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","16":"I u"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"B C"},E:{"2":"I J HC zB IC","16":"u D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC AC TC rB","16":"qB"},G:{"2":"zB UC BC VC WC","16":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC sC BC tC uC","16":"rC"},J:{"2":"A","16":"D"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"Test feature - updated"};


/***/ }),

/***/ 6866:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","2052":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"DC tB I u EC FC","1028":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","1060":"0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O v w x y z AB BB"},D:{"2":"0 1 I u J D E F A B C K L G M N O v w x y z","226":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB","2052":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D HC zB IC JC","772":"K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","804":"E F A B C LC 0B qB","1316":"KC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB PC QC RC SC qB AC TC rB","226":"BB CB DB EB FB GB HB IB JB","2052":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"zB UC BC VC WC XC","292":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","2052":"g"},L:{"2052":"H"},M:{"1028":"H"},N:{"2":"A B"},O:{"2052":"vC"},P:{"2":"I wC xC","2052":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2052":"1B"},R:{"2052":"9C"},S:{"1028":"AD"}},B:4,C:"text-decoration styling"};


/***/ }),

/***/ 76001:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"k l m n o p q r s t f H","2":"C K L G M N O","164":"P Q R S T U V W X Y Z a b c d e h i j"},C:{"1":"MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB EC FC","322":"LB"},D:{"1":"k l m n o p q r s t f H xB yB GC","2":"0 I u J D E F A B C K L G M N O v w x y z","164":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j"},E:{"1":"E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC","164":"D JC"},F:{"1":"V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","164":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC","164":"tC uC"},J:{"2":"D","164":"A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"164":"vC"},P:{"1":"7C 8C","164":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C"},Q:{"164":"1B"},R:{"164":"9C"},S:{"1":"AD"}},B:4,C:"text-emphasis styling"};


/***/ }),

/***/ 73033:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B","2":"CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","8":"DC tB I u J EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e qB AC TC rB","33":"F PC QC RC SC"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"g rB","33":"A B C qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"CSS3 Text-overflow"};


/***/ }),

/***/ 2368:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","33":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB","258":"2"},E:{"2":"I u J D E F A B C K L G HC zB JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","258":"IC"},F:{"1":"JB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB KB PC QC RC SC qB AC TC rB"},G:{"2":"zB UC BC","33":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"33":"H"},N:{"161":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"CSS text-size-adjust"};


/***/ }),

/***/ 10481:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L","33":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","161":"G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB EC FC","161":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","450":"OB"},D:{"33":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"33":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"33":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","36":"zB"},H:{"2":"oC"},I:{"2":"tB","33":"I f pC qC rC sC BC tC uC"},J:{"33":"D A"},K:{"2":"A B C qB AC rB","33":"g"},L:{"33":"H"},M:{"161":"H"},N:{"2":"A B"},O:{"33":"vC"},P:{"33":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"33":"1B"},R:{"33":"9C"},S:{"161":"AD"}},B:7,C:"CSS text-stroke and text-fill"};


/***/ }),

/***/ 2846:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"HC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","16":"F"},G:{"1":"E UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB"},H:{"1":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Node.textContent"};


/***/ }),

/***/ 96073:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O EC FC","132":"v"},D:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"TextEncoder & TextDecoder"};


/***/ }),

/***/ 76376:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D CC","66":"E F A"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB","2":"DC tB I u J D E F A B C K L G M N O v w x y EC FC","66":"z","129":"gB hB iB jB kB g lB mB nB oB","388":"pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T","2":"I u J D E F A B C K L G M N O v w x","1540":"U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"D E F A B C K KC LC 0B qB rB","2":"I u J HC zB IC JC","513":"L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB rB","2":"F B C PC QC RC SC qB AC TC","1540":"g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"1":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"1":"A","2":"D"},K:{"1":"g rB","2":"A B C qB AC"},L:{"1":"H"},M:{"129":"H"},N:{"1":"B","66":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"TLS 1.1"};


/***/ }),

/***/ 99062:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D CC","66":"E F A"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O v w x y z EC FC","66":"0 1 2"},D:{"1":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC JC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F G PC","66":"B C QC RC SC qB AC TC rB"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"1":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"1":"A","2":"D"},K:{"1":"g rB","2":"A B C qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","66":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"TLS 1.2"};


/***/ }),

/***/ 5423:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB EC FC","132":"ZB vB aB","450":"RB SB TB UB VB WB XB YB uB"},D:{"1":"iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB","706":"UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB"},E:{"1":"L G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C HC zB IC JC KC LC 0B qB","1028":"K rB 1B"},F:{"1":"XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB PC QC RC SC qB AC TC rB","706":"UB VB WB"},G:{"1":"gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:6,C:"TLS 1.3"};


/***/ }),

/***/ 61653:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","8":"A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","578":"C K L G M N O"},C:{"1":"0 O v w x y z SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","4":"I u J D E F A B C K L G M N","194":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O v w x"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"8":"A","260":"B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:2,C:"Touch events"};


/***/ }),

/***/ 98415:
/***/ ((module) => {

module.exports={A:{A:{"2":"CC","8":"J D E","129":"A B","161":"F"},B:{"1":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","129":"C K L G M"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB","33":"I u J D E F A B C K L G EC FC"},D:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","33":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","33":"I u J D E HC zB IC JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F PC QC","33":"B C G M N O v w x y RC SC qB AC TC"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","33":"E zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"f","33":"tB I pC qC rC sC BC tC uC"},J:{"33":"D A"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS3 2D Transforms"};


/***/ }),

/***/ 48912:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","132":"A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F EC FC","33":"A B C K L G"},D:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B","33":"0 1 2 3 4 5 6 7 8 9 C K L G M N O v w x y z AB BB"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB","33":"I u J D E IC JC KC","257":"F A B C K L G LC 0B qB rB 1B MC NC 2B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","33":"G M N O v w x y"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","33":"E zB UC BC VC WC XC YC","257":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B"},H:{"2":"oC"},I:{"1":"f","2":"pC qC rC","33":"tB I sC BC tC uC"},J:{"33":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"132":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:5,C:"CSS3 3D Transforms"};


/***/ }),

/***/ 58552:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O P Q R"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"Trusted Types for DOM manipulation"};


/***/ }),

/***/ 23126:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","132":"F A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC tB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e QC RC SC qB AC TC rB","2":"F PC"},G:{"1":"E BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC"},H:{"2":"oC"},I:{"1":"tB I f qC rC sC BC tC uC","2":"pC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"132":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"TTF/OTF - TrueType and OpenType font support"};


/***/ }),

/***/ 71426:
/***/ ((module) => {

module.exports={A:{A:{"1":"B","2":"J D E F CC","132":"A"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB","260":"IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","2":"F B PC QC RC SC qB AC"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC","260":"BC"},H:{"1":"oC"},I:{"1":"I f sC BC tC uC","2":"tB pC qC rC"},J:{"1":"A","2":"D"},K:{"1":"C g rB","2":"A B qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"132":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Typed Arrays"};


/***/ }),

/***/ 61405:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O r s t f H","513":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q"},C:{"1":"fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB EC FC","322":"NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB yB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB r s t f H xB yB GC","130":"EB FB GB","513":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i","578":"j k l m n o p q"},E:{"1":"K L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C HC zB IC JC KC LC 0B qB rB"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB HB PC QC RC SC qB AC TC rB","513":"GB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"322":"AD"}},B:7,C:"FIDO U2F API"};


/***/ }),

/***/ 43287:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB EC FC"},D:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B"},F:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB PC QC RC SC qB AC TC rB"},G:{"1":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC","16":"dC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:1,C:"unhandledrejection/rejectionhandled events"};


/***/ }),

/***/ 97798:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M"},C:{"1":"IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB EC FC"},D:{"1":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"Upgrade Insecure Requests"};


/***/ }),

/***/ 52411:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O","66":"P Q R"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g","66":"lB mB nB oB pB P Q"},E:{"1":"6B 7B 8B 9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB"},F:{"1":"gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB PC QC RC SC qB AC TC rB","66":"eB fB"},G:{"1":"6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"URL Scroll-To-Text Fragment"};


/***/ }),

/***/ 80081:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 DC tB I u J D E F A B C K L G M N O v w x y z EC FC"},D:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O v w x y","130":"0 1 2 3 4 5 6 7 z"},E:{"1":"E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC JC","130":"D"},F:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","130":"G M N O"},G:{"1":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC","130":"XC"},H:{"2":"oC"},I:{"1":"f uC","2":"tB I pC qC rC sC BC","130":"tC"},J:{"2":"D","130":"A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"URL API"};


/***/ }),

/***/ 17586:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M"},C:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","132":"5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB"},D:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB"},E:{"1":"B C K L G 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC"},F:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB PC QC RC SC qB AC TC rB"},G:{"1":"cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"URLSearchParams"};


/***/ }),

/***/ 33500:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","132":"u IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","2":"F B PC QC RC SC qB AC"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"1":"oC"},I:{"1":"tB I f sC BC tC uC","2":"pC qC rC"},J:{"1":"D A"},K:{"1":"C g AC rB","2":"A B qB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"ECMAScript 5 Strict Mode"};


/***/ }),

/***/ 85671:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","33":"A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","33":"C K L G M N O"},C:{"1":"hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","33":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB EC FC"},D:{"1":"UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","33":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB"},E:{"1":"OC","33":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B"},F:{"1":"HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","33":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB"},G:{"33":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","33":"tB I pC qC rC sC BC tC uC"},J:{"33":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"33":"A B"},O:{"1":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","33":"I wC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"33":"AD"}},B:5,C:"CSS user-select: none"};


/***/ }),

/***/ 98345:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EC FC"},D:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"User Timing API"};


/***/ }),

/***/ 56153:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB EC FC","4609":"aB bB cB dB eB fB gB hB iB","4674":"vB","5698":"ZB","7490":"TB UB VB WB XB","7746":"YB uB","8705":"jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB","4097":"eB","4290":"uB ZB vB","6148":"aB bB cB dB"},E:{"1":"G NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B","4609":"B C qB rB","8193":"K L 1B MC"},F:{"1":"UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PC QC RC SC qB AC TC rB","4097":"TB","6148":"PB QB RB SB"},G:{"1":"hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC","4097":"dC eC fC gC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"4097":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"2":"I wC xC yC","4097":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"Variable fonts"};


/***/ }),

/***/ 18563:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J D E F A B C K L"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","2":"F B PC QC RC SC qB AC"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC"},H:{"1":"oC"},I:{"1":"f tC uC","16":"tB I pC qC rC sC BC"},J:{"16":"D A"},K:{"1":"C g rB","2":"A B qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"SVG vector-effect: non-scaling-stroke"};


/***/ }),

/***/ 78480:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A EC FC","33":"B C K L G"},D:{"1":"6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 I u J D E F A B C K L G M N O v w x y z"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"Vibration API"};


/***/ }),

/***/ 69345:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB","260":"I u J D E F A B C K L G M N O v EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A IC JC KC LC 0B","2":"HC zB","513":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","2":"F PC QC"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC","513":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I f rC sC BC tC uC","132":"pC qC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Video element"};


/***/ }),

/***/ 32495:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O","322":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","194":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB","322":"LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J HC zB IC"},F:{"2":"0 1 2 3 4 5 6 7 F B C G M N O v w x y z PC QC RC SC qB AC TC rB","322":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","322":"g"},L:{"322":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"322":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"322":"1B"},R:{"322":"9C"},S:{"194":"AD"}},B:1,C:"Video Tracks"};


/***/ }),

/***/ 26571:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"t f H","2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p","194":"q r s"},C:{"1":"m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l EC FC"},D:{"1":"t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k","194":"l m n o p q r s"},E:{"1":"3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B"},F:{"1":"d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z PC QC RC SC qB AC TC rB","194":"a b c"},G:{"1":"3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"Small, Large, and Dynamic viewport units"};


/***/ }),

/***/ 23396:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","132":"F","260":"A B"},B:{"1":"M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","260":"C K L G"},C:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L G M N O EC FC"},D:{"1":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N O v","260":"0 1 w x y z"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC","260":"J"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC","516":"XC","772":"WC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"260":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"Viewport units: vw, vh, vmin, vmax"};


/***/ }),

/***/ 32102:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D CC","4":"E F A B"},B:{"4":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"4":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"4":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"HC zB","4":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F","4":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"4":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"4":"oC"},I:{"2":"tB I pC qC rC sC BC","4":"f tC uC"},J:{"2":"D A"},K:{"4":"A B C g qB AC rB"},L:{"4":"H"},M:{"4":"H"},N:{"4":"A B"},O:{"4":"vC"},P:{"4":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"4":"1B"},R:{"4":"9C"},S:{"4":"AD"}},B:2,C:"WAI-ARIA Accessibility features"};


/***/ }),

/***/ 44534:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O","194":"P Q R S T U V W X Y"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB","194":"jB kB g lB mB nB oB pB P Q R S T"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B","4":"9B OC"},F:{"1":"g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB PC QC RC SC qB AC TC rB","194":"YB ZB aB bB cB dB eB fB gB hB iB jB kB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B","4":"9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"4C 5C sB 6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:4,C:"Screen Wake Lock API"};


/***/ }),

/***/ 95495:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L","578":"G"},C:{"1":"TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB EC FC","194":"NB OB PB QB RB","1025":"SB"},D:{"1":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB","322":"RB SB TB UB VB WB"},E:{"1":"B C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B"},F:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB PC QC RC SC qB AC TC rB","322":"EB FB GB HB IB JB"},G:{"1":"dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"194":"AD"}},B:6,C:"WebAssembly"};


/***/ }),

/***/ 22174:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC tB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e RC SC qB AC TC rB","2":"F PC QC"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","16":"A"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"Wav audio format"};


/***/ }),

/***/ 91075:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D CC","2":"E F A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"HC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","16":"F"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC"},H:{"1":"oC"},I:{"1":"tB I f rC sC BC tC uC","16":"pC qC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"wbr (word break opportunity) element"};


/***/ }),

/***/ 17713:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O","260":"P Q R S"},C:{"1":"R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","260":"uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB","516":"NB OB PB QB RB SB TB UB VB WB XB YB","580":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB","2049":"mB nB oB pB P Q"},D:{"1":"T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB","132":"CB DB EB","260":"FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S"},E:{"1":"G NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC 0B","1090":"B C K qB rB","2049":"L 1B MC"},F:{"1":"jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w x y PC QC RC SC qB AC TC rB","132":"0 1 z","260":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC","1090":"dC eC fC gC hC iC jC","2049":"kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"260":"vC"},P:{"260":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"260":"1B"},R:{"1":"9C"},S:{"516":"AD"}},B:5,C:"Web Animations API"};


/***/ }),

/***/ 48215:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M","130":"N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","578":"nB oB pB P Q R wB S T U"},D:{"1":"FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC","4":"9B","260":"eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"Add to home screen (A2HS)"};


/***/ }),

/***/ 46475:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","1025":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB","194":"LB MB NB OB PB QB RB SB","706":"TB UB VB","1025":"WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB PC QC RC SC qB AC TC rB","450":"CB DB EB FB","706":"GB HB IB","1025":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC tC uC","1025":"f"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","1025":"g"},L:{"1025":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1025":"vC"},P:{"1":"xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC"},Q:{"2":"1B"},R:{"1025":"9C"},S:{"2":"AD"}},B:7,C:"Web Bluetooth"};


/***/ }),

/***/ 86902:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O","66":"P Q R S T U V W X"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB","66":"pB P Q R S T U V W X"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB PC QC RC SC qB AC TC rB","66":"dB eB fB gB hB iB jB kB g lB mB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"Web Serial API"};


/***/ }),

/***/ 1574:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"e h i j k l m n o p q r s t f H","2":"C K L G M N O P Q","516":"R S T U V W X Y Z a b c d"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X","130":"0 O v w x y z","1028":"Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"L G MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C HC zB IC JC KC LC 0B qB","2049":"K rB 1B"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC","2049":"gC hC iC jC kC"},H:{"2":"oC"},I:{"2":"tB I pC qC rC sC BC tC","258":"f uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I","258":"wC xC yC"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:4,C:"Web Share API"};


/***/ }),

/***/ 8423:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C","226":"K L G M N"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB EC FC","5124":"ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB"},E:{"1":"K L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A B C HC zB IC JC KC LC 0B qB","322":"rB"},F:{"1":"UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB PC QC RC SC qB AC TC rB"},G:{"1":"mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC","578":"iC","2052":"lC","3076":"jC kC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1028":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:2,C:"Web Authentication API"};


/***/ }),

/***/ 69174:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"d e h i j k l m n o p q r s t f H","2":"C K L G M N O P Q R S T U V W X Y Z a b c"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B","260":"9B OC"},F:{"1":"Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B","260":"9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"6C 7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"WebCodecs API"};


/***/ }),

/***/ 34889:
/***/ ((module) => {

module.exports={A:{A:{"2":"CC","8":"J D E F A","129":"B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","129":"C K L G M N O"},C:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","129":"I u J D E F A B C K L G M N O v w x y z"},D:{"1":"9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D","129":"0 1 2 3 4 5 6 7 8 E F A B C K L G M N O v w x y z"},E:{"1":"E F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB","129":"J D IC JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B PC QC RC SC qB AC TC","129":"C G M N O rB"},G:{"1":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC XC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"1":"A","2":"D"},K:{"1":"C g rB","2":"A B qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"8":"A","129":"B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"129":"AD"}},B:6,C:"WebGL - 3D Canvas graphics"};


/***/ }),

/***/ 75593:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","194":"IB JB KB","450":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB","2242":"LB MB NB OB PB QB"},D:{"1":"WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB","578":"JB KB LB MB NB OB PB QB RB SB TB UB VB"},E:{"1":"G NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F A HC zB IC JC KC LC","1090":"B C K L 0B qB rB 1B MC"},F:{"1":"JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB PC QC RC SC qB AC TC rB"},G:{"1":"nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC","1090":"fC gC hC iC jC kC lC mC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC"},Q:{"1":"1B"},R:{"1":"9C"},S:{"2242":"AD"}},B:6,C:"WebGL 2.0"};


/***/ }),

/***/ 98935:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P","578":"Q R S T U V W X Y Z a b c","1602":"d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB EC FC","194":"bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P","578":"Q R S T U V W X Y Z a b c","1602":"d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B HC zB IC JC KC LC 0B","322":"C K L G qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB PC QC RC SC qB AC TC rB","578":"g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"194":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:5,C:"WebGPU"};


/***/ }),

/***/ 51706:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O","66":"P Q R S T U V W X"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB","66":"pB P Q R S T U V W X"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB PC QC RC SC qB AC TC rB","66":"eB fB gB hB iB jB kB g lB mB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"WebHID API"};


/***/ }),

/***/ 27580:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","132":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"16":"I u J D E F A B C K L G","132":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"F B C PC QC RC SC qB AC TC rB","132":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"CSS -webkit-user-drag property"};


/***/ }),

/***/ 19936:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E CC","520":"F A B"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","8":"C K","388":"L G M N O"},C:{"1":"4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","132":"0 1 2 3 I u J D E F A B C K L G M N O v w x y z"},D:{"1":"1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u","132":"0 J D E F A B C K L G M N O v w x y z"},E:{"1":"sB 6B 7B 8B 9B OC","2":"HC","8":"I u zB IC","520":"J D E F A B C JC KC LC 0B qB","1028":"K rB 1B","7172":"L","8196":"G MC NC 2B 3B 4B 5B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F PC QC RC","132":"B C G SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC","1028":"gC hC iC jC kC","3076":"lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"pC qC","132":"tB I rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"8":"A B"},O:{"1":"vC"},P:{"1":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","132":"I"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:6,C:"WebM video format"};


/***/ }),

/***/ 57179:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O P Y Z a b c d e h i j k l m n o p q r s t f H","450":"Q R S T U V W X"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","450":"Q R S T U V W X"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","450":"fB gB hB iB jB kB g lB mB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"257":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"Web NFC"};


/***/ }),

/***/ 95001:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N"},C:{"1":"dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","8":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB"},D:{"1":"8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u","8":"J D E","132":"F A B C K L G M N O v w x y","260":"0 1 2 3 4 5 6 7 z"},E:{"1":"sB 6B 7B 8B 9B OC","2":"I u J D E F A B C K HC zB IC JC KC LC 0B qB rB 1B","516":"L G MC NC 2B 3B 4B 5B"},F:{"1":"0 1 2 3 4 5 6 7 8 9 v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F PC QC RC","8":"B SC","132":"qB AC TC","260":"C G M N O rB"},G:{"1":"lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC"},H:{"1":"oC"},I:{"1":"f BC tC uC","2":"tB pC qC rC","132":"I sC"},J:{"2":"D A"},K:{"1":"C g qB AC rB","2":"A","132":"B"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"8":"AD"}},B:6,C:"WebP image format"};


/***/ }),

/***/ 9648:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB EC FC","132":"I u","292":"J D E F A"},D:{"1":"0 1 2 3 4 5 6 7 8 9 M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","132":"I u J D E F A B C K L","260":"G"},E:{"1":"D E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","132":"u IC","260":"J JC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F PC QC RC SC","132":"B C qB AC TC"},G:{"1":"E WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC","132":"BC VC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","129":"D"},K:{"1":"g rB","2":"A","132":"B C qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Web Sockets"};


/***/ }),

/***/ 14552:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"j k l m n o p q r s t f H","2":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z e h","66":"a b c d"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB PC QC RC SC qB AC TC rB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"1":"7C 8C","2":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:5,C:"WebTransport"};


/***/ }),

/***/ 75310:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB","66":"UB VB WB XB YB uB ZB"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB PC QC RC SC qB AC TC rB","66":"HB IB JB KB LB MB NB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C","2":"I wC xC yC"},Q:{"2":"1B"},R:{"1":"9C"},S:{"2":"AD"}},B:7,C:"WebUSB"};


/***/ }),

/***/ 28335:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","66":"P","257":"G M N O"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB EC FC","129":"VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","194":"UB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","66":"XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P"},E:{"2":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","66":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C g qB AC rB"},L:{"2":"H"},M:{"2":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"513":"I","516":"wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:7,C:"WebVR API"};


/***/ }),

/***/ 53707:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"DC tB I u J D E F A B C K L G M N O v w x y z EC FC","66":"0 1 2 3 4 5 6","129":"7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB","257":"VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I u J D E F A B C K L G M N"},E:{"1":"J D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC VC WC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB I pC qC rC sC BC"},J:{"1":"A","2":"D"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"B","2":"A"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"129":"AD"}},B:4,C:"WebVTT - Web Video Text Tracks"};


/***/ }),

/***/ 82501:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","2":"CC","8":"J D E F"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","8":"DC tB"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","8":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e SC qB AC TC rB","2":"F PC","8":"QC RC"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"2":"oC"},I:{"1":"f pC tC uC","2":"tB I qC rC sC BC"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","8":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Web Workers"};


/***/ }),

/***/ 85515:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"2":"C K L G M N O","132":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB EC FC","322":"oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB"},D:{"2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB","66":"dB eB fB gB hB iB jB kB g lB mB nB oB pB","132":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"2":"I u J D E F A B C HC zB IC JC KC LC 0B qB rB","578":"K L G 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"2":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB PC QC RC SC qB AC TC rB","66":"SB TB UB VB WB XB YB ZB aB bB cB dB","132":"eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e"},G:{"2":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"2":"oC"},I:{"2":"tB I f pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"2":"A B C qB AC rB","132":"g"},L:{"132":"H"},M:{"322":"H"},N:{"2":"A B"},O:{"2":"vC"},P:{"2":"I wC xC yC zC 0C 0B 1C","132":"2C 3C 4C 5C sB 6C 7C 8C"},Q:{"2":"1B"},R:{"2":"9C"},S:{"2":"AD"}},B:4,C:"WebXR Device API"};


/***/ }),

/***/ 70441:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K L G M N O"},C:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 DC tB I u J D E F A B C K L G M N O v w x y z EC FC","194":"5 6 7 8 9 AB BB"},D:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB"},E:{"1":"A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w x y z PC QC RC SC qB AC TC rB"},G:{"1":"aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS will-change property"};


/***/ }),

/***/ 15216:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB FC","2":"DC tB EC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"I"},E:{"1":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e qB AC TC rB","2":"F B PC QC RC SC"},G:{"1":"E VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC"},H:{"2":"oC"},I:{"1":"f tC uC","2":"tB pC qC rC sC BC","130":"I"},J:{"1":"D A"},K:{"1":"B C g qB AC rB","2":"A"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"WOFF - Web Open Font Format"};


/***/ }),

/***/ 92249:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F A B CC"},B:{"1":"L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","2":"C K"},C:{"1":"FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB EC FC"},D:{"1":"CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","2":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB"},E:{"1":"C K L G rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I u J D E F HC zB IC JC KC LC","132":"A B 0B qB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C G M N O v w x y PC QC RC SC qB AC TC rB"},G:{"1":"bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"E zB UC BC VC WC XC YC ZC aC"},H:{"2":"oC"},I:{"1":"f","2":"tB I pC qC rC sC BC tC uC"},J:{"2":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"2":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:2,C:"WOFF 2.0 - Web Open Font Format"};


/***/ }),

/***/ 72383:
/***/ ((module) => {

module.exports={A:{A:{"1":"J D E F A B CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB I u J D E F A B C K L EC FC"},D:{"1":"KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","4":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB"},E:{"1":"F A B C K L G LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","4":"I u J D E HC zB IC JC KC"},F:{"1":"7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","2":"F B C PC QC RC SC qB AC TC rB","4":"0 1 2 3 4 5 6 G M N O v w x y z"},G:{"1":"ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","4":"E zB UC BC VC WC XC YC"},H:{"2":"oC"},I:{"1":"f","4":"tB I pC qC rC sC BC tC uC"},J:{"4":"D A"},K:{"1":"g","2":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"CSS3 word-break"};


/***/ }),

/***/ 40133:
/***/ ((module) => {

module.exports={A:{A:{"4":"J D E F A B CC"},B:{"1":"O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H","4":"C K L G M N"},C:{"1":"PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB","4":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","4":"I u J D E F A B C K L G M N O v w x y"},E:{"1":"D E F A B C K L G JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","4":"I u J HC zB IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F PC QC","4":"B C RC SC qB AC TC"},G:{"1":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","4":"zB UC BC VC WC"},H:{"4":"oC"},I:{"1":"f tC uC","4":"tB I pC qC rC sC BC"},J:{"1":"A","4":"D"},K:{"1":"g","4":"A B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"4":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"4":"AD"}},B:4,C:"CSS3 Overflow-wrap"};


/***/ }),

/***/ 3334:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D CC","132":"E F","260":"A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC","2":"DC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"HC zB"},F:{"1":"0 1 2 3 4 5 6 7 8 9 B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB","2":"F"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"4":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"Cross-document messaging"};


/***/ }),

/***/ 52711:
/***/ ((module) => {

module.exports={A:{A:{"1":"E F A B","2":"J D CC"},B:{"1":"C K L G M N O","4":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB","4":"I u J D E F A B C K L G M N iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","16":"DC tB EC FC"},D:{"4":"2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"0 1 I u J D E F A B C K L G M N O v w x y z"},E:{"4":"J D E F A B C K L G IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","16":"I u HC zB"},F:{"4":"0 1 2 3 4 5 6 7 8 9 C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e TC rB","16":"F B PC QC RC SC qB AC"},G:{"4":"E XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","16":"zB UC BC VC WC"},H:{"2":"oC"},I:{"4":"I f sC BC tC uC","16":"tB pC qC rC"},J:{"4":"D A"},K:{"4":"g rB","16":"A B C qB AC"},L:{"4":"H"},M:{"4":"H"},N:{"1":"A B"},O:{"4":"vC"},P:{"4":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"4":"1B"},R:{"4":"9C"},S:{"1":"AD"}},B:6,C:"X-Frame-Options HTTP header"};


/***/ }),

/***/ 94381:
/***/ ((module) => {

module.exports={A:{A:{"2":"J D E F CC","132":"A B"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","2":"DC tB","260":"A B","388":"J D E F","900":"I u EC FC"},D:{"1":"7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","16":"I u J","132":"5 6","388":"0 1 2 3 4 D E F A B C K L G M N O v w x y z"},E:{"1":"E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","2":"I HC zB","132":"D JC","388":"u J IC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 C O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e rB","2":"F B PC QC RC SC qB AC TC","132":"G M N"},G:{"1":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","2":"zB UC BC","132":"XC","388":"VC WC"},H:{"2":"oC"},I:{"1":"f uC","2":"pC qC rC","388":"tC","900":"tB I sC BC"},J:{"132":"A","388":"D"},K:{"1":"C g rB","2":"A B qB AC"},L:{"1":"H"},M:{"1":"H"},N:{"132":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"XMLHttpRequest advanced features"};


/***/ }),

/***/ 92605:
/***/ ((module) => {

module.exports={A:{A:{"1":"F A B","2":"J D E CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"1":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"1":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"1":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"1":"oC"},I:{"1":"tB I f pC qC rC sC BC tC uC"},J:{"1":"D A"},K:{"1":"A B C g qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:1,C:"XHTML served as application/xhtml+xml"};


/***/ }),

/***/ 7278:
/***/ ((module) => {

module.exports={A:{A:{"2":"F A B CC","4":"J D E"},B:{"2":"C K L G M N O","8":"P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"8":"0 1 2 3 4 5 6 7 8 9 DC tB I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB EC FC"},D:{"8":"0 1 2 3 4 5 6 7 8 9 I u J D E F A B C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC"},E:{"8":"I u J D E F A B C K L G HC zB IC JC KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC"},F:{"8":"0 1 2 3 4 5 6 7 8 9 F B C G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e PC QC RC SC qB AC TC rB"},G:{"8":"E zB UC BC VC WC XC YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B"},H:{"8":"oC"},I:{"8":"tB I f pC qC rC sC BC tC uC"},J:{"8":"D A"},K:{"8":"A B C g qB AC rB"},L:{"8":"H"},M:{"8":"H"},N:{"2":"A B"},O:{"8":"vC"},P:{"8":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"8":"1B"},R:{"8":"9C"},S:{"8":"AD"}},B:7,C:"XHTML+SMIL animation"};


/***/ }),

/***/ 12227:
/***/ ((module) => {

module.exports={A:{A:{"1":"A B","260":"J D E F CC"},B:{"1":"C K L G M N O P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H"},C:{"1":"0 1 2 3 4 5 6 7 8 9 C K L G M N O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB","132":"B","260":"DC tB I u J D EC FC","516":"E F A"},D:{"1":"7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB uB ZB vB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R S T U V W X Y Z a b c d e h i j k l m n o p q r s t f H xB yB GC","132":"0 1 2 3 4 5 6 I u J D E F A B C K L G M N O v w x y z"},E:{"1":"E F A B C K L G KC LC 0B qB rB 1B MC NC 2B 3B 4B 5B sB 6B 7B 8B 9B OC","132":"I u J D HC zB IC JC"},F:{"1":"0 1 2 3 4 5 6 7 8 9 O v w x y z AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB g lB mB nB oB pB P Q R wB S T U V W X Y Z a b c d e","16":"F PC","132":"B C G M N QC RC SC qB AC TC rB"},G:{"1":"E YC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC 2B 3B 4B 5B sB 6B 7B 8B 9B","132":"zB UC BC VC WC XC"},H:{"132":"oC"},I:{"1":"f tC uC","132":"tB I pC qC rC sC BC"},J:{"132":"D A"},K:{"1":"g","16":"A","132":"B C qB AC rB"},L:{"1":"H"},M:{"1":"H"},N:{"1":"A B"},O:{"1":"vC"},P:{"1":"I wC xC yC zC 0C 0B 1C 2C 3C 4C 5C sB 6C 7C 8C"},Q:{"1":"1B"},R:{"1":"9C"},S:{"1":"AD"}},B:4,C:"DOM Parsing and Serialization"};


/***/ }),

/***/ 20793:
/***/ ((module) => {

module.exports = {
  1: 'ls', // WHATWG Living Standard
  2: 'rec', // W3C Recommendation
  3: 'pr', // W3C Proposed Recommendation
  4: 'cr', // W3C Candidate Recommendation
  5: 'wd', // W3C Working Draft
  6: 'other', // Non-W3C, but reputable
  7: 'unoff' // Unofficial, Editor's Draft or W3C "Note"
}


/***/ }),

/***/ 31708:
/***/ ((module) => {

module.exports = {
  y: 1 << 0,
  n: 1 << 1,
  a: 1 << 2,
  p: 1 << 3,
  u: 1 << 4,
  x: 1 << 5,
  d: 1 << 6
}


/***/ }),

/***/ 87462:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const browsers = (__nccwpck_require__(56609).browsers)
const versions = (__nccwpck_require__(73958).browserVersions)
const agentsData = __nccwpck_require__(306)

function unpackBrowserVersions(versionsData) {
  return Object.keys(versionsData).reduce((usage, version) => {
    usage[versions[version]] = versionsData[version]
    return usage
  }, {})
}

module.exports.agents = Object.keys(agentsData).reduce((map, key) => {
  let versionsData = agentsData[key]
  map[browsers[key]] = Object.keys(versionsData).reduce((data, entry) => {
    if (entry === 'A') {
      data.usage_global = unpackBrowserVersions(versionsData[entry])
    } else if (entry === 'C') {
      data.versions = versionsData[entry].reduce((list, version) => {
        if (version === '') {
          list.push(null)
        } else {
          list.push(versions[version])
        }
        return list
      }, [])
    } else if (entry === 'D') {
      data.prefix_exceptions = unpackBrowserVersions(versionsData[entry])
    } else if (entry === 'E') {
      data.browser = versionsData[entry]
    } else if (entry === 'F') {
      data.release_date = Object.keys(versionsData[entry]).reduce(
        (map2, key2) => {
          map2[versions[key2]] = versionsData[entry][key2]
          return map2
        },
        {}
      )
    } else {
      // entry is B
      data.prefix = versionsData[entry]
    }
    return data
  }, {})
  return map
}, {})


/***/ }),

/***/ 73958:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports.browserVersions = __nccwpck_require__(95582)


/***/ }),

/***/ 56609:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports.browsers = __nccwpck_require__(69178)


/***/ }),

/***/ 13206:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const statuses = __nccwpck_require__(20793)
const supported = __nccwpck_require__(31708)
const browsers = (__nccwpck_require__(56609).browsers)
const versions = (__nccwpck_require__(73958).browserVersions)

const MATH2LOG = Math.log(2)

function unpackSupport(cipher) {
  // bit flags
  let stats = Object.keys(supported).reduce((list, support) => {
    if (cipher & supported[support]) list.push(support)
    return list
  }, [])

  // notes
  let notes = cipher >> 7
  let notesArray = []
  while (notes) {
    let note = Math.floor(Math.log(notes) / MATH2LOG) + 1
    notesArray.unshift(`#${note}`)
    notes -= Math.pow(2, note - 1)
  }

  return stats.concat(notesArray).join(' ')
}

function unpackFeature(packed) {
  let unpacked = { status: statuses[packed.B], title: packed.C }
  unpacked.stats = Object.keys(packed.A).reduce((browserStats, key) => {
    let browser = packed.A[key]
    browserStats[browsers[key]] = Object.keys(browser).reduce(
      (stats, support) => {
        let packedVersions = browser[support].split(' ')
        let unpacked2 = unpackSupport(support)
        packedVersions.forEach(v => (stats[versions[v]] = unpacked2))
        return stats
      },
      {}
    )
    return browserStats
  }, {})
  return unpacked
}

module.exports = unpackFeature
module.exports["default"] = unpackFeature


/***/ }),

/***/ 65334:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*
 * Load this dynamically so that it
 * doesn't appear in the rollup bundle.
 */

module.exports.features = __nccwpck_require__(28649)


/***/ }),

/***/ 64006:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports.agents = __nccwpck_require__(87462).agents
module.exports.feature = __nccwpck_require__(13206)
module.exports.features = __nccwpck_require__(65334).features
module.exports.region = __nccwpck_require__(53506)


/***/ }),

/***/ 53506:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const browsers = (__nccwpck_require__(56609).browsers)

function unpackRegion(packed) {
  return Object.keys(packed).reduce((list, browser) => {
    let data = packed[browser]
    list[browsers[browser]] = Object.keys(data).reduce((memo, key) => {
      let stats = data[key]
      if (key === '_') {
        stats.split(' ').forEach(version => (memo[version] = null))
      } else {
        memo[key] = stats
      }
      return memo
    }, {})
    return list
  }, {})
}

module.exports = unpackRegion
module.exports["default"] = unpackRegion


/***/ }),

/***/ 78510:
/***/ ((module) => {

"use strict";


module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};


/***/ }),

/***/ 63120:
/***/ ((module) => {

"use strict";
/*! https://mths.be/cssesc v3.0.0 by @mathias */


var object = {};
var hasOwnProperty = object.hasOwnProperty;
var merge = function merge(options, defaults) {
	if (!options) {
		return defaults;
	}
	var result = {};
	for (var key in defaults) {
		// `if (defaults.hasOwnProperty(key) { … }` is not needed here, since
		// only recognized option names are used.
		result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
	}
	return result;
};

var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
var regexAlwaysEscape = /['"\\]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;

// https://mathiasbynens.be/notes/css-escapes#css
var cssesc = function cssesc(string, options) {
	options = merge(options, cssesc.options);
	if (options.quotes != 'single' && options.quotes != 'double') {
		options.quotes = 'single';
	}
	var quote = options.quotes == 'double' ? '"' : '\'';
	var isIdentifier = options.isIdentifier;

	var firstChar = string.charAt(0);
	var output = '';
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var character = string.charAt(counter++);
		var codePoint = character.charCodeAt();
		var value = void 0;
		// If it’s not a printable ASCII character…
		if (codePoint < 0x20 || codePoint > 0x7E) {
			if (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {
				// It’s a high surrogate, and there is a next character.
				var extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// next character is low surrogate
					codePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;
				} else {
					// It’s an unmatched surrogate; only append this code unit, in case
					// the next code unit is the high surrogate of a surrogate pair.
					counter--;
				}
			}
			value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
		} else {
			if (options.escapeEverything) {
				if (regexAnySingleEscape.test(character)) {
					value = '\\' + character;
				} else {
					value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
				}
			} else if (/[\t\n\f\r\x0B]/.test(character)) {
				value = '\\' + codePoint.toString(16).toUpperCase() + ' ';
			} else if (character == '\\' || !isIdentifier && (character == '"' && quote == character || character == '\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
				value = '\\' + character;
			} else {
				value = character;
			}
		}
		output += value;
	}

	if (isIdentifier) {
		if (/^-[-\d]/.test(output)) {
			output = '\\-' + output.slice(1);
		} else if (/\d/.test(firstChar)) {
			output = '\\3' + firstChar + ' ' + output.slice(1);
		}
	}

	// Remove spaces after `\HEX` escapes that are not followed by a hex digit,
	// since they’re redundant. Note that this is only possible if the escape
	// sequence isn’t preceded by an odd number of backslashes.
	output = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {
		if ($1 && $1.length % 2) {
			// It’s not safe to remove the space, so don’t.
			return $0;
		}
		// Strip the space.
		return ($1 || '') + $2;
	});

	if (!isIdentifier && options.wrap) {
		return quote + output + quote;
	}
	return output;
};

// Expose default options (so they can be overridden globally).
cssesc.options = {
	'escapeEverything': false,
	'isIdentifier': false,
	'quotes': 'single',
	'wrap': false
};

cssesc.version = '3.0.0';

module.exports = cssesc;


/***/ }),

/***/ 38777:
/***/ ((module) => {

"use strict";


module.exports = function defined() {
	for (var i = 0; i < arguments.length; i++) {
		if (typeof arguments[i] !== 'undefined') {
			return arguments[i];
		}
	}
};


/***/ }),

/***/ 58339:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var acorn = __nccwpck_require__(30315);
var walk = __nccwpck_require__(20083);
var defined = __nccwpck_require__(38777);

var requireRe = /\brequire\b/;

function parse (src, opts) {
    if (!opts) opts = {};
    var acornOpts = {
        ranges: defined(opts.ranges, opts.range),
        locations: defined(opts.locations, opts.loc),
        allowReserved: defined(opts.allowReserved, true),
        allowImportExportEverywhere: defined(opts.allowImportExportEverywhere, false)
    };

    // Use acorn-node's defaults for the rest.
    if (opts.ecmaVersion != null) acornOpts.ecmaVersion = opts.ecmaVersion;
    if (opts.sourceType != null) acornOpts.sourceType = opts.sourceType;
    if (opts.allowHashBang != null) acornOpts.allowHashBang = opts.allowHashBang;
    if (opts.allowReturnOutsideFunction != null) acornOpts.allowReturnOutsideFunction = opts.allowReturnOutsideFunction;

    return acorn.parse(src, acornOpts);
}

var exports = module.exports = function (src, opts) {
    return exports.find(src, opts).strings;
};

exports.find = function (src, opts) {
    if (!opts) opts = {};
    
    var word = opts.word === undefined ? 'require' : opts.word;
    if (typeof src !== 'string') src = String(src);
    
    var isRequire = opts.isRequire || function (node) {
        return node.callee.type === 'Identifier'
            && node.callee.name === word
        ;
    };
    
    var modules = { strings : [], expressions : [] };
    if (opts.nodes) modules.nodes = [];
    
    var wordRe = word === 'require' ? requireRe : RegExp('\\b' + word + '\\b');
    if (!wordRe.test(src)) return modules;
    
    var ast = parse(src, opts.parse);
    
    function visit(node, st, c) {
        var hasRequire = wordRe.test(src.slice(node.start, node.end));
        if (!hasRequire) return;
        walk.base[node.type](node, st, c);
        if (node.type !== 'CallExpression') return;
        if (isRequire(node)) {
            if (node.arguments.length) {
                var arg = node.arguments[0];
                if (arg.type === 'Literal') {
                    modules.strings.push(arg.value);
                }
                else if (arg.type === 'TemplateLiteral'
                        && arg.quasis.length === 1
                        && arg.expressions.length === 0) {

                    modules.strings.push(arg.quasis[0].value.raw);
                }
                else {
                    modules.expressions.push(src.slice(arg.start, arg.end));
                }
            }
            if (opts.nodes) modules.nodes.push(node);
        }
    }
    
    walk.recursive(ast, null, {
        Statement: visit,
        Expression: visit
    });
    
    return modules;
};


/***/ }),

/***/ 15150:
/***/ ((module) => {

/*

didYouMean.js - A simple JavaScript matching engine
===================================================

[Available on GitHub](https://github.com/dcporter/didyoumean.js).

A super-simple, highly optimized JS library for matching human-quality input to a list of potential
matches. You can use it to suggest a misspelled command-line utility option to a user, or to offer
links to nearby valid URLs on your 404 page. (The examples below are taken from a personal project,
my [HTML5 business card](http://dcporter.aws.af.cm/me), which uses didYouMean.js to suggest correct
URLs from misspelled ones, such as [dcporter.aws.af.cm/me/instagarm](http://dcporter.aws.af.cm/me/instagarm).)
Uses the [Levenshtein distance algorithm](https://en.wikipedia.org/wiki/Levenshtein_distance).

didYouMean.js works in the browser as well as in node.js. To install it for use in node:

```
npm install didyoumean
```


Examples
--------

Matching against a list of strings:
```
var input = 'insargrm'
var list = ['facebook', 'twitter', 'instagram', 'linkedin'];
console.log(didYouMean(input, list));
> 'instagram'
// The method matches 'insargrm' to 'instagram'.

input = 'google plus';
console.log(didYouMean(input, list));
> null
// The method was unable to find 'google plus' in the list of options.
```

Matching against a list of objects:
```
var input = 'insargrm';
var list = [ { id: 'facebook' }, { id: 'twitter' }, { id: 'instagram' }, { id: 'linkedin' } ];
var key = 'id';
console.log(didYouMean(input, list, key));
> 'instagram'
// The method returns the matching value.

didYouMean.returnWinningObject = true;
console.log(didYouMean(input, list, key));
> { id: 'instagram' }
// The method returns the matching object.
```


didYouMean(str, list, [key])
----------------------------

- str: The string input to match.
- list: An array of strings or objects to match against.
- key (OPTIONAL): If your list array contains objects, you must specify the key which contains the string
  to match against.

Returns: the closest matching string, or null if no strings exceed the threshold.


Options
-------

Options are set on the didYouMean function object. You may change them at any time.

### threshold

  By default, the method will only return strings whose edit distance is less than 40% (0.4x) of their length.
  For example, if a ten-letter string is five edits away from its nearest match, the method will return null.

  You can control this by setting the "threshold" value on the didYouMean function. For example, to set the
  edit distance threshold to 50% of the input string's length:

  ```
  didYouMean.threshold = 0.5;
  ```

  To return the nearest match no matter the threshold, set this value to null.

### thresholdAbsolute

  This option behaves the same as threshold, but instead takes an integer number of edit steps. For example,
  if thresholdAbsolute is set to 20 (the default), then the method will only return strings whose edit distance
  is less than 20. Both options apply.

### caseSensitive

  By default, the method will perform case-insensitive comparisons. If you wish to force case sensitivity, set
  the "caseSensitive" value to true:

  ```
  didYouMean.caseSensitive = true;
  ```

### nullResultValue

  By default, the method will return null if there is no sufficiently close match. You can change this value here.

### returnWinningObject

  By default, the method will return the winning string value (if any). If your list contains objects rather
  than strings, you may set returnWinningObject to true.
  
  ```
  didYouMean.returnWinningObject = true;
  ```
  
  This option has no effect on lists of strings.

### returnFirstMatch
  
  By default, the method will search all values and return the closest match. If you're simply looking for a "good-
  enough" match, you can set your thresholds appropriately and set returnFirstMatch to true to substantially speed
  things up.


License
-------

didYouMean copyright (c) 2013-2014 Dave Porter.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License
[here](http://www.apache.org/licenses/LICENSE-2.0).

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
(function() {
  "use strict";

  // The didYouMean method.
  function didYouMean(str, list, key) {
    if (!str) return null;

    // If we're running a case-insensitive search, smallify str.
    if (!didYouMean.caseSensitive) { str = str.toLowerCase(); }

    // Calculate the initial value (the threshold) if present.
    var thresholdRelative = didYouMean.threshold === null ? null : didYouMean.threshold * str.length,
        thresholdAbsolute = didYouMean.thresholdAbsolute,
        winningVal;
    if (thresholdRelative !== null && thresholdAbsolute !== null) winningVal = Math.min(thresholdRelative, thresholdAbsolute);
    else if (thresholdRelative !== null) winningVal = thresholdRelative;
    else if (thresholdAbsolute !== null) winningVal = thresholdAbsolute;
    else winningVal = null;

    // Get the edit distance to each option. If the closest one is less than 40% (by default) of str's length,
    // then return it.
    var winner, candidate, testCandidate, val,
        i, len = list.length;
    for (i = 0; i < len; i++) {
      // Get item.
      candidate = list[i];
      // If there's a key, get the candidate value out of the object.
      if (key) { candidate = candidate[key]; }
      // Gatekeep.
      if (!candidate) { continue; }
      // If we're running a case-insensitive search, smallify the candidate.
      if (!didYouMean.caseSensitive) { testCandidate = candidate.toLowerCase(); }
      else { testCandidate = candidate; }
      // Get and compare edit distance.
      val = getEditDistance(str, testCandidate, winningVal);
      // If this value is smaller than our current winning value, OR if we have no winning val yet (i.e. the
      // threshold option is set to null, meaning the caller wants a match back no matter how bad it is), then
      // this is our new winner.
      if (winningVal === null || val < winningVal) {
        winningVal = val;
        // Set the winner to either the value or its object, depending on the returnWinningObject option.
        if (key && didYouMean.returnWinningObject) winner = list[i];
        else winner = candidate;
        // If we're returning the first match, return it now.
        if (didYouMean.returnFirstMatch) return winner;
      }
    }

    // If we have a winner, return it.
    return winner || didYouMean.nullResultValue;
  }

  // Set default options.
  didYouMean.threshold = 0.4;
  didYouMean.thresholdAbsolute = 20;
  didYouMean.caseSensitive = false;
  didYouMean.nullResultValue = null;
  didYouMean.returnWinningObject = null;
  didYouMean.returnFirstMatch = false;

  // Expose.
  // In node...
  if ( true && module.exports) {
    module.exports = didYouMean;
  }
  // Otherwise...
  else {
    window.didYouMean = didYouMean;
  }

  var MAX_INT = Math.pow(2,32) - 1; // We could probably go higher than this, but for practical reasons let's not.
  function getEditDistance(a, b, max) {
    // Handle null or undefined max.
    max = max || max === 0 ? max : MAX_INT;

    var lena = a.length;
    var lenb = b.length;

    // Fast path - no A or B.
    if (lena === 0) return Math.min(max + 1, lenb);
    if (lenb === 0) return Math.min(max + 1, lena);

    // Fast path - length diff larger than max.
    if (Math.abs(lena - lenb) > max) return max + 1;

    // Slow path.
    var matrix = [],
        i, j, colMin, minJ, maxJ;

    // Set up the first row ([0, 1, 2, 3, etc]).
    for (i = 0; i <= lenb; i++) { matrix[i] = [i]; }

    // Set up the first column (same).
    for (j = 0; j <= lena; j++) { matrix[0][j] = j; }

    // Loop over the rest of the columns.
    for (i = 1; i <= lenb; i++) {
      colMin = MAX_INT;
      minJ = 1;
      if (i > max) minJ = i - max;
      maxJ = lenb + 1;
      if (maxJ > max + i) maxJ = max + i;
      // Loop over the rest of the rows.
      for (j = 1; j <= lena; j++) {
        // If j is out of bounds, just put a large value in the slot.
        if (j < minJ || j > maxJ) {
          matrix[i][j] = max + 1;
        }

        // Otherwise do the normal Levenshtein thing.
        else {
          // If the characters are the same, there's no change in edit distance.
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          }
          // Otherwise, see if we're substituting, inserting or deleting.
          else {
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // Substitute
                                    Math.min(matrix[i][j - 1] + 1, // Insert
                                    matrix[i - 1][j] + 1)); // Delete
          }
        }

        // Either way, update colMin.
        if (matrix[i][j] < colMin) colMin = matrix[i][j];
      }

      // If this column's minimum is greater than the allowed maximum, there's no point
      // in going on with life.
      if (colMin > max) return max + 1;
    }
    // If we made it this far without running into the max, then return the final matrix value.
    return matrix[lenb][lena];
  }

})();


/***/ }),

/***/ 34420:
/***/ ((module) => {

module.exports=function(t,e,l,n,o){for(e=e.split?e.split("."):e,n=0;n<e.length;n++)t=t?t[e[n]]:o;return t===o?l:t};
//# sourceMappingURL=dlv.js.map


/***/ }),

/***/ 46719:
/***/ ((module) => {

module.exports = {
	"0.20": "39",
	"0.21": "41",
	"0.22": "41",
	"0.23": "41",
	"0.24": "41",
	"0.25": "42",
	"0.26": "42",
	"0.27": "43",
	"0.28": "43",
	"0.29": "43",
	"0.30": "44",
	"0.31": "45",
	"0.32": "45",
	"0.33": "45",
	"0.34": "45",
	"0.35": "45",
	"0.36": "47",
	"0.37": "49",
	"1.0": "49",
	"1.1": "50",
	"1.2": "51",
	"1.3": "52",
	"1.4": "53",
	"1.5": "54",
	"1.6": "56",
	"1.7": "58",
	"1.8": "59",
	"2.0": "61",
	"2.1": "61",
	"3.0": "66",
	"3.1": "66",
	"4.0": "69",
	"4.1": "69",
	"4.2": "69",
	"5.0": "73",
	"6.0": "76",
	"6.1": "76",
	"7.0": "78",
	"7.1": "78",
	"7.2": "78",
	"7.3": "78",
	"8.0": "80",
	"8.1": "80",
	"8.2": "80",
	"8.3": "80",
	"8.4": "80",
	"8.5": "80",
	"9.0": "83",
	"9.1": "83",
	"9.2": "83",
	"9.3": "83",
	"9.4": "83",
	"10.0": "85",
	"10.1": "85",
	"10.2": "85",
	"10.3": "85",
	"10.4": "85",
	"11.0": "87",
	"11.1": "87",
	"11.2": "87",
	"11.3": "87",
	"11.4": "87",
	"11.5": "87",
	"12.0": "89",
	"12.1": "89",
	"12.2": "89",
	"13.0": "91",
	"13.1": "91",
	"13.2": "91",
	"13.3": "91",
	"13.4": "91",
	"13.5": "91",
	"13.6": "91",
	"14.0": "93",
	"14.1": "93",
	"14.2": "93",
	"15.0": "94",
	"15.1": "94",
	"15.2": "94",
	"15.3": "94",
	"15.4": "94",
	"15.5": "94",
	"16.0": "96",
	"16.1": "96",
	"16.2": "96",
	"17.0": "98",
	"17.1": "98",
	"17.2": "98",
	"17.3": "98",
	"17.4": "98",
	"18.0": "100",
	"18.1": "100",
	"18.2": "100",
	"18.3": "100",
	"19.0": "102",
	"19.1": "102",
	"20.0": "104",
	"20.1": "104",
	"20.2": "104",
	"20.3": "104",
	"21.0": "106",
	"21.1": "106",
	"21.2": "106",
	"21.3": "106",
	"21.4": "106",
	"22.0": "108",
	"22.1": "108",
	"22.2": "108",
	"22.3": "108",
	"23.0": "110",
	"23.1": "110",
	"24.0": "111"
};

/***/ }),

/***/ 94070:
/***/ ((module) => {

"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */



/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

module.exports = escapeHtml;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;';
        break;
      case 38: // &
        escape = '&amp;';
        break;
      case 39: // '
        escape = '&#39;';
        break;
      case 60: // <
        escape = '&lt;';
        break;
      case 62: // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index
    ? html + str.substring(lastIndex, index)
    : html;
}


/***/ }),

/***/ 43664:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const taskManager = __nccwpck_require__(42708);
const patternManager = __nccwpck_require__(18306);
const async_1 = __nccwpck_require__(95679);
const stream_1 = __nccwpck_require__(94630);
const sync_1 = __nccwpck_require__(42405);
const settings_1 = __nccwpck_require__(10952);
const utils = __nccwpck_require__(45444);
async function FastGlob(source, options) {
    assertPatternsInput(source);
    const works = getWorks(source, async_1.default, options);
    const result = await Promise.all(works);
    return utils.array.flatten(result);
}
// https://github.com/typescript-eslint/typescript-eslint/issues/60
// eslint-disable-next-line no-redeclare
(function (FastGlob) {
    function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
    }
    FastGlob.sync = sync;
    function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        /**
         * The stream returned by the provider cannot work with an asynchronous iterator.
         * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
         * This affects performance (+25%). I don't see best solution right now.
         */
        return utils.stream.merge(works);
    }
    FastGlob.stream = stream;
    function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = patternManager.transform([].concat(source));
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
    }
    FastGlob.generateTasks = generateTasks;
    function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
    }
    FastGlob.isDynamicPattern = isDynamicPattern;
    function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
    }
    FastGlob.escapePath = escapePath;
})(FastGlob || (FastGlob = {}));
function getWorks(source, _Provider, options) {
    const patterns = patternManager.transform([].concat(source));
    const settings = new settings_1.default(options);
    const tasks = taskManager.generate(patterns, settings);
    const provider = new _Provider(settings);
    return tasks.map(provider.read, provider);
}
function assertPatternsInput(input) {
    const source = [].concat(input);
    const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
    if (!isValidSource) {
        throw new TypeError('Patterns must be a string (non empty) or an array of strings');
    }
}
module.exports = FastGlob;


/***/ }),

/***/ 18306:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeDuplicateSlashes = exports.transform = void 0;
/**
 * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.
 * The latter is due to the presence of the device path at the beginning of the UNC path.
 * @todo rewrite to negative lookbehind with the next major release.
 */
const DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
function transform(patterns) {
    return patterns.map((pattern) => removeDuplicateSlashes(pattern));
}
exports.transform = transform;
/**
 * This package only works with forward slashes as a path separator.
 * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.
 */
function removeDuplicateSlashes(pattern) {
    return pattern.replace(DOUBLE_SLASH_RE, '/');
}
exports.removeDuplicateSlashes = removeDuplicateSlashes;


/***/ }),

/***/ 42708:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;
const utils = __nccwpck_require__(45444);
function generate(patterns, settings) {
    const positivePatterns = getPositivePatterns(patterns);
    const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
    const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
    const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);
    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);
    return staticTasks.concat(dynamicTasks);
}
exports.generate = generate;
/**
 * Returns tasks grouped by basic pattern directories.
 *
 * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.
 * This is necessary because directory traversal starts at the base directory and goes deeper.
 */
function convertPatternsToTasks(positive, negative, dynamic) {
    const tasks = [];
    const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
    const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
    const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
    const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
    tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
    /*
     * For the sake of reducing future accesses to the file system, we merge all tasks within the current directory
     * into a global task, if at least one pattern refers to the root (`.`). In this case, the global task covers the rest.
     */
    if ('.' in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask('.', patternsInsideCurrentDirectory, negative, dynamic));
    }
    else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
    }
    return tasks;
}
exports.convertPatternsToTasks = convertPatternsToTasks;
function getPositivePatterns(patterns) {
    return utils.pattern.getPositivePatterns(patterns);
}
exports.getPositivePatterns = getPositivePatterns;
function getNegativePatternsAsPositive(patterns, ignore) {
    const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
    const positive = negative.map(utils.pattern.convertToPositivePattern);
    return positive;
}
exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
function groupPatternsByBaseDirectory(patterns) {
    const group = {};
    return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
            collection[base].push(pattern);
        }
        else {
            collection[base] = [pattern];
        }
        return collection;
    }, group);
}
exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
function convertPatternGroupsToTasks(positive, negative, dynamic) {
    return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
    });
}
exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
function convertPatternGroupToTask(base, positive, negative, dynamic) {
    return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
    };
}
exports.convertPatternGroupToTask = convertPatternGroupToTask;


/***/ }),

/***/ 95679:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async_1 = __nccwpck_require__(97747);
const provider_1 = __nccwpck_require__(60257);
class ProviderAsync extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new async_1.default(this._settings);
    }
    async read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = await this.api(root, task, options);
        return entries.map((entry) => options.transform(entry));
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports["default"] = ProviderAsync;


/***/ }),

/***/ 36983:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __nccwpck_require__(45444);
const partial_1 = __nccwpck_require__(35295);
class DeepFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
    }
    getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
    }
    _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
    }
    _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
            return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
            return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
            return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
    }
    _isSkippedByDeep(basePath, entryPath) {
        /**
         * Avoid unnecessary depth calculations when it doesn't matter.
         */
        if (this._settings.deep === Infinity) {
            return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
    }
    _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split('/').length;
        if (basePath === '') {
            return entryPathDepth;
        }
        const basePathDepth = basePath.split('/').length;
        return entryPathDepth - basePathDepth;
    }
    _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
    }
    _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
    }
    _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
    }
}
exports["default"] = DeepFilter;


/***/ }),

/***/ 71343:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __nccwpck_require__(45444);
class EntryFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
    }
    getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
    }
    _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
            return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
            return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
            return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isDirectory = entry.dirent.isDirectory();
        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(entry.path, negativeRe, isDirectory);
        if (this._settings.unique && isMatched) {
            this._createIndexRecord(entry);
        }
        return isMatched;
    }
    _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
    }
    _createIndexRecord(entry) {
        this.index.set(entry.path, undefined);
    }
    _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
    }
    _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }
    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
            return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
    }
    _isMatchToPatterns(entryPath, patternsRe, isDirectory) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        // Trying to match files and directories by patterns.
        const isMatched = utils.pattern.matchAny(filepath, patternsRe);
        // A pattern with a trailling slash can be used for directory matching.
        // To apply such pattern, we need to add a tralling slash to the path.
        if (!isMatched && isDirectory) {
            return utils.pattern.matchAny(filepath + '/', patternsRe);
        }
        return isMatched;
    }
}
exports["default"] = EntryFilter;


/***/ }),

/***/ 36654:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __nccwpck_require__(45444);
class ErrorFilter {
    constructor(_settings) {
        this._settings = _settings;
    }
    getFilter() {
        return (error) => this._isNonFatalError(error);
    }
    _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
    }
}
exports["default"] = ErrorFilter;


/***/ }),

/***/ 32576:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __nccwpck_require__(45444);
class Matcher {
    constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
    }
    _fillStorage() {
        /**
         * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).
         * So, before expand patterns with brace expansion into separated patterns.
         */
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
            const segments = this._getPatternSegments(pattern);
            const sections = this._splitSegmentsIntoSections(segments);
            this._storage.push({
                complete: sections.length <= 1,
                pattern,
                segments,
                sections
            });
        }
    }
    _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
            const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
            if (!dynamic) {
                return {
                    dynamic: false,
                    pattern: part
                };
            }
            return {
                dynamic: true,
                pattern: part,
                patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
            };
        });
    }
    _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
    }
}
exports["default"] = Matcher;


/***/ }),

/***/ 35295:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const matcher_1 = __nccwpck_require__(32576);
class PartialMatcher extends matcher_1.default {
    match(filepath) {
        const parts = filepath.split('/');
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
            const section = pattern.sections[0];
            /**
             * In this case, the pattern has a globstar and we must read all directories unconditionally,
             * but only if the level has reached the end of the first group.
             *
             * fixtures/{a,b}/**
             *  ^ true/false  ^ always true
            */
            if (!pattern.complete && levels > section.length) {
                return true;
            }
            const match = parts.every((part, index) => {
                const segment = pattern.segments[index];
                if (segment.dynamic && segment.patternRe.test(part)) {
                    return true;
                }
                if (!segment.dynamic && segment.pattern === part) {
                    return true;
                }
                return false;
            });
            if (match) {
                return true;
            }
        }
        return false;
    }
}
exports["default"] = PartialMatcher;


/***/ }),

/***/ 60257:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __nccwpck_require__(71017);
const deep_1 = __nccwpck_require__(36983);
const entry_1 = __nccwpck_require__(71343);
const error_1 = __nccwpck_require__(36654);
const entry_2 = __nccwpck_require__(94029);
class Provider {
    constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
    }
    _getRootDirectory(task) {
        return path.resolve(this._settings.cwd, task.base);
    }
    _getReaderOptions(task) {
        const basePath = task.base === '.' ? '' : task.base;
        return {
            basePath,
            pathSegmentSeparator: '/',
            concurrency: this._settings.concurrency,
            deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
            entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
            errorFilter: this.errorFilter.getFilter(),
            followSymbolicLinks: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            stats: this._settings.stats,
            throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
            transform: this.entryTransformer.getTransformer()
        };
    }
    _getMicromatchOptions() {
        return {
            dot: this._settings.dot,
            matchBase: this._settings.baseNameMatch,
            nobrace: !this._settings.braceExpansion,
            nocase: !this._settings.caseSensitiveMatch,
            noext: !this._settings.extglob,
            noglobstar: !this._settings.globstar,
            posix: true,
            strictSlashes: false
        };
    }
}
exports["default"] = Provider;


/***/ }),

/***/ 94630:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __nccwpck_require__(12781);
const stream_2 = __nccwpck_require__(12083);
const provider_1 = __nccwpck_require__(60257);
class ProviderStream extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => { } });
        source
            .once('error', (error) => destination.emit('error', error))
            .on('data', (entry) => destination.emit('data', options.transform(entry)))
            .once('end', () => destination.emit('end'));
        destination
            .once('close', () => source.destroy());
        return destination;
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports["default"] = ProviderStream;


/***/ }),

/***/ 42405:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sync_1 = __nccwpck_require__(76234);
const provider_1 = __nccwpck_require__(60257);
class ProviderSync extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports["default"] = ProviderSync;


/***/ }),

/***/ 94029:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __nccwpck_require__(45444);
class EntryTransformer {
    constructor(_settings) {
        this._settings = _settings;
    }
    getTransformer() {
        return (entry) => this._transform(entry);
    }
    _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
            filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
            filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
            filepath += '/';
        }
        if (!this._settings.objectMode) {
            return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
    }
}
exports["default"] = EntryTransformer;


/***/ }),

/***/ 97747:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsWalk = __nccwpck_require__(26026);
const reader_1 = __nccwpck_require__(65582);
const stream_1 = __nccwpck_require__(12083);
class ReaderAsync extends reader_1.default {
    constructor() {
        super(...arguments);
        this._walkAsync = fsWalk.walk;
        this._readerStream = new stream_1.default(this._settings);
    }
    dynamic(root, options) {
        return new Promise((resolve, reject) => {
            this._walkAsync(root, options, (error, entries) => {
                if (error === null) {
                    resolve(entries);
                }
                else {
                    reject(error);
                }
            });
        });
    }
    async static(patterns, options) {
        const entries = [];
        const stream = this._readerStream.static(patterns, options);
        // After #235, replace it with an asynchronous iterator.
        return new Promise((resolve, reject) => {
            stream.once('error', reject);
            stream.on('data', (entry) => entries.push(entry));
            stream.once('end', () => resolve(entries));
        });
    }
}
exports["default"] = ReaderAsync;


/***/ }),

/***/ 65582:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __nccwpck_require__(71017);
const fsStat = __nccwpck_require__(70109);
const utils = __nccwpck_require__(45444);
class Reader {
    constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
    }
    _getFullEntryPath(filepath) {
        return path.resolve(this._settings.cwd, filepath);
    }
    _makeEntry(stats, pattern) {
        const entry = {
            name: pattern,
            path: pattern,
            dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
            entry.stats = stats;
        }
        return entry;
    }
    _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
    }
}
exports["default"] = Reader;


/***/ }),

/***/ 12083:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __nccwpck_require__(12781);
const fsStat = __nccwpck_require__(70109);
const fsWalk = __nccwpck_require__(26026);
const reader_1 = __nccwpck_require__(65582);
class ReaderStream extends reader_1.default {
    constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
    }
    dynamic(root, options) {
        return this._walkStream(root, options);
    }
    static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
            return this._getEntry(filepaths[index], patterns[index], options)
                .then((entry) => {
                if (entry !== null && options.entryFilter(entry)) {
                    stream.push(entry);
                }
                if (index === filepaths.length - 1) {
                    stream.end();
                }
                done();
            })
                .catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
            stream.write(i);
        }
        return stream;
    }
    _getEntry(filepath, pattern, options) {
        return this._getStat(filepath)
            .then((stats) => this._makeEntry(stats, pattern))
            .catch((error) => {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        });
    }
    _getStat(filepath) {
        return new Promise((resolve, reject) => {
            this._stat(filepath, this._fsStatSettings, (error, stats) => {
                return error === null ? resolve(stats) : reject(error);
            });
        });
    }
}
exports["default"] = ReaderStream;


/***/ }),

/***/ 76234:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsStat = __nccwpck_require__(70109);
const fsWalk = __nccwpck_require__(26026);
const reader_1 = __nccwpck_require__(65582);
class ReaderSync extends reader_1.default {
    constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
    }
    dynamic(root, options) {
        return this._walkSync(root, options);
    }
    static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
            const filepath = this._getFullEntryPath(pattern);
            const entry = this._getEntry(filepath, pattern, options);
            if (entry === null || !options.entryFilter(entry)) {
                continue;
            }
            entries.push(entry);
        }
        return entries;
    }
    _getEntry(filepath, pattern, options) {
        try {
            const stats = this._getStat(filepath);
            return this._makeEntry(stats, pattern);
        }
        catch (error) {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        }
    }
    _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
    }
}
exports["default"] = ReaderSync;


/***/ }),

/***/ 10952:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
const fs = __nccwpck_require__(57147);
const os = __nccwpck_require__(22037);
/**
 * The `os.cpus` method can return zero. We expect the number of cores to be greater than zero.
 * https://github.com/nodejs/node/blob/7faeddf23a98c53896f8b574a6e66589e8fb1eb8/lib/os.js#L106-L107
 */
const CPU_COUNT = Math.max(os.cpus().length, 1);
exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    lstatSync: fs.lstatSync,
    stat: fs.stat,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
            this.onlyFiles = false;
        }
        if (this.stats) {
            this.objectMode = true;
        }
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
    _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }
}
exports["default"] = Settings;


/***/ }),

/***/ 85325:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.splitWhen = exports.flatten = void 0;
function flatten(items) {
    return items.reduce((collection, item) => [].concat(collection, item), []);
}
exports.flatten = flatten;
function splitWhen(items, predicate) {
    const result = [[]];
    let groupIndex = 0;
    for (const item of items) {
        if (predicate(item)) {
            groupIndex++;
            result[groupIndex] = [];
        }
        else {
            result[groupIndex].push(item);
        }
    }
    return result;
}
exports.splitWhen = splitWhen;


/***/ }),

/***/ 41230:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isEnoentCodeError = void 0;
function isEnoentCodeError(error) {
    return error.code === 'ENOENT';
}
exports.isEnoentCodeError = isEnoentCodeError;


/***/ }),

/***/ 17543:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDirentFromStats = void 0;
class DirentFromStats {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
exports.createDirentFromStats = createDirentFromStats;


/***/ }),

/***/ 45444:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;
const array = __nccwpck_require__(85325);
exports.array = array;
const errno = __nccwpck_require__(41230);
exports.errno = errno;
const fs = __nccwpck_require__(17543);
exports.fs = fs;
const path = __nccwpck_require__(63873);
exports.path = path;
const pattern = __nccwpck_require__(81221);
exports.pattern = pattern;
const stream = __nccwpck_require__(18382);
exports.stream = stream;
const string = __nccwpck_require__(52203);
exports.string = string;


/***/ }),

/***/ 63873:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeLeadingDotSegment = exports.escape = exports.makeAbsolute = exports.unixify = void 0;
const path = __nccwpck_require__(71017);
const LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\
const UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
/**
 * Designed to work only with simple paths: `dir\\file`.
 */
function unixify(filepath) {
    return filepath.replace(/\\/g, '/');
}
exports.unixify = unixify;
function makeAbsolute(cwd, filepath) {
    return path.resolve(cwd, filepath);
}
exports.makeAbsolute = makeAbsolute;
function escape(pattern) {
    return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
}
exports.escape = escape;
function removeLeadingDotSegment(entry) {
    // We do not use `startsWith` because this is 10x slower than current implementation for some cases.
    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
    if (entry.charAt(0) === '.') {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === '/' || secondCharactery === '\\') {
            return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
    }
    return entry;
}
exports.removeLeadingDotSegment = removeLeadingDotSegment;


/***/ }),

/***/ 81221:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;
const path = __nccwpck_require__(71017);
const globParent = __nccwpck_require__(54655);
const micromatch = __nccwpck_require__(76228);
const GLOBSTAR = '**';
const ESCAPE_SYMBOL = '\\';
const COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
const REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
const REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
const GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
const BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
function isStaticPattern(pattern, options = {}) {
    return !isDynamicPattern(pattern, options);
}
exports.isStaticPattern = isStaticPattern;
function isDynamicPattern(pattern, options = {}) {
    /**
     * A special case with an empty string is necessary for matching patterns that start with a forward slash.
     * An empty string cannot be a dynamic pattern.
     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.
     */
    if (pattern === '') {
        return false;
    }
    /**
     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check
     * filepath directly (without read directory).
     */
    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
    }
    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
    }
    return false;
}
exports.isDynamicPattern = isDynamicPattern;
function hasBraceExpansion(pattern) {
    const openingBraceIndex = pattern.indexOf('{');
    if (openingBraceIndex === -1) {
        return false;
    }
    const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);
    if (closingBraceIndex === -1) {
        return false;
    }
    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
}
function convertToPositivePattern(pattern) {
    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
}
exports.convertToPositivePattern = convertToPositivePattern;
function convertToNegativePattern(pattern) {
    return '!' + pattern;
}
exports.convertToNegativePattern = convertToNegativePattern;
function isNegativePattern(pattern) {
    return pattern.startsWith('!') && pattern[1] !== '(';
}
exports.isNegativePattern = isNegativePattern;
function isPositivePattern(pattern) {
    return !isNegativePattern(pattern);
}
exports.isPositivePattern = isPositivePattern;
function getNegativePatterns(patterns) {
    return patterns.filter(isNegativePattern);
}
exports.getNegativePatterns = getNegativePatterns;
function getPositivePatterns(patterns) {
    return patterns.filter(isPositivePattern);
}
exports.getPositivePatterns = getPositivePatterns;
/**
 * Returns patterns that can be applied inside the current directory.
 *
 * @example
 * // ['./*', '*', 'a/*']
 * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
 */
function getPatternsInsideCurrentDirectory(patterns) {
    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
}
exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
/**
 * Returns patterns to be expanded relative to (outside) the current directory.
 *
 * @example
 * // ['../*', './../*']
 * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
 */
function getPatternsOutsideCurrentDirectory(patterns) {
    return patterns.filter(isPatternRelatedToParentDirectory);
}
exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
function isPatternRelatedToParentDirectory(pattern) {
    return pattern.startsWith('..') || pattern.startsWith('./..');
}
exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
function getBaseDirectory(pattern) {
    return globParent(pattern, { flipBackslashes: false });
}
exports.getBaseDirectory = getBaseDirectory;
function hasGlobStar(pattern) {
    return pattern.includes(GLOBSTAR);
}
exports.hasGlobStar = hasGlobStar;
function endsWithSlashGlobStar(pattern) {
    return pattern.endsWith('/' + GLOBSTAR);
}
exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
function isAffectDepthOfReadingPattern(pattern) {
    const basename = path.basename(pattern);
    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
}
exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
function expandPatternsWithBraceExpansion(patterns) {
    return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
    }, []);
}
exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
function expandBraceExpansion(pattern) {
    return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
    });
}
exports.expandBraceExpansion = expandBraceExpansion;
function getPatternParts(pattern, options) {
    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
    /**
     * The scan method returns an empty array in some cases.
     * See micromatch/picomatch#58 for more details.
     */
    if (parts.length === 0) {
        parts = [pattern];
    }
    /**
     * The scan method does not return an empty part for the pattern with a forward slash.
     * This is another part of micromatch/picomatch#58.
     */
    if (parts[0].startsWith('/')) {
        parts[0] = parts[0].slice(1);
        parts.unshift('');
    }
    return parts;
}
exports.getPatternParts = getPatternParts;
function makeRe(pattern, options) {
    return micromatch.makeRe(pattern, options);
}
exports.makeRe = makeRe;
function convertPatternsToRe(patterns, options) {
    return patterns.map((pattern) => makeRe(pattern, options));
}
exports.convertPatternsToRe = convertPatternsToRe;
function matchAny(entry, patternsRe) {
    return patternsRe.some((patternRe) => patternRe.test(entry));
}
exports.matchAny = matchAny;


/***/ }),

/***/ 18382:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.merge = void 0;
const merge2 = __nccwpck_require__(82578);
function merge(streams) {
    const mergedStream = merge2(streams);
    streams.forEach((stream) => {
        stream.once('error', (error) => mergedStream.emit('error', error));
    });
    mergedStream.once('close', () => propagateCloseEventToSources(streams));
    mergedStream.once('end', () => propagateCloseEventToSources(streams));
    return mergedStream;
}
exports.merge = merge;
function propagateCloseEventToSources(streams) {
    streams.forEach((stream) => stream.emit('close'));
}


/***/ }),

/***/ 52203:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isEmpty = exports.isString = void 0;
function isString(input) {
    return typeof input === 'string';
}
exports.isString = isString;
function isEmpty(input) {
    return input === '';
}
exports.isEmpty = isEmpty;


/***/ }),

/***/ 7340:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


/* eslint-disable no-var */

var reusify = __nccwpck_require__(32113)

function fastqueue (context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker
    worker = context
    context = null
  }

  if (concurrency < 1) {
    throw new Error('fastqueue concurrency must be greater than 1')
  }

  var cache = reusify(Task)
  var queueHead = null
  var queueTail = null
  var _running = 0
  var errorHandler = null

  var self = {
    push: push,
    drain: noop,
    saturated: noop,
    pause: pause,
    paused: false,
    concurrency: concurrency,
    running: running,
    resume: resume,
    idle: idle,
    length: length,
    getQueue: getQueue,
    unshift: unshift,
    empty: noop,
    kill: kill,
    killAndDrain: killAndDrain,
    error: error
  }

  return self

  function running () {
    return _running
  }

  function pause () {
    self.paused = true
  }

  function length () {
    var current = queueHead
    var counter = 0

    while (current) {
      current = current.next
      counter++
    }

    return counter
  }

  function getQueue () {
    var current = queueHead
    var tasks = []

    while (current) {
      tasks.push(current.value)
      current = current.next
    }

    return tasks
  }

  function resume () {
    if (!self.paused) return
    self.paused = false
    for (var i = 0; i < self.concurrency; i++) {
      _running++
      release()
    }
  }

  function idle () {
    return _running === 0 && self.length() === 0
  }

  function push (value, done) {
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop
    current.errorHandler = errorHandler

    if (_running === self.concurrency || self.paused) {
      if (queueTail) {
        queueTail.next = current
        queueTail = current
      } else {
        queueHead = current
        queueTail = current
        self.saturated()
      }
    } else {
      _running++
      worker.call(context, current.value, current.worked)
    }
  }

  function unshift (value, done) {
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop

    if (_running === self.concurrency || self.paused) {
      if (queueHead) {
        current.next = queueHead
        queueHead = current
      } else {
        queueHead = current
        queueTail = current
        self.saturated()
      }
    } else {
      _running++
      worker.call(context, current.value, current.worked)
    }
  }

  function release (holder) {
    if (holder) {
      cache.release(holder)
    }
    var next = queueHead
    if (next) {
      if (!self.paused) {
        if (queueTail === queueHead) {
          queueTail = null
        }
        queueHead = next.next
        next.next = null
        worker.call(context, next.value, next.worked)
        if (queueTail === null) {
          self.empty()
        }
      } else {
        _running--
      }
    } else if (--_running === 0) {
      self.drain()
    }
  }

  function kill () {
    queueHead = null
    queueTail = null
    self.drain = noop
  }

  function killAndDrain () {
    queueHead = null
    queueTail = null
    self.drain()
    self.drain = noop
  }

  function error (handler) {
    errorHandler = handler
  }
}

function noop () {}

function Task () {
  this.value = null
  this.callback = noop
  this.next = null
  this.release = noop
  this.context = null
  this.errorHandler = null

  var self = this

  this.worked = function worked (err, result) {
    var callback = self.callback
    var errorHandler = self.errorHandler
    var val = self.value
    self.value = null
    self.callback = noop
    if (self.errorHandler) {
      errorHandler(err, val)
    }
    callback.call(self.context, err, result)
    self.release(self)
  }
}

function queueAsPromised (context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker
    worker = context
    context = null
  }

  function asyncWrapper (arg, cb) {
    worker.call(this, arg)
      .then(function (res) {
        cb(null, res)
      }, cb)
  }

  var queue = fastqueue(context, asyncWrapper, concurrency)

  var pushCb = queue.push
  var unshiftCb = queue.unshift

  queue.push = push
  queue.unshift = unshift
  queue.drained = drained

  return queue

  function push (value) {
    var p = new Promise(function (resolve, reject) {
      pushCb(value, function (err, result) {
        if (err) {
          reject(err)
          return
        }
        resolve(result)
      })
    })

    // Let's fork the promise chain to
    // make the error bubble up to the user but
    // not lead to a unhandledRejection
    p.catch(noop)

    return p
  }

  function unshift (value) {
    var p = new Promise(function (resolve, reject) {
      unshiftCb(value, function (err, result) {
        if (err) {
          reject(err)
          return
        }
        resolve(result)
      })
    })

    // Let's fork the promise chain to
    // make the error bubble up to the user but
    // not lead to a unhandledRejection
    p.catch(noop)

    return p
  }

  function drained () {
    if (queue.idle()) {
      return new Promise(function (resolve) {
        resolve()
      })
    }

    var previousDrain = queue.drain

    var p = new Promise(function (resolve) {
      queue.drain = function () {
        previousDrain()
        resolve()
      }
    })

    return p
  }
}

module.exports = fastqueue
module.exports.promise = queueAsPromised


/***/ }),

/***/ 6330:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */



const util = __nccwpck_require__(73837);
const toRegexRange = __nccwpck_require__(1861);

const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

const transform = toNumber => {
  return value => toNumber === true ? Number(value) : String(value);
};

const isValidValue = value => {
  return typeof value === 'number' || (typeof value === 'string' && value !== '');
};

const isNumber = num => Number.isInteger(+num);

const zeros = input => {
  let value = `${input}`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;
  while (value[++index] === '0');
  return index > 0;
};

const stringify = (start, end, options) => {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }
  return options.stringify === true;
};

const pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
  }
  if (toNumber === false) {
    return String(input);
  }
  return input;
};

const toMaxLen = (input, maxLength) => {
  let negative = input[0] === '-' ? '-' : '';
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length < maxLength) input = '0' + input;
  return negative ? ('-' + input) : input;
};

const toSequence = (parts, options) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);

  let prefix = options.capture ? '' : '?:';
  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) {
    positives = parts.positives.join('|');
  }

  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.join('|')})`;
  }

  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return `(${prefix}${result})`;
  }

  return result;
};

const toRange = (a, b, isNumbers, options) => {
  if (isNumbers) {
    return toRegexRange(a, b, { wrap: false, ...options });
  }

  let start = String.fromCharCode(a);
  if (a === b) return start;

  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const toRegex = (start, end, options) => {
  if (Array.isArray(start)) {
    let wrap = options.wrap === true;
    let prefix = options.capture ? '' : '?:';
    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
  }
  return toRegexRange(start, end, options);
};

const rangeError = (...args) => {
  return new RangeError('Invalid range arguments: ' + util.inspect(...args));
};

const invalidRange = (start, end, options) => {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

const invalidStep = (step, options) => {
  if (options.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};

const fillNumbers = (start, end, step = 1, options = {}) => {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  }

  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;

  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);

  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify(start, end, options) === false;
  let format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  let parts = { negatives: [], positives: [] };
  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step > 1
      ? toSequence(parts, options)
      : toRegex(range, null, { wrap: false, ...options });
  }

  return range;
};

const fillLetters = (start, end, step = 1, options = {}) => {
  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {
    return invalidRange(start, end, options);
  }


  let format = options.transform || (val => String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);

  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex && step === 1) {
    return toRange(min, max, false, options);
  }

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, { wrap: false, options });
  }

  return range;
};

const fill = (start, end, step, options = {}) => {
  if (end == null && isValidValue(start)) {
    return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    return fill(start, end, 1, { transform: step });
  }

  if (isObject(step)) {
    return fill(start, end, 0, step);
  }

  let opts = { ...options };
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null && !isObject(step)) return invalidStep(step, opts);
    return fill(start, end, 1, step);
  }

  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

module.exports = fill;


/***/ }),

/***/ 85729:
/***/ (function(module) {

/**
 * @license Fraction.js v4.2.0 05/03/2022
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/


/**
 *
 * This class offers the possibility to calculate fractions.
 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
 *
 * Array/Object form
 * [ 0 => <nominator>, 1 => <denominator> ]
 * [ n => <nominator>, d => <denominator> ]
 *
 * Integer form
 * - Single integer value
 *
 * Double form
 * - Single double value
 *
 * String form
 * 123.456 - a simple double
 * 123/456 - a string fraction
 * 123.'456' - a double with repeating decimal places
 * 123.(456) - synonym
 * 123.45'6' - a double with repeating last place
 * 123.45(6) - synonym
 *
 * Example:
 *
 * var f = new Fraction("9.4'31'");
 * f.mul([-4, 3]).div(4.9);
 *
 */

(function(root) {

  "use strict";

  // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
  // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
  // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
  var MAX_CYCLE_LEN = 2000;

  // Parsed data to avoid calling "new" all the time
  var P = {
    "s": 1,
    "n": 0,
    "d": 1
  };

  function assign(n, s) {

    if (isNaN(n = parseInt(n, 10))) {
      throw Fraction['InvalidParameter'];
    }
    return n * s;
  }

  // Creates a new Fraction internally without the need of the bulky constructor
  function newFraction(n, d) {

    if (d === 0) {
      throw Fraction['DivisionByZero'];
    }

    var f = Object.create(Fraction.prototype);
    f["s"] = n < 0 ? -1 : 1;

    n = n < 0 ? -n : n;

    var a = gcd(n, d);

    f["n"] = n / a;
    f["d"] = d / a;
    return f;
  }

  function factorize(num) {

    var factors = {};

    var n = num;
    var i = 2;
    var s = 4;

    while (s <= n) {

      while (n % i === 0) {
        n/= i;
        factors[i] = (factors[i] || 0) + 1;
      }
      s+= 1 + 2 * i++;
    }

    if (n !== num) {
      if (n > 1)
        factors[n] = (factors[n] || 0) + 1;
    } else {
      factors[num] = (factors[num] || 0) + 1;
    }
    return factors;
  }

  var parse = function(p1, p2) {

    var n = 0, d = 1, s = 1;
    var v = 0, w = 0, x = 0, y = 1, z = 1;

    var A = 0, B = 1;
    var C = 1, D = 1;

    var N = 10000000;
    var M;

    if (p1 === undefined || p1 === null) {
      /* void */
    } else if (p2 !== undefined) {
      n = p1;
      d = p2;
      s = n * d;

      if (n % 1 !== 0 || d % 1 !== 0) {
        throw Fraction['NonIntegerParameter'];
      }

    } else
      switch (typeof p1) {

        case "object":
          {
            if ("d" in p1 && "n" in p1) {
              n = p1["n"];
              d = p1["d"];
              if ("s" in p1)
                n*= p1["s"];
            } else if (0 in p1) {
              n = p1[0];
              if (1 in p1)
                d = p1[1];
            } else {
              throw Fraction['InvalidParameter'];
            }
            s = n * d;
            break;
          }
        case "number":
          {
            if (p1 < 0) {
              s = p1;
              p1 = -p1;
            }

            if (p1 % 1 === 0) {
              n = p1;
            } else if (p1 > 0) { // check for != 0, scale would become NaN (log(0)), which converges really slow

              if (p1 >= 1) {
                z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                p1/= z;
              }

              // Using Farey Sequences
              // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/

              while (B <= N && D <= N) {
                M = (A + C) / (B + D);

                if (p1 === M) {
                  if (B + D <= N) {
                    n = A + C;
                    d = B + D;
                  } else if (D > B) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                  break;

                } else {

                  if (p1 > M) {
                    A+= C;
                    B+= D;
                  } else {
                    C+= A;
                    D+= B;
                  }

                  if (B > N) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                }
              }
              n*= z;
            } else if (isNaN(p1) || isNaN(p2)) {
              d = n = NaN;
            }
            break;
          }
        case "string":
          {
            B = p1.match(/\d+|./g);

            if (B === null)
              throw Fraction['InvalidParameter'];

            if (B[A] === '-') {// Check for minus sign at the beginning
              s = -1;
              A++;
            } else if (B[A] === '+') {// Check for plus sign at the beginning
              A++;
            }

            if (B.length === A + 1) { // Check if it's just a simple number "1234"
              w = assign(B[A++], s);
            } else if (B[A + 1] === '.' || B[A] === '.') { // Check if it's a decimal number

              if (B[A] !== '.') { // Handle 0.5 and .5
                v = assign(B[A++], s);
              }
              A++;

              // Check for decimal places
              if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
                w = assign(B[A], s);
                y = Math.pow(10, B[A].length);
                A++;
              }

              // Check for repeating places
              if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
                x = assign(B[A + 1], s);
                z = Math.pow(10, B[A + 1].length) - 1;
                A+= 3;
              }

            } else if (B[A + 1] === '/' || B[A + 1] === ':') { // Check for a simple fraction "123/456" or "123:456"
              w = assign(B[A], s);
              y = assign(B[A + 2], 1);
              A+= 3;
            } else if (B[A + 3] === '/' && B[A + 1] === ' ') { // Check for a complex fraction "123 1/2"
              v = assign(B[A], s);
              w = assign(B[A + 2], s);
              y = assign(B[A + 4], 1);
              A+= 5;
            }

            if (B.length <= A) { // Check for more tokens on the stack
              d = y * z;
              s = /* void */
              n = x + d * v + z * w;
              break;
            }

            /* Fall through on error */
          }
        default:
          throw Fraction['InvalidParameter'];
      }

    if (d === 0) {
      throw Fraction['DivisionByZero'];
    }

    P["s"] = s < 0 ? -1 : 1;
    P["n"] = Math.abs(n);
    P["d"] = Math.abs(d);
  };

  function modpow(b, e, m) {

    var r = 1;
    for (; e > 0; b = (b * b) % m, e >>= 1) {

      if (e & 1) {
        r = (r * b) % m;
      }
    }
    return r;
  }


  function cycleLen(n, d) {

    for (; d % 2 === 0;
      d/= 2) {
    }

    for (; d % 5 === 0;
      d/= 5) {
    }

    if (d === 1) // Catch non-cyclic numbers
      return 0;

    // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
    // 10^(d-1) % d == 1
    // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
    // as we want to translate the numbers to strings.

    var rem = 10 % d;
    var t = 1;

    for (; rem !== 1; t++) {
      rem = rem * 10 % d;

      if (t > MAX_CYCLE_LEN)
        return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
    }
    return t;
  }


  function cycleStart(n, d, len) {

    var rem1 = 1;
    var rem2 = modpow(10, len, d);

    for (var t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)
      // Solve 10^s == 10^(s+t) (mod d)

      if (rem1 === rem2)
        return t;

      rem1 = rem1 * 10 % d;
      rem2 = rem2 * 10 % d;
    }
    return 0;
  }

  function gcd(a, b) {

    if (!a)
      return b;
    if (!b)
      return a;

    while (1) {
      a%= b;
      if (!a)
        return b;
      b%= a;
      if (!b)
        return a;
    }
  };

  /**
   * Module constructor
   *
   * @constructor
   * @param {number|Fraction=} a
   * @param {number=} b
   */
  function Fraction(a, b) {

    parse(a, b);

    if (this instanceof Fraction) {
      a = gcd(P["d"], P["n"]); // Abuse variable a
      this["s"] = P["s"];
      this["n"] = P["n"] / a;
      this["d"] = P["d"] / a;
    } else {
      return newFraction(P['s'] * P['n'], P['d']);
    }
  }

  Fraction['DivisionByZero'] = new Error("Division by Zero");
  Fraction['InvalidParameter'] = new Error("Invalid argument");
  Fraction['NonIntegerParameter'] = new Error("Parameters must be integer");

  Fraction.prototype = {

    "s": 1,
    "n": 0,
    "d": 1,

    /**
     * Calculates the absolute value
     *
     * Ex: new Fraction(-4).abs() => 4
     **/
    "abs": function() {

      return newFraction(this["n"], this["d"]);
    },

    /**
     * Inverts the sign of the current fraction
     *
     * Ex: new Fraction(-4).neg() => 4
     **/
    "neg": function() {

      return newFraction(-this["s"] * this["n"], this["d"]);
    },

    /**
     * Adds two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
     **/
    "add": function(a, b) {

      parse(a, b);
      return newFraction(
        this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
        this["d"] * P["d"]
      );
    },

    /**
     * Subtracts two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
     **/
    "sub": function(a, b) {

      parse(a, b);
      return newFraction(
        this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
        this["d"] * P["d"]
      );
    },

    /**
     * Multiplies two rational numbers
     *
     * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
     **/
    "mul": function(a, b) {

      parse(a, b);
      return newFraction(
        this["s"] * P["s"] * this["n"] * P["n"],
        this["d"] * P["d"]
      );
    },

    /**
     * Divides two rational numbers
     *
     * Ex: new Fraction("-17.(345)").inverse().div(3)
     **/
    "div": function(a, b) {

      parse(a, b);
      return newFraction(
        this["s"] * P["s"] * this["n"] * P["d"],
        this["d"] * P["n"]
      );
    },

    /**
     * Clones the actual object
     *
     * Ex: new Fraction("-17.(345)").clone()
     **/
    "clone": function() {
      return newFraction(this['s'] * this['n'], this['d']);
    },

    /**
     * Calculates the modulo of two rational numbers - a more precise fmod
     *
     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
     **/
    "mod": function(a, b) {

      if (isNaN(this['n']) || isNaN(this['d'])) {
        return new Fraction(NaN);
      }

      if (a === undefined) {
        return newFraction(this["s"] * this["n"] % this["d"], 1);
      }

      parse(a, b);
      if (0 === P["n"] && 0 === this["d"]) {
        throw Fraction['DivisionByZero'];
      }

      /*
       * First silly attempt, kinda slow
       *
       return that["sub"]({
       "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
       "d": num["d"],
       "s": this["s"]
       });*/

      /*
       * New attempt: a1 / b1 = a2 / b2 * q + r
       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
       * => (b2 * a1 % a2 * b1) / (b1 * b2)
       */
      return newFraction(
        this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
        P["d"] * this["d"]
      );
    },

    /**
     * Calculates the fractional gcd of two rational numbers
     *
     * Ex: new Fraction(5,8).gcd(3,7) => 1/56
     */
    "gcd": function(a, b) {

      parse(a, b);

      // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

      return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
    },

    /**
     * Calculates the fractional lcm of two rational numbers
     *
     * Ex: new Fraction(5,8).lcm(3,7) => 15
     */
    "lcm": function(a, b) {

      parse(a, b);

      // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

      if (P["n"] === 0 && this["n"] === 0) {
        return newFraction(0, 1);
      }
      return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
    },

    /**
     * Calculates the ceil of a rational number
     *
     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
     **/
    "ceil": function(places) {

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) {
        return new Fraction(NaN);
      }
      return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
    },

    /**
     * Calculates the floor of a rational number
     *
     * Ex: new Fraction('4.(3)').floor() => (4 / 1)
     **/
    "floor": function(places) {

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) {
        return new Fraction(NaN);
      }
      return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
    },

    /**
     * Rounds a rational numbers
     *
     * Ex: new Fraction('4.(3)').round() => (4 / 1)
     **/
    "round": function(places) {

      places = Math.pow(10, places || 0);

      if (isNaN(this["n"]) || isNaN(this["d"])) {
        return new Fraction(NaN);
      }
      return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
    },

    /**
     * Gets the inverse of the fraction, means numerator and denominator are exchanged
     *
     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
     **/
    "inverse": function() {

      return newFraction(this["s"] * this["d"], this["n"]);
    },

    /**
     * Calculates the fraction to some rational exponent, if possible
     *
     * Ex: new Fraction(-1,2).pow(-3) => -8
     */
    "pow": function(a, b) {

      parse(a, b);

      // Trivial case when exp is an integer

      if (P['d'] === 1) {

        if (P['s'] < 0) {
          return newFraction(Math.pow(this['s'] * this["d"], P['n']), Math.pow(this["n"], P['n']));
        } else {
          return newFraction(Math.pow(this['s'] * this["n"], P['n']), Math.pow(this["d"], P['n']));
        }
      }

      // Negative roots become complex
      //     (-a/b)^(c/d) = x
      // <=> (-1)^(c/d) * (a/b)^(c/d) = x
      // <=> (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180°
      // <=> (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )
      // From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.
      if (this['s'] < 0) return null;

      // Now prime factor n and d
      var N = factorize(this['n']);
      var D = factorize(this['d']);

      // Exponentiate and take root for n and d individually
      var n = 1;
      var d = 1;
      for (var k in N) {
        if (k === '1') continue;
        if (k === '0') {
          n = 0;
          break;
        }
        N[k]*= P['n'];

        if (N[k] % P['d'] === 0) {
          N[k]/= P['d'];
        } else return null;
        n*= Math.pow(k, N[k]);
      }

      for (var k in D) {
        if (k === '1') continue;
        D[k]*= P['n'];

        if (D[k] % P['d'] === 0) {
          D[k]/= P['d'];
        } else return null;
        d*= Math.pow(k, D[k]);
      }

      if (P['s'] < 0) {
        return newFraction(d, n);
      }
      return newFraction(n, d);
    },

    /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/
    "equals": function(a, b) {

      parse(a, b);
      return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
    },

    /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/
    "compare": function(a, b) {

      parse(a, b);
      var t = (this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"]);
      return (0 < t) - (t < 0);
    },

    "simplify": function(eps) {

      if (isNaN(this['n']) || isNaN(this['d'])) {
        return this;
      }

      eps = eps || 0.001;

      var thisABS = this['abs']();
      var cont = thisABS['toContinued']();

      for (var i = 1; i < cont.length; i++) {

        var s = newFraction(cont[i - 1], 1);
        for (var k = i - 2; k >= 0; k--) {
          s = s['inverse']()['add'](cont[k]);
        }

        if (s['sub'](thisABS)['abs']().valueOf() < eps) {
          return s['mul'](this['s']);
        }
      }
      return this;
    },

    /**
     * Check if two rational numbers are divisible
     *
     * Ex: new Fraction(19.6).divisible(1.5);
     */
    "divisible": function(a, b) {

      parse(a, b);
      return !(!(P["n"] * this["d"]) || ((this["n"] * P["d"]) % (P["n"] * this["d"])));
    },

    /**
     * Returns a decimal representation of the fraction
     *
     * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
     **/
    'valueOf': function() {

      return this["s"] * this["n"] / this["d"];
    },

    /**
     * Returns a string-fraction representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
     **/
    'toFraction': function(excludeWhole) {

      var whole, str = "";
      var n = this["n"];
      var d = this["d"];
      if (this["s"] < 0) {
        str+= '-';
      }

      if (d === 1) {
        str+= n;
      } else {

        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
          str+= whole;
          str+= " ";
          n%= d;
        }

        str+= n;
        str+= '/';
        str+= d;
      }
      return str;
    },

    /**
     * Returns a latex representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
     **/
    'toLatex': function(excludeWhole) {

      var whole, str = "";
      var n = this["n"];
      var d = this["d"];
      if (this["s"] < 0) {
        str+= '-';
      }

      if (d === 1) {
        str+= n;
      } else {

        if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
          str+= whole;
          n%= d;
        }

        str+= "\\frac{";
        str+= n;
        str+= '}{';
        str+= d;
        str+= '}';
      }
      return str;
    },

    /**
     * Returns an array of continued fraction elements
     *
     * Ex: new Fraction("7/8").toContinued() => [0,1,7]
     */
    'toContinued': function() {

      var t;
      var a = this['n'];
      var b = this['d'];
      var res = [];

      if (isNaN(a) || isNaN(b)) {
        return res;
      }

      do {
        res.push(Math.floor(a / b));
        t = a % b;
        a = b;
        b = t;
      } while (a !== 1);

      return res;
    },

    /**
     * Creates a string representation of a fraction with all digits
     *
     * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
     **/
    'toString': function(dec) {

      var N = this["n"];
      var D = this["d"];

      if (isNaN(N) || isNaN(D)) {
        return "NaN";
      }

      dec = dec || 15; // 15 = decimal places when no repetation

      var cycLen = cycleLen(N, D); // Cycle length
      var cycOff = cycleStart(N, D, cycLen); // Cycle start

      var str = this['s'] < 0 ? "-" : "";

      str+= N / D | 0;

      N%= D;
      N*= 10;

      if (N)
        str+= ".";

      if (cycLen) {

        for (var i = cycOff; i--;) {
          str+= N / D | 0;
          N%= D;
          N*= 10;
        }
        str+= "(";
        for (var i = cycLen; i--;) {
          str+= N / D | 0;
          N%= D;
          N*= 10;
        }
        str+= ")";
      } else {
        for (var i = dec; N && i--;) {
          str+= N / D | 0;
          N%= D;
          N*= 10;
        }
      }
      return str;
    }
  };

  if (typeof define === "function" && define["amd"]) {
    define([], function() {
      return Fraction;
    });
  } else if (true) {
    Object.defineProperty(Fraction, "__esModule", { 'value': true });
    Fraction['default'] = Fraction;
    Fraction['Fraction'] = Fraction;
    module['exports'] = Fraction;
  } else {}

})(this);


/***/ }),

/***/ 19320:
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ 88334:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var implementation = __nccwpck_require__(19320);

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ 54655:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var isGlob = __nccwpck_require__(34466);
var pathPosixDirname = (__nccwpck_require__(71017).posix.dirname);
var isWin32 = (__nccwpck_require__(22037).platform)() === 'win32';

var slash = '/';
var backslash = /\\/g;
var enclosure = /[\{\[].*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;

/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 * @returns {string}
 */
module.exports = function globParent(str, opts) {
  var options = Object.assign({ flipBackslashes: true }, opts);

  // flip windows path separators
  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
    str = str.replace(backslash, slash);
  }

  // special case for strings ending in enclosure containing path separator
  if (enclosure.test(str)) {
    str += slash;
  }

  // preserves full path in case of trailing path separator
  str += 'a';

  // remove path parts that are globby
  do {
    str = pathPosixDirname(str);
  } while (isGlob(str) || globby.test(str));

  // remove escape chars and return result
  return str.replace(escaped, '$1');
};


/***/ }),

/***/ 76339:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var bind = __nccwpck_require__(88334);

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ 56873:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var has = __nccwpck_require__(76339);

function specifierIncluded(current, specifier) {
	var nodeParts = current.split('.');
	var parts = specifier.split(' ');
	var op = parts.length > 1 ? parts[0] : '=';
	var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

	for (var i = 0; i < 3; ++i) {
		var cur = parseInt(nodeParts[i] || 0, 10);
		var ver = parseInt(versionParts[i] || 0, 10);
		if (cur === ver) {
			continue; // eslint-disable-line no-restricted-syntax, no-continue
		}
		if (op === '<') {
			return cur < ver;
		}
		if (op === '>=') {
			return cur >= ver;
		}
		return false;
	}
	return op === '>=';
}

function matchesRange(current, range) {
	var specifiers = range.split(/ ?&& ?/);
	if (specifiers.length === 0) {
		return false;
	}
	for (var i = 0; i < specifiers.length; ++i) {
		if (!specifierIncluded(current, specifiers[i])) {
			return false;
		}
	}
	return true;
}

function versionIncluded(nodeVersion, specifierValue) {
	if (typeof specifierValue === 'boolean') {
		return specifierValue;
	}

	var current = typeof nodeVersion === 'undefined'
		? process.versions && process.versions.node
		: nodeVersion;

	if (typeof current !== 'string') {
		throw new TypeError(typeof nodeVersion === 'undefined' ? 'Unable to determine current node version' : 'If provided, a valid node version is required');
	}

	if (specifierValue && typeof specifierValue === 'object') {
		for (var i = 0; i < specifierValue.length; ++i) {
			if (matchesRange(current, specifierValue[i])) {
				return true;
			}
		}
		return false;
	}
	return matchesRange(current, specifierValue);
}

var data = __nccwpck_require__(66151);

module.exports = function isCore(x, nodeVersion) {
	return has(data, x) && versionIncluded(nodeVersion, data[x]);
};


/***/ }),

/***/ 76435:
/***/ ((module) => {

/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

module.exports = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;
  while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};


/***/ }),

/***/ 34466:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isExtglob = __nccwpck_require__(76435);
var chars = { '{': '}', '(': ')', '[': ']'};
var strictCheck = function(str) {
  if (str[0] === '!') {
    return true;
  }
  var index = 0;
  var pipeIndex = -2;
  var closeSquareIndex = -2;
  var closeCurlyIndex = -2;
  var closeParenIndex = -2;
  var backSlashIndex = -2;
  while (index < str.length) {
    if (str[index] === '*') {
      return true;
    }

    if (str[index + 1] === '?' && /[\].+)]/.test(str[index])) {
      return true;
    }

    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {
      if (closeSquareIndex < index) {
        closeSquareIndex = str.indexOf(']', index);
      }
      if (closeSquareIndex > index) {
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
        backSlashIndex = str.indexOf('\\', index);
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
      }
    }

    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {
      closeCurlyIndex = str.indexOf('}', index);
      if (closeCurlyIndex > index) {
        backSlashIndex = str.indexOf('\\', index);
        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
          return true;
        }
      }
    }

    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {
      closeParenIndex = str.indexOf(')', index);
      if (closeParenIndex > index) {
        backSlashIndex = str.indexOf('\\', index);
        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
          return true;
        }
      }
    }

    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {
      if (pipeIndex < index) {
        pipeIndex = str.indexOf('|', index);
      }
      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {
        closeParenIndex = str.indexOf(')', pipeIndex);
        if (closeParenIndex > pipeIndex) {
          backSlashIndex = str.indexOf('\\', pipeIndex);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
    }

    if (str[index] === '\\') {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];

      if (close) {
        var n = str.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }

      if (str[index] === '!') {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};

var relaxedCheck = function(str) {
  if (str[0] === '!') {
    return true;
  }
  var index = 0;
  while (index < str.length) {
    if (/[*?{}()[\]]/.test(str[index])) {
      return true;
    }

    if (str[index] === '\\') {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];

      if (close) {
        var n = str.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }

      if (str[index] === '!') {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};

module.exports = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var check = strictCheck;

  // optionally relax check
  if (options && options.strict === false) {
    check = relaxedCheck;
  }

  return check(str);
};


/***/ }),

/***/ 75680:
/***/ ((module) => {

"use strict";
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */



module.exports = function(num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};


/***/ }),

/***/ 82578:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

/*
 * merge2
 * https://github.com/teambition/merge2
 *
 * Copyright (c) 2014-2020 Teambition
 * Licensed under the MIT license.
 */
const Stream = __nccwpck_require__(12781)
const PassThrough = Stream.PassThrough
const slice = Array.prototype.slice

module.exports = merge2

function merge2 () {
  const streamsQueue = []
  const args = slice.call(arguments)
  let merging = false
  let options = args[args.length - 1]

  if (options && !Array.isArray(options) && options.pipe == null) {
    args.pop()
  } else {
    options = {}
  }

  const doEnd = options.end !== false
  const doPipeError = options.pipeError === true
  if (options.objectMode == null) {
    options.objectMode = true
  }
  if (options.highWaterMark == null) {
    options.highWaterMark = 64 * 1024
  }
  const mergedStream = PassThrough(options)

  function addStream () {
    for (let i = 0, len = arguments.length; i < len; i++) {
      streamsQueue.push(pauseStreams(arguments[i], options))
    }
    mergeStream()
    return this
  }

  function mergeStream () {
    if (merging) {
      return
    }
    merging = true

    let streams = streamsQueue.shift()
    if (!streams) {
      process.nextTick(endStream)
      return
    }
    if (!Array.isArray(streams)) {
      streams = [streams]
    }

    let pipesCount = streams.length + 1

    function next () {
      if (--pipesCount > 0) {
        return
      }
      merging = false
      mergeStream()
    }

    function pipe (stream) {
      function onend () {
        stream.removeListener('merge2UnpipeEnd', onend)
        stream.removeListener('end', onend)
        if (doPipeError) {
          stream.removeListener('error', onerror)
        }
        next()
      }
      function onerror (err) {
        mergedStream.emit('error', err)
      }
      // skip ended stream
      if (stream._readableState.endEmitted) {
        return next()
      }

      stream.on('merge2UnpipeEnd', onend)
      stream.on('end', onend)

      if (doPipeError) {
        stream.on('error', onerror)
      }

      stream.pipe(mergedStream, { end: false })
      // compatible for old stream
      stream.resume()
    }

    for (let i = 0; i < streams.length; i++) {
      pipe(streams[i])
    }

    next()
  }

  function endStream () {
    merging = false
    // emit 'queueDrain' when all streams merged.
    mergedStream.emit('queueDrain')
    if (doEnd) {
      mergedStream.end()
    }
  }

  mergedStream.setMaxListeners(0)
  mergedStream.add = addStream
  mergedStream.on('unpipe', function (stream) {
    stream.emit('merge2UnpipeEnd')
  })

  if (args.length) {
    addStream.apply(null, args)
  }
  return mergedStream
}

// check and pause streams for pipe.
function pauseStreams (streams, options) {
  if (!Array.isArray(streams)) {
    // Backwards-compat with old-style streams
    if (!streams._readableState && streams.pipe) {
      streams = streams.pipe(PassThrough(options))
    }
    if (!streams._readableState || !streams.pause || !streams.pipe) {
      throw new Error('Only readable stream can be merged.')
    }
    streams.pause()
  } else {
    for (let i = 0, len = streams.length; i < len; i++) {
      streams[i] = pauseStreams(streams[i], options)
    }
  }
  return streams
}


/***/ }),

/***/ 76228:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const util = __nccwpck_require__(73837);
const braces = __nccwpck_require__(50610);
const picomatch = __nccwpck_require__(78569);
const utils = __nccwpck_require__(30479);
const isEmptyString = val => val === '' || val === './';

/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {String|Array<string>} `list` List of strings to match.
 * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options)
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

const micromatch = (list, patterns, options) => {
  patterns = [].concat(patterns);
  list = [].concat(list);

  let omit = new Set();
  let keep = new Set();
  let items = new Set();
  let negatives = 0;

  let onResult = state => {
    items.add(state.output);
    if (options && options.onResult) {
      options.onResult(state);
    }
  };

  for (let i = 0; i < patterns.length; i++) {
    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
    if (negated) negatives++;

    for (let item of list) {
      let matched = isMatch(item, true);

      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match) continue;

      if (negated) {
        omit.add(matched.output);
      } else {
        omit.delete(matched.output);
        keep.add(matched.output);
      }
    }
  }

  let result = negatives === patterns.length ? [...items] : [...keep];
  let matches = result.filter(item => !omit.has(item));

  if (options && matches.length === 0) {
    if (options.failglob === true) {
      throw new Error(`No matches found for "${patterns.join(', ')}"`);
    }

    if (options.nonull === true || options.nullglob === true) {
      return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
    }
  }

  return matches;
};

/**
 * Backwards compatibility
 */

micromatch.match = micromatch;

/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options`
 * @return {Function} Returns a matcher function.
 * @api public
 */

micromatch.matcher = (pattern, options) => picomatch(pattern, options);

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(mm.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `[options]` See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Backwards compatibility
 */

micromatch.any = micromatch.isMatch;

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch.not = (list, patterns, options = {}) => {
  patterns = [].concat(patterns).map(String);
  let result = new Set();
  let items = [];

  let onResult = state => {
    if (options.onResult) options.onResult(state);
    items.push(state.output);
  };

  let matches = new Set(micromatch(list, patterns, { ...options, onResult }));

  for (let item of items) {
    if (!matches.has(item)) {
      result.add(item);
    }
  }
  return [...result];
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any of the patterns matches any part of `str`.
 * @api public
 */

micromatch.contains = (str, pattern, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  if (Array.isArray(pattern)) {
    return pattern.some(p => micromatch.contains(str, p, options));
  }

  if (typeof pattern === 'string') {
    if (isEmptyString(str) || isEmptyString(pattern)) {
      return false;
    }

    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {
      return true;
    }
  }

  return micromatch.isMatch(str, pattern, { ...options, contains: true });
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch.matchKeys = (obj, patterns, options) => {
  if (!utils.isObject(obj)) {
    throw new TypeError('Expected the first argument to be an object');
  }
  let keys = micromatch(Object.keys(obj), patterns, options);
  let res = {};
  for (let key of keys) res[key] = obj[key];
  return res;
};

/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`
 * @api public
 */

micromatch.some = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (items.some(item => isMatch(item))) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`
 * @api public
 */

micromatch.every = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (!items.every(item => isMatch(item))) {
      return false;
    }
  }
  return true;
};

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.all = (str, patterns, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  return [].concat(patterns).every(p => picomatch(p, options)(str));
};

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `glob` Glob pattern to use for matching.
 * @param {String} `input` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch.capture = (glob, input, options) => {
  let posix = utils.isWindows(options);
  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);

  if (match) {
    return match.slice(1).map(v => v === void 0 ? '' : v);
  }
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

micromatch.makeRe = (...args) => picomatch.makeRe(...args);

/**
 * Scan a glob pattern to separate the pattern into segments. Used
 * by the [split](#split) method.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.scan(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

micromatch.scan = (...args) => picomatch.scan(...args);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.parse(pattern[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */

micromatch.parse = (patterns, options) => {
  let res = [];
  for (let pattern of [].concat(patterns || [])) {
    for (let str of braces(String(pattern), options)) {
      res.push(picomatch.parse(str, options));
    }
  }
  return res;
};

/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const { braces } = require('micromatch');
 * console.log(braces('foo/{a,b,c}/bar'));
 * //=> [ 'foo/(a|b|c)/bar' ]
 *
 * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
 * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
 * ```
 * @param {String} `pattern` String with brace pattern to process.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */

micromatch.braces = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  if ((options && options.nobrace === true) || !/\{.*\}/.test(pattern)) {
    return [pattern];
  }
  return braces(pattern, options);
};

/**
 * Expand braces
 */

micromatch.braceExpand = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  return micromatch.braces(pattern, { ...options, expand: true });
};

/**
 * Expose micromatch
 */

module.exports = micromatch;


/***/ }),

/***/ 55388:
/***/ ((module) => {

/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

module.exports = function(path, stripTrailing) {
  if (typeof path !== 'string') {
    throw new TypeError('expected path to be a string');
  }

  if (path === '\\' || path === '/') return '/';

  var len = path.length;
  if (len <= 1) return path;

  // ensure that win32 namespaces has two leading slashes, so that the path is
  // handled properly by the win32 version of path.parse() after being normalized
  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces
  var prefix = '';
  if (len > 4 && path[3] === '\\') {
    var ch = path[2];
    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
      path = path.slice(2);
      prefix = '//';
    }
  }

  var segs = path.split(/[/\\]+/);
  if (stripTrailing !== false && segs[segs.length - 1] === '') {
    segs.pop();
  }
  return prefix + segs.join('/');
};


/***/ }),

/***/ 24251:
/***/ ((module) => {

"use strict";

module.exports = {
  wrap: wrapRange,
  limit: limitRange,
  validate: validateRange,
  test: testRange,
  curry: curry,
  name: name
};

function wrapRange(min, max, value) {
  var maxLessMin = max - min;
  return ((value - min) % maxLessMin + maxLessMin) % maxLessMin + min;
}

function limitRange(min, max, value) {
  return Math.max(min, Math.min(max, value));
}

function validateRange(min, max, value, minExclusive, maxExclusive) {
  if (!testRange(min, max, value, minExclusive, maxExclusive)) {
    throw new Error(value + ' is outside of range [' + min + ',' + max + ')');
  }
  return value;
}

function testRange(min, max, value, minExclusive, maxExclusive) {
  return !(
       value < min ||
       value > max ||
       (maxExclusive && (value === max)) ||
       (minExclusive && (value === min))
  );
}

function name(min, max, minExcl, maxExcl) {
  return (minExcl ? '(' : '[') + min + ',' + max + (maxExcl ? ')' : ']');
}

function curry(min, max, minExclusive, maxExclusive) {
  var boundNameFn = name.bind(null, min, max, minExclusive, maxExclusive);
  return {
    wrap: wrapRange.bind(null, min, max),
    limit: limitRange.bind(null, min, max),
    validate: function(value) {
      return validateRange(min, max, value, minExclusive, maxExclusive);
    },
    test: function(value) {
      return testRange(min, max, value, minExclusive, maxExclusive);
    },
    toString: boundNameFn,
    name: boundNameFn
  };
}


/***/ }),

/***/ 24856:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


var crypto = __nccwpck_require__(6113);

/**
 * Exported function
 *
 * Options:
 *
 *  - `algorithm` hash algo to be used by this instance: *'sha1', 'md5'
 *  - `excludeValues` {true|*false} hash object keys, values ignored
 *  - `encoding` hash encoding, supports 'buffer', '*hex', 'binary', 'base64'
 *  - `ignoreUnknown` {true|*false} ignore unknown object types
 *  - `replacer` optional function that replaces values before hashing
 *  - `respectFunctionProperties` {*true|false} consider function properties when hashing
 *  - `respectFunctionNames` {*true|false} consider 'name' property of functions for hashing
 *  - `respectType` {*true|false} Respect special properties (prototype, constructor)
 *    when hashing to distinguish between types
 *  - `unorderedArrays` {true|*false} Sort all arrays before hashing
 *  - `unorderedSets` {*true|false} Sort `Set` and `Map` instances before hashing
 *  * = default
 *
 * @param {object} object value to hash
 * @param {object} options hashing options
 * @return {string} hash value
 * @api public
 */
exports = module.exports = objectHash;

function objectHash(object, options){
  options = applyDefaults(object, options);

  return hash(object, options);
}

/**
 * Exported sugar methods
 *
 * @param {object} object value to hash
 * @return {string} hash value
 * @api public
 */
exports.sha1 = function(object){
  return objectHash(object);
};
exports.keys = function(object){
  return objectHash(object, {excludeValues: true, algorithm: 'sha1', encoding: 'hex'});
};
exports.MD5 = function(object){
  return objectHash(object, {algorithm: 'md5', encoding: 'hex'});
};
exports.keysMD5 = function(object){
  return objectHash(object, {algorithm: 'md5', encoding: 'hex', excludeValues: true});
};

// Internals
var hashes = crypto.getHashes ? crypto.getHashes().slice() : ['sha1', 'md5'];
hashes.push('passthrough');
var encodings = ['buffer', 'hex', 'binary', 'base64'];

function applyDefaults(object, sourceOptions){
  sourceOptions = sourceOptions || {};

  // create a copy rather than mutating
  var options = {};
  options.algorithm = sourceOptions.algorithm || 'sha1';
  options.encoding = sourceOptions.encoding || 'hex';
  options.excludeValues = sourceOptions.excludeValues ? true : false;
  options.algorithm = options.algorithm.toLowerCase();
  options.encoding = options.encoding.toLowerCase();
  options.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true; // default to false
  options.respectType = sourceOptions.respectType === false ? false : true; // default to true
  options.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true;
  options.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true;
  options.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true; // default to false
  options.unorderedSets = sourceOptions.unorderedSets === false ? false : true; // default to false
  options.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true; // default to true
  options.replacer = sourceOptions.replacer || undefined;
  options.excludeKeys = sourceOptions.excludeKeys || undefined;

  if(typeof object === 'undefined') {
    throw new Error('Object argument required.');
  }

  // if there is a case-insensitive match in the hashes list, accept it
  // (i.e. SHA256 for sha256)
  for (var i = 0; i < hashes.length; ++i) {
    if (hashes[i].toLowerCase() === options.algorithm.toLowerCase()) {
      options.algorithm = hashes[i];
    }
  }

  if(hashes.indexOf(options.algorithm) === -1){
    throw new Error('Algorithm "' + options.algorithm + '"  not supported. ' +
      'supported values: ' + hashes.join(', '));
  }

  if(encodings.indexOf(options.encoding) === -1 &&
     options.algorithm !== 'passthrough'){
    throw new Error('Encoding "' + options.encoding + '"  not supported. ' +
      'supported values: ' + encodings.join(', '));
  }

  return options;
}

/** Check if the given function is a native function */
function isNativeFunction(f) {
  if ((typeof f) !== 'function') {
    return false;
  }
  var exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i;
  return exp.exec(Function.prototype.toString.call(f)) != null;
}

function hash(object, options) {
  var hashingStream;

  if (options.algorithm !== 'passthrough') {
    hashingStream = crypto.createHash(options.algorithm);
  } else {
    hashingStream = new PassThrough();
  }

  if (typeof hashingStream.write === 'undefined') {
    hashingStream.write = hashingStream.update;
    hashingStream.end   = hashingStream.update;
  }

  var hasher = typeHasher(options, hashingStream);
  hasher.dispatch(object);
  if (!hashingStream.update) {
    hashingStream.end('');
  }

  if (hashingStream.digest) {
    return hashingStream.digest(options.encoding === 'buffer' ? undefined : options.encoding);
  }

  var buf = hashingStream.read();
  if (options.encoding === 'buffer') {
    return buf;
  }

  return buf.toString(options.encoding);
}

/**
 * Expose streaming API
 *
 * @param {object} object  Value to serialize
 * @param {object} options  Options, as for hash()
 * @param {object} stream  A stream to write the serializiation to
 * @api public
 */
exports.writeToStream = function(object, options, stream) {
  if (typeof stream === 'undefined') {
    stream = options;
    options = {};
  }

  options = applyDefaults(object, options);

  return typeHasher(options, stream).dispatch(object);
};

function typeHasher(options, writeTo, context){
  context = context || [];
  var write = function(str) {
    if (writeTo.update) {
      return writeTo.update(str, 'utf8');
    } else {
      return writeTo.write(str, 'utf8');
    }
  };

  return {
    dispatch: function(value){
      if (options.replacer) {
        value = options.replacer(value);
      }

      var type = typeof value;
      if (value === null) {
        type = 'null';
      }

      //console.log("[DEBUG] Dispatch: ", value, "->", type, " -> ", "_" + type);

      return this['_' + type](value);
    },
    _object: function(object) {
      var pattern = (/\[object (.*)\]/i);
      var objString = Object.prototype.toString.call(object);
      var objType = pattern.exec(objString);
      if (!objType) { // object type did not match [object ...]
        objType = 'unknown:[' + objString + ']';
      } else {
        objType = objType[1]; // take only the class name
      }

      objType = objType.toLowerCase();

      var objectNumber = null;

      if ((objectNumber = context.indexOf(object)) >= 0) {
        return this.dispatch('[CIRCULAR:' + objectNumber + ']');
      } else {
        context.push(object);
      }

      if (typeof Buffer !== 'undefined' && Buffer.isBuffer && Buffer.isBuffer(object)) {
        write('buffer:');
        return write(object);
      }

      if(objType !== 'object' && objType !== 'function' && objType !== 'asyncfunction') {
        if(this['_' + objType]) {
          this['_' + objType](object);
        } else if (options.ignoreUnknown) {
          return write('[' + objType + ']');
        } else {
          throw new Error('Unknown object type "' + objType + '"');
        }
      }else{
        var keys = Object.keys(object);
        if (options.unorderedObjects) {
          keys = keys.sort();
        }
        // Make sure to incorporate special properties, so
        // Types with different prototypes will produce
        // a different hash and objects derived from
        // different functions (`new Foo`, `new Bar`) will
        // produce different hashes.
        // We never do this for native functions since some
        // seem to break because of that.
        if (options.respectType !== false && !isNativeFunction(object)) {
          keys.splice(0, 0, 'prototype', '__proto__', 'constructor');
        }

        if (options.excludeKeys) {
          keys = keys.filter(function(key) { return !options.excludeKeys(key); });
        }

        write('object:' + keys.length + ':');
        var self = this;
        return keys.forEach(function(key){
          self.dispatch(key);
          write(':');
          if(!options.excludeValues) {
            self.dispatch(object[key]);
          }
          write(',');
        });
      }
    },
    _array: function(arr, unordered){
      unordered = typeof unordered !== 'undefined' ? unordered :
        options.unorderedArrays !== false; // default to options.unorderedArrays

      var self = this;
      write('array:' + arr.length + ':');
      if (!unordered || arr.length <= 1) {
        return arr.forEach(function(entry) {
          return self.dispatch(entry);
        });
      }

      // the unordered case is a little more complicated:
      // since there is no canonical ordering on objects,
      // i.e. {a:1} < {a:2} and {a:1} > {a:2} are both false,
      // we first serialize each entry using a PassThrough stream
      // before sorting.
      // also: we can’t use the same context array for all entries
      // since the order of hashing should *not* matter. instead,
      // we keep track of the additions to a copy of the context array
      // and add all of them to the global context array when we’re done
      var contextAdditions = [];
      var entries = arr.map(function(entry) {
        var strm = new PassThrough();
        var localContext = context.slice(); // make copy
        var hasher = typeHasher(options, strm, localContext);
        hasher.dispatch(entry);
        // take only what was added to localContext and append it to contextAdditions
        contextAdditions = contextAdditions.concat(localContext.slice(context.length));
        return strm.read().toString();
      });
      context = context.concat(contextAdditions);
      entries.sort();
      return this._array(entries, false);
    },
    _date: function(date){
      return write('date:' + date.toJSON());
    },
    _symbol: function(sym){
      return write('symbol:' + sym.toString());
    },
    _error: function(err){
      return write('error:' + err.toString());
    },
    _boolean: function(bool){
      return write('bool:' + bool.toString());
    },
    _string: function(string){
      write('string:' + string.length + ':');
      write(string.toString());
    },
    _function: function(fn){
      write('fn:');
      if (isNativeFunction(fn)) {
        this.dispatch('[native]');
      } else {
        this.dispatch(fn.toString());
      }

      if (options.respectFunctionNames !== false) {
        // Make sure we can still distinguish native functions
        // by their name, otherwise String and Function will
        // have the same hash
        this.dispatch("function-name:" + String(fn.name));
      }

      if (options.respectFunctionProperties) {
        this._object(fn);
      }
    },
    _number: function(number){
      return write('number:' + number.toString());
    },
    _xml: function(xml){
      return write('xml:' + xml.toString());
    },
    _null: function() {
      return write('Null');
    },
    _undefined: function() {
      return write('Undefined');
    },
    _regexp: function(regex){
      return write('regex:' + regex.toString());
    },
    _uint8array: function(arr){
      write('uint8array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _uint8clampedarray: function(arr){
      write('uint8clampedarray:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _int8array: function(arr){
      write('int8array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _uint16array: function(arr){
      write('uint16array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _int16array: function(arr){
      write('int16array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _uint32array: function(arr){
      write('uint32array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _int32array: function(arr){
      write('int32array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _float32array: function(arr){
      write('float32array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _float64array: function(arr){
      write('float64array:');
      return this.dispatch(Array.prototype.slice.call(arr));
    },
    _arraybuffer: function(arr){
      write('arraybuffer:');
      return this.dispatch(new Uint8Array(arr));
    },
    _url: function(url) {
      return write('url:' + url.toString(), 'utf8');
    },
    _map: function(map) {
      write('map:');
      var arr = Array.from(map);
      return this._array(arr, options.unorderedSets !== false);
    },
    _set: function(set) {
      write('set:');
      var arr = Array.from(set);
      return this._array(arr, options.unorderedSets !== false);
    },
    _file: function(file) {
      write('file:');
      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);
    },
    _blob: function() {
      if (options.ignoreUnknown) {
        return write('[blob]');
      }

      throw Error('Hashing Blob objects is currently not supported\n' +
        '(see https://github.com/puleos/object-hash/issues/26)\n' +
        'Use "options.replacer" or "options.ignoreUnknown"\n');
    },
    _domwindow: function() { return write('domwindow'); },
    _bigint: function(number){
      return write('bigint:' + number.toString());
    },
    /* Node.js standard native objects */
    _process: function() { return write('process'); },
    _timer: function() { return write('timer'); },
    _pipe: function() { return write('pipe'); },
    _tcp: function() { return write('tcp'); },
    _udp: function() { return write('udp'); },
    _tty: function() { return write('tty'); },
    _statwatcher: function() { return write('statwatcher'); },
    _securecontext: function() { return write('securecontext'); },
    _connection: function() { return write('connection'); },
    _zlib: function() { return write('zlib'); },
    _context: function() { return write('context'); },
    _nodescript: function() { return write('nodescript'); },
    _httpparser: function() { return write('httpparser'); },
    _dataview: function() { return write('dataview'); },
    _signal: function() { return write('signal'); },
    _fsevent: function() { return write('fsevent'); },
    _tlswrap: function() { return write('tlswrap'); },
  };
}

// Mini-implementation of stream.PassThrough
// We are far from having need for the full implementation, and we can
// make assumptions like "many writes, then only one final read"
// and we can ignore encoding specifics
function PassThrough() {
  return {
    buf: '',

    write: function(b) {
      this.buf += b;
    },

    end: function(b) {
      this.buf += b;
    },

    read: function() {
      return this.buf;
    }
  };
}


/***/ }),

/***/ 5980:
/***/ ((module) => {

"use strict";


var isWindows = process.platform === 'win32';

// Regex to split a windows path into into [dir, root, basename, name, ext]
var splitWindowsRe =
    /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;

var win32 = {};

function win32SplitPath(filename) {
  return splitWindowsRe.exec(filename).slice(1);
}

win32.parse = function(pathString) {
  if (typeof pathString !== 'string') {
    throw new TypeError(
        "Parameter 'pathString' must be a string, not " + typeof pathString
    );
  }
  var allParts = win32SplitPath(pathString);
  if (!allParts || allParts.length !== 5) {
    throw new TypeError("Invalid path '" + pathString + "'");
  }
  return {
    root: allParts[1],
    dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
    base: allParts[2],
    ext: allParts[4],
    name: allParts[3]
  };
};



// Split a filename into [dir, root, basename, name, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
var posix = {};


function posixSplitPath(filename) {
  return splitPathRe.exec(filename).slice(1);
}


posix.parse = function(pathString) {
  if (typeof pathString !== 'string') {
    throw new TypeError(
        "Parameter 'pathString' must be a string, not " + typeof pathString
    );
  }
  var allParts = posixSplitPath(pathString);
  if (!allParts || allParts.length !== 5) {
    throw new TypeError("Invalid path '" + pathString + "'");
  }
  
  return {
    root: allParts[1],
    dir: allParts[0].slice(0, -1),
    base: allParts[2],
    ext: allParts[4],
    name: allParts[3],
  };
};


if (isWindows)
  module.exports = win32.parse;
else /* posix */
  module.exports = posix.parse;

module.exports.posix = posix.parse;
module.exports.win32 = win32.parse;


/***/ }),

/***/ 37023:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let tty = __nccwpck_require__(76224)

let isColorSupported =
	!("NO_COLOR" in process.env || process.argv.includes("--no-color")) &&
	("FORCE_COLOR" in process.env ||
		process.argv.includes("--color") ||
		process.platform === "win32" ||
		(tty.isatty(1) && process.env.TERM !== "dumb") ||
		"CI" in process.env)

let formatter =
	(open, close, replace = open) =>
	input => {
		let string = "" + input
		let index = string.indexOf(close, open.length)
		return ~index
			? open + replaceClose(string, close, replace, index) + close
			: open + string + close
	}

let replaceClose = (string, close, replace, index) => {
	let start = string.substring(0, index) + replace
	let end = string.substring(index + close.length)
	let nextIndex = end.indexOf(close)
	return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end
}

let createColors = (enabled = isColorSupported) => ({
	isColorSupported: enabled,
	reset: enabled ? s => `\x1b[0m${s}\x1b[0m` : String,
	bold: enabled ? formatter("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m") : String,
	dim: enabled ? formatter("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m") : String,
	italic: enabled ? formatter("\x1b[3m", "\x1b[23m") : String,
	underline: enabled ? formatter("\x1b[4m", "\x1b[24m") : String,
	inverse: enabled ? formatter("\x1b[7m", "\x1b[27m") : String,
	hidden: enabled ? formatter("\x1b[8m", "\x1b[28m") : String,
	strikethrough: enabled ? formatter("\x1b[9m", "\x1b[29m") : String,
	black: enabled ? formatter("\x1b[30m", "\x1b[39m") : String,
	red: enabled ? formatter("\x1b[31m", "\x1b[39m") : String,
	green: enabled ? formatter("\x1b[32m", "\x1b[39m") : String,
	yellow: enabled ? formatter("\x1b[33m", "\x1b[39m") : String,
	blue: enabled ? formatter("\x1b[34m", "\x1b[39m") : String,
	magenta: enabled ? formatter("\x1b[35m", "\x1b[39m") : String,
	cyan: enabled ? formatter("\x1b[36m", "\x1b[39m") : String,
	white: enabled ? formatter("\x1b[37m", "\x1b[39m") : String,
	gray: enabled ? formatter("\x1b[90m", "\x1b[39m") : String,
	bgBlack: enabled ? formatter("\x1b[40m", "\x1b[49m") : String,
	bgRed: enabled ? formatter("\x1b[41m", "\x1b[49m") : String,
	bgGreen: enabled ? formatter("\x1b[42m", "\x1b[49m") : String,
	bgYellow: enabled ? formatter("\x1b[43m", "\x1b[49m") : String,
	bgBlue: enabled ? formatter("\x1b[44m", "\x1b[49m") : String,
	bgMagenta: enabled ? formatter("\x1b[45m", "\x1b[49m") : String,
	bgCyan: enabled ? formatter("\x1b[46m", "\x1b[49m") : String,
	bgWhite: enabled ? formatter("\x1b[47m", "\x1b[49m") : String,
})

module.exports = createColors()
module.exports.createColors = createColors


/***/ }),

/***/ 78569:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


module.exports = __nccwpck_require__(33322);


/***/ }),

/***/ 16099:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const path = __nccwpck_require__(71017);
const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

/**
 * Posix glob regex
 */

const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;

const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
};

/**
 * Windows glob regex
 */

const WINDOWS_CHARS = {
  ...POSIX_CHARS,

  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};

/**
 * POSIX Bracket Regex
 */

const POSIX_REGEX_SOURCE = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

module.exports = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE,

  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },

  // Digits
  CHAR_0: 48, /* 0 */
  CHAR_9: 57, /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 65, /* A */
  CHAR_LOWERCASE_A: 97, /* a */
  CHAR_UPPERCASE_Z: 90, /* Z */
  CHAR_LOWERCASE_Z: 122, /* z */

  CHAR_LEFT_PARENTHESES: 40, /* ( */
  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  CHAR_ASTERISK: 42, /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38, /* & */
  CHAR_AT: 64, /* @ */
  CHAR_BACKWARD_SLASH: 92, /* \ */
  CHAR_CARRIAGE_RETURN: 13, /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  CHAR_COLON: 58, /* : */
  CHAR_COMMA: 44, /* , */
  CHAR_DOT: 46, /* . */
  CHAR_DOUBLE_QUOTE: 34, /* " */
  CHAR_EQUAL: 61, /* = */
  CHAR_EXCLAMATION_MARK: 33, /* ! */
  CHAR_FORM_FEED: 12, /* \f */
  CHAR_FORWARD_SLASH: 47, /* / */
  CHAR_GRAVE_ACCENT: 96, /* ` */
  CHAR_HASH: 35, /* # */
  CHAR_HYPHEN_MINUS: 45, /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  CHAR_LINE_FEED: 10, /* \n */
  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  CHAR_PERCENT: 37, /* % */
  CHAR_PLUS: 43, /* + */
  CHAR_QUESTION_MARK: 63, /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  CHAR_SEMICOLON: 59, /* ; */
  CHAR_SINGLE_QUOTE: 39, /* ' */
  CHAR_SPACE: 32, /*   */
  CHAR_TAB: 9, /* \t */
  CHAR_UNDERSCORE: 95, /* _ */
  CHAR_VERTICAL_LINE: 124, /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  SEP: path.sep,

  /**
   * Create EXTGLOB_CHARS
   */

  extglobChars(chars) {
    return {
      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
      '?': { type: 'qmark', open: '(?:', close: ')?' },
      '+': { type: 'plus', open: '(?:', close: ')+' },
      '*': { type: 'star', open: '(?:', close: ')*' },
      '@': { type: 'at', open: '(?:', close: ')' }
    };
  },

  /**
   * Create GLOB_CHARS
   */

  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};


/***/ }),

/***/ 92139:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const constants = __nccwpck_require__(16099);
const utils = __nccwpck_require__(30479);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(win32);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = opts => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index] || '';
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };

  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren') {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');
    let rest;

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
        // In this case, we need to parse the string and use it in the output of the original pattern.
        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
        //
        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
        const expression = parse(rest, { ...options, fastpaths: false }).output;

        output = token.close = `)${expression})${extglobStar})`;
      }

      if (token.prev.type === 'bos') {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance();
      } else {
        value += advance();
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      increment('parens');
      push({ type: 'paren', value });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Square brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      decrement('brackets');

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = `/${value}`;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      increment('braces');

      const open = {
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };

      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({ type: 'text', value, output: value });
        continue;
      }

      let output = ')';

      if (brace.dots === true) {
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === 'brace') {
            break;
          }
          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true && brace.dots !== true) {
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\{';
        value = output = '\\}';
        state.output = out;
        for (const t of toks) {
          state.output += (t.output || t.value);
        }
      }

      push({ type: 'brace', value, output });
      decrement('braces');
      braces.pop();
      continue;
    }

    /**
     * Pipes
     */

    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: 'text', value });
      continue;
    }

    /**
     * Commas
     */

    if (value === ',') {
      let output = value;

      const brace = braces[braces.length - 1];
      if (brace && stack[stack.length - 1] === 'braces') {
        brace.comma = true;
        output = '|';
      }

      push({ type: 'comma', value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
      }

      push({ type: 'slash', value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({ type: 'text', value, output: DOT_LITERAL });
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      const isGroup = prev && prev.value === '(';
      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        const next = peek();
        let output = value;

        if (next === '<' && !utils.supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
          output = `\\${value}`;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if ((prev && prev.value === '(') || opts.regex === false) {
        push({ type: 'plus', value, output: PLUS_LITERAL });
        continue;
      }

      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', extglob: true, value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = `\\${value}`;
      }

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') {
        const after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        const end = rest[1] !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse.fastpaths = (input, options) => {
  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants.globChars(win32);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = { negated: false, prefix: '' };
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = opts => {
    if (opts.noglobstar === true) return star;
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        const source = create(match[1]);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  const output = utils.removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL}?`;
  }

  return source;
};

module.exports = parse;


/***/ }),

/***/ 33322:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const path = __nccwpck_require__(71017);
const scan = __nccwpck_require__(32429);
const parse = __nccwpck_require__(92139);
const utils = __nccwpck_require__(30479);
const constants = __nccwpck_require__(16099);
const isObject = val => val && typeof val === 'object' && !Array.isArray(val);

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */

const picomatch = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
    const fns = glob.map(input => picomatch(input, options, returnState));
    const arrayMatcher = str => {
      for (const isMatch of fns) {
        const state = isMatch(str);
        if (state) return state;
      }
      return false;
    };
    return arrayMatcher;
  }

  const isState = isObject(glob) && glob.tokens && glob.input;

  if (glob === '' || (typeof glob !== 'string' && !isState)) {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  const opts = options || {};
  const posix = utils.isWindows(options);
  const regex = isState
    ? picomatch.compileRe(glob, options)
    : picomatch.makeRe(glob, options, false, true);

  const state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) {
    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
    const result = { glob, state, regex, posix, input, output, match, isMatch };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */

picomatch.test = (input, regex, options, { glob, posix } = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return { isMatch: false, output: '' };
  }

  const opts = options || {};
  const format = opts.format || (posix ? utils.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return { isMatch: Boolean(match), match, output };
};

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */

picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  return regex.test(path.basename(input));
};

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch.parse = (pattern, options) => {
  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
  return parse(pattern, { ...options, fastpaths: false });
};

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

picomatch.scan = (input, options) => scan(input, options);

/**
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param {Object} `state`
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return {RegExp}
 * @api public
 */

picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return state.output;
  }

  const opts = options || {};
  const prepend = opts.contains ? '' : '^';
  const append = opts.contains ? '' : '$';

  let source = `${prepend}(?:${state.output})${append}`;
  if (state && state.negated === true) {
    source = `^(?!${source}).*$`;
  }

  const regex = picomatch.toRegex(source, options);
  if (returnState === true) {
    regex.state = state;
  }

  return regex;
};

/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  let parsed = { negated: false, fastpaths: true };

  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    parsed.output = parse.fastpaths(input, options);
  }

  if (!parsed.output) {
    parsed = parse(input, options);
  }

  return picomatch.compileRe(parsed, options, returnOutput, returnState);
};

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

picomatch.toRegex = (source, options) => {
  try {
    const opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};

/**
 * Picomatch constants.
 * @return {Object}
 */

picomatch.constants = constants;

/**
 * Expose "picomatch"
 */

module.exports = picomatch;


/***/ }),

/***/ 32429:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const utils = __nccwpck_require__(30479);
const {
  CHAR_ASTERISK,             /* * */
  CHAR_AT,                   /* @ */
  CHAR_BACKWARD_SLASH,       /* \ */
  CHAR_COMMA,                /* , */
  CHAR_DOT,                  /* . */
  CHAR_EXCLAMATION_MARK,     /* ! */
  CHAR_FORWARD_SLASH,        /* / */
  CHAR_LEFT_CURLY_BRACE,     /* { */
  CHAR_LEFT_PARENTHESES,     /* ( */
  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  CHAR_PLUS,                 /* + */
  CHAR_QUESTION_MARK,        /* ? */
  CHAR_RIGHT_CURLY_BRACE,    /* } */
  CHAR_RIGHT_PARENTHESES,    /* ) */
  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
} = __nccwpck_require__(16099);

const isPathSeparator = code => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

const depth = token => {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */

const scan = (input, options) => {
  const opts = options || {};

  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];

  let str = input;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let negatedExtglob = false;
  let finished = false;
  let braces = 0;
  let prev;
  let code;
  let token = { value: '', depth: 0, isGlob: false };

  const eos = () => index >= length;
  const peek = () => str.charCodeAt(index + 1);
  const advance = () => {
    prev = code;
    return str.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    let next;

    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance();

      if (code === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }
      continue;
    }

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (eos() !== true && (code = advance())) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (braceEscaped !== true && code === CHAR_COMMA) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (code === CHAR_RIGHT_CURLY_BRACE) {
          braces--;

          if (braces === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === CHAR_FORWARD_SLASH) {
      slashes.push(index);
      tokens.push(token);
      token = { value: '', depth: 0, isGlob: false };

      if (finished === true) continue;
      if (prev === CHAR_DOT && index === (start + 1)) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (opts.noext !== true) {
      const isExtglobChar = code === CHAR_PLUS
        || code === CHAR_AT
        || code === CHAR_ASTERISK
        || code === CHAR_QUESTION_MARK
        || code === CHAR_EXCLAMATION_MARK;

      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;
        if (code === CHAR_EXCLAMATION_MARK && index === start) {
          negatedExtglob = true;
        }

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
    }

    if (code === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_QUESTION_MARK) {
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_LEFT_SQUARE_BRACKET) {
      while (eos() !== true && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;
          break;
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = token.negated = true;
      start++;
      continue;
    }

    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
      isGlob = token.isGlob = true;

      if (scanToEnd === true) {
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_LEFT_PARENTHESES) {
            backslashes = token.backslashes = true;
            code = advance();
            continue;
          }

          if (code === CHAR_RIGHT_PARENTHESES) {
            finished = true;
            break;
          }
        }
        continue;
      }
      break;
    }

    if (isGlob === true) {
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }
  }

  if (opts.noext === true) {
    isExtglob = false;
    isGlob = false;
  }

  let base = str;
  let prefix = '';
  let glob = '';

  if (start > 0) {
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = str;
  } else {
    base = str;
  }

  if (base && base !== '' && base !== '/' && base !== str) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = utils.removeBackslashes(glob);

    if (base && backslashes === true) {
      base = utils.removeBackslashes(base);
    }
  }

  const state = {
    prefix,
    input,
    start,
    base,
    glob,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated,
    negatedExtglob
  };

  if (opts.tokens === true) {
    state.maxDepth = 0;
    if (!isPathSeparator(code)) {
      tokens.push(token);
    }
    state.tokens = tokens;
  }

  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;

    for (let idx = 0; idx < slashes.length; idx++) {
      const n = prevIndex ? prevIndex + 1 : start;
      const i = slashes[idx];
      const value = input.slice(n, i);
      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value;
        }
        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }
      if (idx !== 0 || value !== '') {
        parts.push(value);
      }
      prevIndex = i;
    }

    if (prevIndex && prevIndex + 1 < input.length) {
      const value = input.slice(prevIndex + 1);
      parts.push(value);

      if (opts.tokens) {
        tokens[tokens.length - 1].value = value;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }

    state.slashes = slashes;
    state.parts = parts;
  }

  return state;
};

module.exports = scan;


/***/ }),

/***/ 30479:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const path = __nccwpck_require__(71017);
const win32 = process.platform === 'win32';
const {
  REGEX_BACKSLASH,
  REGEX_REMOVE_BACKSLASH,
  REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL
} = __nccwpck_require__(16099);

exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

exports.removeBackslashes = str => {
  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
    return match === '\\' ? '' : match;
  });
};

exports.supportsLookbehinds = () => {
  const segs = process.version.slice(1).split('.').map(Number);
  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
    return true;
  }
  return false;
};

exports.isWindows = options => {
  if (options && typeof options.windows === 'boolean') {
    return options.windows;
  }
  return win32 === true || path.sep === '\\';
};

exports.escapeLast = (input, char, lastIdx) => {
  const idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};

exports.removePrefix = (input, state = {}) => {
  let output = input;
  if (output.startsWith('./')) {
    output = output.slice(2);
    state.prefix = './';
  }
  return output;
};

exports.wrapOutput = (input, state = {}, options = {}) => {
  const prepend = options.contains ? '' : '^';
  const append = options.contains ? '' : '$';

  let output = `${prepend}(?:${input})${append}`;
  if (state.negated === true) {
    output = `(?:^(?!${output}).*$)`;
  }
  return output;
};


/***/ }),

/***/ 26674:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let postcss = __nccwpck_require__(77001)

let processResult = __nccwpck_require__(21384)
let parse = __nccwpck_require__(86379)

module.exports = function async(plugins) {
  let processor = postcss(plugins)
  return async input => {
    let result = await processor.process(input, {
      parser: parse,
      from: undefined
    })
    return processResult(result)
  }
}


/***/ }),

/***/ 70481:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let objectify = __nccwpck_require__(99617)
let parse = __nccwpck_require__(86379)
let async = __nccwpck_require__(26674)
let sync = __nccwpck_require__(4614)

module.exports = {
  objectify,
  parse,
  async,
  sync
}


/***/ }),

/***/ 99617:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let camelcase = __nccwpck_require__(69227)

let UNITLESS = {
  boxFlex: true,
  boxFlexGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  strokeDashoffset: true,
  strokeOpacity: true,
  strokeWidth: true
}

function atRule(node) {
  if (typeof node.nodes === 'undefined') {
    return true
  } else {
    return process(node)
  }
}

function process(node) {
  let name
  let result = {}

  node.each(child => {
    if (child.type === 'atrule') {
      name = '@' + child.name
      if (child.params) name += ' ' + child.params
      if (typeof result[name] === 'undefined') {
        result[name] = atRule(child)
      } else if (Array.isArray(result[name])) {
        result[name].push(atRule(child))
      } else {
        result[name] = [result[name], atRule(child)]
      }
    } else if (child.type === 'rule') {
      let body = process(child)
      if (result[child.selector]) {
        for (let i in body) {
          result[child.selector][i] = body[i]
        }
      } else {
        result[child.selector] = body
      }
    } else if (child.type === 'decl') {
      if (child.prop[0] === '-' && child.prop[1] === '-') {
        name = child.prop
      } else if (child.parent && child.parent.selector === ':export') {
        name = child.prop
      } else {
        name = camelcase(child.prop)
      }
      let value = child.value
      if (!isNaN(child.value) && UNITLESS[name]) {
        value = parseFloat(child.value)
      }
      if (child.important) value += ' !important'
      if (typeof result[name] === 'undefined') {
        result[name] = value
      } else if (Array.isArray(result[name])) {
        result[name].push(value)
      } else {
        result[name] = [result[name], value]
      }
    }
  })
  return result
}

module.exports = process


/***/ }),

/***/ 86379:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let postcss = __nccwpck_require__(77001)

let IMPORTANT = /\s*!important\s*$/i

let UNITLESS = {
  'box-flex': true,
  'box-flex-group': true,
  'column-count': true,
  'flex': true,
  'flex-grow': true,
  'flex-positive': true,
  'flex-shrink': true,
  'flex-negative': true,
  'font-weight': true,
  'line-clamp': true,
  'line-height': true,
  'opacity': true,
  'order': true,
  'orphans': true,
  'tab-size': true,
  'widows': true,
  'z-index': true,
  'zoom': true,
  'fill-opacity': true,
  'stroke-dashoffset': true,
  'stroke-opacity': true,
  'stroke-width': true
}

function dashify(str) {
  return str
    .replace(/([A-Z])/g, '-$1')
    .replace(/^ms-/, '-ms-')
    .toLowerCase()
}

function decl(parent, name, value) {
  if (value === false || value === null) return

  if (!name.startsWith('--')) {
    name = dashify(name)
  }

  if (typeof value === 'number') {
    if (value === 0 || UNITLESS[name]) {
      value = value.toString()
    } else {
      value += 'px'
    }
  }

  if (name === 'css-float') name = 'float'

  if (IMPORTANT.test(value)) {
    value = value.replace(IMPORTANT, '')
    parent.push(postcss.decl({ prop: name, value, important: true }))
  } else {
    parent.push(postcss.decl({ prop: name, value }))
  }
}

function atRule(parent, parts, value) {
  let node = postcss.atRule({ name: parts[1], params: parts[3] || '' })
  if (typeof value === 'object') {
    node.nodes = []
    parse(value, node)
  }
  parent.push(node)
}

function parse(obj, parent) {
  let name, value, node
  for (name in obj) {
    value = obj[name]
    if (value === null || typeof value === 'undefined') {
      continue
    } else if (name[0] === '@') {
      let parts = name.match(/@(\S+)(\s+([\W\w]*)\s*)?/)
      if (Array.isArray(value)) {
        for (let i of value) {
          atRule(parent, parts, i)
        }
      } else {
        atRule(parent, parts, value)
      }
    } else if (Array.isArray(value)) {
      for (let i of value) {
        decl(parent, name, i)
      }
    } else if (typeof value === 'object') {
      node = postcss.rule({ selector: name })
      parse(value, node)
      parent.push(node)
    } else {
      decl(parent, name, value)
    }
  }
}

module.exports = function (obj) {
  let root = postcss.root()
  parse(obj, root)
  return root
}


/***/ }),

/***/ 21384:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let objectify = __nccwpck_require__(99617)

module.exports = function processResult(result) {
  if (console && console.warn) {
    result.warnings().forEach(warn => {
      let source = warn.plugin || 'PostCSS'
      console.warn(source + ': ' + warn.text)
    })
  }
  return objectify(result.root)
}


/***/ }),

/***/ 4614:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

let postcss = __nccwpck_require__(77001)

let processResult = __nccwpck_require__(21384)
let parse = __nccwpck_require__(86379)

module.exports = function (plugins) {
  let processor = postcss(plugins)
  return input => {
    let result = processor.process(input, { parser: parse, from: undefined })
    return processResult(result)
  }
}


/***/ }),

/***/ 90124:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { Rule, AtRule } = __nccwpck_require__(77001)
let parser = __nccwpck_require__(32997)

/**
 * Run a selector string through postcss-selector-parser
 */
function parse(rawSelector, rule) {
  let nodes
  try {
    parser(parsed => {
      nodes = parsed
    }).processSync(rawSelector)
  } catch (e) {
    if (rawSelector.includes(':')) {
      throw rule ? rule.error('Missed semicolon') : e
    } else {
      throw rule ? rule.error(e.message) : e
    }
  }
  return nodes.at(0)
}

/**
 * Replaces the "&" token in a node's selector with the parent selector
 * similar to what SCSS does.
 *
 * Mutates the nodes list
 */
function interpolateAmpInSelector(nodes, parent) {
  let replaced = false
  nodes.each(node => {
    if (node.type === 'nesting') {
      let clonedParent = parent.clone({})
      if (node.value !== '&') {
        node.replaceWith(
          parse(node.value.replace('&', clonedParent.toString()))
        )
      } else {
        node.replaceWith(clonedParent)
      }
      replaced = true
    } else if ('nodes' in node && node.nodes) {
      if (interpolateAmpInSelector(node, parent)) {
        replaced = true
      }
    }
  })
  return replaced
}

/**
 * Combines parent and child selectors, in a SCSS-like way
 */
function mergeSelectors(parent, child) {
  let merged = []
  parent.selectors.forEach(sel => {
    let parentNode = parse(sel, parent)

    child.selectors.forEach(selector => {
      if (!selector) {
        return
      }
      let node = parse(selector, child)
      let replaced = interpolateAmpInSelector(node, parentNode)
      if (!replaced) {
        node.prepend(parser.combinator({ value: ' ' }))
        node.prepend(parentNode.clone({}))
      }
      merged.push(node.toString())
    })
  })
  return merged
}

/**
 * Move a child and its preceeding comment(s) to after "after"
 */
function breakOut(child, after) {
  let prev = child.prev()
  after.after(child)
  while (prev && prev.type === 'comment') {
    let nextPrev = prev.prev()
    after.after(prev)
    prev = nextPrev
  }
  return child
}

function createFnAtruleChilds(bubble) {
  return function atruleChilds(rule, atrule, bubbling, mergeSels = bubbling) {
    let children = []
    atrule.each(child => {
      if (child.type === 'rule' && bubbling) {
        if (mergeSels) {
          child.selectors = mergeSelectors(rule, child)
        }
      } else if (child.type === 'atrule' && child.nodes) {
        if (bubble[child.name]) {
          atruleChilds(rule, child, mergeSels)
        } else if (atrule[rootRuleMergeSel] !== false) {
          children.push(child)
        }
      } else {
        children.push(child)
      }
    })
    if (bubbling) {
      if (children.length) {
        let clone = rule.clone({ nodes: [] })
        for (let child of children) {
          clone.append(child)
        }
        atrule.prepend(clone)
      }
    }
  }
}

function pickDeclarations(selector, declarations, after) {
  let parent = new Rule({
    selector,
    nodes: []
  })
  parent.append(declarations)
  after.after(parent)
  return parent
}

function atruleNames(defaults, custom) {
  let list = {}
  for (let name of defaults) {
    list[name] = true
  }
  if (custom) {
    for (let name of custom) {
      list[name.replace(/^@/, '')] = true
    }
  }
  return list
}

function parseRootRuleParams(params) {
  params = params.trim()
  let braceBlock = params.match(/^\((.*)\)$/)
  if (!braceBlock) {
    return { type: 'basic', selector: params }
  }
  let bits = braceBlock[1].match(/^(with(?:out)?):(.+)$/)
  if (bits) {
    let allowlist = bits[1] === 'with'
    let rules = Object.fromEntries(
      bits[2]
        .trim()
        .split(/\s+/)
        .map(name => [name, true])
    )
    if (allowlist && rules.all) {
      return { type: 'noop' }
    }
    let escapes = rule => !!rules[rule]
    if (rules.all) {
      escapes = () => true
    } else if (allowlist) {
      escapes = rule => (rule === 'all' ? false : !rules[rule])
    }

    return {
      type: 'withrules',
      escapes
    }
  }
  // Unrecognized brace block
  return { type: 'unknown' }
}

function getAncestorRules(leaf) {
  let lineage = []
  let parent = leaf.parent

  while (parent && parent instanceof AtRule) {
    lineage.push(parent)
    parent = parent.parent
  }
  return lineage
}

function unwrapRootRule(rule) {
  let escapes = rule[rootRuleEscapes]

  if (!escapes) {
    rule.after(rule.nodes)
  } else {
    let nodes = rule.nodes

    let topEscaped
    let topEscapedIdx = -1
    let breakoutLeaf
    let breakoutRoot
    let clone

    let lineage = getAncestorRules(rule)
    lineage.forEach((parent, i) => {
      if (escapes(parent.name)) {
        topEscaped = parent
        topEscapedIdx = i
        breakoutRoot = clone
      } else {
        let oldClone = clone
        clone = parent.clone({ nodes: [] })
        oldClone && clone.append(oldClone)
        breakoutLeaf = breakoutLeaf || clone
      }
    })

    if (!topEscaped) {
      rule.after(nodes)
    } else if (!breakoutRoot) {
      topEscaped.after(nodes)
    } else {
      let leaf = breakoutLeaf
      leaf.append(nodes)
      topEscaped.after(breakoutRoot)
    }

    if (rule.next() && topEscaped) {
      let restRoot
      lineage.slice(0, topEscapedIdx + 1).forEach((parent, i, arr) => {
        let oldRoot = restRoot
        restRoot = parent.clone({ nodes: [] })
        oldRoot && restRoot.append(oldRoot)

        let nextSibs = []
        let _child = arr[i - 1] || rule
        let next = _child.next()
        while (next) {
          nextSibs.push(next)
          next = next.next()
        }
        restRoot.append(nextSibs)
      })
      restRoot && (breakoutRoot || nodes[nodes.length - 1]).after(restRoot)
    }
  }

  rule.remove()
}

const rootRuleMergeSel = Symbol('rootRuleMergeSel')
const rootRuleEscapes = Symbol('rootRuleEscapes')

function normalizeRootRule(rule) {
  let { params } = rule
  let { type, selector, escapes } = parseRootRuleParams(params)
  if (type === 'unknown') {
    throw rule.error(
      `Unknown @${rule.name} parameter ${JSON.stringify(params)}`
    )
  }
  if (type === 'basic' && selector) {
    let selectorBlock = new Rule({ selector, nodes: rule.nodes })
    rule.removeAll()
    rule.append(selectorBlock)
  }
  rule[rootRuleEscapes] = escapes
  rule[rootRuleMergeSel] = escapes ? !escapes('all') : type === 'noop'
}

const hasRootRule = Symbol('hasRootRule')

module.exports = (opts = {}) => {
  let bubble = atruleNames(['media', 'supports', 'layer'], opts.bubble)
  let atruleChilds = createFnAtruleChilds(bubble)
  let unwrap = atruleNames(
    [
      'document',
      'font-face',
      'keyframes',
      '-webkit-keyframes',
      '-moz-keyframes'
    ],
    opts.unwrap
  )
  let rootRuleName = (opts.rootRuleName || 'at-root').replace(/^@/, '')
  let preserveEmpty = opts.preserveEmpty

  return {
    postcssPlugin: 'postcss-nested',

    Once(root) {
      root.walkAtRules(rootRuleName, node => {
        normalizeRootRule(node)
        root[hasRootRule] = true
      })
    },

    Rule(rule) {
      let unwrapped = false
      let after = rule
      let copyDeclarations = false
      let declarations = []

      rule.each(child => {
        if (child.type === 'rule') {
          if (declarations.length) {
            after = pickDeclarations(rule.selector, declarations, after)
            declarations = []
          }

          copyDeclarations = true
          unwrapped = true
          child.selectors = mergeSelectors(rule, child)
          after = breakOut(child, after)
        } else if (child.type === 'atrule') {
          if (declarations.length) {
            after = pickDeclarations(rule.selector, declarations, after)
            declarations = []
          }
          if (child.name === rootRuleName) {
            unwrapped = true
            atruleChilds(rule, child, true, child[rootRuleMergeSel])
            after = breakOut(child, after)
          } else if (bubble[child.name]) {
            copyDeclarations = true
            unwrapped = true
            atruleChilds(rule, child, true)
            after = breakOut(child, after)
          } else if (unwrap[child.name]) {
            copyDeclarations = true
            unwrapped = true
            atruleChilds(rule, child, false)
            after = breakOut(child, after)
          } else if (copyDeclarations) {
            declarations.push(child)
          }
        } else if (child.type === 'decl' && copyDeclarations) {
          declarations.push(child)
        }
      })

      if (declarations.length) {
        after = pickDeclarations(rule.selector, declarations, after)
      }

      if (unwrapped && preserveEmpty !== true) {
        rule.raws.semicolon = true
        if (rule.nodes.length === 0) rule.remove()
      }
    },

    RootExit(root) {
      if (root[hasRootRule]) {
        root.walkAtRules(rootRuleName, unwrapRootRule)
        root[hasRootRule] = false
      }
    }
  }
}
module.exports.postcss = true


/***/ }),

/***/ 32997:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _processor = _interopRequireDefault(__nccwpck_require__(10390));

var selectors = _interopRequireWildcard(__nccwpck_require__(31483));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var parser = function parser(processor) {
  return new _processor["default"](processor);
};

Object.assign(parser, selectors);
delete parser.__esModule;
var _default = parser;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),

/***/ 68526:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _root = _interopRequireDefault(__nccwpck_require__(74804));

var _selector = _interopRequireDefault(__nccwpck_require__(97370));

var _className = _interopRequireDefault(__nccwpck_require__(9780));

var _comment = _interopRequireDefault(__nccwpck_require__(90974));

var _id = _interopRequireDefault(__nccwpck_require__(12050));

var _tag = _interopRequireDefault(__nccwpck_require__(99646));

var _string = _interopRequireDefault(__nccwpck_require__(62391));

var _pseudo = _interopRequireDefault(__nccwpck_require__(28681));

var _attribute = _interopRequireWildcard(__nccwpck_require__(90326));

var _universal = _interopRequireDefault(__nccwpck_require__(14843));

var _combinator = _interopRequireDefault(__nccwpck_require__(8765));

var _nesting = _interopRequireDefault(__nccwpck_require__(52821));

var _sortAscending = _interopRequireDefault(__nccwpck_require__(18520));

var _tokenize = _interopRequireWildcard(__nccwpck_require__(53370));

var tokens = _interopRequireWildcard(__nccwpck_require__(26684));

var types = _interopRequireWildcard(__nccwpck_require__(86895));

var _util = __nccwpck_require__(73621);

var _WHITESPACE_TOKENS, _Object$assign;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));

function tokenStart(token) {
  return {
    line: token[_tokenize.FIELDS.START_LINE],
    column: token[_tokenize.FIELDS.START_COL]
  };
}

function tokenEnd(token) {
  return {
    line: token[_tokenize.FIELDS.END_LINE],
    column: token[_tokenize.FIELDS.END_COL]
  };
}

function getSource(startLine, startColumn, endLine, endColumn) {
  return {
    start: {
      line: startLine,
      column: startColumn
    },
    end: {
      line: endLine,
      column: endColumn
    }
  };
}

function getTokenSource(token) {
  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
}

function getTokenSourceSpan(startToken, endToken) {
  if (!startToken) {
    return undefined;
  }

  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
}

function unescapeProp(node, prop) {
  var value = node[prop];

  if (typeof value !== "string") {
    return;
  }

  if (value.indexOf("\\") !== -1) {
    (0, _util.ensureObject)(node, 'raws');
    node[prop] = (0, _util.unesc)(value);

    if (node.raws[prop] === undefined) {
      node.raws[prop] = value;
    }
  }

  return node;
}

function indexesOf(array, item) {
  var i = -1;
  var indexes = [];

  while ((i = array.indexOf(item, i + 1)) !== -1) {
    indexes.push(i);
  }

  return indexes;
}

function uniqs() {
  var list = Array.prototype.concat.apply([], arguments);
  return list.filter(function (item, i) {
    return i === list.indexOf(item);
  });
}

var Parser = /*#__PURE__*/function () {
  function Parser(rule, options) {
    if (options === void 0) {
      options = {};
    }

    this.rule = rule;
    this.options = Object.assign({
      lossy: false,
      safe: false
    }, options);
    this.position = 0;
    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;
    this.tokens = (0, _tokenize["default"])({
      css: this.css,
      error: this._errorGenerator(),
      safe: this.options.safe
    });
    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
    this.root = new _root["default"]({
      source: rootSource
    });
    this.root.errorGenerator = this._errorGenerator();
    var selector = new _selector["default"]({
      source: {
        start: {
          line: 1,
          column: 1
        }
      }
    });
    this.root.append(selector);
    this.current = selector;
    this.loop();
  }

  var _proto = Parser.prototype;

  _proto._errorGenerator = function _errorGenerator() {
    var _this = this;

    return function (message, errorOptions) {
      if (typeof _this.rule === 'string') {
        return new Error(message);
      }

      return _this.rule.error(message, errorOptions);
    };
  };

  _proto.attribute = function attribute() {
    var attr = [];
    var startingToken = this.currToken;
    this.position++;

    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
      attr.push(this.currToken);
      this.position++;
    }

    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
    }

    var len = attr.length;
    var node = {
      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
    };

    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);
    }

    var pos = 0;
    var spaceBefore = '';
    var commentBefore = '';
    var lastAdded = null;
    var spaceAfterMeaningfulToken = false;

    while (pos < len) {
      var token = attr[pos];
      var content = this.content(token);
      var next = attr[pos + 1];

      switch (token[_tokenize.FIELDS.TYPE]) {
        case tokens.space:
          // if (
          //     len === 1 ||
          //     pos === 0 && this.content(next) === '|'
          // ) {
          //     return this.expected('attribute', token[TOKEN.START_POS], content);
          // }
          spaceAfterMeaningfulToken = true;

          if (this.options.lossy) {
            break;
          }

          if (lastAdded) {
            (0, _util.ensureObject)(node, 'spaces', lastAdded);
            var prevContent = node.spaces[lastAdded].after || '';
            node.spaces[lastAdded].after = prevContent + content;
            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;

            if (existingComment) {
              node.raws.spaces[lastAdded].after = existingComment + content;
            }
          } else {
            spaceBefore = spaceBefore + content;
            commentBefore = commentBefore + content;
          }

          break;

        case tokens.asterisk:
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if ((!node.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
            if (spaceBefore) {
              (0, _util.ensureObject)(node, 'spaces', 'attribute');
              node.spaces.attribute.before = spaceBefore;
              spaceBefore = '';
            }

            if (commentBefore) {
              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
              node.raws.spaces.attribute.before = spaceBefore;
              commentBefore = '';
            }

            node.namespace = (node.namespace || "") + content;
            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;

            if (rawValue) {
              node.raws.namespace += content;
            }

            lastAdded = 'namespace';
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.dollar:
          if (lastAdded === "value") {
            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');
            node.value += "$";

            if (oldRawValue) {
              node.raws.value = oldRawValue + "$";
            }

            break;
          }

        // Falls through

        case tokens.caret:
          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.combinator:
          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          }

          if (content !== '|') {
            spaceAfterMeaningfulToken = false;
            break;
          }

          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
            node.operator = content;
            lastAdded = 'operator';
          } else if (!node.namespace && !node.attribute) {
            node.namespace = true;
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.word:
          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
          !node.operator && !node.namespace) {
            node.namespace = content;
            lastAdded = 'namespace';
          } else if (!node.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
            if (spaceBefore) {
              (0, _util.ensureObject)(node, 'spaces', 'attribute');
              node.spaces.attribute.before = spaceBefore;
              spaceBefore = '';
            }

            if (commentBefore) {
              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');
              node.raws.spaces.attribute.before = commentBefore;
              commentBefore = '';
            }

            node.attribute = (node.attribute || "") + content;

            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;

            if (_rawValue) {
              node.raws.attribute += content;
            }

            lastAdded = 'attribute';
          } else if (!node.value && node.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node.quoteMark)) {
            var _unescaped = (0, _util.unesc)(content);

            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';

            var oldValue = node.value || '';
            node.value = oldValue + _unescaped;
            node.quoteMark = null;

            if (_unescaped !== content || _oldRawValue) {
              (0, _util.ensureObject)(node, 'raws');
              node.raws.value = (_oldRawValue || oldValue) + content;
            }

            lastAdded = 'value';
          } else {
            var insensitive = content === 'i' || content === "I";

            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {
              node.insensitive = insensitive;

              if (!insensitive || content === "I") {
                (0, _util.ensureObject)(node, 'raws');
                node.raws.insensitiveFlag = content;
              }

              lastAdded = 'insensitive';

              if (spaceBefore) {
                (0, _util.ensureObject)(node, 'spaces', 'insensitive');
                node.spaces.insensitive.before = spaceBefore;
                spaceBefore = '';
              }

              if (commentBefore) {
                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');
                node.raws.spaces.insensitive.before = commentBefore;
                commentBefore = '';
              }
            } else if (node.value || node.value === '') {
              lastAdded = 'value';
              node.value += content;

              if (node.raws.value) {
                node.raws.value += content;
              }
            }
          }

          spaceAfterMeaningfulToken = false;
          break;

        case tokens.str:
          if (!node.attribute || !node.operator) {
            return this.error("Expected an attribute followed by an operator preceding the string.", {
              index: token[_tokenize.FIELDS.START_POS]
            });
          }

          var _unescapeValue = (0, _attribute.unescapeValue)(content),
              unescaped = _unescapeValue.unescaped,
              quoteMark = _unescapeValue.quoteMark;

          node.value = unescaped;
          node.quoteMark = quoteMark;
          lastAdded = 'value';
          (0, _util.ensureObject)(node, 'raws');
          node.raws.value = content;
          spaceAfterMeaningfulToken = false;
          break;

        case tokens.equals:
          if (!node.attribute) {
            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);
          }

          if (node.value) {
            return this.error('Unexpected "=" found; an operator was already defined.', {
              index: token[_tokenize.FIELDS.START_POS]
            });
          }

          node.operator = node.operator ? node.operator + content : content;
          lastAdded = 'operator';
          spaceAfterMeaningfulToken = false;
          break;

        case tokens.comment:
          if (lastAdded) {
            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {
              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';
              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;
              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);
              node.raws.spaces[lastAdded].after = rawLastComment + content;
            } else {
              var lastValue = node[lastAdded] || '';
              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;
              (0, _util.ensureObject)(node, 'raws');
              node.raws[lastAdded] = rawLastValue + content;
            }
          } else {
            commentBefore = commentBefore + content;
          }

          break;

        default:
          return this.error("Unexpected \"" + content + "\" found.", {
            index: token[_tokenize.FIELDS.START_POS]
          });
      }

      pos++;
    }

    unescapeProp(node, "attribute");
    unescapeProp(node, "namespace");
    this.newNode(new _attribute["default"](node));
    this.position++;
  }
  /**
   * return a node containing meaningless garbage up to (but not including) the specified token position.
   * if the token position is negative, all remaining tokens are consumed.
   *
   * This returns an array containing a single string node if all whitespace,
   * otherwise an array of comment nodes with space before and after.
   *
   * These tokens are not added to the current selector, the caller can add them or use them to amend
   * a previous node's space metadata.
   *
   * In lossy mode, this returns only comments.
   */
  ;

  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
    if (stopPosition < 0) {
      stopPosition = this.tokens.length;
    }

    var startPosition = this.position;
    var nodes = [];
    var space = "";
    var lastComment = undefined;

    do {
      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
        if (!this.options.lossy) {
          space += this.content();
        }
      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
        var spaces = {};

        if (space) {
          spaces.before = space;
          space = "";
        }

        lastComment = new _comment["default"]({
          value: this.content(),
          source: getTokenSource(this.currToken),
          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
          spaces: spaces
        });
        nodes.push(lastComment);
      }
    } while (++this.position < stopPosition);

    if (space) {
      if (lastComment) {
        lastComment.spaces.after = space;
      } else if (!this.options.lossy) {
        var firstToken = this.tokens[startPosition];
        var lastToken = this.tokens[this.position - 1];
        nodes.push(new _string["default"]({
          value: '',
          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
          spaces: {
            before: space,
            after: ''
          }
        }));
      }
    }

    return nodes;
  }
  /**
   *
   * @param {*} nodes
   */
  ;

  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
    var _this2 = this;

    if (requiredSpace === void 0) {
      requiredSpace = false;
    }

    var space = "";
    var rawSpace = "";
    nodes.forEach(function (n) {
      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);

      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);

      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
    });

    if (rawSpace === space) {
      rawSpace = undefined;
    }

    var result = {
      space: space,
      rawSpace: rawSpace
    };
    return result;
  };

  _proto.isNamedCombinator = function isNamedCombinator(position) {
    if (position === void 0) {
      position = this.position;
    }

    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
  };

  _proto.namedCombinator = function namedCombinator() {
    if (this.isNamedCombinator()) {
      var nameRaw = this.content(this.tokens[this.position + 1]);
      var name = (0, _util.unesc)(nameRaw).toLowerCase();
      var raws = {};

      if (name !== nameRaw) {
        raws.value = "/" + nameRaw + "/";
      }

      var node = new _combinator["default"]({
        value: "/" + name + "/",
        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
        raws: raws
      });
      this.position = this.position + 3;
      return node;
    } else {
      this.unexpected();
    }
  };

  _proto.combinator = function combinator() {
    var _this3 = this;

    if (this.content() === '|') {
      return this.namespace();
    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.


    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);

    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);

      if (nodes.length > 0) {
        var last = this.current.last;

        if (last) {
          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),
              space = _this$convertWhitespa.space,
              rawSpace = _this$convertWhitespa.rawSpace;

          if (rawSpace !== undefined) {
            last.rawSpaceAfter += rawSpace;
          }

          last.spaces.after += space;
        } else {
          nodes.forEach(function (n) {
            return _this3.newNode(n);
          });
        }
      }

      return;
    }

    var firstToken = this.currToken;
    var spaceOrDescendantSelectorNodes = undefined;

    if (nextSigTokenPos > this.position) {
      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
    }

    var node;

    if (this.isNamedCombinator()) {
      node = this.namedCombinator();
    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
      node = new _combinator["default"]({
        value: this.content(),
        source: getTokenSource(this.currToken),
        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
      });
      this.position++;
    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass
    } else if (!spaceOrDescendantSelectorNodes) {
      this.unexpected();
    }

    if (node) {
      if (spaceOrDescendantSelectorNodes) {
        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),
            _space = _this$convertWhitespa2.space,
            _rawSpace = _this$convertWhitespa2.rawSpace;

        node.spaces.before = _space;
        node.rawSpaceBefore = _rawSpace;
      }
    } else {
      // descendant combinator
      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),
          _space2 = _this$convertWhitespa3.space,
          _rawSpace2 = _this$convertWhitespa3.rawSpace;

      if (!_rawSpace2) {
        _rawSpace2 = _space2;
      }

      var spaces = {};
      var raws = {
        spaces: {}
      };

      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {
        spaces.before = _space2.slice(0, _space2.length - 1);
        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {
        spaces.after = _space2.slice(1);
        raws.spaces.after = _rawSpace2.slice(1);
      } else {
        raws.value = _rawSpace2;
      }

      node = new _combinator["default"]({
        value: ' ',
        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
        spaces: spaces,
        raws: raws
      });
    }

    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
      node.spaces.after = this.optionalSpace(this.content());
      this.position++;
    }

    return this.newNode(node);
  };

  _proto.comma = function comma() {
    if (this.position === this.tokens.length - 1) {
      this.root.trailingComma = true;
      this.position++;
      return;
    }

    this.current._inferEndPosition();

    var selector = new _selector["default"]({
      source: {
        start: tokenStart(this.tokens[this.position + 1])
      }
    });
    this.current.parent.append(selector);
    this.current = selector;
    this.position++;
  };

  _proto.comment = function comment() {
    var current = this.currToken;
    this.newNode(new _comment["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };

  _proto.error = function error(message, opts) {
    throw this.root.error(message, opts);
  };

  _proto.missingBackslash = function missingBackslash() {
    return this.error('Expected a backslash preceding the semicolon.', {
      index: this.currToken[_tokenize.FIELDS.START_POS]
    });
  };

  _proto.missingParenthesis = function missingParenthesis() {
    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
  };

  _proto.missingSquareBracket = function missingSquareBracket() {
    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);
  };

  _proto.unexpected = function unexpected() {
    return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
  };

  _proto.namespace = function namespace() {
    var before = this.prevToken && this.content(this.prevToken) || true;

    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
      this.position++;
      return this.word(before);
    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
      this.position++;
      return this.universal(before);
    }
  };

  _proto.nesting = function nesting() {
    if (this.nextToken) {
      var nextContent = this.content(this.nextToken);

      if (nextContent === "|") {
        this.position++;
        return;
      }
    }

    var current = this.currToken;
    this.newNode(new _nesting["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };

  _proto.parentheses = function parentheses() {
    var last = this.current.last;
    var unbalanced = 1;
    this.position++;

    if (last && last.type === types.PSEUDO) {
      var selector = new _selector["default"]({
        source: {
          start: tokenStart(this.tokens[this.position - 1])
        }
      });
      var cache = this.current;
      last.append(selector);
      this.current = selector;

      while (this.position < this.tokens.length && unbalanced) {
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          unbalanced++;
        }

        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          unbalanced--;
        }

        if (unbalanced) {
          this.parse();
        } else {
          this.current.source.end = tokenEnd(this.currToken);
          this.current.parent.source.end = tokenEnd(this.currToken);
          this.position++;
        }
      }

      this.current = cache;
    } else {
      // I think this case should be an error. It's used to implement a basic parse of media queries
      // but I don't think it's a good idea.
      var parenStart = this.currToken;
      var parenValue = "(";
      var parenEnd;

      while (this.position < this.tokens.length && unbalanced) {
        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          unbalanced++;
        }

        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
          unbalanced--;
        }

        parenEnd = this.currToken;
        parenValue += this.parseParenthesisToken(this.currToken);
        this.position++;
      }

      if (last) {
        last.appendToPropertyAndEscape("value", parenValue, parenValue);
      } else {
        this.newNode(new _string["default"]({
          value: parenValue,
          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
        }));
      }
    }

    if (unbalanced) {
      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);
    }
  };

  _proto.pseudo = function pseudo() {
    var _this4 = this;

    var pseudoStr = '';
    var startingToken = this.currToken;

    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
      pseudoStr += this.content();
      this.position++;
    }

    if (!this.currToken) {
      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);
    }

    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
      this.splitWord(false, function (first, length) {
        pseudoStr += first;

        _this4.newNode(new _pseudo["default"]({
          value: pseudoStr,
          source: getTokenSourceSpan(startingToken, _this4.currToken),
          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
        }));

        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
          _this4.error('Misplaced parenthesis.', {
            index: _this4.nextToken[_tokenize.FIELDS.START_POS]
          });
        }
      });
    } else {
      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);
    }
  };

  _proto.space = function space() {
    var content = this.content(); // Handle space before and after the selector

    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {
      return node.type === 'comment';
    })) {
      this.spaces = this.optionalSpace(content);
      this.position++;
    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
      this.current.last.spaces.after = this.optionalSpace(content);
      this.position++;
    } else {
      this.combinator();
    }
  };

  _proto.string = function string() {
    var current = this.currToken;
    this.newNode(new _string["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }));
    this.position++;
  };

  _proto.universal = function universal(namespace) {
    var nextToken = this.nextToken;

    if (nextToken && this.content(nextToken) === '|') {
      this.position++;
      return this.namespace();
    }

    var current = this.currToken;
    this.newNode(new _universal["default"]({
      value: this.content(),
      source: getTokenSource(current),
      sourceIndex: current[_tokenize.FIELDS.START_POS]
    }), namespace);
    this.position++;
  };

  _proto.splitWord = function splitWord(namespace, firstCallback) {
    var _this5 = this;

    var nextToken = this.nextToken;
    var word = this.content();

    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
      this.position++;
      var current = this.content();
      word += current;

      if (current.lastIndexOf('\\') === current.length - 1) {
        var next = this.nextToken;

        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
          word += this.requiredSpace(this.content(next));
          this.position++;
        }
      }

      nextToken = this.nextToken;
    }

    var hasClass = indexesOf(word, '.').filter(function (i) {
      // Allow escaped dot within class name
      var escapedDot = word[i - 1] === '\\'; // Allow decimal numbers percent in @keyframes

      var isKeyframesPercent = /^\d+\.\d+%$/.test(word);
      return !escapedDot && !isKeyframesPercent;
    });
    var hasId = indexesOf(word, '#').filter(function (i) {
      return word[i - 1] !== '\\';
    }); // Eliminate Sass interpolations from the list of id indexes

    var interpolations = indexesOf(word, '#{');

    if (interpolations.length) {
      hasId = hasId.filter(function (hashIndex) {
        return !~interpolations.indexOf(hashIndex);
      });
    }

    var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
    indices.forEach(function (ind, i) {
      var index = indices[i + 1] || word.length;
      var value = word.slice(ind, index);

      if (i === 0 && firstCallback) {
        return firstCallback.call(_this5, value, indices.length);
      }

      var node;
      var current = _this5.currToken;
      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];
      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));

      if (~hasClass.indexOf(ind)) {
        var classNameOpts = {
          value: value.slice(1),
          source: source,
          sourceIndex: sourceIndex
        };
        node = new _className["default"](unescapeProp(classNameOpts, "value"));
      } else if (~hasId.indexOf(ind)) {
        var idOpts = {
          value: value.slice(1),
          source: source,
          sourceIndex: sourceIndex
        };
        node = new _id["default"](unescapeProp(idOpts, "value"));
      } else {
        var tagOpts = {
          value: value,
          source: source,
          sourceIndex: sourceIndex
        };
        unescapeProp(tagOpts, "value");
        node = new _tag["default"](tagOpts);
      }

      _this5.newNode(node, namespace); // Ensure that the namespace is used only once


      namespace = null;
    });
    this.position++;
  };

  _proto.word = function word(namespace) {
    var nextToken = this.nextToken;

    if (nextToken && this.content(nextToken) === '|') {
      this.position++;
      return this.namespace();
    }

    return this.splitWord(namespace);
  };

  _proto.loop = function loop() {
    while (this.position < this.tokens.length) {
      this.parse(true);
    }

    this.current._inferEndPosition();

    return this.root;
  };

  _proto.parse = function parse(throwOnParenthesis) {
    switch (this.currToken[_tokenize.FIELDS.TYPE]) {
      case tokens.space:
        this.space();
        break;

      case tokens.comment:
        this.comment();
        break;

      case tokens.openParenthesis:
        this.parentheses();
        break;

      case tokens.closeParenthesis:
        if (throwOnParenthesis) {
          this.missingParenthesis();
        }

        break;

      case tokens.openSquare:
        this.attribute();
        break;

      case tokens.dollar:
      case tokens.caret:
      case tokens.equals:
      case tokens.word:
        this.word();
        break;

      case tokens.colon:
        this.pseudo();
        break;

      case tokens.comma:
        this.comma();
        break;

      case tokens.asterisk:
        this.universal();
        break;

      case tokens.ampersand:
        this.nesting();
        break;

      case tokens.slash:
      case tokens.combinator:
        this.combinator();
        break;

      case tokens.str:
        this.string();
        break;
      // These cases throw; no break needed.

      case tokens.closeSquare:
        this.missingSquareBracket();

      case tokens.semicolon:
        this.missingBackslash();

      default:
        this.unexpected();
    }
  }
  /**
   * Helpers
   */
  ;

  _proto.expected = function expected(description, index, found) {
    if (Array.isArray(description)) {
      var last = description.pop();
      description = description.join(', ') + " or " + last;
    }

    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';

    if (!found) {
      return this.error("Expected " + an + " " + description + ".", {
        index: index
      });
    }

    return this.error("Expected " + an + " " + description + ", found \"" + found + "\" instead.", {
      index: index
    });
  };

  _proto.requiredSpace = function requiredSpace(space) {
    return this.options.lossy ? ' ' : space;
  };

  _proto.optionalSpace = function optionalSpace(space) {
    return this.options.lossy ? '' : space;
  };

  _proto.lossySpace = function lossySpace(space, required) {
    if (this.options.lossy) {
      return required ? ' ' : '';
    } else {
      return space;
    }
  };

  _proto.parseParenthesisToken = function parseParenthesisToken(token) {
    var content = this.content(token);

    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
      return this.requiredSpace(content);
    } else {
      return content;
    }
  };

  _proto.newNode = function newNode(node, namespace) {
    if (namespace) {
      if (/^ +$/.test(namespace)) {
        if (!this.options.lossy) {
          this.spaces = (this.spaces || '') + namespace;
        }

        namespace = true;
      }

      node.namespace = namespace;
      unescapeProp(node, "namespace");
    }

    if (this.spaces) {
      node.spaces.before = this.spaces;
      this.spaces = '';
    }

    return this.current.append(node);
  };

  _proto.content = function content(token) {
    if (token === void 0) {
      token = this.currToken;
    }

    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
  };

  /**
   * returns the index of the next non-whitespace, non-comment token.
   * returns -1 if no meaningful token is found.
   */
  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
    if (startPosition === void 0) {
      startPosition = this.position + 1;
    }

    var searchPosition = startPosition;

    while (searchPosition < this.tokens.length) {
      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
        searchPosition++;
        continue;
      } else {
        return searchPosition;
      }
    }

    return -1;
  };

  _createClass(Parser, [{
    key: "currToken",
    get: function get() {
      return this.tokens[this.position];
    }
  }, {
    key: "nextToken",
    get: function get() {
      return this.tokens[this.position + 1];
    }
  }, {
    key: "prevToken",
    get: function get() {
      return this.tokens[this.position - 1];
    }
  }]);

  return Parser;
}();

exports["default"] = Parser;
module.exports = exports.default;

/***/ }),

/***/ 10390:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _parser = _interopRequireDefault(__nccwpck_require__(68526));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var Processor = /*#__PURE__*/function () {
  function Processor(func, options) {
    this.func = func || function noop() {};

    this.funcRes = null;
    this.options = options;
  }

  var _proto = Processor.prototype;

  _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule, options) {
    if (options === void 0) {
      options = {};
    }

    var merged = Object.assign({}, this.options, options);

    if (merged.updateSelector === false) {
      return false;
    } else {
      return typeof rule !== "string";
    }
  };

  _proto._isLossy = function _isLossy(options) {
    if (options === void 0) {
      options = {};
    }

    var merged = Object.assign({}, this.options, options);

    if (merged.lossless === false) {
      return true;
    } else {
      return false;
    }
  };

  _proto._root = function _root(rule, options) {
    if (options === void 0) {
      options = {};
    }

    var parser = new _parser["default"](rule, this._parseOptions(options));
    return parser.root;
  };

  _proto._parseOptions = function _parseOptions(options) {
    return {
      lossy: this._isLossy(options)
    };
  };

  _proto._run = function _run(rule, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    return new Promise(function (resolve, reject) {
      try {
        var root = _this._root(rule, options);

        Promise.resolve(_this.func(root)).then(function (transform) {
          var string = undefined;

          if (_this._shouldUpdateSelector(rule, options)) {
            string = root.toString();
            rule.selector = string;
          }

          return {
            transform: transform,
            root: root,
            string: string
          };
        }).then(resolve, reject);
      } catch (e) {
        reject(e);
        return;
      }
    });
  };

  _proto._runSync = function _runSync(rule, options) {
    if (options === void 0) {
      options = {};
    }

    var root = this._root(rule, options);

    var transform = this.func(root);

    if (transform && typeof transform.then === "function") {
      throw new Error("Selector processor returned a promise to a synchronous call.");
    }

    var string = undefined;

    if (options.updateSelector && typeof rule !== "string") {
      string = root.toString();
      rule.selector = string;
    }

    return {
      transform: transform,
      root: root,
      string: string
    };
  }
  /**
   * Process rule into a selector AST.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {Promise<parser.Root>} The AST of the selector after processing it.
   */
  ;

  _proto.ast = function ast(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.root;
    });
  }
  /**
   * Process rule into a selector AST synchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {parser.Root} The AST of the selector after processing it.
   */
  ;

  _proto.astSync = function astSync(rule, options) {
    return this._runSync(rule, options).root;
  }
  /**
   * Process a selector into a transformed value asynchronously
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {Promise<any>} The value returned by the processor.
   */
  ;

  _proto.transform = function transform(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.transform;
    });
  }
  /**
   * Process a selector into a transformed value synchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {any} The value returned by the processor.
   */
  ;

  _proto.transformSync = function transformSync(rule, options) {
    return this._runSync(rule, options).transform;
  }
  /**
   * Process a selector into a new selector string asynchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {string} the selector after processing.
   */
  ;

  _proto.process = function process(rule, options) {
    return this._run(rule, options).then(function (result) {
      return result.string || result.root.toString();
    });
  }
  /**
   * Process a selector into a new selector string synchronously.
   *
   * @param rule {postcss.Rule | string} The css selector to be processed
   * @param options The options for processing
   * @returns {string} the selector after processing.
   */
  ;

  _proto.processSync = function processSync(rule, options) {
    var result = this._runSync(rule, options);

    return result.string || result.root.toString();
  };

  return Processor;
}();

exports["default"] = Processor;
module.exports = exports.default;

/***/ }),

/***/ 90326:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.unescapeValue = unescapeValue;
exports["default"] = void 0;

var _cssesc = _interopRequireDefault(__nccwpck_require__(63120));

var _unesc = _interopRequireDefault(__nccwpck_require__(2897));

var _namespace = _interopRequireDefault(__nccwpck_require__(65669));

var _types = __nccwpck_require__(86895);

var _CSSESC_QUOTE_OPTIONS;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var deprecate = __nccwpck_require__(65278);

var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
var warnOfDeprecatedValueAssignment = deprecate(function () {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. " + "Call attribute.setValue() instead.");
var warnOfDeprecatedQuotedAssignment = deprecate(function () {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
var warnOfDeprecatedConstructor = deprecate(function () {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");

function unescapeValue(value) {
  var deprecatedUsage = false;
  var quoteMark = null;
  var unescaped = value;
  var m = unescaped.match(WRAPPED_IN_QUOTES);

  if (m) {
    quoteMark = m[1];
    unescaped = m[2];
  }

  unescaped = (0, _unesc["default"])(unescaped);

  if (unescaped !== value) {
    deprecatedUsage = true;
  }

  return {
    deprecatedUsage: deprecatedUsage,
    unescaped: unescaped,
    quoteMark: quoteMark
  };
}

function handleDeprecatedContructorOpts(opts) {
  if (opts.quoteMark !== undefined) {
    return opts;
  }

  if (opts.value === undefined) {
    return opts;
  }

  warnOfDeprecatedConstructor();

  var _unescapeValue = unescapeValue(opts.value),
      quoteMark = _unescapeValue.quoteMark,
      unescaped = _unescapeValue.unescaped;

  if (!opts.raws) {
    opts.raws = {};
  }

  if (opts.raws.value === undefined) {
    opts.raws.value = opts.value;
  }

  opts.value = unescaped;
  opts.quoteMark = quoteMark;
  return opts;
}

var Attribute = /*#__PURE__*/function (_Namespace) {
  _inheritsLoose(Attribute, _Namespace);

  function Attribute(opts) {
    var _this;

    if (opts === void 0) {
      opts = {};
    }

    _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
    _this.type = _types.ATTRIBUTE;
    _this.raws = _this.raws || {};
    Object.defineProperty(_this.raws, 'unquoted', {
      get: deprecate(function () {
        return _this.value;
      }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
      set: deprecate(function () {
        return _this.value;
      }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
    });
    _this._constructed = true;
    return _this;
  }
  /**
   * Returns the Attribute's value quoted such that it would be legal to use
   * in the value of a css file. The original value's quotation setting
   * used for stringification is left unchanged. See `setValue(value, options)`
   * if you want to control the quote settings of a new value for the attribute.
   *
   * You can also change the quotation used for the current value by setting quoteMark.
   *
   * Options:
   *   * quoteMark {'"' | "'" | null} - Use this value to quote the value. If this
   *     option is not set, the original value for quoteMark will be used. If
   *     indeterminate, a double quote is used. The legal values are:
   *     * `null` - the value will be unquoted and characters will be escaped as necessary.
   *     * `'` - the value will be quoted with a single quote and single quotes are escaped.
   *     * `"` - the value will be quoted with a double quote and double quotes are escaped.
   *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark
   *     over the quoteMark option value.
   *   * smart {boolean} - if true, will select a quote mark based on the value
   *     and the other options specified here. See the `smartQuoteMark()`
   *     method.
   **/


  var _proto = Attribute.prototype;

  _proto.getQuotedValue = function getQuotedValue(options) {
    if (options === void 0) {
      options = {};
    }

    var quoteMark = this._determineQuoteMark(options);

    var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
    var escaped = (0, _cssesc["default"])(this._value, cssescopts);
    return escaped;
  };

  _proto._determineQuoteMark = function _determineQuoteMark(options) {
    return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);
  }
  /**
   * Set the unescaped value with the specified quotation options. The value
   * provided must not include any wrapping quote marks -- those quotes will
   * be interpreted as part of the value and escaped accordingly.
   */
  ;

  _proto.setValue = function setValue(value, options) {
    if (options === void 0) {
      options = {};
    }

    this._value = value;
    this._quoteMark = this._determineQuoteMark(options);

    this._syncRawValue();
  }
  /**
   * Intelligently select a quoteMark value based on the value's contents. If
   * the value is a legal CSS ident, it will not be quoted. Otherwise a quote
   * mark will be picked that minimizes the number of escapes.
   *
   * If there's no clear winner, the quote mark from these options is used,
   * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is
   * true). If the quoteMark is unspecified, a double quote is used.
   *
   * @param options This takes the quoteMark and preferCurrentQuoteMark options
   * from the quoteValue method.
   */
  ;

  _proto.smartQuoteMark = function smartQuoteMark(options) {
    var v = this.value;
    var numSingleQuotes = v.replace(/[^']/g, '').length;
    var numDoubleQuotes = v.replace(/[^"]/g, '').length;

    if (numSingleQuotes + numDoubleQuotes === 0) {
      var escaped = (0, _cssesc["default"])(v, {
        isIdentifier: true
      });

      if (escaped === v) {
        return Attribute.NO_QUOTE;
      } else {
        var pref = this.preferredQuoteMark(options);

        if (pref === Attribute.NO_QUOTE) {
          // pick a quote mark that isn't none and see if it's smaller
          var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;
          var opts = CSSESC_QUOTE_OPTIONS[quote];
          var quoteValue = (0, _cssesc["default"])(v, opts);

          if (quoteValue.length < escaped.length) {
            return quote;
          }
        }

        return pref;
      }
    } else if (numDoubleQuotes === numSingleQuotes) {
      return this.preferredQuoteMark(options);
    } else if (numDoubleQuotes < numSingleQuotes) {
      return Attribute.DOUBLE_QUOTE;
    } else {
      return Attribute.SINGLE_QUOTE;
    }
  }
  /**
   * Selects the preferred quote mark based on the options and the current quote mark value.
   * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`
   * instead.
   */
  ;

  _proto.preferredQuoteMark = function preferredQuoteMark(options) {
    var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;

    if (quoteMark === undefined) {
      quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;
    }

    if (quoteMark === undefined) {
      quoteMark = Attribute.DOUBLE_QUOTE;
    }

    return quoteMark;
  };

  _proto._syncRawValue = function _syncRawValue() {
    var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);

    if (rawValue === this._value) {
      if (this.raws) {
        delete this.raws.value;
      }
    } else {
      this.raws.value = rawValue;
    }
  };

  _proto._handleEscapes = function _handleEscapes(prop, value) {
    if (this._constructed) {
      var escaped = (0, _cssesc["default"])(value, {
        isIdentifier: true
      });

      if (escaped !== value) {
        this.raws[prop] = escaped;
      } else {
        delete this.raws[prop];
      }
    }
  };

  _proto._spacesFor = function _spacesFor(name) {
    var attrSpaces = {
      before: '',
      after: ''
    };
    var spaces = this.spaces[name] || {};
    var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};
    return Object.assign(attrSpaces, spaces, rawSpaces);
  };

  _proto._stringFor = function _stringFor(name, spaceName, concat) {
    if (spaceName === void 0) {
      spaceName = name;
    }

    if (concat === void 0) {
      concat = defaultAttrConcat;
    }

    var attrSpaces = this._spacesFor(spaceName);

    return concat(this.stringifyProperty(name), attrSpaces);
  }
  /**
   * returns the offset of the attribute part specified relative to the
   * start of the node of the output string.
   *
   * * "ns" - alias for "namespace"
   * * "namespace" - the namespace if it exists.
   * * "attribute" - the attribute name
   * * "attributeNS" - the start of the attribute or its namespace
   * * "operator" - the match operator of the attribute
   * * "value" - The value (string or identifier)
   * * "insensitive" - the case insensitivity flag;
   * @param part One of the possible values inside an attribute.
   * @returns -1 if the name is invalid or the value doesn't exist in this attribute.
   */
  ;

  _proto.offsetOf = function offsetOf(name) {
    var count = 1;

    var attributeSpaces = this._spacesFor("attribute");

    count += attributeSpaces.before.length;

    if (name === "namespace" || name === "ns") {
      return this.namespace ? count : -1;
    }

    if (name === "attributeNS") {
      return count;
    }

    count += this.namespaceString.length;

    if (this.namespace) {
      count += 1;
    }

    if (name === "attribute") {
      return count;
    }

    count += this.stringifyProperty("attribute").length;
    count += attributeSpaces.after.length;

    var operatorSpaces = this._spacesFor("operator");

    count += operatorSpaces.before.length;
    var operator = this.stringifyProperty("operator");

    if (name === "operator") {
      return operator ? count : -1;
    }

    count += operator.length;
    count += operatorSpaces.after.length;

    var valueSpaces = this._spacesFor("value");

    count += valueSpaces.before.length;
    var value = this.stringifyProperty("value");

    if (name === "value") {
      return value ? count : -1;
    }

    count += value.length;
    count += valueSpaces.after.length;

    var insensitiveSpaces = this._spacesFor("insensitive");

    count += insensitiveSpaces.before.length;

    if (name === "insensitive") {
      return this.insensitive ? count : -1;
    }

    return -1;
  };

  _proto.toString = function toString() {
    var _this2 = this;

    var selector = [this.rawSpaceBefore, '['];
    selector.push(this._stringFor('qualifiedAttribute', 'attribute'));

    if (this.operator && (this.value || this.value === '')) {
      selector.push(this._stringFor('operator'));
      selector.push(this._stringFor('value'));
      selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {
        if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
          attrSpaces.before = " ";
        }

        return defaultAttrConcat(attrValue, attrSpaces);
      }));
    }

    selector.push(']');
    selector.push(this.rawSpaceAfter);
    return selector.join('');
  };

  _createClass(Attribute, [{
    key: "quoted",
    get: function get() {
      var qm = this.quoteMark;
      return qm === "'" || qm === '"';
    },
    set: function set(value) {
      warnOfDeprecatedQuotedAssignment();
    }
    /**
     * returns a single (`'`) or double (`"`) quote character if the value is quoted.
     * returns `null` if the value is not quoted.
     * returns `undefined` if the quotation state is unknown (this can happen when
     * the attribute is constructed without specifying a quote mark.)
     */

  }, {
    key: "quoteMark",
    get: function get() {
      return this._quoteMark;
    }
    /**
     * Set the quote mark to be used by this attribute's value.
     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute
     * value is updated accordingly.
     *
     * @param {"'" | '"' | null} quoteMark The quote mark or `null` if the value should be unquoted.
     */
    ,
    set: function set(quoteMark) {
      if (!this._constructed) {
        this._quoteMark = quoteMark;
        return;
      }

      if (this._quoteMark !== quoteMark) {
        this._quoteMark = quoteMark;

        this._syncRawValue();
      }
    }
  }, {
    key: "qualifiedAttribute",
    get: function get() {
      return this.qualifiedName(this.raws.attribute || this.attribute);
    }
  }, {
    key: "insensitiveFlag",
    get: function get() {
      return this.insensitive ? 'i' : '';
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    },
    set:
    /**
     * Before 3.0, the value had to be set to an escaped value including any wrapped
     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
     * is unescaped during parsing and any quote marks are removed.
     *
     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
     * a deprecation warning is raised when the new value contains any characters that would
     * require escaping (including if it contains wrapped quotes).
     *
     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
     * how the new value is quoted.
     */
    function set(v) {
      if (this._constructed) {
        var _unescapeValue2 = unescapeValue(v),
            deprecatedUsage = _unescapeValue2.deprecatedUsage,
            unescaped = _unescapeValue2.unescaped,
            quoteMark = _unescapeValue2.quoteMark;

        if (deprecatedUsage) {
          warnOfDeprecatedValueAssignment();
        }

        if (unescaped === this._value && quoteMark === this._quoteMark) {
          return;
        }

        this._value = unescaped;
        this._quoteMark = quoteMark;

        this._syncRawValue();
      } else {
        this._value = v;
      }
    }
  }, {
    key: "insensitive",
    get: function get() {
      return this._insensitive;
    }
    /**
     * Set the case insensitive flag.
     * If the case insensitive flag changes, the raw (escaped) value at `attr.raws.insensitiveFlag`
     * of the attribute is updated accordingly.
     *
     * @param {true | false} insensitive true if the attribute should match case-insensitively.
     */
    ,
    set: function set(insensitive) {
      if (!insensitive) {
        this._insensitive = false; // "i" and "I" can be used in "this.raws.insensitiveFlag" to store the original notation.
        // When setting `attr.insensitive = false` both should be erased to ensure correct serialization.

        if (this.raws && (this.raws.insensitiveFlag === 'I' || this.raws.insensitiveFlag === 'i')) {
          this.raws.insensitiveFlag = undefined;
        }
      }

      this._insensitive = insensitive;
    }
  }, {
    key: "attribute",
    get: function get() {
      return this._attribute;
    },
    set: function set(name) {
      this._handleEscapes("attribute", name);

      this._attribute = name;
    }
  }]);

  return Attribute;
}(_namespace["default"]);

exports["default"] = Attribute;
Attribute.NO_QUOTE = null;
Attribute.SINGLE_QUOTE = "'";
Attribute.DOUBLE_QUOTE = '"';
var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
  "'": {
    quotes: 'single',
    wrap: true
  },
  '"': {
    quotes: 'double',
    wrap: true
  }
}, _CSSESC_QUOTE_OPTIONS[null] = {
  isIdentifier: true
}, _CSSESC_QUOTE_OPTIONS);

function defaultAttrConcat(attrValue, attrSpaces) {
  return "" + attrSpaces.before + attrValue + attrSpaces.after;
}

/***/ }),

/***/ 9780:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _cssesc = _interopRequireDefault(__nccwpck_require__(63120));

var _util = __nccwpck_require__(73621);

var _node = _interopRequireDefault(__nccwpck_require__(83206));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ClassName = /*#__PURE__*/function (_Node) {
  _inheritsLoose(ClassName, _Node);

  function ClassName(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.CLASS;
    _this._constructed = true;
    return _this;
  }

  var _proto = ClassName.prototype;

  _proto.valueToString = function valueToString() {
    return '.' + _Node.prototype.valueToString.call(this);
  };

  _createClass(ClassName, [{
    key: "value",
    get: function get() {
      return this._value;
    },
    set: function set(v) {
      if (this._constructed) {
        var escaped = (0, _cssesc["default"])(v, {
          isIdentifier: true
        });

        if (escaped !== v) {
          (0, _util.ensureObject)(this, "raws");
          this.raws.value = escaped;
        } else if (this.raws) {
          delete this.raws.value;
        }
      }

      this._value = v;
    }
  }]);

  return ClassName;
}(_node["default"]);

exports["default"] = ClassName;
module.exports = exports.default;

/***/ }),

/***/ 8765:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__nccwpck_require__(83206));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Combinator = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Combinator, _Node);

  function Combinator(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.COMBINATOR;
    return _this;
  }

  return Combinator;
}(_node["default"]);

exports["default"] = Combinator;
module.exports = exports.default;

/***/ }),

/***/ 90974:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__nccwpck_require__(83206));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Comment = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Comment, _Node);

  function Comment(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.COMMENT;
    return _this;
  }

  return Comment;
}(_node["default"]);

exports["default"] = Comment;
module.exports = exports.default;

/***/ }),

/***/ 55850:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.universal = exports.tag = exports.string = exports.selector = exports.root = exports.pseudo = exports.nesting = exports.id = exports.comment = exports.combinator = exports.className = exports.attribute = void 0;

var _attribute = _interopRequireDefault(__nccwpck_require__(90326));

var _className = _interopRequireDefault(__nccwpck_require__(9780));

var _combinator = _interopRequireDefault(__nccwpck_require__(8765));

var _comment = _interopRequireDefault(__nccwpck_require__(90974));

var _id = _interopRequireDefault(__nccwpck_require__(12050));

var _nesting = _interopRequireDefault(__nccwpck_require__(52821));

var _pseudo = _interopRequireDefault(__nccwpck_require__(28681));

var _root = _interopRequireDefault(__nccwpck_require__(74804));

var _selector = _interopRequireDefault(__nccwpck_require__(97370));

var _string = _interopRequireDefault(__nccwpck_require__(62391));

var _tag = _interopRequireDefault(__nccwpck_require__(99646));

var _universal = _interopRequireDefault(__nccwpck_require__(14843));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var attribute = function attribute(opts) {
  return new _attribute["default"](opts);
};

exports.attribute = attribute;

var className = function className(opts) {
  return new _className["default"](opts);
};

exports.className = className;

var combinator = function combinator(opts) {
  return new _combinator["default"](opts);
};

exports.combinator = combinator;

var comment = function comment(opts) {
  return new _comment["default"](opts);
};

exports.comment = comment;

var id = function id(opts) {
  return new _id["default"](opts);
};

exports.id = id;

var nesting = function nesting(opts) {
  return new _nesting["default"](opts);
};

exports.nesting = nesting;

var pseudo = function pseudo(opts) {
  return new _pseudo["default"](opts);
};

exports.pseudo = pseudo;

var root = function root(opts) {
  return new _root["default"](opts);
};

exports.root = root;

var selector = function selector(opts) {
  return new _selector["default"](opts);
};

exports.selector = selector;

var string = function string(opts) {
  return new _string["default"](opts);
};

exports.string = string;

var tag = function tag(opts) {
  return new _tag["default"](opts);
};

exports.tag = tag;

var universal = function universal(opts) {
  return new _universal["default"](opts);
};

exports.universal = universal;

/***/ }),

/***/ 37240:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__nccwpck_require__(83206));

var types = _interopRequireWildcard(__nccwpck_require__(86895));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Container = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Container, _Node);

  function Container(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;

    if (!_this.nodes) {
      _this.nodes = [];
    }

    return _this;
  }

  var _proto = Container.prototype;

  _proto.append = function append(selector) {
    selector.parent = this;
    this.nodes.push(selector);
    return this;
  };

  _proto.prepend = function prepend(selector) {
    selector.parent = this;
    this.nodes.unshift(selector);
    return this;
  };

  _proto.at = function at(index) {
    return this.nodes[index];
  };

  _proto.index = function index(child) {
    if (typeof child === 'number') {
      return child;
    }

    return this.nodes.indexOf(child);
  };

  _proto.removeChild = function removeChild(child) {
    child = this.index(child);
    this.at(child).parent = undefined;
    this.nodes.splice(child, 1);
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (index >= child) {
        this.indexes[id] = index - 1;
      }
    }

    return this;
  };

  _proto.removeAll = function removeAll() {
    for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done;) {
      var node = _step.value;
      node.parent = undefined;
    }

    this.nodes = [];
    return this;
  };

  _proto.empty = function empty() {
    return this.removeAll();
  };

  _proto.insertAfter = function insertAfter(oldNode, newNode) {
    newNode.parent = this;
    var oldIndex = this.index(oldNode);
    this.nodes.splice(oldIndex + 1, 0, newNode);
    newNode.parent = this;
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (oldIndex <= index) {
        this.indexes[id] = index + 1;
      }
    }

    return this;
  };

  _proto.insertBefore = function insertBefore(oldNode, newNode) {
    newNode.parent = this;
    var oldIndex = this.index(oldNode);
    this.nodes.splice(oldIndex, 0, newNode);
    newNode.parent = this;
    var index;

    for (var id in this.indexes) {
      index = this.indexes[id];

      if (index <= oldIndex) {
        this.indexes[id] = index + 1;
      }
    }

    return this;
  };

  _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
    var found = undefined;
    this.each(function (node) {
      if (node.atPosition) {
        var foundChild = node.atPosition(line, col);

        if (foundChild) {
          found = foundChild;
          return false;
        }
      } else if (node.isAtPosition(line, col)) {
        found = node;
        return false;
      }
    });
    return found;
  }
  /**
   * Return the most specific node at the line and column number given.
   * The source location is based on the original parsed location, locations aren't
   * updated as selector nodes are mutated.
   * 
   * Note that this location is relative to the location of the first character
   * of the selector, and not the location of the selector in the overall document
   * when used in conjunction with postcss.
   *
   * If not found, returns undefined.
   * @param {number} line The line number of the node to find. (1-based index)
   * @param {number} col  The column number of the node to find. (1-based index)
   */
  ;

  _proto.atPosition = function atPosition(line, col) {
    if (this.isAtPosition(line, col)) {
      return this._findChildAtPosition(line, col) || this;
    } else {
      return undefined;
    }
  };

  _proto._inferEndPosition = function _inferEndPosition() {
    if (this.last && this.last.source && this.last.source.end) {
      this.source = this.source || {};
      this.source.end = this.source.end || {};
      Object.assign(this.source.end, this.last.source.end);
    }
  };

  _proto.each = function each(callback) {
    if (!this.lastEach) {
      this.lastEach = 0;
    }

    if (!this.indexes) {
      this.indexes = {};
    }

    this.lastEach++;
    var id = this.lastEach;
    this.indexes[id] = 0;

    if (!this.length) {
      return undefined;
    }

    var index, result;

    while (this.indexes[id] < this.length) {
      index = this.indexes[id];
      result = callback(this.at(index), index);

      if (result === false) {
        break;
      }

      this.indexes[id] += 1;
    }

    delete this.indexes[id];

    if (result === false) {
      return false;
    }
  };

  _proto.walk = function walk(callback) {
    return this.each(function (node, i) {
      var result = callback(node, i);

      if (result !== false && node.length) {
        result = node.walk(callback);
      }

      if (result === false) {
        return false;
      }
    });
  };

  _proto.walkAttributes = function walkAttributes(callback) {
    var _this2 = this;

    return this.walk(function (selector) {
      if (selector.type === types.ATTRIBUTE) {
        return callback.call(_this2, selector);
      }
    });
  };

  _proto.walkClasses = function walkClasses(callback) {
    var _this3 = this;

    return this.walk(function (selector) {
      if (selector.type === types.CLASS) {
        return callback.call(_this3, selector);
      }
    });
  };

  _proto.walkCombinators = function walkCombinators(callback) {
    var _this4 = this;

    return this.walk(function (selector) {
      if (selector.type === types.COMBINATOR) {
        return callback.call(_this4, selector);
      }
    });
  };

  _proto.walkComments = function walkComments(callback) {
    var _this5 = this;

    return this.walk(function (selector) {
      if (selector.type === types.COMMENT) {
        return callback.call(_this5, selector);
      }
    });
  };

  _proto.walkIds = function walkIds(callback) {
    var _this6 = this;

    return this.walk(function (selector) {
      if (selector.type === types.ID) {
        return callback.call(_this6, selector);
      }
    });
  };

  _proto.walkNesting = function walkNesting(callback) {
    var _this7 = this;

    return this.walk(function (selector) {
      if (selector.type === types.NESTING) {
        return callback.call(_this7, selector);
      }
    });
  };

  _proto.walkPseudos = function walkPseudos(callback) {
    var _this8 = this;

    return this.walk(function (selector) {
      if (selector.type === types.PSEUDO) {
        return callback.call(_this8, selector);
      }
    });
  };

  _proto.walkTags = function walkTags(callback) {
    var _this9 = this;

    return this.walk(function (selector) {
      if (selector.type === types.TAG) {
        return callback.call(_this9, selector);
      }
    });
  };

  _proto.walkUniversals = function walkUniversals(callback) {
    var _this10 = this;

    return this.walk(function (selector) {
      if (selector.type === types.UNIVERSAL) {
        return callback.call(_this10, selector);
      }
    });
  };

  _proto.split = function split(callback) {
    var _this11 = this;

    var current = [];
    return this.reduce(function (memo, node, index) {
      var split = callback.call(_this11, node);
      current.push(node);

      if (split) {
        memo.push(current);
        current = [];
      } else if (index === _this11.length - 1) {
        memo.push(current);
      }

      return memo;
    }, []);
  };

  _proto.map = function map(callback) {
    return this.nodes.map(callback);
  };

  _proto.reduce = function reduce(callback, memo) {
    return this.nodes.reduce(callback, memo);
  };

  _proto.every = function every(callback) {
    return this.nodes.every(callback);
  };

  _proto.some = function some(callback) {
    return this.nodes.some(callback);
  };

  _proto.filter = function filter(callback) {
    return this.nodes.filter(callback);
  };

  _proto.sort = function sort(callback) {
    return this.nodes.sort(callback);
  };

  _proto.toString = function toString() {
    return this.map(String).join('');
  };

  _createClass(Container, [{
    key: "first",
    get: function get() {
      return this.at(0);
    }
  }, {
    key: "last",
    get: function get() {
      return this.at(this.length - 1);
    }
  }, {
    key: "length",
    get: function get() {
      return this.nodes.length;
    }
  }]);

  return Container;
}(_node["default"]);

exports["default"] = Container;
module.exports = exports.default;

/***/ }),

/***/ 5873:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.isNode = isNode;
exports.isPseudoElement = isPseudoElement;
exports.isPseudoClass = isPseudoClass;
exports.isContainer = isContainer;
exports.isNamespace = isNamespace;
exports.isUniversal = exports.isTag = exports.isString = exports.isSelector = exports.isRoot = exports.isPseudo = exports.isNesting = exports.isIdentifier = exports.isComment = exports.isCombinator = exports.isClassName = exports.isAttribute = void 0;

var _types = __nccwpck_require__(86895);

var _IS_TYPE;

var IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);

function isNode(node) {
  return typeof node === "object" && IS_TYPE[node.type];
}

function isNodeType(type, node) {
  return isNode(node) && node.type === type;
}

var isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
exports.isAttribute = isAttribute;
var isClassName = isNodeType.bind(null, _types.CLASS);
exports.isClassName = isClassName;
var isCombinator = isNodeType.bind(null, _types.COMBINATOR);
exports.isCombinator = isCombinator;
var isComment = isNodeType.bind(null, _types.COMMENT);
exports.isComment = isComment;
var isIdentifier = isNodeType.bind(null, _types.ID);
exports.isIdentifier = isIdentifier;
var isNesting = isNodeType.bind(null, _types.NESTING);
exports.isNesting = isNesting;
var isPseudo = isNodeType.bind(null, _types.PSEUDO);
exports.isPseudo = isPseudo;
var isRoot = isNodeType.bind(null, _types.ROOT);
exports.isRoot = isRoot;
var isSelector = isNodeType.bind(null, _types.SELECTOR);
exports.isSelector = isSelector;
var isString = isNodeType.bind(null, _types.STRING);
exports.isString = isString;
var isTag = isNodeType.bind(null, _types.TAG);
exports.isTag = isTag;
var isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
exports.isUniversal = isUniversal;

function isPseudoElement(node) {
  return isPseudo(node) && node.value && (node.value.startsWith("::") || node.value.toLowerCase() === ":before" || node.value.toLowerCase() === ":after" || node.value.toLowerCase() === ":first-letter" || node.value.toLowerCase() === ":first-line");
}

function isPseudoClass(node) {
  return isPseudo(node) && !isPseudoElement(node);
}

function isContainer(node) {
  return !!(isNode(node) && node.walk);
}

function isNamespace(node) {
  return isAttribute(node) || isTag(node);
}

/***/ }),

/***/ 12050:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__nccwpck_require__(83206));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ID = /*#__PURE__*/function (_Node) {
  _inheritsLoose(ID, _Node);

  function ID(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.ID;
    return _this;
  }

  var _proto = ID.prototype;

  _proto.valueToString = function valueToString() {
    return '#' + _Node.prototype.valueToString.call(this);
  };

  return ID;
}(_node["default"]);

exports["default"] = ID;
module.exports = exports.default;

/***/ }),

/***/ 31483:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;

var _types = __nccwpck_require__(86895);

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _types[key]) return;
  exports[key] = _types[key];
});

var _constructors = __nccwpck_require__(55850);

Object.keys(_constructors).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _constructors[key]) return;
  exports[key] = _constructors[key];
});

var _guards = __nccwpck_require__(5873);

Object.keys(_guards).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _guards[key]) return;
  exports[key] = _guards[key];
});

/***/ }),

/***/ 65669:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _cssesc = _interopRequireDefault(__nccwpck_require__(63120));

var _util = __nccwpck_require__(73621);

var _node = _interopRequireDefault(__nccwpck_require__(83206));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Namespace = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Namespace, _Node);

  function Namespace() {
    return _Node.apply(this, arguments) || this;
  }

  var _proto = Namespace.prototype;

  _proto.qualifiedName = function qualifiedName(value) {
    if (this.namespace) {
      return this.namespaceString + "|" + value;
    } else {
      return value;
    }
  };

  _proto.valueToString = function valueToString() {
    return this.qualifiedName(_Node.prototype.valueToString.call(this));
  };

  _createClass(Namespace, [{
    key: "namespace",
    get: function get() {
      return this._namespace;
    },
    set: function set(namespace) {
      if (namespace === true || namespace === "*" || namespace === "&") {
        this._namespace = namespace;

        if (this.raws) {
          delete this.raws.namespace;
        }

        return;
      }

      var escaped = (0, _cssesc["default"])(namespace, {
        isIdentifier: true
      });
      this._namespace = namespace;

      if (escaped !== namespace) {
        (0, _util.ensureObject)(this, "raws");
        this.raws.namespace = escaped;
      } else if (this.raws) {
        delete this.raws.namespace;
      }
    }
  }, {
    key: "ns",
    get: function get() {
      return this._namespace;
    },
    set: function set(namespace) {
      this.namespace = namespace;
    }
  }, {
    key: "namespaceString",
    get: function get() {
      if (this.namespace) {
        var ns = this.stringifyProperty("namespace");

        if (ns === true) {
          return '';
        } else {
          return ns;
        }
      } else {
        return '';
      }
    }
  }]);

  return Namespace;
}(_node["default"]);

exports["default"] = Namespace;
;
module.exports = exports.default;

/***/ }),

/***/ 52821:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__nccwpck_require__(83206));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Nesting = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Nesting, _Node);

  function Nesting(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.NESTING;
    _this.value = '&';
    return _this;
  }

  return Nesting;
}(_node["default"]);

exports["default"] = Nesting;
module.exports = exports.default;

/***/ }),

/***/ 83206:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _util = __nccwpck_require__(73621);

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var cloneNode = function cloneNode(obj, parent) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  var cloned = new obj.constructor();

  for (var i in obj) {
    if (!obj.hasOwnProperty(i)) {
      continue;
    }

    var value = obj[i];
    var type = typeof value;

    if (i === 'parent' && type === 'object') {
      if (parent) {
        cloned[i] = parent;
      }
    } else if (value instanceof Array) {
      cloned[i] = value.map(function (j) {
        return cloneNode(j, cloned);
      });
    } else {
      cloned[i] = cloneNode(value, cloned);
    }
  }

  return cloned;
};

var Node = /*#__PURE__*/function () {
  function Node(opts) {
    if (opts === void 0) {
      opts = {};
    }

    Object.assign(this, opts);
    this.spaces = this.spaces || {};
    this.spaces.before = this.spaces.before || '';
    this.spaces.after = this.spaces.after || '';
  }

  var _proto = Node.prototype;

  _proto.remove = function remove() {
    if (this.parent) {
      this.parent.removeChild(this);
    }

    this.parent = undefined;
    return this;
  };

  _proto.replaceWith = function replaceWith() {
    if (this.parent) {
      for (var index in arguments) {
        this.parent.insertBefore(this, arguments[index]);
      }

      this.remove();
    }

    return this;
  };

  _proto.next = function next() {
    return this.parent.at(this.parent.index(this) + 1);
  };

  _proto.prev = function prev() {
    return this.parent.at(this.parent.index(this) - 1);
  };

  _proto.clone = function clone(overrides) {
    if (overrides === void 0) {
      overrides = {};
    }

    var cloned = cloneNode(this);

    for (var name in overrides) {
      cloned[name] = overrides[name];
    }

    return cloned;
  }
  /**
   * Some non-standard syntax doesn't follow normal escaping rules for css.
   * This allows non standard syntax to be appended to an existing property
   * by specifying the escaped value. By specifying the escaped value,
   * illegal characters are allowed to be directly inserted into css output.
   * @param {string} name the property to set
   * @param {any} value the unescaped value of the property
   * @param {string} valueEscaped optional. the escaped value of the property.
   */
  ;

  _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name, value, valueEscaped) {
    if (!this.raws) {
      this.raws = {};
    }

    var originalValue = this[name];
    var originalEscaped = this.raws[name];
    this[name] = originalValue + value; // this may trigger a setter that updates raws, so it has to be set first.

    if (originalEscaped || valueEscaped !== value) {
      this.raws[name] = (originalEscaped || originalValue) + valueEscaped;
    } else {
      delete this.raws[name]; // delete any escaped value that was created by the setter.
    }
  }
  /**
   * Some non-standard syntax doesn't follow normal escaping rules for css.
   * This allows the escaped value to be specified directly, allowing illegal
   * characters to be directly inserted into css output.
   * @param {string} name the property to set
   * @param {any} value the unescaped value of the property
   * @param {string} valueEscaped the escaped value of the property.
   */
  ;

  _proto.setPropertyAndEscape = function setPropertyAndEscape(name, value, valueEscaped) {
    if (!this.raws) {
      this.raws = {};
    }

    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

    this.raws[name] = valueEscaped;
  }
  /**
   * When you want a value to passed through to CSS directly. This method
   * deletes the corresponding raw value causing the stringifier to fallback
   * to the unescaped value.
   * @param {string} name the property to set.
   * @param {any} value The value that is both escaped and unescaped.
   */
  ;

  _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name, value) {
    this[name] = value; // this may trigger a setter that updates raws, so it has to be set first.

    if (this.raws) {
      delete this.raws[name];
    }
  }
  /**
   *
   * @param {number} line The number (starting with 1)
   * @param {number} column The column number (starting with 1)
   */
  ;

  _proto.isAtPosition = function isAtPosition(line, column) {
    if (this.source && this.source.start && this.source.end) {
      if (this.source.start.line > line) {
        return false;
      }

      if (this.source.end.line < line) {
        return false;
      }

      if (this.source.start.line === line && this.source.start.column > column) {
        return false;
      }

      if (this.source.end.line === line && this.source.end.column < column) {
        return false;
      }

      return true;
    }

    return undefined;
  };

  _proto.stringifyProperty = function stringifyProperty(name) {
    return this.raws && this.raws[name] || this[name];
  };

  _proto.valueToString = function valueToString() {
    return String(this.stringifyProperty("value"));
  };

  _proto.toString = function toString() {
    return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join('');
  };

  _createClass(Node, [{
    key: "rawSpaceBefore",
    get: function get() {
      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;

      if (rawSpace === undefined) {
        rawSpace = this.spaces && this.spaces.before;
      }

      return rawSpace || "";
    },
    set: function set(raw) {
      (0, _util.ensureObject)(this, "raws", "spaces");
      this.raws.spaces.before = raw;
    }
  }, {
    key: "rawSpaceAfter",
    get: function get() {
      var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;

      if (rawSpace === undefined) {
        rawSpace = this.spaces.after;
      }

      return rawSpace || "";
    },
    set: function set(raw) {
      (0, _util.ensureObject)(this, "raws", "spaces");
      this.raws.spaces.after = raw;
    }
  }]);

  return Node;
}();

exports["default"] = Node;
module.exports = exports.default;

/***/ }),

/***/ 28681:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _container = _interopRequireDefault(__nccwpck_require__(37240));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Pseudo = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Pseudo, _Container);

  function Pseudo(opts) {
    var _this;

    _this = _Container.call(this, opts) || this;
    _this.type = _types.PSEUDO;
    return _this;
  }

  var _proto = Pseudo.prototype;

  _proto.toString = function toString() {
    var params = this.length ? '(' + this.map(String).join(',') + ')' : '';
    return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join('');
  };

  return Pseudo;
}(_container["default"]);

exports["default"] = Pseudo;
module.exports = exports.default;

/***/ }),

/***/ 74804:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _container = _interopRequireDefault(__nccwpck_require__(37240));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Root = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Root, _Container);

  function Root(opts) {
    var _this;

    _this = _Container.call(this, opts) || this;
    _this.type = _types.ROOT;
    return _this;
  }

  var _proto = Root.prototype;

  _proto.toString = function toString() {
    var str = this.reduce(function (memo, selector) {
      memo.push(String(selector));
      return memo;
    }, []).join(',');
    return this.trailingComma ? str + ',' : str;
  };

  _proto.error = function error(message, options) {
    if (this._error) {
      return this._error(message, options);
    } else {
      return new Error(message);
    }
  };

  _createClass(Root, [{
    key: "errorGenerator",
    set: function set(handler) {
      this._error = handler;
    }
  }]);

  return Root;
}(_container["default"]);

exports["default"] = Root;
module.exports = exports.default;

/***/ }),

/***/ 97370:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _container = _interopRequireDefault(__nccwpck_require__(37240));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Selector = /*#__PURE__*/function (_Container) {
  _inheritsLoose(Selector, _Container);

  function Selector(opts) {
    var _this;

    _this = _Container.call(this, opts) || this;
    _this.type = _types.SELECTOR;
    return _this;
  }

  return Selector;
}(_container["default"]);

exports["default"] = Selector;
module.exports = exports.default;

/***/ }),

/***/ 62391:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _node = _interopRequireDefault(__nccwpck_require__(83206));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var String = /*#__PURE__*/function (_Node) {
  _inheritsLoose(String, _Node);

  function String(opts) {
    var _this;

    _this = _Node.call(this, opts) || this;
    _this.type = _types.STRING;
    return _this;
  }

  return String;
}(_node["default"]);

exports["default"] = String;
module.exports = exports.default;

/***/ }),

/***/ 99646:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _namespace = _interopRequireDefault(__nccwpck_require__(65669));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Tag = /*#__PURE__*/function (_Namespace) {
  _inheritsLoose(Tag, _Namespace);

  function Tag(opts) {
    var _this;

    _this = _Namespace.call(this, opts) || this;
    _this.type = _types.TAG;
    return _this;
  }

  return Tag;
}(_namespace["default"]);

exports["default"] = Tag;
module.exports = exports.default;

/***/ }),

/***/ 86895:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.UNIVERSAL = exports.ATTRIBUTE = exports.CLASS = exports.COMBINATOR = exports.COMMENT = exports.ID = exports.NESTING = exports.PSEUDO = exports.ROOT = exports.SELECTOR = exports.STRING = exports.TAG = void 0;
var TAG = 'tag';
exports.TAG = TAG;
var STRING = 'string';
exports.STRING = STRING;
var SELECTOR = 'selector';
exports.SELECTOR = SELECTOR;
var ROOT = 'root';
exports.ROOT = ROOT;
var PSEUDO = 'pseudo';
exports.PSEUDO = PSEUDO;
var NESTING = 'nesting';
exports.NESTING = NESTING;
var ID = 'id';
exports.ID = ID;
var COMMENT = 'comment';
exports.COMMENT = COMMENT;
var COMBINATOR = 'combinator';
exports.COMBINATOR = COMBINATOR;
var CLASS = 'class';
exports.CLASS = CLASS;
var ATTRIBUTE = 'attribute';
exports.ATTRIBUTE = ATTRIBUTE;
var UNIVERSAL = 'universal';
exports.UNIVERSAL = UNIVERSAL;

/***/ }),

/***/ 14843:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = void 0;

var _namespace = _interopRequireDefault(__nccwpck_require__(65669));

var _types = __nccwpck_require__(86895);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Universal = /*#__PURE__*/function (_Namespace) {
  _inheritsLoose(Universal, _Namespace);

  function Universal(opts) {
    var _this;

    _this = _Namespace.call(this, opts) || this;
    _this.type = _types.UNIVERSAL;
    _this.value = '*';
    return _this;
  }

  return Universal;
}(_namespace["default"]);

exports["default"] = Universal;
module.exports = exports.default;

/***/ }),

/***/ 18520:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = sortAscending;

function sortAscending(list) {
  return list.sort(function (a, b) {
    return a - b;
  });
}

;
module.exports = exports.default;

/***/ }),

/***/ 26684:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.combinator = exports.word = exports.comment = exports.str = exports.tab = exports.newline = exports.feed = exports.cr = exports.backslash = exports.bang = exports.slash = exports.doubleQuote = exports.singleQuote = exports.space = exports.greaterThan = exports.pipe = exports.equals = exports.plus = exports.caret = exports.tilde = exports.dollar = exports.closeSquare = exports.openSquare = exports.closeParenthesis = exports.openParenthesis = exports.semicolon = exports.colon = exports.comma = exports.at = exports.asterisk = exports.ampersand = void 0;
var ampersand = 38; // `&`.charCodeAt(0);

exports.ampersand = ampersand;
var asterisk = 42; // `*`.charCodeAt(0);

exports.asterisk = asterisk;
var at = 64; // `@`.charCodeAt(0);

exports.at = at;
var comma = 44; // `,`.charCodeAt(0);

exports.comma = comma;
var colon = 58; // `:`.charCodeAt(0);

exports.colon = colon;
var semicolon = 59; // `;`.charCodeAt(0);

exports.semicolon = semicolon;
var openParenthesis = 40; // `(`.charCodeAt(0);

exports.openParenthesis = openParenthesis;
var closeParenthesis = 41; // `)`.charCodeAt(0);

exports.closeParenthesis = closeParenthesis;
var openSquare = 91; // `[`.charCodeAt(0);

exports.openSquare = openSquare;
var closeSquare = 93; // `]`.charCodeAt(0);

exports.closeSquare = closeSquare;
var dollar = 36; // `$`.charCodeAt(0);

exports.dollar = dollar;
var tilde = 126; // `~`.charCodeAt(0);

exports.tilde = tilde;
var caret = 94; // `^`.charCodeAt(0);

exports.caret = caret;
var plus = 43; // `+`.charCodeAt(0);

exports.plus = plus;
var equals = 61; // `=`.charCodeAt(0);

exports.equals = equals;
var pipe = 124; // `|`.charCodeAt(0);

exports.pipe = pipe;
var greaterThan = 62; // `>`.charCodeAt(0);

exports.greaterThan = greaterThan;
var space = 32; // ` `.charCodeAt(0);

exports.space = space;
var singleQuote = 39; // `'`.charCodeAt(0);

exports.singleQuote = singleQuote;
var doubleQuote = 34; // `"`.charCodeAt(0);

exports.doubleQuote = doubleQuote;
var slash = 47; // `/`.charCodeAt(0);

exports.slash = slash;
var bang = 33; // `!`.charCodeAt(0);

exports.bang = bang;
var backslash = 92; // '\\'.charCodeAt(0);

exports.backslash = backslash;
var cr = 13; // '\r'.charCodeAt(0);

exports.cr = cr;
var feed = 12; // '\f'.charCodeAt(0);

exports.feed = feed;
var newline = 10; // '\n'.charCodeAt(0);

exports.newline = newline;
var tab = 9; // '\t'.charCodeAt(0);
// Expose aliases primarily for readability.

exports.tab = tab;
var str = singleQuote; // No good single character representation!

exports.str = str;
var comment = -1;
exports.comment = comment;
var word = -2;
exports.word = word;
var combinator = -3;
exports.combinator = combinator;

/***/ }),

/***/ 53370:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports["default"] = tokenize;
exports.FIELDS = void 0;

var t = _interopRequireWildcard(__nccwpck_require__(26684));

var _unescapable, _wordDelimiters;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
var hex = {};
var hexChars = "0123456789abcdefABCDEF";

for (var i = 0; i < hexChars.length; i++) {
  hex[hexChars.charCodeAt(i)] = true;
}
/**
 *  Returns the last index of the bar css word
 * @param {string} css The string in which the word begins
 * @param {number} start The index into the string where word's first letter occurs
 */


function consumeWord(css, start) {
  var next = start;
  var code;

  do {
    code = css.charCodeAt(next);

    if (wordDelimiters[code]) {
      return next - 1;
    } else if (code === t.backslash) {
      next = consumeEscape(css, next) + 1;
    } else {
      // All other characters are part of the word
      next++;
    }
  } while (next < css.length);

  return next - 1;
}
/**
 *  Returns the last index of the escape sequence
 * @param {string} css The string in which the sequence begins
 * @param {number} start The index into the string where escape character (`\`) occurs.
 */


function consumeEscape(css, start) {
  var next = start;
  var code = css.charCodeAt(next + 1);

  if (unescapable[code]) {// just consume the escape char
  } else if (hex[code]) {
    var hexDigits = 0; // consume up to 6 hex chars

    do {
      next++;
      hexDigits++;
      code = css.charCodeAt(next + 1);
    } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape


    if (hexDigits < 6 && code === t.space) {
      next++;
    }
  } else {
    // the next char is part of the current word
    next++;
  }

  return next;
}

var FIELDS = {
  TYPE: 0,
  START_LINE: 1,
  START_COL: 2,
  END_LINE: 3,
  END_COL: 4,
  START_POS: 5,
  END_POS: 6
};
exports.FIELDS = FIELDS;

function tokenize(input) {
  var tokens = [];
  var css = input.css.valueOf();
  var _css = css,
      length = _css.length;
  var offset = -1;
  var line = 1;
  var start = 0;
  var end = 0;
  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;

  function unclosed(what, fix) {
    if (input.safe) {
      // fyi: this is never set to true.
      css += fix;
      next = css.length - 1;
    } else {
      throw input.error('Unclosed ' + what, line, start - offset, start);
    }
  }

  while (start < length) {
    code = css.charCodeAt(start);

    if (code === t.newline) {
      offset = start;
      line += 1;
    }

    switch (code) {
      case t.space:
      case t.tab:
      case t.newline:
      case t.cr:
      case t.feed:
        next = start;

        do {
          next += 1;
          code = css.charCodeAt(next);

          if (code === t.newline) {
            offset = next;
            line += 1;
          }
        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);

        tokenType = t.space;
        endLine = line;
        endColumn = next - offset - 1;
        end = next;
        break;

      case t.plus:
      case t.greaterThan:
      case t.tilde:
      case t.pipe:
        next = start;

        do {
          next += 1;
          code = css.charCodeAt(next);
        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);

        tokenType = t.combinator;
        endLine = line;
        endColumn = start - offset;
        end = next;
        break;
      // Consume these characters as single tokens.

      case t.asterisk:
      case t.ampersand:
      case t.bang:
      case t.comma:
      case t.equals:
      case t.dollar:
      case t.caret:
      case t.openSquare:
      case t.closeSquare:
      case t.colon:
      case t.semicolon:
      case t.openParenthesis:
      case t.closeParenthesis:
        next = start;
        tokenType = code;
        endLine = line;
        endColumn = start - offset;
        end = next + 1;
        break;

      case t.singleQuote:
      case t.doubleQuote:
        quote = code === t.singleQuote ? "'" : '"';
        next = start;

        do {
          escaped = false;
          next = css.indexOf(quote, next + 1);

          if (next === -1) {
            unclosed('quote', quote);
          }

          escapePos = next;

          while (css.charCodeAt(escapePos - 1) === t.backslash) {
            escapePos -= 1;
            escaped = !escaped;
          }
        } while (escaped);

        tokenType = t.str;
        endLine = line;
        endColumn = start - offset;
        end = next + 1;
        break;

      default:
        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
          next = css.indexOf('*/', start + 2) + 1;

          if (next === 0) {
            unclosed('comment', '*/');
          }

          content = css.slice(start, next + 1);
          lines = content.split('\n');
          last = lines.length - 1;

          if (last > 0) {
            nextLine = line + last;
            nextOffset = next - lines[last].length;
          } else {
            nextLine = line;
            nextOffset = offset;
          }

          tokenType = t.comment;
          line = nextLine;
          endLine = nextLine;
          endColumn = next - nextOffset;
        } else if (code === t.slash) {
          next = start;
          tokenType = code;
          endLine = line;
          endColumn = start - offset;
          end = next + 1;
        } else {
          next = consumeWord(css, start);
          tokenType = t.word;
          endLine = line;
          endColumn = next - offset;
        }

        end = next + 1;
        break;
    } // Ensure that the token structure remains consistent


    tokens.push([tokenType, // [0] Token type
    line, // [1] Starting line
    start - offset, // [2] Starting column
    endLine, // [3] Ending line
    endColumn, // [4] Ending column
    start, // [5] Start position / Source index
    end // [6] End position
    ]); // Reset offset for the next token

    if (nextOffset) {
      offset = nextOffset;
      nextOffset = null;
    }

    start = end;
  }

  return tokens;
}

/***/ }),

/***/ 23573:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = ensureObject;

function ensureObject(obj) {
  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    props[_key - 1] = arguments[_key];
  }

  while (props.length > 0) {
    var prop = props.shift();

    if (!obj[prop]) {
      obj[prop] = {};
    }

    obj = obj[prop];
  }
}

module.exports = exports.default;

/***/ }),

/***/ 83514:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = getProp;

function getProp(obj) {
  for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    props[_key - 1] = arguments[_key];
  }

  while (props.length > 0) {
    var prop = props.shift();

    if (!obj[prop]) {
      return undefined;
    }

    obj = obj[prop];
  }

  return obj;
}

module.exports = exports.default;

/***/ }),

/***/ 73621:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


exports.__esModule = true;
exports.stripComments = exports.ensureObject = exports.getProp = exports.unesc = void 0;

var _unesc = _interopRequireDefault(__nccwpck_require__(2897));

exports.unesc = _unesc["default"];

var _getProp = _interopRequireDefault(__nccwpck_require__(83514));

exports.getProp = _getProp["default"];

var _ensureObject = _interopRequireDefault(__nccwpck_require__(23573));

exports.ensureObject = _ensureObject["default"];

var _stripComments = _interopRequireDefault(__nccwpck_require__(37142));

exports.stripComments = _stripComments["default"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/***/ }),

/***/ 37142:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = stripComments;

function stripComments(str) {
  var s = "";
  var commentStart = str.indexOf("/*");
  var lastEnd = 0;

  while (commentStart >= 0) {
    s = s + str.slice(lastEnd, commentStart);
    var commentEnd = str.indexOf("*/", commentStart + 2);

    if (commentEnd < 0) {
      return s;
    }

    lastEnd = commentEnd + 2;
    commentStart = str.indexOf("/*", lastEnd);
  }

  s = s + str.slice(lastEnd);
  return s;
}

module.exports = exports.default;

/***/ }),

/***/ 2897:
/***/ ((module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = unesc;

// Many thanks for this post which made this migration much easier.
// https://mathiasbynens.be/notes/css-escapes

/**
 * 
 * @param {string} str 
 * @returns {[string, number]|undefined}
 */
function gobbleHex(str) {
  var lower = str.toLowerCase();
  var hex = '';
  var spaceTerminated = false;

  for (var i = 0; i < 6 && lower[i] !== undefined; i++) {
    var code = lower.charCodeAt(i); // check to see if we are dealing with a valid hex char [a-f|0-9]

    var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57; // https://drafts.csswg.org/css-syntax/#consume-escaped-code-point

    spaceTerminated = code === 32;

    if (!valid) {
      break;
    }

    hex += lower[i];
  }

  if (hex.length === 0) {
    return undefined;
  }

  var codePoint = parseInt(hex, 16);
  var isSurrogate = codePoint >= 0xD800 && codePoint <= 0xDFFF; // Add special case for
  // "If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point"
  // https://drafts.csswg.org/css-syntax/#maximum-allowed-code-point

  if (isSurrogate || codePoint === 0x0000 || codePoint > 0x10FFFF) {
    return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
  }

  return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
}

var CONTAINS_ESCAPE = /\\/;

function unesc(str) {
  var needToProcess = CONTAINS_ESCAPE.test(str);

  if (!needToProcess) {
    return str;
  }

  var ret = "";

  for (var i = 0; i < str.length; i++) {
    if (str[i] === "\\") {
      var gobbled = gobbleHex(str.slice(i + 1, i + 7));

      if (gobbled !== undefined) {
        ret += gobbled[0];
        i += gobbled[1];
        continue;
      } // Retain a pair of \\ if double escaped `\\\\`
      // https://github.com/postcss/postcss-selector-parser/commit/268c9a7656fb53f543dc620aa5b73a30ec3ff20e


      if (str[i + 1] === "\\") {
        ret += "\\";
        i++;
        continue;
      } // if \\ is at the end of the string retain it
      // https://github.com/postcss/postcss-selector-parser/commit/01a6b346e3612ce1ab20219acc26abdc259ccefb


      if (str.length === i + 1) {
        ret += str[i];
      }

      continue;
    }

    ret += str[i];
  }

  return ret;
}

module.exports = exports.default;

/***/ }),

/***/ 19285:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var parse = __nccwpck_require__(75920);
var walk = __nccwpck_require__(69987);
var stringify = __nccwpck_require__(27952);

function ValueParser(value) {
  if (this instanceof ValueParser) {
    this.nodes = parse(value);
    return this;
  }
  return new ValueParser(value);
}

ValueParser.prototype.toString = function() {
  return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
};

ValueParser.prototype.walk = function(cb, bubble) {
  walk(this.nodes, cb, bubble);
  return this;
};

ValueParser.unit = __nccwpck_require__(45148);

ValueParser.walk = walk;

ValueParser.stringify = stringify;

module.exports = ValueParser;


/***/ }),

/***/ 75920:
/***/ ((module) => {

var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);
var uLower = "u".charCodeAt(0);
var uUpper = "U".charCodeAt(0);
var plus = "+".charCodeAt(0);
var isUnicodeRange = /^[a-f0-9?-]+$/i;

module.exports = function(input) {
  var tokens = [];
  var value = input;

  var next,
    quote,
    prev,
    token,
    escape,
    escapePos,
    whitespacePos,
    parenthesesOpenPos;
  var pos = 0;
  var code = value.charCodeAt(pos);
  var max = value.length;
  var stack = [{ nodes: tokens }];
  var balanced = 0;
  var parent;

  var name = "";
  var before = "";
  var after = "";

  while (pos < max) {
    // Whitespaces
    if (code <= 32) {
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      token = value.slice(pos, next);

      prev = tokens[tokens.length - 1];
      if (code === closeParentheses && balanced) {
        after = token;
      } else if (prev && prev.type === "div") {
        prev.after = token;
        prev.sourceEndIndex += token.length;
      } else if (
        code === comma ||
        code === colon ||
        (code === slash &&
          value.charCodeAt(next + 1) !== star &&
          (!parent ||
            (parent && parent.type === "function" && parent.value !== "calc")))
      ) {
        before = token;
      } else {
        tokens.push({
          type: "space",
          sourceIndex: pos,
          sourceEndIndex: next,
          value: token
        });
      }

      pos = next;

      // Quotes
    } else if (code === singleQuote || code === doubleQuote) {
      next = pos;
      quote = code === singleQuote ? "'" : '"';
      token = {
        type: "string",
        sourceIndex: pos,
        quote: quote
      };
      do {
        escape = false;
        next = value.indexOf(quote, next + 1);
        if (~next) {
          escapePos = next;
          while (value.charCodeAt(escapePos - 1) === backslash) {
            escapePos -= 1;
            escape = !escape;
          }
        } else {
          value += quote;
          next = value.length - 1;
          token.unclosed = true;
        }
      } while (escape);
      token.value = value.slice(pos + 1, next);
      token.sourceEndIndex = token.unclosed ? next : next + 1;
      tokens.push(token);
      pos = next + 1;
      code = value.charCodeAt(pos);

      // Comments
    } else if (code === slash && value.charCodeAt(pos + 1) === star) {
      next = value.indexOf("*/", pos);

      token = {
        type: "comment",
        sourceIndex: pos,
        sourceEndIndex: next + 2
      };

      if (next === -1) {
        token.unclosed = true;
        next = value.length;
        token.sourceEndIndex = next;
      }

      token.value = value.slice(pos + 2, next);
      tokens.push(token);

      pos = next + 2;
      code = value.charCodeAt(pos);

      // Operation within calc
    } else if (
      (code === slash || code === star) &&
      parent &&
      parent.type === "function" &&
      parent.value === "calc"
    ) {
      token = value[pos];
      tokens.push({
        type: "word",
        sourceIndex: pos - before.length,
        sourceEndIndex: pos + token.length,
        value: token
      });
      pos += 1;
      code = value.charCodeAt(pos);

      // Dividers
    } else if (code === slash || code === comma || code === colon) {
      token = value[pos];

      tokens.push({
        type: "div",
        sourceIndex: pos - before.length,
        sourceEndIndex: pos + token.length,
        value: token,
        before: before,
        after: ""
      });
      before = "";

      pos += 1;
      code = value.charCodeAt(pos);

      // Open parentheses
    } else if (openParentheses === code) {
      // Whitespaces after open parentheses
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      parenthesesOpenPos = pos;
      token = {
        type: "function",
        sourceIndex: pos - name.length,
        value: name,
        before: value.slice(parenthesesOpenPos + 1, next)
      };
      pos = next;

      if (name === "url" && code !== singleQuote && code !== doubleQuote) {
        next -= 1;
        do {
          escape = false;
          next = value.indexOf(")", next + 1);
          if (~next) {
            escapePos = next;
            while (value.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape = !escape;
            }
          } else {
            value += ")";
            next = value.length - 1;
            token.unclosed = true;
          }
        } while (escape);
        // Whitespaces before closed
        whitespacePos = next;
        do {
          whitespacePos -= 1;
          code = value.charCodeAt(whitespacePos);
        } while (code <= 32);
        if (parenthesesOpenPos < whitespacePos) {
          if (pos !== whitespacePos + 1) {
            token.nodes = [
              {
                type: "word",
                sourceIndex: pos,
                sourceEndIndex: whitespacePos + 1,
                value: value.slice(pos, whitespacePos + 1)
              }
            ];
          } else {
            token.nodes = [];
          }
          if (token.unclosed && whitespacePos + 1 !== next) {
            token.after = "";
            token.nodes.push({
              type: "space",
              sourceIndex: whitespacePos + 1,
              sourceEndIndex: next,
              value: value.slice(whitespacePos + 1, next)
            });
          } else {
            token.after = value.slice(whitespacePos + 1, next);
            token.sourceEndIndex = next;
          }
        } else {
          token.after = "";
          token.nodes = [];
        }
        pos = next + 1;
        token.sourceEndIndex = token.unclosed ? next : pos;
        code = value.charCodeAt(pos);
        tokens.push(token);
      } else {
        balanced += 1;
        token.after = "";
        token.sourceEndIndex = pos + 1;
        tokens.push(token);
        stack.push(token);
        tokens = token.nodes = [];
        parent = token;
      }
      name = "";

      // Close parentheses
    } else if (closeParentheses === code && balanced) {
      pos += 1;
      code = value.charCodeAt(pos);

      parent.after = after;
      parent.sourceEndIndex += after.length;
      after = "";
      balanced -= 1;
      stack[stack.length - 1].sourceEndIndex = pos;
      stack.pop();
      parent = stack[balanced];
      tokens = parent.nodes;

      // Words
    } else {
      next = pos;
      do {
        if (code === backslash) {
          next += 1;
        }
        next += 1;
        code = value.charCodeAt(next);
      } while (
        next < max &&
        !(
          code <= 32 ||
          code === singleQuote ||
          code === doubleQuote ||
          code === comma ||
          code === colon ||
          code === slash ||
          code === openParentheses ||
          (code === star &&
            parent &&
            parent.type === "function" &&
            parent.value === "calc") ||
          (code === slash &&
            parent.type === "function" &&
            parent.value === "calc") ||
          (code === closeParentheses && balanced)
        )
      );
      token = value.slice(pos, next);

      if (openParentheses === code) {
        name = token;
      } else if (
        (uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) &&
        plus === token.charCodeAt(1) &&
        isUnicodeRange.test(token.slice(2))
      ) {
        tokens.push({
          type: "unicode-range",
          sourceIndex: pos,
          sourceEndIndex: next,
          value: token
        });
      } else {
        tokens.push({
          type: "word",
          sourceIndex: pos,
          sourceEndIndex: next,
          value: token
        });
      }

      pos = next;
    }
  }

  for (pos = stack.length - 1; pos; pos -= 1) {
    stack[pos].unclosed = true;
    stack[pos].sourceEndIndex = value.length;
  }

  return stack[0].nodes;
};


/***/ }),

/***/ 27952:
/***/ ((module) => {

function stringifyNode(node, custom) {
  var type = node.type;
  var value = node.value;
  var buf;
  var customResult;

  if (custom && (customResult = custom(node)) !== undefined) {
    return customResult;
  } else if (type === "word" || type === "space") {
    return value;
  } else if (type === "string") {
    buf = node.quote || "";
    return buf + value + (node.unclosed ? "" : buf);
  } else if (type === "comment") {
    return "/*" + value + (node.unclosed ? "" : "*/");
  } else if (type === "div") {
    return (node.before || "") + value + (node.after || "");
  } else if (Array.isArray(node.nodes)) {
    buf = stringify(node.nodes, custom);
    if (type !== "function") {
      return buf;
    }
    return (
      value +
      "(" +
      (node.before || "") +
      buf +
      (node.after || "") +
      (node.unclosed ? "" : ")")
    );
  }
  return value;
}

function stringify(nodes, custom) {
  var result, i;

  if (Array.isArray(nodes)) {
    result = "";
    for (i = nodes.length - 1; ~i; i -= 1) {
      result = stringifyNode(nodes[i], custom) + result;
    }
    return result;
  }
  return stringifyNode(nodes, custom);
}

module.exports = stringify;


/***/ }),

/***/ 45148:
/***/ ((module) => {

var minus = "-".charCodeAt(0);
var plus = "+".charCodeAt(0);
var dot = ".".charCodeAt(0);
var exp = "e".charCodeAt(0);
var EXP = "E".charCodeAt(0);

// Check if three code points would start a number
// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
function likeNumber(value) {
  var code = value.charCodeAt(0);
  var nextCode;

  if (code === plus || code === minus) {
    nextCode = value.charCodeAt(1);

    if (nextCode >= 48 && nextCode <= 57) {
      return true;
    }

    var nextNextCode = value.charCodeAt(2);

    if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
      return true;
    }

    return false;
  }

  if (code === dot) {
    nextCode = value.charCodeAt(1);

    if (nextCode >= 48 && nextCode <= 57) {
      return true;
    }

    return false;
  }

  if (code >= 48 && code <= 57) {
    return true;
  }

  return false;
}

// Consume a number
// https://www.w3.org/TR/css-syntax-3/#consume-number
module.exports = function(value) {
  var pos = 0;
  var length = value.length;
  var code;
  var nextCode;
  var nextNextCode;

  if (length === 0 || !likeNumber(value)) {
    return false;
  }

  code = value.charCodeAt(pos);

  if (code === plus || code === minus) {
    pos++;
  }

  while (pos < length) {
    code = value.charCodeAt(pos);

    if (code < 48 || code > 57) {
      break;
    }

    pos += 1;
  }

  code = value.charCodeAt(pos);
  nextCode = value.charCodeAt(pos + 1);

  if (code === dot && nextCode >= 48 && nextCode <= 57) {
    pos += 2;

    while (pos < length) {
      code = value.charCodeAt(pos);

      if (code < 48 || code > 57) {
        break;
      }

      pos += 1;
    }
  }

  code = value.charCodeAt(pos);
  nextCode = value.charCodeAt(pos + 1);
  nextNextCode = value.charCodeAt(pos + 2);

  if (
    (code === exp || code === EXP) &&
    ((nextCode >= 48 && nextCode <= 57) ||
      ((nextCode === plus || nextCode === minus) &&
        nextNextCode >= 48 &&
        nextNextCode <= 57))
  ) {
    pos += nextCode === plus || nextCode === minus ? 3 : 2;

    while (pos < length) {
      code = value.charCodeAt(pos);

      if (code < 48 || code > 57) {
        break;
      }

      pos += 1;
    }
  }

  return {
    number: value.slice(0, pos),
    unit: value.slice(pos)
  };
};


/***/ }),

/***/ 69987:
/***/ ((module) => {

module.exports = function walk(nodes, cb, bubble) {
  var i, max, node, result;

  for (i = 0, max = nodes.length; i < max; i += 1) {
    node = nodes[i];
    if (!bubble) {
      result = cb(node, i, nodes);
    }

    if (
      result !== false &&
      node.type === "function" &&
      Array.isArray(node.nodes)
    ) {
      walk(node.nodes, cb, bubble);
    }

    if (bubble) {
      cb(node, i, nodes);
    }
  }
};


/***/ }),

/***/ 54193:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let Container = __nccwpck_require__(56919)

class AtRule extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'atrule'
  }

  append(...children) {
    if (!this.proxyOf.nodes) this.nodes = []
    return super.append(...children)
  }

  prepend(...children) {
    if (!this.proxyOf.nodes) this.nodes = []
    return super.prepend(...children)
  }
}

module.exports = AtRule
AtRule.default = AtRule

Container.registerAtRule(AtRule)


/***/ }),

/***/ 37592:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let Node = __nccwpck_require__(48557)

class Comment extends Node {
  constructor(defaults) {
    super(defaults)
    this.type = 'comment'
  }
}

module.exports = Comment
Comment.default = Comment


/***/ }),

/***/ 56919:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let { isClean, my } = __nccwpck_require__(32594)
let Declaration = __nccwpck_require__(33522)
let Comment = __nccwpck_require__(37592)
let Node = __nccwpck_require__(48557)

let parse, Rule, AtRule, Root

function cleanSource(nodes) {
  return nodes.map(i => {
    if (i.nodes) i.nodes = cleanSource(i.nodes)
    delete i.source
    return i
  })
}

function markDirtyUp(node) {
  node[isClean] = false
  if (node.proxyOf.nodes) {
    for (let i of node.proxyOf.nodes) {
      markDirtyUp(i)
    }
  }
}

class Container extends Node {
  push(child) {
    child.parent = this
    this.proxyOf.nodes.push(child)
    return this
  }

  each(callback) {
    if (!this.proxyOf.nodes) return undefined
    let iterator = this.getIterator()

    let index, result
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index = this.indexes[iterator]
      result = callback(this.proxyOf.nodes[index], index)
      if (result === false) break

      this.indexes[iterator] += 1
    }

    delete this.indexes[iterator]
    return result
  }

  walk(callback) {
    return this.each((child, i) => {
      let result
      try {
        result = callback(child, i)
      } catch (e) {
        throw child.addToError(e)
      }
      if (result !== false && child.walk) {
        result = child.walk(callback)
      }

      return result
    })
  }

  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop
      return this.walk((child, i) => {
        if (child.type === 'decl') {
          return callback(child, i)
        }
      })
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'decl' && prop.test(child.prop)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'decl' && child.prop === prop) {
        return callback(child, i)
      }
    })
  }

  walkRules(selector, callback) {
    if (!callback) {
      callback = selector

      return this.walk((child, i) => {
        if (child.type === 'rule') {
          return callback(child, i)
        }
      })
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'rule' && selector.test(child.selector)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'rule' && child.selector === selector) {
        return callback(child, i)
      }
    })
  }

  walkAtRules(name, callback) {
    if (!callback) {
      callback = name
      return this.walk((child, i) => {
        if (child.type === 'atrule') {
          return callback(child, i)
        }
      })
    }
    if (name instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'atrule' && name.test(child.name)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'atrule' && child.name === name) {
        return callback(child, i)
      }
    })
  }

  walkComments(callback) {
    return this.walk((child, i) => {
      if (child.type === 'comment') {
        return callback(child, i)
      }
    })
  }

  append(...children) {
    for (let child of children) {
      let nodes = this.normalize(child, this.last)
      for (let node of nodes) this.proxyOf.nodes.push(node)
    }

    this.markDirty()

    return this
  }

  prepend(...children) {
    children = children.reverse()
    for (let child of children) {
      let nodes = this.normalize(child, this.first, 'prepend').reverse()
      for (let node of nodes) this.proxyOf.nodes.unshift(node)
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween)
    if (this.nodes) {
      for (let node of this.nodes) node.cleanRaws(keepBetween)
    }
  }

  insertBefore(exist, add) {
    let existIndex = this.index(exist)
    let type = existIndex === 0 ? 'prepend' : false
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse()
    existIndex = this.index(exist)
    for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (existIndex <= index) {
        this.indexes[id] = index + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  insertAfter(exist, add) {
    let existIndex = this.index(exist)
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse()
    existIndex = this.index(exist)
    for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (existIndex < index) {
        this.indexes[id] = index + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  removeChild(child) {
    child = this.index(child)
    this.proxyOf.nodes[child].parent = undefined
    this.proxyOf.nodes.splice(child, 1)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (index >= child) {
        this.indexes[id] = index - 1
      }
    }

    this.markDirty()

    return this
  }

  removeAll() {
    for (let node of this.proxyOf.nodes) node.parent = undefined
    this.proxyOf.nodes = []

    this.markDirty()

    return this
  }

  replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts
      opts = {}
    }

    this.walkDecls(decl => {
      if (opts.props && !opts.props.includes(decl.prop)) return
      if (opts.fast && !decl.value.includes(opts.fast)) return

      decl.value = decl.value.replace(pattern, callback)
    })

    this.markDirty()

    return this
  }

  every(condition) {
    return this.nodes.every(condition)
  }

  some(condition) {
    return this.nodes.some(condition)
  }

  index(child) {
    if (typeof child === 'number') return child
    if (child.proxyOf) child = child.proxyOf
    return this.proxyOf.nodes.indexOf(child)
  }

  get first() {
    if (!this.proxyOf.nodes) return undefined
    return this.proxyOf.nodes[0]
  }

  get last() {
    if (!this.proxyOf.nodes) return undefined
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]
  }

  normalize(nodes, sample) {
    if (typeof nodes === 'string') {
      nodes = cleanSource(parse(nodes).nodes)
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0)
      for (let i of nodes) {
        if (i.parent) i.parent.removeChild(i, 'ignore')
      }
    } else if (nodes.type === 'root' && this.type !== 'document') {
      nodes = nodes.nodes.slice(0)
      for (let i of nodes) {
        if (i.parent) i.parent.removeChild(i, 'ignore')
      }
    } else if (nodes.type) {
      nodes = [nodes]
    } else if (nodes.prop) {
      if (typeof nodes.value === 'undefined') {
        throw new Error('Value field is missed in node creation')
      } else if (typeof nodes.value !== 'string') {
        nodes.value = String(nodes.value)
      }
      nodes = [new Declaration(nodes)]
    } else if (nodes.selector) {
      nodes = [new Rule(nodes)]
    } else if (nodes.name) {
      nodes = [new AtRule(nodes)]
    } else if (nodes.text) {
      nodes = [new Comment(nodes)]
    } else {
      throw new Error('Unknown node type in node creation')
    }

    let processed = nodes.map(i => {
      /* c8 ignore next */
      if (!i[my]) Container.rebuild(i)
      i = i.proxyOf
      if (i.parent) i.parent.removeChild(i)
      if (i[isClean]) markDirtyUp(i)
      if (typeof i.raws.before === 'undefined') {
        if (sample && typeof sample.raws.before !== 'undefined') {
          i.raws.before = sample.raws.before.replace(/\S/g, '')
        }
      }
      i.parent = this.proxyOf
      return i
    })

    return processed
  }

  getProxyProcessor() {
    return {
      set(node, prop, value) {
        if (node[prop] === value) return true
        node[prop] = value
        if (prop === 'name' || prop === 'params' || prop === 'selector') {
          node.markDirty()
        }
        return true
      },

      get(node, prop) {
        if (prop === 'proxyOf') {
          return node
        } else if (!node[prop]) {
          return node[prop]
        } else if (
          prop === 'each' ||
          (typeof prop === 'string' && prop.startsWith('walk'))
        ) {
          return (...args) => {
            return node[prop](
              ...args.map(i => {
                if (typeof i === 'function') {
                  return (child, index) => i(child.toProxy(), index)
                } else {
                  return i
                }
              })
            )
          }
        } else if (prop === 'every' || prop === 'some') {
          return cb => {
            return node[prop]((child, ...other) =>
              cb(child.toProxy(), ...other)
            )
          }
        } else if (prop === 'root') {
          return () => node.root().toProxy()
        } else if (prop === 'nodes') {
          return node.nodes.map(i => i.toProxy())
        } else if (prop === 'first' || prop === 'last') {
          return node[prop].toProxy()
        } else {
          return node[prop]
        }
      }
    }
  }

  getIterator() {
    if (!this.lastEach) this.lastEach = 0
    if (!this.indexes) this.indexes = {}

    this.lastEach += 1
    let iterator = this.lastEach
    this.indexes[iterator] = 0

    return iterator
  }
}

Container.registerParse = dependant => {
  parse = dependant
}

Container.registerRule = dependant => {
  Rule = dependant
}

Container.registerAtRule = dependant => {
  AtRule = dependant
}

Container.registerRoot = dependant => {
  Root = dependant
}

module.exports = Container
Container.default = Container

/* c8 ignore start */
Container.rebuild = node => {
  if (node.type === 'atrule') {
    Object.setPrototypeOf(node, AtRule.prototype)
  } else if (node.type === 'rule') {
    Object.setPrototypeOf(node, Rule.prototype)
  } else if (node.type === 'decl') {
    Object.setPrototypeOf(node, Declaration.prototype)
  } else if (node.type === 'comment') {
    Object.setPrototypeOf(node, Comment.prototype)
  } else if (node.type === 'root') {
    Object.setPrototypeOf(node, Root.prototype)
  }

  node[my] = true

  if (node.nodes) {
    node.nodes.forEach(child => {
      Container.rebuild(child)
    })
  }
}
/* c8 ignore stop */


/***/ }),

/***/ 63279:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let pico = __nccwpck_require__(37023)

let terminalHighlight = __nccwpck_require__(51040)

class CssSyntaxError extends Error {
  constructor(message, line, column, source, file, plugin) {
    super(message)
    this.name = 'CssSyntaxError'
    this.reason = message

    if (file) {
      this.file = file
    }
    if (source) {
      this.source = source
    }
    if (plugin) {
      this.plugin = plugin
    }
    if (typeof line !== 'undefined' && typeof column !== 'undefined') {
      if (typeof line === 'number') {
        this.line = line
        this.column = column
      } else {
        this.line = line.line
        this.column = line.column
        this.endLine = column.line
        this.endColumn = column.column
      }
    }

    this.setMessage()

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CssSyntaxError)
    }
  }

  setMessage() {
    this.message = this.plugin ? this.plugin + ': ' : ''
    this.message += this.file ? this.file : '<css input>'
    if (typeof this.line !== 'undefined') {
      this.message += ':' + this.line + ':' + this.column
    }
    this.message += ': ' + this.reason
  }

  showSourceCode(color) {
    if (!this.source) return ''

    let css = this.source
    if (color == null) color = pico.isColorSupported
    if (terminalHighlight) {
      if (color) css = terminalHighlight(css)
    }

    let lines = css.split(/\r?\n/)
    let start = Math.max(this.line - 3, 0)
    let end = Math.min(this.line + 2, lines.length)

    let maxWidth = String(end).length

    let mark, aside
    if (color) {
      let { bold, red, gray } = pico.createColors(true)
      mark = text => bold(red(text))
      aside = text => gray(text)
    } else {
      mark = aside = str => str
    }

    return lines
      .slice(start, end)
      .map((line, index) => {
        let number = start + 1 + index
        let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | '
        if (number === this.line) {
          let spacing =
            aside(gutter.replace(/\d/g, ' ')) +
            line.slice(0, this.column - 1).replace(/[^\t]/g, ' ')
          return mark('>') + aside(gutter) + line + '\n ' + spacing + mark('^')
        }
        return ' ' + aside(gutter) + line
      })
      .join('\n')
  }

  toString() {
    let code = this.showSourceCode()
    if (code) {
      code = '\n\n' + code + '\n'
    }
    return this.name + ': ' + this.message + code
  }
}

module.exports = CssSyntaxError
CssSyntaxError.default = CssSyntaxError


/***/ }),

/***/ 33522:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let Node = __nccwpck_require__(48557)

class Declaration extends Node {
  constructor(defaults) {
    if (
      defaults &&
      typeof defaults.value !== 'undefined' &&
      typeof defaults.value !== 'string'
    ) {
      defaults = { ...defaults, value: String(defaults.value) }
    }
    super(defaults)
    this.type = 'decl'
  }

  get variable() {
    return this.prop.startsWith('--') || this.prop[0] === '$'
  }
}

module.exports = Declaration
Declaration.default = Declaration


/***/ }),

/***/ 58085:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let Container = __nccwpck_require__(56919)

let LazyResult, Processor

class Document extends Container {
  constructor(defaults) {
    // type needs to be passed to super, otherwise child roots won't be normalized correctly
    super({ type: 'document', ...defaults })

    if (!this.nodes) {
      this.nodes = []
    }
  }

  toResult(opts = {}) {
    let lazy = new LazyResult(new Processor(), this, opts)

    return lazy.stringify()
  }
}

Document.registerLazyResult = dependant => {
  LazyResult = dependant
}

Document.registerProcessor = dependant => {
  Processor = dependant
}

module.exports = Document
Document.default = Document


/***/ }),

/***/ 71543:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let Declaration = __nccwpck_require__(33522)
let PreviousMap = __nccwpck_require__(91090)
let Comment = __nccwpck_require__(37592)
let AtRule = __nccwpck_require__(54193)
let Input = __nccwpck_require__(2690)
let Root = __nccwpck_require__(22630)
let Rule = __nccwpck_require__(12234)

function fromJSON(json, inputs) {
  if (Array.isArray(json)) return json.map(n => fromJSON(n))

  let { inputs: ownInputs, ...defaults } = json
  if (ownInputs) {
    inputs = []
    for (let input of ownInputs) {
      let inputHydrated = { ...input, __proto__: Input.prototype }
      if (inputHydrated.map) {
        inputHydrated.map = {
          ...inputHydrated.map,
          __proto__: PreviousMap.prototype
        }
      }
      inputs.push(inputHydrated)
    }
  }
  if (defaults.nodes) {
    defaults.nodes = json.nodes.map(n => fromJSON(n, inputs))
  }
  if (defaults.source) {
    let { inputId, ...source } = defaults.source
    defaults.source = source
    if (inputId != null) {
      defaults.source.input = inputs[inputId]
    }
  }
  if (defaults.type === 'root') {
    return new Root(defaults)
  } else if (defaults.type === 'decl') {
    return new Declaration(defaults)
  } else if (defaults.type === 'rule') {
    return new Rule(defaults)
  } else if (defaults.type === 'comment') {
    return new Comment(defaults)
  } else if (defaults.type === 'atrule') {
    return new AtRule(defaults)
  } else {
    throw new Error('Unknown node type: ' + json.type)
  }
}

module.exports = fromJSON
fromJSON.default = fromJSON


/***/ }),

/***/ 2690:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let { SourceMapConsumer, SourceMapGenerator } = __nccwpck_require__(26766)
let { fileURLToPath, pathToFileURL } = __nccwpck_require__(57310)
let { resolve, isAbsolute } = __nccwpck_require__(71017)
let { nanoid } = __nccwpck_require__(83163)

let terminalHighlight = __nccwpck_require__(51040)
let CssSyntaxError = __nccwpck_require__(63279)
let PreviousMap = __nccwpck_require__(91090)

let fromOffsetCache = Symbol('fromOffsetCache')

let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)
let pathAvailable = Boolean(resolve && isAbsolute)

class Input {
  constructor(css, opts = {}) {
    if (
      css === null ||
      typeof css === 'undefined' ||
      (typeof css === 'object' && !css.toString)
    ) {
      throw new Error(`PostCSS received ${css} instead of CSS string`)
    }

    this.css = css.toString()

    if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
      this.hasBOM = true
      this.css = this.css.slice(1)
    } else {
      this.hasBOM = false
    }

    if (opts.from) {
      if (
        !pathAvailable ||
        /^\w+:\/\//.test(opts.from) ||
        isAbsolute(opts.from)
      ) {
        this.file = opts.from
      } else {
        this.file = resolve(opts.from)
      }
    }

    if (pathAvailable && sourceMapAvailable) {
      let map = new PreviousMap(this.css, opts)
      if (map.text) {
        this.map = map
        let file = map.consumer().file
        if (!this.file && file) this.file = this.mapResolve(file)
      }
    }

    if (!this.file) {
      this.id = '<input css ' + nanoid(6) + '>'
    }
    if (this.map) this.map.file = this.from
  }

  fromOffset(offset) {
    let lastLine, lineToIndex
    if (!this[fromOffsetCache]) {
      let lines = this.css.split('\n')
      lineToIndex = new Array(lines.length)
      let prevIndex = 0

      for (let i = 0, l = lines.length; i < l; i++) {
        lineToIndex[i] = prevIndex
        prevIndex += lines[i].length + 1
      }

      this[fromOffsetCache] = lineToIndex
    } else {
      lineToIndex = this[fromOffsetCache]
    }
    lastLine = lineToIndex[lineToIndex.length - 1]

    let min = 0
    if (offset >= lastLine) {
      min = lineToIndex.length - 1
    } else {
      let max = lineToIndex.length - 2
      let mid
      while (min < max) {
        mid = min + ((max - min) >> 1)
        if (offset < lineToIndex[mid]) {
          max = mid - 1
        } else if (offset >= lineToIndex[mid + 1]) {
          min = mid + 1
        } else {
          min = mid
          break
        }
      }
    }
    return {
      line: min + 1,
      col: offset - lineToIndex[min] + 1
    }
  }

  error(message, line, column, opts = {}) {
    let result, endLine, endColumn

    if (line && typeof line === 'object') {
      let start = line
      let end = column
      if (typeof start.offset === 'number') {
        let pos = this.fromOffset(start.offset)
        line = pos.line
        column = pos.col
      } else {
        line = start.line
        column = start.column
      }
      if (typeof end.offset === 'number') {
        let pos = this.fromOffset(end.offset)
        endLine = pos.line
        endColumn = pos.col
      } else {
        endLine = end.line
        endColumn = end.column
      }
    } else if (!column) {
      let pos = this.fromOffset(line)
      line = pos.line
      column = pos.col
    }

    let origin = this.origin(line, column, endLine, endColumn)
    if (origin) {
      result = new CssSyntaxError(
        message,
        origin.endLine === undefined
          ? origin.line
          : { line: origin.line, column: origin.column },
        origin.endLine === undefined
          ? origin.column
          : { line: origin.endLine, column: origin.endColumn },
        origin.source,
        origin.file,
        opts.plugin
      )
    } else {
      result = new CssSyntaxError(
        message,
        endLine === undefined ? line : { line, column },
        endLine === undefined ? column : { line: endLine, column: endColumn },
        this.css,
        this.file,
        opts.plugin
      )
    }

    result.input = { line, column, endLine, endColumn, source: this.css }
    if (this.file) {
      if (pathToFileURL) {
        result.input.url = pathToFileURL(this.file).toString()
      }
      result.input.file = this.file
    }

    return result
  }

  origin(line, column, endLine, endColumn) {
    if (!this.map) return false
    let consumer = this.map.consumer()

    let from = consumer.originalPositionFor({ line, column })
    if (!from.source) return false

    let to
    if (typeof endLine === 'number') {
      to = consumer.originalPositionFor({ line: endLine, column: endColumn })
    }

    let fromUrl

    if (isAbsolute(from.source)) {
      fromUrl = pathToFileURL(from.source)
    } else {
      fromUrl = new URL(
        from.source,
        this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
      )
    }

    let result = {
      url: fromUrl.toString(),
      line: from.line,
      column: from.column,
      endLine: to && to.line,
      endColumn: to && to.column
    }

    if (fromUrl.protocol === 'file:') {
      if (fileURLToPath) {
        result.file = fileURLToPath(fromUrl)
      } else {
        /* c8 ignore next 2 */
        throw new Error(`file: protocol is not available in this PostCSS build`)
      }
    }

    let source = consumer.sourceContentFor(from.source)
    if (source) result.source = source

    return result
  }

  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file
    }
    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file)
  }

  get from() {
    return this.file || this.id
  }

  toJSON() {
    let json = {}
    for (let name of ['hasBOM', 'css', 'file', 'id']) {
      if (this[name] != null) {
        json[name] = this[name]
      }
    }
    if (this.map) {
      json.map = { ...this.map }
      if (json.map.consumerCache) {
        json.map.consumerCache = undefined
      }
    }
    return json
  }
}

module.exports = Input
Input.default = Input

if (terminalHighlight && terminalHighlight.registerInput) {
  terminalHighlight.registerInput(Input)
}


/***/ }),

/***/ 46310:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let { isClean, my } = __nccwpck_require__(32594)
let MapGenerator = __nccwpck_require__(93091)
let stringify = __nccwpck_require__(34793)
let Container = __nccwpck_require__(56919)
let Document = __nccwpck_require__(58085)
let warnOnce = __nccwpck_require__(21600)
let Result = __nccwpck_require__(66846)
let parse = __nccwpck_require__(2128)
let Root = __nccwpck_require__(22630)

const TYPE_TO_CLASS_NAME = {
  document: 'Document',
  root: 'Root',
  atrule: 'AtRule',
  rule: 'Rule',
  decl: 'Declaration',
  comment: 'Comment'
}

const PLUGIN_PROPS = {
  postcssPlugin: true,
  prepare: true,
  Once: true,
  Document: true,
  Root: true,
  Declaration: true,
  Rule: true,
  AtRule: true,
  Comment: true,
  DeclarationExit: true,
  RuleExit: true,
  AtRuleExit: true,
  CommentExit: true,
  RootExit: true,
  DocumentExit: true,
  OnceExit: true
}

const NOT_VISITORS = {
  postcssPlugin: true,
  prepare: true,
  Once: true
}

const CHILDREN = 0

function isPromise(obj) {
  return typeof obj === 'object' && typeof obj.then === 'function'
}

function getEvents(node) {
  let key = false
  let type = TYPE_TO_CLASS_NAME[node.type]
  if (node.type === 'decl') {
    key = node.prop.toLowerCase()
  } else if (node.type === 'atrule') {
    key = node.name.toLowerCase()
  }

  if (key && node.append) {
    return [
      type,
      type + '-' + key,
      CHILDREN,
      type + 'Exit',
      type + 'Exit-' + key
    ]
  } else if (key) {
    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key]
  } else if (node.append) {
    return [type, CHILDREN, type + 'Exit']
  } else {
    return [type, type + 'Exit']
  }
}

function toStack(node) {
  let events
  if (node.type === 'document') {
    events = ['Document', CHILDREN, 'DocumentExit']
  } else if (node.type === 'root') {
    events = ['Root', CHILDREN, 'RootExit']
  } else {
    events = getEvents(node)
  }

  return {
    node,
    events,
    eventIndex: 0,
    visitors: [],
    visitorIndex: 0,
    iterator: 0
  }
}

function cleanMarks(node) {
  node[isClean] = false
  if (node.nodes) node.nodes.forEach(i => cleanMarks(i))
  return node
}

let postcss = {}

class LazyResult {
  constructor(processor, css, opts) {
    this.stringified = false
    this.processed = false

    let root
    if (
      typeof css === 'object' &&
      css !== null &&
      (css.type === 'root' || css.type === 'document')
    ) {
      root = cleanMarks(css)
    } else if (css instanceof LazyResult || css instanceof Result) {
      root = cleanMarks(css.root)
      if (css.map) {
        if (typeof opts.map === 'undefined') opts.map = {}
        if (!opts.map.inline) opts.map.inline = false
        opts.map.prev = css.map
      }
    } else {
      let parser = parse
      if (opts.syntax) parser = opts.syntax.parse
      if (opts.parser) parser = opts.parser
      if (parser.parse) parser = parser.parse

      try {
        root = parser(css, opts)
      } catch (error) {
        this.processed = true
        this.error = error
      }

      if (root && !root[my]) {
        /* c8 ignore next 2 */
        Container.rebuild(root)
      }
    }

    this.result = new Result(processor, root, opts)
    this.helpers = { ...postcss, result: this.result, postcss }
    this.plugins = this.processor.plugins.map(plugin => {
      if (typeof plugin === 'object' && plugin.prepare) {
        return { ...plugin, ...plugin.prepare(this.result) }
      } else {
        return plugin
      }
    })
  }

  get [Symbol.toStringTag]() {
    return 'LazyResult'
  }

  get processor() {
    return this.result.processor
  }

  get opts() {
    return this.result.opts
  }

  get css() {
    return this.stringify().css
  }

  get content() {
    return this.stringify().content
  }

  get map() {
    return this.stringify().map
  }

  get root() {
    return this.sync().root
  }

  get messages() {
    return this.sync().messages
  }

  warnings() {
    return this.sync().warnings()
  }

  toString() {
    return this.css
  }

  then(onFulfilled, onRejected) {
    if (process.env.NODE_ENV !== 'production') {
      if (!('from' in this.opts)) {
        warnOnce(
          'Without `from` option PostCSS could generate wrong source map ' +
            'and will not find Browserslist config. Set it to CSS file path ' +
            'or to `undefined` to prevent this warning.'
        )
      }
    }
    return this.async().then(onFulfilled, onRejected)
  }

  catch(onRejected) {
    return this.async().catch(onRejected)
  }

  finally(onFinally) {
    return this.async().then(onFinally, onFinally)
  }

  async() {
    if (this.error) return Promise.reject(this.error)
    if (this.processed) return Promise.resolve(this.result)
    if (!this.processing) {
      this.processing = this.runAsync()
    }
    return this.processing
  }

  sync() {
    if (this.error) throw this.error
    if (this.processed) return this.result
    this.processed = true

    if (this.processing) {
      throw this.getAsyncError()
    }

    for (let plugin of this.plugins) {
      let promise = this.runOnRoot(plugin)
      if (isPromise(promise)) {
        throw this.getAsyncError()
      }
    }

    this.prepareVisitors()
    if (this.hasListener) {
      let root = this.result.root
      while (!root[isClean]) {
        root[isClean] = true
        this.walkSync(root)
      }
      if (this.listeners.OnceExit) {
        if (root.type === 'document') {
          for (let subRoot of root.nodes) {
            this.visitSync(this.listeners.OnceExit, subRoot)
          }
        } else {
          this.visitSync(this.listeners.OnceExit, root)
        }
      }
    }

    return this.result
  }

  stringify() {
    if (this.error) throw this.error
    if (this.stringified) return this.result
    this.stringified = true

    this.sync()

    let opts = this.result.opts
    let str = stringify
    if (opts.syntax) str = opts.syntax.stringify
    if (opts.stringifier) str = opts.stringifier
    if (str.stringify) str = str.stringify

    let map = new MapGenerator(str, this.result.root, this.result.opts)
    let data = map.generate()
    this.result.css = data[0]
    this.result.map = data[1]

    return this.result
  }

  walkSync(node) {
    node[isClean] = true
    let events = getEvents(node)
    for (let event of events) {
      if (event === CHILDREN) {
        if (node.nodes) {
          node.each(child => {
            if (!child[isClean]) this.walkSync(child)
          })
        }
      } else {
        let visitors = this.listeners[event]
        if (visitors) {
          if (this.visitSync(visitors, node.toProxy())) return
        }
      }
    }
  }

  visitSync(visitors, node) {
    for (let [plugin, visitor] of visitors) {
      this.result.lastPlugin = plugin
      let promise
      try {
        promise = visitor(node, this.helpers)
      } catch (e) {
        throw this.handleError(e, node.proxyOf)
      }
      if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
        return true
      }
      if (isPromise(promise)) {
        throw this.getAsyncError()
      }
    }
  }

  runOnRoot(plugin) {
    this.result.lastPlugin = plugin
    try {
      if (typeof plugin === 'object' && plugin.Once) {
        if (this.result.root.type === 'document') {
          let roots = this.result.root.nodes.map(root =>
            plugin.Once(root, this.helpers)
          )

          if (isPromise(roots[0])) {
            return Promise.all(roots)
          }

          return roots
        }

        return plugin.Once(this.result.root, this.helpers)
      } else if (typeof plugin === 'function') {
        return plugin(this.result.root, this.result)
      }
    } catch (error) {
      throw this.handleError(error)
    }
  }

  getAsyncError() {
    throw new Error('Use process(css).then(cb) to work with async plugins')
  }

  handleError(error, node) {
    let plugin = this.result.lastPlugin
    try {
      if (node) node.addToError(error)
      this.error = error
      if (error.name === 'CssSyntaxError' && !error.plugin) {
        error.plugin = plugin.postcssPlugin
        error.setMessage()
      } else if (plugin.postcssVersion) {
        if (process.env.NODE_ENV !== 'production') {
          let pluginName = plugin.postcssPlugin
          let pluginVer = plugin.postcssVersion
          let runtimeVer = this.result.processor.version
          let a = pluginVer.split('.')
          let b = runtimeVer.split('.')

          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
            // eslint-disable-next-line no-console
            console.error(
              'Unknown error from PostCSS plugin. Your current PostCSS ' +
                'version is ' +
                runtimeVer +
                ', but ' +
                pluginName +
                ' uses ' +
                pluginVer +
                '. Perhaps this is the source of the error below.'
            )
          }
        }
      }
    } catch (err) {
      /* c8 ignore next 3 */
      // eslint-disable-next-line no-console
      if (console && console.error) console.error(err)
    }
    return error
  }

  async runAsync() {
    this.plugin = 0
    for (let i = 0; i < this.plugins.length; i++) {
      let plugin = this.plugins[i]
      let promise = this.runOnRoot(plugin)
      if (isPromise(promise)) {
        try {
          await promise
        } catch (error) {
          throw this.handleError(error)
        }
      }
    }

    this.prepareVisitors()
    if (this.hasListener) {
      let root = this.result.root
      while (!root[isClean]) {
        root[isClean] = true
        let stack = [toStack(root)]
        while (stack.length > 0) {
          let promise = this.visitTick(stack)
          if (isPromise(promise)) {
            try {
              await promise
            } catch (e) {
              let node = stack[stack.length - 1].node
              throw this.handleError(e, node)
            }
          }
        }
      }

      if (this.listeners.OnceExit) {
        for (let [plugin, visitor] of this.listeners.OnceExit) {
          this.result.lastPlugin = plugin
          try {
            if (root.type === 'document') {
              let roots = root.nodes.map(subRoot =>
                visitor(subRoot, this.helpers)
              )

              await Promise.all(roots)
            } else {
              await visitor(root, this.helpers)
            }
          } catch (e) {
            throw this.handleError(e)
          }
        }
      }
    }

    this.processed = true
    return this.stringify()
  }

  prepareVisitors() {
    this.listeners = {}
    let add = (plugin, type, cb) => {
      if (!this.listeners[type]) this.listeners[type] = []
      this.listeners[type].push([plugin, cb])
    }
    for (let plugin of this.plugins) {
      if (typeof plugin === 'object') {
        for (let event in plugin) {
          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
            throw new Error(
              `Unknown event ${event} in ${plugin.postcssPlugin}. ` +
                `Try to update PostCSS (${this.processor.version} now).`
            )
          }
          if (!NOT_VISITORS[event]) {
            if (typeof plugin[event] === 'object') {
              for (let filter in plugin[event]) {
                if (filter === '*') {
                  add(plugin, event, plugin[event][filter])
                } else {
                  add(
                    plugin,
                    event + '-' + filter.toLowerCase(),
                    plugin[event][filter]
                  )
                }
              }
            } else if (typeof plugin[event] === 'function') {
              add(plugin, event, plugin[event])
            }
          }
        }
      }
    }
    this.hasListener = Object.keys(this.listeners).length > 0
  }

  visitTick(stack) {
    let visit = stack[stack.length - 1]
    let { node, visitors } = visit

    if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
      stack.pop()
      return
    }

    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
      let [plugin, visitor] = visitors[visit.visitorIndex]
      visit.visitorIndex += 1
      if (visit.visitorIndex === visitors.length) {
        visit.visitors = []
        visit.visitorIndex = 0
      }
      this.result.lastPlugin = plugin
      try {
        return visitor(node.toProxy(), this.helpers)
      } catch (e) {
        throw this.handleError(e, node)
      }
    }

    if (visit.iterator !== 0) {
      let iterator = visit.iterator
      let child
      while ((child = node.nodes[node.indexes[iterator]])) {
        node.indexes[iterator] += 1
        if (!child[isClean]) {
          child[isClean] = true
          stack.push(toStack(child))
          return
        }
      }
      visit.iterator = 0
      delete node.indexes[iterator]
    }

    let events = visit.events
    while (visit.eventIndex < events.length) {
      let event = events[visit.eventIndex]
      visit.eventIndex += 1
      if (event === CHILDREN) {
        if (node.nodes && node.nodes.length) {
          node[isClean] = true
          visit.iterator = node.getIterator()
        }
        return
      } else if (this.listeners[event]) {
        visit.visitors = this.listeners[event]
        return
      }
    }
    stack.pop()
  }
}

LazyResult.registerPostcss = dependant => {
  postcss = dependant
}

module.exports = LazyResult
LazyResult.default = LazyResult

Root.registerLazyResult(LazyResult)
Document.registerLazyResult(LazyResult)


/***/ }),

/***/ 41608:
/***/ ((module) => {

"use strict";


let list = {
  split(string, separators, last) {
    let array = []
    let current = ''
    let split = false

    let func = 0
    let inQuote = false
    let prevQuote = ''
    let escape = false

    for (let letter of string) {
      if (escape) {
        escape = false
      } else if (letter === '\\') {
        escape = true
      } else if (inQuote) {
        if (letter === prevQuote) {
          inQuote = false
        }
      } else if (letter === '"' || letter === "'") {
        inQuote = true
        prevQuote = letter
      } else if (letter === '(') {
        func += 1
      } else if (letter === ')') {
        if (func > 0) func -= 1
      } else if (func === 0) {
        if (separators.includes(letter)) split = true
      }

      if (split) {
        if (current !== '') array.push(current.trim())
        current = ''
        split = false
      } else {
        current += letter
      }
    }

    if (last || current !== '') array.push(current.trim())
    return array
  },

  space(string) {
    let spaces = [' ', '\n', '\t']
    return list.split(string, spaces)
  },

  comma(string) {
    return list.split(string, [','], true)
  }
}

module.exports = list
list.default = list


/***/ }),

/***/ 93091:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let { SourceMapConsumer, SourceMapGenerator } = __nccwpck_require__(26766)
let { dirname, resolve, relative, sep } = __nccwpck_require__(71017)
let { pathToFileURL } = __nccwpck_require__(57310)

let Input = __nccwpck_require__(2690)

let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)
let pathAvailable = Boolean(dirname && resolve && relative && sep)

class MapGenerator {
  constructor(stringify, root, opts, cssString) {
    this.stringify = stringify
    this.mapOpts = opts.map || {}
    this.root = root
    this.opts = opts
    this.css = cssString
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute
  }

  isMap() {
    if (typeof this.opts.map !== 'undefined') {
      return !!this.opts.map
    }
    return this.previous().length > 0
  }

  previous() {
    if (!this.previousMaps) {
      this.previousMaps = []
      if (this.root) {
        this.root.walk(node => {
          if (node.source && node.source.input.map) {
            let map = node.source.input.map
            if (!this.previousMaps.includes(map)) {
              this.previousMaps.push(map)
            }
          }
        })
      } else {
        let input = new Input(this.css, this.opts)
        if (input.map) this.previousMaps.push(input.map)
      }
    }

    return this.previousMaps
  }

  isInline() {
    if (typeof this.mapOpts.inline !== 'undefined') {
      return this.mapOpts.inline
    }

    let annotation = this.mapOpts.annotation
    if (typeof annotation !== 'undefined' && annotation !== true) {
      return false
    }

    if (this.previous().length) {
      return this.previous().some(i => i.inline)
    }
    return true
  }

  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== 'undefined') {
      return this.mapOpts.sourcesContent
    }
    if (this.previous().length) {
      return this.previous().some(i => i.withContent())
    }
    return true
  }

  clearAnnotation() {
    if (this.mapOpts.annotation === false) return

    if (this.root) {
      let node
      for (let i = this.root.nodes.length - 1; i >= 0; i--) {
        node = this.root.nodes[i]
        if (node.type !== 'comment') continue
        if (node.text.indexOf('# sourceMappingURL=') === 0) {
          this.root.removeChild(i)
        }
      }
    } else if (this.css) {
      this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, '')
    }
  }

  setSourcesContent() {
    let already = {}
    if (this.root) {
      this.root.walk(node => {
        if (node.source) {
          let from = node.source.input.from
          if (from && !already[from]) {
            already[from] = true
            let fromUrl = this.usesFileUrls
              ? this.toFileUrl(from)
              : this.toUrl(this.path(from))
            this.map.setSourceContent(fromUrl, node.source.input.css)
          }
        }
      })
    } else if (this.css) {
      let from = this.opts.from
        ? this.toUrl(this.path(this.opts.from))
        : '<no source>'
      this.map.setSourceContent(from, this.css)
    }
  }

  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from = this.toUrl(this.path(prev.file))
      let root = prev.root || dirname(prev.file)
      let map

      if (this.mapOpts.sourcesContent === false) {
        map = new SourceMapConsumer(prev.text)
        if (map.sourcesContent) {
          map.sourcesContent = map.sourcesContent.map(() => null)
        }
      } else {
        map = prev.consumer()
      }

      this.map.applySourceMap(map, from, this.toUrl(this.path(root)))
    }
  }

  isAnnotation() {
    if (this.isInline()) {
      return true
    }
    if (typeof this.mapOpts.annotation !== 'undefined') {
      return this.mapOpts.annotation
    }
    if (this.previous().length) {
      return this.previous().some(i => i.annotation)
    }
    return true
  }

  toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString('base64')
    } else {
      return window.btoa(unescape(encodeURIComponent(str)))
    }
  }

  addAnnotation() {
    let content

    if (this.isInline()) {
      content =
        'data:application/json;base64,' + this.toBase64(this.map.toString())
    } else if (typeof this.mapOpts.annotation === 'string') {
      content = this.mapOpts.annotation
    } else if (typeof this.mapOpts.annotation === 'function') {
      content = this.mapOpts.annotation(this.opts.to, this.root)
    } else {
      content = this.outputFile() + '.map'
    }
    let eol = '\n'
    if (this.css.includes('\r\n')) eol = '\r\n'

    this.css += eol + '/*# sourceMappingURL=' + content + ' */'
  }

  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to)
    } else if (this.opts.from) {
      return this.path(this.opts.from)
    } else {
      return 'to.css'
    }
  }

  generateMap() {
    if (this.root) {
      this.generateString()
    } else if (this.previous().length === 1) {
      let prev = this.previous()[0].consumer()
      prev.file = this.outputFile()
      this.map = SourceMapGenerator.fromSourceMap(prev)
    } else {
      this.map = new SourceMapGenerator({ file: this.outputFile() })
      this.map.addMapping({
        source: this.opts.from
          ? this.toUrl(this.path(this.opts.from))
          : '<no source>',
        generated: { line: 1, column: 0 },
        original: { line: 1, column: 0 }
      })
    }

    if (this.isSourcesContent()) this.setSourcesContent()
    if (this.root && this.previous().length > 0) this.applyPrevMaps()
    if (this.isAnnotation()) this.addAnnotation()

    if (this.isInline()) {
      return [this.css]
    } else {
      return [this.css, this.map]
    }
  }

  path(file) {
    if (file.indexOf('<') === 0) return file
    if (/^\w+:\/\//.test(file)) return file
    if (this.mapOpts.absolute) return file

    let from = this.opts.to ? dirname(this.opts.to) : '.'

    if (typeof this.mapOpts.annotation === 'string') {
      from = dirname(resolve(from, this.mapOpts.annotation))
    }

    file = relative(from, file)
    return file
  }

  toUrl(path) {
    if (sep === '\\') {
      path = path.replace(/\\/g, '/')
    }
    return encodeURI(path).replace(/[#?]/g, encodeURIComponent)
  }

  toFileUrl(path) {
    if (pathToFileURL) {
      return pathToFileURL(path).toString()
    } else {
      throw new Error(
        '`map.absolute` option is not available in this PostCSS build'
      )
    }
  }

  sourcePath(node) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from)
    } else if (this.usesFileUrls) {
      return this.toFileUrl(node.source.input.from)
    } else {
      return this.toUrl(this.path(node.source.input.from))
    }
  }

  generateString() {
    this.css = ''
    this.map = new SourceMapGenerator({ file: this.outputFile() })

    let line = 1
    let column = 1

    let noSource = '<no source>'
    let mapping = {
      source: '',
      generated: { line: 0, column: 0 },
      original: { line: 0, column: 0 }
    }

    let lines, last
    this.stringify(this.root, (str, node, type) => {
      this.css += str

      if (node && type !== 'end') {
        mapping.generated.line = line
        mapping.generated.column = column - 1
        if (node.source && node.source.start) {
          mapping.source = this.sourcePath(node)
          mapping.original.line = node.source.start.line
          mapping.original.column = node.source.start.column - 1
          this.map.addMapping(mapping)
        } else {
          mapping.source = noSource
          mapping.original.line = 1
          mapping.original.column = 0
          this.map.addMapping(mapping)
        }
      }

      lines = str.match(/\n/g)
      if (lines) {
        line += lines.length
        last = str.lastIndexOf('\n')
        column = str.length - last
      } else {
        column += str.length
      }

      if (node && type !== 'start') {
        let p = node.parent || { raws: {} }
        let childless =
          node.type === 'decl' || (node.type === 'atrule' && !node.nodes)
        if (!childless || node !== p.last || p.raws.semicolon) {
          if (node.source && node.source.end) {
            mapping.source = this.sourcePath(node)
            mapping.original.line = node.source.end.line
            mapping.original.column = node.source.end.column - 1
            mapping.generated.line = line
            mapping.generated.column = column - 2
            this.map.addMapping(mapping)
          } else {
            mapping.source = noSource
            mapping.original.line = 1
            mapping.original.column = 0
            mapping.generated.line = line
            mapping.generated.column = column - 1
            this.map.addMapping(mapping)
          }
        }
      }
    })
  }

  generate() {
    this.clearAnnotation()
    if (pathAvailable && sourceMapAvailable && this.isMap()) {
      return this.generateMap()
    } else {
      let result = ''
      this.stringify(this.root, i => {
        result += i
      })
      return [result]
    }
  }
}

module.exports = MapGenerator


/***/ }),

/***/ 69810:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let MapGenerator = __nccwpck_require__(93091)
let stringify = __nccwpck_require__(34793)
let warnOnce = __nccwpck_require__(21600)
let parse = __nccwpck_require__(2128)
const Result = __nccwpck_require__(66846)

class NoWorkResult {
  constructor(processor, css, opts) {
    css = css.toString()
    this.stringified = false

    this._processor = processor
    this._css = css
    this._opts = opts
    this._map = undefined
    let root

    let str = stringify
    this.result = new Result(this._processor, root, this._opts)
    this.result.css = css

    let self = this
    Object.defineProperty(this.result, 'root', {
      get() {
        return self.root
      }
    })

    let map = new MapGenerator(str, root, this._opts, css)
    if (map.isMap()) {
      let [generatedCSS, generatedMap] = map.generate()
      if (generatedCSS) {
        this.result.css = generatedCSS
      }
      if (generatedMap) {
        this.result.map = generatedMap
      }
    }
  }

  get [Symbol.toStringTag]() {
    return 'NoWorkResult'
  }

  get processor() {
    return this.result.processor
  }

  get opts() {
    return this.result.opts
  }

  get css() {
    return this.result.css
  }

  get content() {
    return this.result.css
  }

  get map() {
    return this.result.map
  }

  get root() {
    if (this._root) {
      return this._root
    }

    let root
    let parser = parse

    try {
      root = parser(this._css, this._opts)
    } catch (error) {
      this.error = error
    }

    if (this.error) {
      throw this.error
    } else {
      this._root = root
      return root
    }
  }

  get messages() {
    return []
  }

  warnings() {
    return []
  }

  toString() {
    return this._css
  }

  then(onFulfilled, onRejected) {
    if (process.env.NODE_ENV !== 'production') {
      if (!('from' in this._opts)) {
        warnOnce(
          'Without `from` option PostCSS could generate wrong source map ' +
            'and will not find Browserslist config. Set it to CSS file path ' +
            'or to `undefined` to prevent this warning.'
        )
      }
    }

    return this.async().then(onFulfilled, onRejected)
  }

  catch(onRejected) {
    return this.async().catch(onRejected)
  }

  finally(onFinally) {
    return this.async().then(onFinally, onFinally)
  }

  async() {
    if (this.error) return Promise.reject(this.error)
    return Promise.resolve(this.result)
  }

  sync() {
    if (this.error) throw this.error
    return this.result
  }
}

module.exports = NoWorkResult
NoWorkResult.default = NoWorkResult


/***/ }),

/***/ 48557:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let { isClean, my } = __nccwpck_require__(32594)
let CssSyntaxError = __nccwpck_require__(63279)
let Stringifier = __nccwpck_require__(59414)
let stringify = __nccwpck_require__(34793)

function cloneNode(obj, parent) {
  let cloned = new obj.constructor()

  for (let i in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i)) {
      /* c8 ignore next 2 */
      continue
    }
    if (i === 'proxyCache') continue
    let value = obj[i]
    let type = typeof value

    if (i === 'parent' && type === 'object') {
      if (parent) cloned[i] = parent
    } else if (i === 'source') {
      cloned[i] = value
    } else if (Array.isArray(value)) {
      cloned[i] = value.map(j => cloneNode(j, cloned))
    } else {
      if (type === 'object' && value !== null) value = cloneNode(value)
      cloned[i] = value
    }
  }

  return cloned
}

class Node {
  constructor(defaults = {}) {
    this.raws = {}
    this[isClean] = false
    this[my] = true

    for (let name in defaults) {
      if (name === 'nodes') {
        this.nodes = []
        for (let node of defaults[name]) {
          if (typeof node.clone === 'function') {
            this.append(node.clone())
          } else {
            this.append(node)
          }
        }
      } else {
        this[name] = defaults[name]
      }
    }
  }

  error(message, opts = {}) {
    if (this.source) {
      let { start, end } = this.rangeBy(opts)
      return this.source.input.error(
        message,
        { line: start.line, column: start.column },
        { line: end.line, column: end.column },
        opts
      )
    }
    return new CssSyntaxError(message)
  }

  warn(result, text, opts) {
    let data = { node: this }
    for (let i in opts) data[i] = opts[i]
    return result.warn(text, data)
  }

  remove() {
    if (this.parent) {
      this.parent.removeChild(this)
    }
    this.parent = undefined
    return this
  }

  toString(stringifier = stringify) {
    if (stringifier.stringify) stringifier = stringifier.stringify
    let result = ''
    stringifier(this, i => {
      result += i
    })
    return result
  }

  assign(overrides = {}) {
    for (let name in overrides) {
      this[name] = overrides[name]
    }
    return this
  }

  clone(overrides = {}) {
    let cloned = cloneNode(this)
    for (let name in overrides) {
      cloned[name] = overrides[name]
    }
    return cloned
  }

  cloneBefore(overrides = {}) {
    let cloned = this.clone(overrides)
    this.parent.insertBefore(this, cloned)
    return cloned
  }

  cloneAfter(overrides = {}) {
    let cloned = this.clone(overrides)
    this.parent.insertAfter(this, cloned)
    return cloned
  }

  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this
      let foundSelf = false
      for (let node of nodes) {
        if (node === this) {
          foundSelf = true
        } else if (foundSelf) {
          this.parent.insertAfter(bookmark, node)
          bookmark = node
        } else {
          this.parent.insertBefore(bookmark, node)
        }
      }

      if (!foundSelf) {
        this.remove()
      }
    }

    return this
  }

  next() {
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index + 1]
  }

  prev() {
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index - 1]
  }

  before(add) {
    this.parent.insertBefore(this, add)
    return this
  }

  after(add) {
    this.parent.insertAfter(this, add)
    return this
  }

  root() {
    let result = this
    while (result.parent && result.parent.type !== 'document') {
      result = result.parent
    }
    return result
  }

  raw(prop, defaultType) {
    let str = new Stringifier()
    return str.raw(this, prop, defaultType)
  }

  cleanRaws(keepBetween) {
    delete this.raws.before
    delete this.raws.after
    if (!keepBetween) delete this.raws.between
  }

  toJSON(_, inputs) {
    let fixed = {}
    let emitInputs = inputs == null
    inputs = inputs || new Map()
    let inputsNextIndex = 0

    for (let name in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name)) {
        /* c8 ignore next 2 */
        continue
      }
      if (name === 'parent' || name === 'proxyCache') continue
      let value = this[name]

      if (Array.isArray(value)) {
        fixed[name] = value.map(i => {
          if (typeof i === 'object' && i.toJSON) {
            return i.toJSON(null, inputs)
          } else {
            return i
          }
        })
      } else if (typeof value === 'object' && value.toJSON) {
        fixed[name] = value.toJSON(null, inputs)
      } else if (name === 'source') {
        let inputId = inputs.get(value.input)
        if (inputId == null) {
          inputId = inputsNextIndex
          inputs.set(value.input, inputsNextIndex)
          inputsNextIndex++
        }
        fixed[name] = {
          inputId,
          start: value.start,
          end: value.end
        }
      } else {
        fixed[name] = value
      }
    }

    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map(input => input.toJSON())
    }

    return fixed
  }

  positionInside(index) {
    let string = this.toString()
    let column = this.source.start.column
    let line = this.source.start.line

    for (let i = 0; i < index; i++) {
      if (string[i] === '\n') {
        column = 1
        line += 1
      } else {
        column += 1
      }
    }

    return { line, column }
  }

  positionBy(opts) {
    let pos = this.source.start
    if (opts.index) {
      pos = this.positionInside(opts.index)
    } else if (opts.word) {
      let index = this.toString().indexOf(opts.word)
      if (index !== -1) pos = this.positionInside(index)
    }
    return pos
  }

  rangeBy(opts) {
    let start = {
      line: this.source.start.line,
      column: this.source.start.column
    }
    let end = this.source.end
      ? {
          line: this.source.end.line,
          column: this.source.end.column + 1
        }
      : {
          line: start.line,
          column: start.column + 1
        }

    if (opts.word) {
      let index = this.toString().indexOf(opts.word)
      if (index !== -1) {
        start = this.positionInside(index)
        end = this.positionInside(index + opts.word.length)
      }
    } else {
      if (opts.start) {
        start = {
          line: opts.start.line,
          column: opts.start.column
        }
      } else if (opts.index) {
        start = this.positionInside(opts.index)
      }

      if (opts.end) {
        end = {
          line: opts.end.line,
          column: opts.end.column
        }
      } else if (opts.endIndex) {
        end = this.positionInside(opts.endIndex)
      } else if (opts.index) {
        end = this.positionInside(opts.index + 1)
      }
    }

    if (
      end.line < start.line ||
      (end.line === start.line && end.column <= start.column)
    ) {
      end = { line: start.line, column: start.column + 1 }
    }

    return { start, end }
  }

  getProxyProcessor() {
    return {
      set(node, prop, value) {
        if (node[prop] === value) return true
        node[prop] = value
        if (
          prop === 'prop' ||
          prop === 'value' ||
          prop === 'name' ||
          prop === 'params' ||
          prop === 'important' ||
          /* c8 ignore next */
          prop === 'text'
        ) {
          node.markDirty()
        }
        return true
      },

      get(node, prop) {
        if (prop === 'proxyOf') {
          return node
        } else if (prop === 'root') {
          return () => node.root().toProxy()
        } else {
          return node[prop]
        }
      }
    }
  }

  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor())
    }
    return this.proxyCache
  }

  addToError(error) {
    error.postcssNode = this
    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
      let s = this.source
      error.stack = error.stack.replace(
        /\n\s{4}at /,
        `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
      )
    }
    return error
  }

  markDirty() {
    if (this[isClean]) {
      this[isClean] = false
      let next = this
      while ((next = next.parent)) {
        next[isClean] = false
      }
    }
  }

  get proxyOf() {
    return this
  }
}

module.exports = Node
Node.default = Node


/***/ }),

/***/ 2128:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let Container = __nccwpck_require__(56919)
let Parser = __nccwpck_require__(95613)
let Input = __nccwpck_require__(2690)

function parse(css, opts) {
  let input = new Input(css, opts)
  let parser = new Parser(input)
  try {
    parser.parse()
  } catch (e) {
    if (process.env.NODE_ENV !== 'production') {
      if (e.name === 'CssSyntaxError' && opts && opts.from) {
        if (/\.scss$/i.test(opts.from)) {
          e.message +=
            '\nYou tried to parse SCSS with ' +
            'the standard CSS parser; ' +
            'try again with the postcss-scss parser'
        } else if (/\.sass/i.test(opts.from)) {
          e.message +=
            '\nYou tried to parse Sass with ' +
            'the standard CSS parser; ' +
            'try again with the postcss-sass parser'
        } else if (/\.less$/i.test(opts.from)) {
          e.message +=
            '\nYou tried to parse Less with ' +
            'the standard CSS parser; ' +
            'try again with the postcss-less parser'
        }
      }
    }
    throw e
  }

  return parser.root
}

module.exports = parse
parse.default = parse

Container.registerParse(parse)


/***/ }),

/***/ 95613:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let Declaration = __nccwpck_require__(33522)
let tokenizer = __nccwpck_require__(45790)
let Comment = __nccwpck_require__(37592)
let AtRule = __nccwpck_require__(54193)
let Root = __nccwpck_require__(22630)
let Rule = __nccwpck_require__(12234)

const SAFE_COMMENT_NEIGHBOR = {
  empty: true,
  space: true
}

function findLastWithPosition(tokens) {
  for (let i = tokens.length - 1; i >= 0; i--) {
    let token = tokens[i]
    let pos = token[3] || token[2]
    if (pos) return pos
  }
}

class Parser {
  constructor(input) {
    this.input = input

    this.root = new Root()
    this.current = this.root
    this.spaces = ''
    this.semicolon = false
    this.customProperty = false

    this.createTokenizer()
    this.root.source = { input, start: { offset: 0, line: 1, column: 1 } }
  }

  createTokenizer() {
    this.tokenizer = tokenizer(this.input)
  }

  parse() {
    let token
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken()

      switch (token[0]) {
        case 'space':
          this.spaces += token[1]
          break

        case ';':
          this.freeSemicolon(token)
          break

        case '}':
          this.end(token)
          break

        case 'comment':
          this.comment(token)
          break

        case 'at-word':
          this.atrule(token)
          break

        case '{':
          this.emptyRule(token)
          break

        default:
          this.other(token)
          break
      }
    }
    this.endFile()
  }

  comment(token) {
    let node = new Comment()
    this.init(node, token[2])
    node.source.end = this.getPosition(token[3] || token[2])

    let text = token[1].slice(2, -2)
    if (/^\s*$/.test(text)) {
      node.text = ''
      node.raws.left = text
      node.raws.right = ''
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/)
      node.text = match[2]
      node.raws.left = match[1]
      node.raws.right = match[3]
    }
  }

  emptyRule(token) {
    let node = new Rule()
    this.init(node, token[2])
    node.selector = ''
    node.raws.between = ''
    this.current = node
  }

  other(start) {
    let end = false
    let type = null
    let colon = false
    let bracket = null
    let brackets = []
    let customProperty = start[1].startsWith('--')

    let tokens = []
    let token = start
    while (token) {
      type = token[0]
      tokens.push(token)

      if (type === '(' || type === '[') {
        if (!bracket) bracket = token
        brackets.push(type === '(' ? ')' : ']')
      } else if (customProperty && colon && type === '{') {
        if (!bracket) bracket = token
        brackets.push('}')
      } else if (brackets.length === 0) {
        if (type === ';') {
          if (colon) {
            this.decl(tokens, customProperty)
            return
          } else {
            break
          }
        } else if (type === '{') {
          this.rule(tokens)
          return
        } else if (type === '}') {
          this.tokenizer.back(tokens.pop())
          end = true
          break
        } else if (type === ':') {
          colon = true
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop()
        if (brackets.length === 0) bracket = null
      }

      token = this.tokenizer.nextToken()
    }

    if (this.tokenizer.endOfFile()) end = true
    if (brackets.length > 0) this.unclosedBracket(bracket)

    if (end && colon) {
      if (!customProperty) {
        while (tokens.length) {
          token = tokens[tokens.length - 1][0]
          if (token !== 'space' && token !== 'comment') break
          this.tokenizer.back(tokens.pop())
        }
      }
      this.decl(tokens, customProperty)
    } else {
      this.unknownWord(tokens)
    }
  }

  rule(tokens) {
    tokens.pop()

    let node = new Rule()
    this.init(node, tokens[0][2])

    node.raws.between = this.spacesAndCommentsFromEnd(tokens)
    this.raw(node, 'selector', tokens)
    this.current = node
  }

  decl(tokens, customProperty) {
    let node = new Declaration()
    this.init(node, tokens[0][2])

    let last = tokens[tokens.length - 1]
    if (last[0] === ';') {
      this.semicolon = true
      tokens.pop()
    }

    node.source.end = this.getPosition(
      last[3] || last[2] || findLastWithPosition(tokens)
    )

    while (tokens[0][0] !== 'word') {
      if (tokens.length === 1) this.unknownWord(tokens)
      node.raws.before += tokens.shift()[1]
    }
    node.source.start = this.getPosition(tokens[0][2])

    node.prop = ''
    while (tokens.length) {
      let type = tokens[0][0]
      if (type === ':' || type === 'space' || type === 'comment') {
        break
      }
      node.prop += tokens.shift()[1]
    }

    node.raws.between = ''

    let token
    while (tokens.length) {
      token = tokens.shift()

      if (token[0] === ':') {
        node.raws.between += token[1]
        break
      } else {
        if (token[0] === 'word' && /\w/.test(token[1])) {
          this.unknownWord([token])
        }
        node.raws.between += token[1]
      }
    }

    if (node.prop[0] === '_' || node.prop[0] === '*') {
      node.raws.before += node.prop[0]
      node.prop = node.prop.slice(1)
    }

    let firstSpaces = []
    let next
    while (tokens.length) {
      next = tokens[0][0]
      if (next !== 'space' && next !== 'comment') break
      firstSpaces.push(tokens.shift())
    }

    this.precheckMissedSemicolon(tokens)

    for (let i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i]
      if (token[1].toLowerCase() === '!important') {
        node.important = true
        let string = this.stringFrom(tokens, i)
        string = this.spacesFromEnd(tokens) + string
        if (string !== ' !important') node.raws.important = string
        break
      } else if (token[1].toLowerCase() === 'important') {
        let cache = tokens.slice(0)
        let str = ''
        for (let j = i; j > 0; j--) {
          let type = cache[j][0]
          if (str.trim().indexOf('!') === 0 && type !== 'space') {
            break
          }
          str = cache.pop()[1] + str
        }
        if (str.trim().indexOf('!') === 0) {
          node.important = true
          node.raws.important = str
          tokens = cache
        }
      }

      if (token[0] !== 'space' && token[0] !== 'comment') {
        break
      }
    }

    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')

    if (hasWord) {
      node.raws.between += firstSpaces.map(i => i[1]).join('')
      firstSpaces = []
    }
    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)

    if (node.value.includes(':') && !customProperty) {
      this.checkMissedSemicolon(tokens)
    }
  }

  atrule(token) {
    let node = new AtRule()
    node.name = token[1].slice(1)
    if (node.name === '') {
      this.unnamedAtrule(node, token)
    }
    this.init(node, token[2])

    let type
    let prev
    let shift
    let last = false
    let open = false
    let params = []
    let brackets = []

    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken()
      type = token[0]

      if (type === '(' || type === '[') {
        brackets.push(type === '(' ? ')' : ']')
      } else if (type === '{' && brackets.length > 0) {
        brackets.push('}')
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop()
      }

      if (brackets.length === 0) {
        if (type === ';') {
          node.source.end = this.getPosition(token[2])
          this.semicolon = true
          break
        } else if (type === '{') {
          open = true
          break
        } else if (type === '}') {
          if (params.length > 0) {
            shift = params.length - 1
            prev = params[shift]
            while (prev && prev[0] === 'space') {
              prev = params[--shift]
            }
            if (prev) {
              node.source.end = this.getPosition(prev[3] || prev[2])
            }
          }
          this.end(token)
          break
        } else {
          params.push(token)
        }
      } else {
        params.push(token)
      }

      if (this.tokenizer.endOfFile()) {
        last = true
        break
      }
    }

    node.raws.between = this.spacesAndCommentsFromEnd(params)
    if (params.length) {
      node.raws.afterName = this.spacesAndCommentsFromStart(params)
      this.raw(node, 'params', params)
      if (last) {
        token = params[params.length - 1]
        node.source.end = this.getPosition(token[3] || token[2])
        this.spaces = node.raws.between
        node.raws.between = ''
      }
    } else {
      node.raws.afterName = ''
      node.params = ''
    }

    if (open) {
      node.nodes = []
      this.current = node
    }
  }

  end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.semicolon = false

    this.current.raws.after = (this.current.raws.after || '') + this.spaces
    this.spaces = ''

    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2])
      this.current = this.current.parent
    } else {
      this.unexpectedClose(token)
    }
  }

  endFile() {
    if (this.current.parent) this.unclosedBlock()
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.current.raws.after = (this.current.raws.after || '') + this.spaces
  }

  freeSemicolon(token) {
    this.spaces += token[1]
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1]
      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces
        this.spaces = ''
      }
    }
  }

  // Helpers

  getPosition(offset) {
    let pos = this.input.fromOffset(offset)
    return {
      offset,
      line: pos.line,
      column: pos.col
    }
  }

  init(node, offset) {
    this.current.push(node)
    node.source = {
      start: this.getPosition(offset),
      input: this.input
    }
    node.raws.before = this.spaces
    this.spaces = ''
    if (node.type !== 'comment') this.semicolon = false
  }

  raw(node, prop, tokens, customProperty) {
    let token, type
    let length = tokens.length
    let value = ''
    let clean = true
    let next, prev

    for (let i = 0; i < length; i += 1) {
      token = tokens[i]
      type = token[0]
      if (type === 'space' && i === length - 1 && !customProperty) {
        clean = false
      } else if (type === 'comment') {
        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty'
        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty'
        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
          if (value.slice(-1) === ',') {
            clean = false
          } else {
            value += token[1]
          }
        } else {
          clean = false
        }
      } else {
        value += token[1]
      }
    }
    if (!clean) {
      let raw = tokens.reduce((all, i) => all + i[1], '')
      node.raws[prop] = { value, raw }
    }
    node[prop] = value
  }

  spacesAndCommentsFromEnd(tokens) {
    let lastTokenType
    let spaces = ''
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break
      spaces = tokens.pop()[1] + spaces
    }
    return spaces
  }

  spacesAndCommentsFromStart(tokens) {
    let next
    let spaces = ''
    while (tokens.length) {
      next = tokens[0][0]
      if (next !== 'space' && next !== 'comment') break
      spaces += tokens.shift()[1]
    }
    return spaces
  }

  spacesFromEnd(tokens) {
    let lastTokenType
    let spaces = ''
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== 'space') break
      spaces = tokens.pop()[1] + spaces
    }
    return spaces
  }

  stringFrom(tokens, from) {
    let result = ''
    for (let i = from; i < tokens.length; i++) {
      result += tokens[i][1]
    }
    tokens.splice(from, tokens.length - from)
    return result
  }

  colon(tokens) {
    let brackets = 0
    let token, type, prev
    for (let [i, element] of tokens.entries()) {
      token = element
      type = token[0]

      if (type === '(') {
        brackets += 1
      }
      if (type === ')') {
        brackets -= 1
      }
      if (brackets === 0 && type === ':') {
        if (!prev) {
          this.doubleColon(token)
        } else if (prev[0] === 'word' && prev[1] === 'progid') {
          continue
        } else {
          return i
        }
      }

      prev = token
    }
    return false
  }

  // Errors

  unclosedBracket(bracket) {
    throw this.input.error(
      'Unclosed bracket',
      { offset: bracket[2] },
      { offset: bracket[2] + 1 }
    )
  }

  unknownWord(tokens) {
    throw this.input.error(
      'Unknown word',
      { offset: tokens[0][2] },
      { offset: tokens[0][2] + tokens[0][1].length }
    )
  }

  unexpectedClose(token) {
    throw this.input.error(
      'Unexpected }',
      { offset: token[2] },
      { offset: token[2] + 1 }
    )
  }

  unclosedBlock() {
    let pos = this.current.source.start
    throw this.input.error('Unclosed block', pos.line, pos.column)
  }

  doubleColon(token) {
    throw this.input.error(
      'Double colon',
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    )
  }

  unnamedAtrule(node, token) {
    throw this.input.error(
      'At-rule without name',
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    )
  }

  precheckMissedSemicolon(/* tokens */) {
    // Hook for Safe Parser
  }

  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens)
    if (colon === false) return

    let founded = 0
    let token
    for (let j = colon - 1; j >= 0; j--) {
      token = tokens[j]
      if (token[0] !== 'space') {
        founded += 1
        if (founded === 2) break
      }
    }
    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
    // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
    // And because we need it after that one we do +1 to get the next one.
    throw this.input.error(
      'Missed semicolon',
      token[0] === 'word' ? token[3] + 1 : token[2]
    )
  }
}

module.exports = Parser


/***/ }),

/***/ 77001:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let CssSyntaxError = __nccwpck_require__(63279)
let Declaration = __nccwpck_require__(33522)
let LazyResult = __nccwpck_require__(46310)
let Container = __nccwpck_require__(56919)
let Processor = __nccwpck_require__(79189)
let stringify = __nccwpck_require__(34793)
let fromJSON = __nccwpck_require__(71543)
let Document = __nccwpck_require__(58085)
let Warning = __nccwpck_require__(87143)
let Comment = __nccwpck_require__(37592)
let AtRule = __nccwpck_require__(54193)
let Result = __nccwpck_require__(66846)
let Input = __nccwpck_require__(2690)
let parse = __nccwpck_require__(2128)
let list = __nccwpck_require__(41608)
let Rule = __nccwpck_require__(12234)
let Root = __nccwpck_require__(22630)
let Node = __nccwpck_require__(48557)

function postcss(...plugins) {
  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0]
  }
  return new Processor(plugins)
}

postcss.plugin = function plugin(name, initializer) {
  let warningPrinted = false
  function creator(...args) {
    // eslint-disable-next-line no-console
    if (console && console.warn && !warningPrinted) {
      warningPrinted = true
      // eslint-disable-next-line no-console
      console.warn(
        name +
          ': postcss.plugin was deprecated. Migration guide:\n' +
          'https://evilmartians.com/chronicles/postcss-8-plugin-migration'
      )
      if (process.env.LANG && process.env.LANG.startsWith('cn')) {
        /* c8 ignore next 7 */
        // eslint-disable-next-line no-console
        console.warn(
          name +
            ': 里面 postcss.plugin 被弃用. 迁移指南:\n' +
            'https://www.w3ctech.com/topic/2226'
        )
      }
    }
    let transformer = initializer(...args)
    transformer.postcssPlugin = name
    transformer.postcssVersion = new Processor().version
    return transformer
  }

  let cache
  Object.defineProperty(creator, 'postcss', {
    get() {
      if (!cache) cache = creator()
      return cache
    }
  })

  creator.process = function (css, processOpts, pluginOpts) {
    return postcss([creator(pluginOpts)]).process(css, processOpts)
  }

  return creator
}

postcss.stringify = stringify
postcss.parse = parse
postcss.fromJSON = fromJSON
postcss.list = list

postcss.comment = defaults => new Comment(defaults)
postcss.atRule = defaults => new AtRule(defaults)
postcss.decl = defaults => new Declaration(defaults)
postcss.rule = defaults => new Rule(defaults)
postcss.root = defaults => new Root(defaults)
postcss.document = defaults => new Document(defaults)

postcss.CssSyntaxError = CssSyntaxError
postcss.Declaration = Declaration
postcss.Container = Container
postcss.Processor = Processor
postcss.Document = Document
postcss.Comment = Comment
postcss.Warning = Warning
postcss.AtRule = AtRule
postcss.Result = Result
postcss.Input = Input
postcss.Rule = Rule
postcss.Root = Root
postcss.Node = Node

LazyResult.registerPostcss(postcss)

module.exports = postcss
postcss.default = postcss


/***/ }),

/***/ 91090:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let { SourceMapConsumer, SourceMapGenerator } = __nccwpck_require__(26766)
let { existsSync, readFileSync } = __nccwpck_require__(57147)
let { dirname, join } = __nccwpck_require__(71017)

function fromBase64(str) {
  if (Buffer) {
    return Buffer.from(str, 'base64').toString()
  } else {
    /* c8 ignore next 2 */
    return window.atob(str)
  }
}

class PreviousMap {
  constructor(css, opts) {
    if (opts.map === false) return
    this.loadAnnotation(css)
    this.inline = this.startWith(this.annotation, 'data:')

    let prev = opts.map ? opts.map.prev : undefined
    let text = this.loadMap(opts.from, prev)
    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from
    }
    if (this.mapFile) this.root = dirname(this.mapFile)
    if (text) this.text = text
  }

  consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new SourceMapConsumer(this.text)
    }
    return this.consumerCache
  }

  withContent() {
    return !!(
      this.consumer().sourcesContent &&
      this.consumer().sourcesContent.length > 0
    )
  }

  startWith(string, start) {
    if (!string) return false
    return string.substr(0, start.length) === start
  }

  getAnnotationURL(sourceMapString) {
    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, '').trim()
  }

  loadAnnotation(css) {
    let comments = css.match(/\/\*\s*# sourceMappingURL=/gm)
    if (!comments) return

    // sourceMappingURLs from comments, strings, etc.
    let start = css.lastIndexOf(comments.pop())
    let end = css.indexOf('*/', start)

    if (start > -1 && end > -1) {
      // Locate the last sourceMappingURL to avoid pickin
      this.annotation = this.getAnnotationURL(css.substring(start, end))
    }
  }

  decodeInline(text) {
    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/
    let baseUri = /^data:application\/json;base64,/
    let charsetUri = /^data:application\/json;charset=utf-?8,/
    let uri = /^data:application\/json,/

    if (charsetUri.test(text) || uri.test(text)) {
      return decodeURIComponent(text.substr(RegExp.lastMatch.length))
    }

    if (baseCharsetUri.test(text) || baseUri.test(text)) {
      return fromBase64(text.substr(RegExp.lastMatch.length))
    }

    let encoding = text.match(/data:application\/json;([^,]+),/)[1]
    throw new Error('Unsupported source map encoding ' + encoding)
  }

  loadFile(path) {
    this.root = dirname(path)
    if (existsSync(path)) {
      this.mapFile = path
      return readFileSync(path, 'utf-8').toString().trim()
    }
  }

  loadMap(file, prev) {
    if (prev === false) return false

    if (prev) {
      if (typeof prev === 'string') {
        return prev
      } else if (typeof prev === 'function') {
        let prevPath = prev(file)
        if (prevPath) {
          let map = this.loadFile(prevPath)
          if (!map) {
            throw new Error(
              'Unable to load previous source map: ' + prevPath.toString()
            )
          }
          return map
        }
      } else if (prev instanceof SourceMapConsumer) {
        return SourceMapGenerator.fromSourceMap(prev).toString()
      } else if (prev instanceof SourceMapGenerator) {
        return prev.toString()
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev)
      } else {
        throw new Error(
          'Unsupported previous source map format: ' + prev.toString()
        )
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation)
    } else if (this.annotation) {
      let map = this.annotation
      if (file) map = join(dirname(file), map)
      return this.loadFile(map)
    }
  }

  isMap(map) {
    if (typeof map !== 'object') return false
    return (
      typeof map.mappings === 'string' ||
      typeof map._mappings === 'string' ||
      Array.isArray(map.sections)
    )
  }
}

module.exports = PreviousMap
PreviousMap.default = PreviousMap


/***/ }),

/***/ 79189:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let NoWorkResult = __nccwpck_require__(69810)
let LazyResult = __nccwpck_require__(46310)
let Document = __nccwpck_require__(58085)
let Root = __nccwpck_require__(22630)

class Processor {
  constructor(plugins = []) {
    this.version = '8.4.21'
    this.plugins = this.normalize(plugins)
  }

  use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]))
    return this
  }

  process(css, opts = {}) {
    if (
      this.plugins.length === 0 &&
      typeof opts.parser === 'undefined' &&
      typeof opts.stringifier === 'undefined' &&
      typeof opts.syntax === 'undefined'
    ) {
      return new NoWorkResult(this, css, opts)
    } else {
      return new LazyResult(this, css, opts)
    }
  }

  normalize(plugins) {
    let normalized = []
    for (let i of plugins) {
      if (i.postcss === true) {
        i = i()
      } else if (i.postcss) {
        i = i.postcss
      }

      if (typeof i === 'object' && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins)
      } else if (typeof i === 'object' && i.postcssPlugin) {
        normalized.push(i)
      } else if (typeof i === 'function') {
        normalized.push(i)
      } else if (typeof i === 'object' && (i.parse || i.stringify)) {
        if (process.env.NODE_ENV !== 'production') {
          throw new Error(
            'PostCSS syntaxes cannot be used as plugins. Instead, please use ' +
              'one of the syntax/parser/stringifier options as outlined ' +
              'in your PostCSS runner documentation.'
          )
        }
      } else {
        throw new Error(i + ' is not a PostCSS plugin')
      }
    }
    return normalized
  }
}

module.exports = Processor
Processor.default = Processor

Root.registerProcessor(Processor)
Document.registerProcessor(Processor)


/***/ }),

/***/ 66846:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let Warning = __nccwpck_require__(87143)

class Result {
  constructor(processor, root, opts) {
    this.processor = processor
    this.messages = []
    this.root = root
    this.opts = opts
    this.css = undefined
    this.map = undefined
  }

  toString() {
    return this.css
  }

  warn(text, opts = {}) {
    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin
      }
    }

    let warning = new Warning(text, opts)
    this.messages.push(warning)

    return warning
  }

  warnings() {
    return this.messages.filter(i => i.type === 'warning')
  }

  get content() {
    return this.css
  }
}

module.exports = Result
Result.default = Result


/***/ }),

/***/ 22630:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let Container = __nccwpck_require__(56919)

let LazyResult, Processor

class Root extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'root'
    if (!this.nodes) this.nodes = []
  }

  removeChild(child, ignore) {
    let index = this.index(child)

    if (!ignore && index === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index].raws.before
    }

    return super.removeChild(child)
  }

  normalize(child, sample, type) {
    let nodes = super.normalize(child)

    if (sample) {
      if (type === 'prepend') {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before
        } else {
          delete sample.raws.before
        }
      } else if (this.first !== sample) {
        for (let node of nodes) {
          node.raws.before = sample.raws.before
        }
      }
    }

    return nodes
  }

  toResult(opts = {}) {
    let lazy = new LazyResult(new Processor(), this, opts)
    return lazy.stringify()
  }
}

Root.registerLazyResult = dependant => {
  LazyResult = dependant
}

Root.registerProcessor = dependant => {
  Processor = dependant
}

module.exports = Root
Root.default = Root

Container.registerRoot(Root)


/***/ }),

/***/ 12234:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let Container = __nccwpck_require__(56919)
let list = __nccwpck_require__(41608)

class Rule extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'rule'
    if (!this.nodes) this.nodes = []
  }

  get selectors() {
    return list.comma(this.selector)
  }

  set selectors(values) {
    let match = this.selector ? this.selector.match(/,\s*/) : null
    let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen')
    this.selector = values.join(sep)
  }
}

module.exports = Rule
Rule.default = Rule

Container.registerRule(Rule)


/***/ }),

/***/ 59414:
/***/ ((module) => {

"use strict";


const DEFAULT_RAW = {
  colon: ': ',
  indent: '    ',
  beforeDecl: '\n',
  beforeRule: '\n',
  beforeOpen: ' ',
  beforeClose: '\n',
  beforeComment: '\n',
  after: '\n',
  emptyBody: '',
  commentLeft: ' ',
  commentRight: ' ',
  semicolon: false
}

function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1)
}

class Stringifier {
  constructor(builder) {
    this.builder = builder
  }

  stringify(node, semicolon) {
    /* c8 ignore start */
    if (!this[node.type]) {
      throw new Error(
        'Unknown AST node type ' +
          node.type +
          '. ' +
          'Maybe you need to change PostCSS stringifier.'
      )
    }
    /* c8 ignore stop */
    this[node.type](node, semicolon)
  }

  document(node) {
    this.body(node)
  }

  root(node) {
    this.body(node)
    if (node.raws.after) this.builder(node.raws.after)
  }

  comment(node) {
    let left = this.raw(node, 'left', 'commentLeft')
    let right = this.raw(node, 'right', 'commentRight')
    this.builder('/*' + left + node.text + right + '*/', node)
  }

  decl(node, semicolon) {
    let between = this.raw(node, 'between', 'colon')
    let string = node.prop + between + this.rawValue(node, 'value')

    if (node.important) {
      string += node.raws.important || ' !important'
    }

    if (semicolon) string += ';'
    this.builder(string, node)
  }

  rule(node) {
    this.block(node, this.rawValue(node, 'selector'))
    if (node.raws.ownSemicolon) {
      this.builder(node.raws.ownSemicolon, node, 'end')
    }
  }

  atrule(node, semicolon) {
    let name = '@' + node.name
    let params = node.params ? this.rawValue(node, 'params') : ''

    if (typeof node.raws.afterName !== 'undefined') {
      name += node.raws.afterName
    } else if (params) {
      name += ' '
    }

    if (node.nodes) {
      this.block(node, name + params)
    } else {
      let end = (node.raws.between || '') + (semicolon ? ';' : '')
      this.builder(name + params + end, node)
    }
  }

  body(node) {
    let last = node.nodes.length - 1
    while (last > 0) {
      if (node.nodes[last].type !== 'comment') break
      last -= 1
    }

    let semicolon = this.raw(node, 'semicolon')
    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i]
      let before = this.raw(child, 'before')
      if (before) this.builder(before)
      this.stringify(child, last !== i || semicolon)
    }
  }

  block(node, start) {
    let between = this.raw(node, 'between', 'beforeOpen')
    this.builder(start + between + '{', node, 'start')

    let after
    if (node.nodes && node.nodes.length) {
      this.body(node)
      after = this.raw(node, 'after')
    } else {
      after = this.raw(node, 'after', 'emptyBody')
    }

    if (after) this.builder(after)
    this.builder('}', node, 'end')
  }

  raw(node, own, detect) {
    let value
    if (!detect) detect = own

    // Already had
    if (own) {
      value = node.raws[own]
      if (typeof value !== 'undefined') return value
    }

    let parent = node.parent

    if (detect === 'before') {
      // Hack for first rule in CSS
      if (!parent || (parent.type === 'root' && parent.first === node)) {
        return ''
      }

      // `root` nodes in `document` should use only their own raws
      if (parent && parent.type === 'document') {
        return ''
      }
    }

    // Floating child without parent
    if (!parent) return DEFAULT_RAW[detect]

    // Detect style by other nodes
    let root = node.root()
    if (!root.rawCache) root.rawCache = {}
    if (typeof root.rawCache[detect] !== 'undefined') {
      return root.rawCache[detect]
    }

    if (detect === 'before' || detect === 'after') {
      return this.beforeAfter(node, detect)
    } else {
      let method = 'raw' + capitalize(detect)
      if (this[method]) {
        value = this[method](root, node)
      } else {
        root.walk(i => {
          value = i.raws[own]
          if (typeof value !== 'undefined') return false
        })
      }
    }

    if (typeof value === 'undefined') value = DEFAULT_RAW[detect]

    root.rawCache[detect] = value
    return value
  }

  rawSemicolon(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length && i.last.type === 'decl') {
        value = i.raws.semicolon
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawEmptyBody(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length === 0) {
        value = i.raws.after
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawIndent(root) {
    if (root.raws.indent) return root.raws.indent
    let value
    root.walk(i => {
      let p = i.parent
      if (p && p !== root && p.parent && p.parent === root) {
        if (typeof i.raws.before !== 'undefined') {
          let parts = i.raws.before.split('\n')
          value = parts[parts.length - 1]
          value = value.replace(/\S/g, '')
          return false
        }
      }
    })
    return value
  }

  rawBeforeComment(root, node) {
    let value
    root.walkComments(i => {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before
        if (value.includes('\n')) {
          value = value.replace(/[^\n]+$/, '')
        }
        return false
      }
    })
    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeDecl')
    } else if (value) {
      value = value.replace(/\S/g, '')
    }
    return value
  }

  rawBeforeDecl(root, node) {
    let value
    root.walkDecls(i => {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before
        if (value.includes('\n')) {
          value = value.replace(/[^\n]+$/, '')
        }
        return false
      }
    })
    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeRule')
    } else if (value) {
      value = value.replace(/\S/g, '')
    }
    return value
  }

  rawBeforeRule(root) {
    let value
    root.walk(i => {
      if (i.nodes && (i.parent !== root || root.first !== i)) {
        if (typeof i.raws.before !== 'undefined') {
          value = i.raws.before
          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '')
          }
          return false
        }
      }
    })
    if (value) value = value.replace(/\S/g, '')
    return value
  }

  rawBeforeClose(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length > 0) {
        if (typeof i.raws.after !== 'undefined') {
          value = i.raws.after
          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '')
          }
          return false
        }
      }
    })
    if (value) value = value.replace(/\S/g, '')
    return value
  }

  rawBeforeOpen(root) {
    let value
    root.walk(i => {
      if (i.type !== 'decl') {
        value = i.raws.between
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawColon(root) {
    let value
    root.walkDecls(i => {
      if (typeof i.raws.between !== 'undefined') {
        value = i.raws.between.replace(/[^\s:]/g, '')
        return false
      }
    })
    return value
  }

  beforeAfter(node, detect) {
    let value
    if (node.type === 'decl') {
      value = this.raw(node, null, 'beforeDecl')
    } else if (node.type === 'comment') {
      value = this.raw(node, null, 'beforeComment')
    } else if (detect === 'before') {
      value = this.raw(node, null, 'beforeRule')
    } else {
      value = this.raw(node, null, 'beforeClose')
    }

    let buf = node.parent
    let depth = 0
    while (buf && buf.type !== 'root') {
      depth += 1
      buf = buf.parent
    }

    if (value.includes('\n')) {
      let indent = this.raw(node, null, 'indent')
      if (indent.length) {
        for (let step = 0; step < depth; step++) value += indent
      }
    }

    return value
  }

  rawValue(node, prop) {
    let value = node[prop]
    let raw = node.raws[prop]
    if (raw && raw.value === value) {
      return raw.raw
    }

    return value
  }
}

module.exports = Stringifier
Stringifier.default = Stringifier


/***/ }),

/***/ 34793:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let Stringifier = __nccwpck_require__(59414)

function stringify(node, builder) {
  let str = new Stringifier(builder)
  str.stringify(node)
}

module.exports = stringify
stringify.default = stringify


/***/ }),

/***/ 32594:
/***/ ((module) => {

"use strict";


module.exports.isClean = Symbol('isClean')

module.exports.my = Symbol('my')


/***/ }),

/***/ 51040:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


let pico = __nccwpck_require__(37023)

let tokenizer = __nccwpck_require__(45790)

let Input

function registerInput(dependant) {
  Input = dependant
}

const HIGHLIGHT_THEME = {
  'brackets': pico.cyan,
  'at-word': pico.cyan,
  'comment': pico.gray,
  'string': pico.green,
  'class': pico.yellow,
  'hash': pico.magenta,
  'call': pico.cyan,
  '(': pico.cyan,
  ')': pico.cyan,
  '{': pico.yellow,
  '}': pico.yellow,
  '[': pico.yellow,
  ']': pico.yellow,
  ':': pico.yellow,
  ';': pico.yellow
}

function getTokenType([type, value], processor) {
  if (type === 'word') {
    if (value[0] === '.') {
      return 'class'
    }
    if (value[0] === '#') {
      return 'hash'
    }
  }

  if (!processor.endOfFile()) {
    let next = processor.nextToken()
    processor.back(next)
    if (next[0] === 'brackets' || next[0] === '(') return 'call'
  }

  return type
}

function terminalHighlight(css) {
  let processor = tokenizer(new Input(css), { ignoreErrors: true })
  let result = ''
  while (!processor.endOfFile()) {
    let token = processor.nextToken()
    let color = HIGHLIGHT_THEME[getTokenType(token, processor)]
    if (color) {
      result += token[1]
        .split(/\r?\n/)
        .map(i => color(i))
        .join('\n')
    } else {
      result += token[1]
    }
  }
  return result
}

terminalHighlight.registerInput = registerInput

module.exports = terminalHighlight


/***/ }),

/***/ 45790:
/***/ ((module) => {

"use strict";


const SINGLE_QUOTE = "'".charCodeAt(0)
const DOUBLE_QUOTE = '"'.charCodeAt(0)
const BACKSLASH = '\\'.charCodeAt(0)
const SLASH = '/'.charCodeAt(0)
const NEWLINE = '\n'.charCodeAt(0)
const SPACE = ' '.charCodeAt(0)
const FEED = '\f'.charCodeAt(0)
const TAB = '\t'.charCodeAt(0)
const CR = '\r'.charCodeAt(0)
const OPEN_SQUARE = '['.charCodeAt(0)
const CLOSE_SQUARE = ']'.charCodeAt(0)
const OPEN_PARENTHESES = '('.charCodeAt(0)
const CLOSE_PARENTHESES = ')'.charCodeAt(0)
const OPEN_CURLY = '{'.charCodeAt(0)
const CLOSE_CURLY = '}'.charCodeAt(0)
const SEMICOLON = ';'.charCodeAt(0)
const ASTERISK = '*'.charCodeAt(0)
const COLON = ':'.charCodeAt(0)
const AT = '@'.charCodeAt(0)

const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g
const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g
const RE_BAD_BRACKET = /.[\n"'(/\\]/
const RE_HEX_ESCAPE = /[\da-f]/i

module.exports = function tokenizer(input, options = {}) {
  let css = input.css.valueOf()
  let ignore = options.ignoreErrors

  let code, next, quote, content, escape
  let escaped, escapePos, prev, n, currentToken

  let length = css.length
  let pos = 0
  let buffer = []
  let returned = []

  function position() {
    return pos
  }

  function unclosed(what) {
    throw input.error('Unclosed ' + what, pos)
  }

  function endOfFile() {
    return returned.length === 0 && pos >= length
  }

  function nextToken(opts) {
    if (returned.length) return returned.pop()
    if (pos >= length) return

    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false

    code = css.charCodeAt(pos)

    switch (code) {
      case NEWLINE:
      case SPACE:
      case TAB:
      case CR:
      case FEED: {
        next = pos
        do {
          next += 1
          code = css.charCodeAt(next)
        } while (
          code === SPACE ||
          code === NEWLINE ||
          code === TAB ||
          code === CR ||
          code === FEED
        )

        currentToken = ['space', css.slice(pos, next)]
        pos = next - 1
        break
      }

      case OPEN_SQUARE:
      case CLOSE_SQUARE:
      case OPEN_CURLY:
      case CLOSE_CURLY:
      case COLON:
      case SEMICOLON:
      case CLOSE_PARENTHESES: {
        let controlChar = String.fromCharCode(code)
        currentToken = [controlChar, controlChar, pos]
        break
      }

      case OPEN_PARENTHESES: {
        prev = buffer.length ? buffer.pop()[1] : ''
        n = css.charCodeAt(pos + 1)
        if (
          prev === 'url' &&
          n !== SINGLE_QUOTE &&
          n !== DOUBLE_QUOTE &&
          n !== SPACE &&
          n !== NEWLINE &&
          n !== TAB &&
          n !== FEED &&
          n !== CR
        ) {
          next = pos
          do {
            escaped = false
            next = css.indexOf(')', next + 1)
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos
                break
              } else {
                unclosed('bracket')
              }
            }
            escapePos = next
            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1
              escaped = !escaped
            }
          } while (escaped)

          currentToken = ['brackets', css.slice(pos, next + 1), pos, next]

          pos = next
        } else {
          next = css.indexOf(')', pos + 1)
          content = css.slice(pos, next + 1)

          if (next === -1 || RE_BAD_BRACKET.test(content)) {
            currentToken = ['(', '(', pos]
          } else {
            currentToken = ['brackets', content, pos, next]
            pos = next
          }
        }

        break
      }

      case SINGLE_QUOTE:
      case DOUBLE_QUOTE: {
        quote = code === SINGLE_QUOTE ? "'" : '"'
        next = pos
        do {
          escaped = false
          next = css.indexOf(quote, next + 1)
          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1
              break
            } else {
              unclosed('string')
            }
          }
          escapePos = next
          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
            escapePos -= 1
            escaped = !escaped
          }
        } while (escaped)

        currentToken = ['string', css.slice(pos, next + 1), pos, next]
        pos = next
        break
      }

      case AT: {
        RE_AT_END.lastIndex = pos + 1
        RE_AT_END.test(css)
        if (RE_AT_END.lastIndex === 0) {
          next = css.length - 1
        } else {
          next = RE_AT_END.lastIndex - 2
        }

        currentToken = ['at-word', css.slice(pos, next + 1), pos, next]

        pos = next
        break
      }

      case BACKSLASH: {
        next = pos
        escape = true
        while (css.charCodeAt(next + 1) === BACKSLASH) {
          next += 1
          escape = !escape
        }
        code = css.charCodeAt(next + 1)
        if (
          escape &&
          code !== SLASH &&
          code !== SPACE &&
          code !== NEWLINE &&
          code !== TAB &&
          code !== CR &&
          code !== FEED
        ) {
          next += 1
          if (RE_HEX_ESCAPE.test(css.charAt(next))) {
            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
              next += 1
            }
            if (css.charCodeAt(next + 1) === SPACE) {
              next += 1
            }
          }
        }

        currentToken = ['word', css.slice(pos, next + 1), pos, next]

        pos = next
        break
      }

      default: {
        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
          next = css.indexOf('*/', pos + 2) + 1
          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css.length
            } else {
              unclosed('comment')
            }
          }

          currentToken = ['comment', css.slice(pos, next + 1), pos, next]
          pos = next
        } else {
          RE_WORD_END.lastIndex = pos + 1
          RE_WORD_END.test(css)
          if (RE_WORD_END.lastIndex === 0) {
            next = css.length - 1
          } else {
            next = RE_WORD_END.lastIndex - 2
          }

          currentToken = ['word', css.slice(pos, next + 1), pos, next]
          buffer.push(currentToken)
          pos = next
        }

        break
      }
    }

    pos++
    return currentToken
  }

  function back(token) {
    returned.push(token)
  }

  return {
    back,
    nextToken,
    endOfFile,
    position
  }
}


/***/ }),

/***/ 21600:
/***/ ((module) => {

"use strict";
/* eslint-disable no-console */


let printed = {}

module.exports = function warnOnce(message) {
  if (printed[message]) return
  printed[message] = true

  if (typeof console !== 'undefined' && console.warn) {
    console.warn(message)
  }
}


/***/ }),

/***/ 87143:
/***/ ((module) => {

"use strict";


class Warning {
  constructor(text, opts = {}) {
    this.type = 'warning'
    this.text = text

    if (opts.node && opts.node.source) {
      let range = opts.node.rangeBy(opts)
      this.line = range.start.line
      this.column = range.start.column
      this.endLine = range.end.line
      this.endColumn = range.end.column
    }

    for (let opt in opts) this[opt] = opts[opt]
  }

  toString() {
    if (this.node) {
      return this.node.error(this.text, {
        plugin: this.plugin,
        index: this.index,
        word: this.word
      }).message
    }

    if (this.plugin) {
      return this.plugin + ': ' + this.text
    }

    return this.text
  }
}

module.exports = Warning
Warning.default = Warning


/***/ }),

/***/ 89795:
/***/ ((module) => {

/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise

module.exports = typeof queueMicrotask === 'function'
  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)
  // reuse resolved promise, and allocate it lazily
  : cb => (promise || (promise = Promise.resolve()))
    .then(cb)
    .catch(err => setTimeout(() => { throw err }, 0))


/***/ }),

/***/ 49273:
/***/ ((module) => {

"use strict";


class QuickLRU {
	constructor(options = {}) {
		if (!(options.maxSize && options.maxSize > 0)) {
			throw new TypeError('`maxSize` must be a number greater than 0');
		}

		this.maxSize = options.maxSize;
		this.onEviction = options.onEviction;
		this.cache = new Map();
		this.oldCache = new Map();
		this._size = 0;
	}

	_set(key, value) {
		this.cache.set(key, value);
		this._size++;

		if (this._size >= this.maxSize) {
			this._size = 0;

			if (typeof this.onEviction === 'function') {
				for (const [key, value] of this.oldCache.entries()) {
					this.onEviction(key, value);
				}
			}

			this.oldCache = this.cache;
			this.cache = new Map();
		}
	}

	get(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			const value = this.oldCache.get(key);
			this.oldCache.delete(key);
			this._set(key, value);
			return value;
		}
	}

	set(key, value) {
		if (this.cache.has(key)) {
			this.cache.set(key, value);
		} else {
			this._set(key, value);
		}

		return this;
	}

	has(key) {
		return this.cache.has(key) || this.oldCache.has(key);
	}

	peek(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			return this.oldCache.get(key);
		}
	}

	delete(key) {
		const deleted = this.cache.delete(key);
		if (deleted) {
			this._size--;
		}

		return this.oldCache.delete(key) || deleted;
	}

	clear() {
		this.cache.clear();
		this.oldCache.clear();
		this._size = 0;
	}

	* keys() {
		for (const [key] of this) {
			yield key;
		}
	}

	* values() {
		for (const [, value] of this) {
			yield value;
		}
	}

	* [Symbol.iterator]() {
		for (const item of this.cache) {
			yield item;
		}

		for (const item of this.oldCache) {
			const [key] = item;
			if (!this.cache.has(key)) {
				yield item;
			}
		}
	}

	get size() {
		let oldCacheSize = 0;
		for (const key of this.oldCache.keys()) {
			if (!this.cache.has(key)) {
				oldCacheSize++;
			}
		}

		return Math.min(this._size + oldCacheSize, this.maxSize);
	}
}

module.exports = QuickLRU;


/***/ }),

/***/ 39283:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var async = __nccwpck_require__(2125);
async.core = __nccwpck_require__(26226);
async.isCore = __nccwpck_require__(38115);
async.sync = __nccwpck_require__(55284);

module.exports = async;


/***/ }),

/***/ 2125:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var fs = __nccwpck_require__(57147);
var getHomedir = __nccwpck_require__(65079);
var path = __nccwpck_require__(71017);
var caller = __nccwpck_require__(36155);
var nodeModulesPaths = __nccwpck_require__(1433);
var normalizeOptions = __nccwpck_require__(17990);
var isCore = __nccwpck_require__(56873);

var realpathFS = process.platform !== 'win32' && fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;

var homedir = getHomedir();
var defaultPaths = function () {
    return [
        path.join(homedir, '.node_modules'),
        path.join(homedir, '.node_libraries')
    ];
};

var defaultIsFile = function isFile(file, cb) {
    fs.stat(file, function (err, stat) {
        if (!err) {
            return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultIsDir = function isDirectory(dir, cb) {
    fs.stat(dir, function (err, stat) {
        if (!err) {
            return cb(null, stat.isDirectory());
        }
        if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
        return cb(err);
    });
};

var defaultRealpath = function realpath(x, cb) {
    realpathFS(x, function (realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);
        else cb(null, realpathErr ? x : realPath);
    });
};

var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
    if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
    } else {
        cb(null, x);
    }
};

var defaultReadPackage = function defaultReadPackage(readFile, pkgfile, cb) {
    readFile(pkgfile, function (readFileErr, body) {
        if (readFileErr) cb(readFileErr);
        else {
            try {
                var pkg = JSON.parse(body);
                cb(null, pkg);
            } catch (jsonErr) {
                cb(null);
            }
        }
    });
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolve(x, options, callback) {
    var cb = callback;
    var opts = options;
    if (typeof options === 'function') {
        cb = opts;
        opts = {};
    }
    if (typeof x !== 'string') {
        var err = new TypeError('Path must be a string.');
        return process.nextTick(function () {
            cb(err);
        });
    }

    opts = normalizeOptions(x, opts);

    var isFile = opts.isFile || defaultIsFile;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var readFile = opts.readFile || fs.readFile;
    var realpath = opts.realpath || defaultRealpath;
    var readPackage = opts.readPackage || defaultReadPackage;
    if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError('`readFile` and `readPackage` are mutually exclusive.');
        return process.nextTick(function () {
            cb(conflictErr);
        });
    }
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || defaultPaths();

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = path.resolve(basedir);

    maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function (err, realStart) {
            if (err) cb(err);
            else init(realStart);
        }
    );

    var res;
    function init(basedir) {
        if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
            res = path.resolve(basedir, x);
            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
            if ((/\/$/).test(x) && res === basedir) {
                loadAsDirectory(res, opts.package, onfile);
            } else loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
            return cb(null, x);
        } else loadNodeModules(x, basedir, function (err, n, pkg) {
            if (err) cb(err);
            else if (n) {
                return maybeRealpath(realpath, n, opts, function (err, realN) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realN, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function onfile(err, m, pkg) {
        if (err) cb(err);
        else if (m) cb(null, m, pkg);
        else loadAsDirectory(res, function (err, d, pkg) {
            if (err) cb(err);
            else if (d) {
                maybeRealpath(realpath, d, opts, function (err, realD) {
                    if (err) {
                        cb(err);
                    } else {
                        cb(null, realD, pkg);
                    }
                });
            } else {
                var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                moduleError.code = 'MODULE_NOT_FOUND';
                cb(moduleError);
            }
        });
    }

    function loadAsFile(x, thePackage, callback) {
        var loadAsFilePackage = thePackage;
        var cb = callback;
        if (typeof loadAsFilePackage === 'function') {
            cb = loadAsFilePackage;
            loadAsFilePackage = undefined;
        }

        var exts = [''].concat(extensions);
        load(exts, x, loadAsFilePackage);

        function load(exts, x, loadPackage) {
            if (exts.length === 0) return cb(null, undefined, loadPackage);
            var file = x + exts[0];

            var pkg = loadPackage;
            if (pkg) onpkg(null, pkg);
            else loadpkg(path.dirname(file), onpkg);

            function onpkg(err, pkg_, dir) {
                pkg = pkg_;
                if (err) return cb(err);
                if (dir && pkg && opts.pathFilter) {
                    var rfile = path.relative(dir, file);
                    var rel = rfile.slice(0, rfile.length - exts[0].length);
                    var r = opts.pathFilter(pkg, x, rel);
                    if (r) return load(
                        [''].concat(extensions.slice()),
                        path.resolve(dir, r),
                        pkg
                    );
                }
                isFile(file, onex);
            }
            function onex(err, ex) {
                if (err) return cb(err);
                if (ex) return cb(null, file, pkg);
                load(exts.slice(1), x, pkg);
            }
        }
    }

    function loadpkg(dir, cb) {
        if (dir === '' || dir === '/') return cb(null);
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return cb(null);
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return cb(null);

        maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return loadpkg(path.dirname(dir), cb);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                // on err, ex is false
                if (!ex) return loadpkg(path.dirname(dir), cb);

                readPackage(readFile, pkgfile, function (err, pkgParam) {
                    if (err) cb(err);

                    var pkg = pkgParam;

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }
                    cb(null, pkg, dir);
                });
            });
        });
    }

    function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
        var cb = callback;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === 'function') {
            cb = fpkg;
            fpkg = opts.package;
        }

        maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {
            if (unwrapErr) return cb(unwrapErr);
            var pkgfile = path.join(pkgdir, 'package.json');
            isFile(pkgfile, function (err, ex) {
                if (err) return cb(err);
                if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);

                readPackage(readFile, pkgfile, function (err, pkgParam) {
                    if (err) return cb(err);

                    var pkg = pkgParam;

                    if (pkg && opts.packageFilter) {
                        pkg = opts.packageFilter(pkg, pkgfile);
                    }

                    if (pkg && pkg.main) {
                        if (typeof pkg.main !== 'string') {
                            var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');
                            mainError.code = 'INVALID_PACKAGE_MAIN';
                            return cb(mainError);
                        }
                        if (pkg.main === '.' || pkg.main === './') {
                            pkg.main = 'index';
                        }
                        loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                            if (err) return cb(err);
                            if (m) return cb(null, m, pkg);
                            if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);

                            var dir = path.resolve(x, pkg.main);
                            loadAsDirectory(dir, pkg, function (err, n, pkg) {
                                if (err) return cb(err);
                                if (n) return cb(null, n, pkg);
                                loadAsFile(path.join(x, 'index'), pkg, cb);
                            });
                        });
                        return;
                    }

                    loadAsFile(path.join(x, '/index'), pkg, cb);
                });
            });
        });
    }

    function processDirs(cb, dirs) {
        if (dirs.length === 0) return cb(null, undefined);
        var dir = dirs[0];

        isDirectory(path.dirname(dir), isdir);

        function isdir(err, isdir) {
            if (err) return cb(err);
            if (!isdir) return processDirs(cb, dirs.slice(1));
            loadAsFile(dir, opts.package, onfile);
        }

        function onfile(err, m, pkg) {
            if (err) return cb(err);
            if (m) return cb(null, m, pkg);
            loadAsDirectory(dir, opts.package, ondir);
        }

        function ondir(err, n, pkg) {
            if (err) return cb(err);
            if (n) return cb(null, n, pkg);
            processDirs(cb, dirs.slice(1));
        }
    }
    function loadNodeModules(x, start, cb) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        processDirs(
            cb,
            packageIterator ? packageIterator(x, start, thunk, opts) : thunk()
        );
    }
};


/***/ }),

/***/ 36155:
/***/ ((module) => {

module.exports = function () {
    // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
    var origPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = function (_, stack) { return stack; };
    var stack = (new Error()).stack;
    Error.prepareStackTrace = origPrepareStackTrace;
    return stack[2].getFileName();
};


/***/ }),

/***/ 26226:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var current = (process.versions && process.versions.node && process.versions.node.split('.')) || [];

function specifierIncluded(specifier) {
    var parts = specifier.split(' ');
    var op = parts.length > 1 ? parts[0] : '=';
    var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

    for (var i = 0; i < 3; ++i) {
        var cur = parseInt(current[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        }
        if (op === '<') {
            return cur < ver;
        } else if (op === '>=') {
            return cur >= ver;
        }
        return false;
    }
    return op === '>=';
}

function matchesRange(range) {
    var specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) { return false; }
    for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(specifiers[i])) { return false; }
    }
    return true;
}

function versionIncluded(specifierValue) {
    if (typeof specifierValue === 'boolean') { return specifierValue; }
    if (specifierValue && typeof specifierValue === 'object') {
        for (var i = 0; i < specifierValue.length; ++i) {
            if (matchesRange(specifierValue[i])) { return true; }
        }
        return false;
    }
    return matchesRange(specifierValue);
}

var data = __nccwpck_require__(74503);

var core = {};
for (var mod in data) { // eslint-disable-line no-restricted-syntax
    if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = versionIncluded(data[mod]);
    }
}
module.exports = core;


/***/ }),

/***/ 65079:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var os = __nccwpck_require__(22037);

// adapted from https://github.com/sindresorhus/os-homedir/blob/11e089f4754db38bb535e5a8416320c4446e8cfd/index.js

module.exports = os.homedir || function homedir() {
    var home = process.env.HOME;
    var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;

    if (process.platform === 'win32') {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
    }

    if (process.platform === 'darwin') {
        return home || (user ? '/Users/' + user : null);
    }

    if (process.platform === 'linux') {
        return home || (process.getuid() === 0 ? '/root' : (user ? '/home/' + user : null)); // eslint-disable-line no-extra-parens
    }

    return home || null;
};


/***/ }),

/***/ 38115:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isCoreModule = __nccwpck_require__(56873);

module.exports = function isCore(x) {
    return isCoreModule(x);
};


/***/ }),

/***/ 1433:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var path = __nccwpck_require__(71017);
var parse = path.parse || __nccwpck_require__(5980); // eslint-disable-line global-require

var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
    var prefix = '/';
    if ((/^([A-Za-z]:)/).test(absoluteStart)) {
        prefix = '';
    } else if ((/^\\\\/).test(absoluteStart)) {
        prefix = '\\\\';
    }

    var paths = [absoluteStart];
    var parsed = parse(absoluteStart);
    while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
    }

    return paths.reduce(function (dirs, aPath) {
        return dirs.concat(modules.map(function (moduleDir) {
            return path.resolve(prefix, aPath, moduleDir);
        }));
    }, []);
};

module.exports = function nodeModulesPaths(start, opts, request) {
    var modules = opts && opts.moduleDirectory
        ? [].concat(opts.moduleDirectory)
        : ['node_modules'];

    if (opts && typeof opts.paths === 'function') {
        return opts.paths(
            request,
            start,
            function () { return getNodeModulesDirs(start, modules); },
            opts
        );
    }

    var dirs = getNodeModulesDirs(start, modules);
    return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
};


/***/ }),

/***/ 17990:
/***/ ((module) => {

module.exports = function (x, opts) {
    /**
     * This file is purposefully a passthrough. It's expected that third-party
     * environments will override it at runtime in order to inject special logic
     * into `resolve` (by manipulating the options). One such example is the PnP
     * code path in Yarn.
     */

    return opts || {};
};


/***/ }),

/***/ 55284:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var isCore = __nccwpck_require__(56873);
var fs = __nccwpck_require__(57147);
var path = __nccwpck_require__(71017);
var getHomedir = __nccwpck_require__(65079);
var caller = __nccwpck_require__(36155);
var nodeModulesPaths = __nccwpck_require__(1433);
var normalizeOptions = __nccwpck_require__(17990);

var realpathFS = process.platform !== 'win32' && fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;

var homedir = getHomedir();
var defaultPaths = function () {
    return [
        path.join(homedir, '.node_modules'),
        path.join(homedir, '.node_libraries')
    ];
};

var defaultIsFile = function isFile(file) {
    try {
        var stat = fs.statSync(file, { throwIfNoEntry: false });
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return !!stat && (stat.isFile() || stat.isFIFO());
};

var defaultIsDir = function isDirectory(dir) {
    try {
        var stat = fs.statSync(dir, { throwIfNoEntry: false });
    } catch (e) {
        if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
        throw e;
    }
    return !!stat && stat.isDirectory();
};

var defaultRealpathSync = function realpathSync(x) {
    try {
        return realpathFS(x);
    } catch (realpathErr) {
        if (realpathErr.code !== 'ENOENT') {
            throw realpathErr;
        }
    }
    return x;
};

var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
    if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
    }
    return x;
};

var defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) {
    var body = readFileSync(pkgfile);
    try {
        var pkg = JSON.parse(body);
        return pkg;
    } catch (jsonErr) {}
};

var getPackageCandidates = function getPackageCandidates(x, start, opts) {
    var dirs = nodeModulesPaths(start, opts, x);
    for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
    }
    return dirs;
};

module.exports = function resolveSync(x, options) {
    if (typeof x !== 'string') {
        throw new TypeError('Path must be a string.');
    }
    var opts = normalizeOptions(x, options);

    var isFile = opts.isFile || defaultIsFile;
    var readFileSync = opts.readFileSync || fs.readFileSync;
    var isDirectory = opts.isDirectory || defaultIsDir;
    var realpathSync = opts.realpathSync || defaultRealpathSync;
    var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
    if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError('`readFileSync` and `readPackageSync` are mutually exclusive.');
    }
    var packageIterator = opts.packageIterator;

    var extensions = opts.extensions || ['.js'];
    var includeCoreModules = opts.includeCoreModules !== false;
    var basedir = opts.basedir || path.dirname(caller());
    var parent = opts.filename || basedir;

    opts.paths = opts.paths || defaultPaths();

    // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
    var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);

    if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
    } else if (includeCoreModules && isCore(x)) {
        return x;
    } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
    }

    var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;

    function loadAsFileSync(x) {
        var pkg = loadpkg(path.dirname(x));

        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
            var rfile = path.relative(pkg.dir, x);
            var r = opts.pathFilter(pkg.pkg, x, rfile);
            if (r) {
                x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
            }
        }

        if (isFile(x)) {
            return x;
        }

        for (var i = 0; i < extensions.length; i++) {
            var file = x + extensions[i];
            if (isFile(file)) {
                return file;
            }
        }
    }

    function loadpkg(dir) {
        if (dir === '' || dir === '/') return;
        if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
            return;
        }
        if ((/[/\\]node_modules[/\\]*$/).test(dir)) return;

        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');

        if (!isFile(pkgfile)) {
            return loadpkg(path.dirname(dir));
        }

        var pkg = readPackageSync(readFileSync, pkgfile);

        if (pkg && opts.packageFilter) {
            // v2 will pass pkgfile
            pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
        }

        return { pkg: pkg, dir: dir };
    }

    function loadAsDirectorySync(x) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');
        if (isFile(pkgfile)) {
            try {
                var pkg = readPackageSync(readFileSync, pkgfile);
            } catch (e) {}

            if (pkg && opts.packageFilter) {
                // v2 will pass pkgfile
                pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
            }

            if (pkg && pkg.main) {
                if (typeof pkg.main !== 'string') {
                    var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');
                    mainError.code = 'INVALID_PACKAGE_MAIN';
                    throw mainError;
                }
                if (pkg.main === '.' || pkg.main === './') {
                    pkg.main = 'index';
                }
                try {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                    var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                    if (n) return n;
                } catch (e) {}
            }
        }

        return loadAsFileSync(path.join(x, '/index'));
    }

    function loadNodeModulesSync(x, start) {
        var thunk = function () { return getPackageCandidates(x, start, opts); };
        var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();

        for (var i = 0; i < dirs.length; i++) {
            var dir = dirs[i];
            if (isDirectory(path.dirname(dir))) {
                var m = loadAsFileSync(dir);
                if (m) return m;
                var n = loadAsDirectorySync(dir);
                if (n) return n;
            }
        }
    }
};


/***/ }),

/***/ 32113:
/***/ ((module) => {

"use strict";


function reusify (Constructor) {
  var head = new Constructor()
  var tail = head

  function get () {
    var current = head

    if (current.next) {
      head = current.next
    } else {
      head = new Constructor()
      tail = head
    }

    current.next = null

    return current
  }

  function release (obj) {
    tail.next = obj
    tail = obj
  }

  return {
    get: get,
    release: release
  }
}

module.exports = reusify


/***/ }),

/***/ 75288:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
module.exports = runParallel

const queueMicrotask = __nccwpck_require__(89795)

function runParallel (tasks, cb) {
  let results, pending, keys
  let isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) queueMicrotask(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (--pending === 0 || err) {
      done(err)
    }
  }

  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.forEach(function (key) {
      tasks[key](function (err, result) { each(key, err, result) })
    })
  } else {
    // array
    tasks.forEach(function (task, i) {
      task(function (err, result) { each(i, err, result) })
    })
  }

  isSync = false
}


/***/ }),

/***/ 65856:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __nccwpck_require__(63297);
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.I = ArraySet;


/***/ }),

/***/ 825:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __nccwpck_require__(12683);

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),

/***/ 12683:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),

/***/ 85607:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),

/***/ 32508:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __nccwpck_require__(63297);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.H = MappingList;


/***/ }),

/***/ 55538:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

function SortTemplate(comparator) {

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot, false) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

  return doQuickSort;
}

function cloneSort(comparator) {
  let template = SortTemplate.toString();
  let templateFn = new Function(`return ${template}`)();
  return templateFn(comparator);
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */

let sortCache = new WeakMap();
exports.U = function (ary, comparator, start = 0) {
  let doQuickSort = sortCache.get(comparator);
  if (doQuickSort === void 0) {
    doQuickSort = cloneSort(comparator);
    sortCache.set(comparator, doQuickSort);
  }
  doQuickSort(ary, comparator, start, ary.length - 1);
};


/***/ }),

/***/ 25146:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

var __webpack_unused_export__;
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __nccwpck_require__(63297);
var binarySearch = __nccwpck_require__(85607);
var ArraySet = (__nccwpck_require__(65856)/* .ArraySet */ .I);
var base64VLQ = __nccwpck_require__(825);
var quickSort = (__nccwpck_require__(55538)/* .quickSort */ .U);

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    var boundCallback = aCallback.bind(context);
    var names = this._names;
    var sources = this._sources;
    var sourceMapURL = this._sourceMapURL;

    for (var i = 0, n = mappings.length; i < n; i++) {
      var mapping = mappings[i];
      var source = mapping.source === null ? null : sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, sourceMapURL);
      boundCallback({
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : names.at(mapping.name)
      });
    }
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */

const compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
function sortGenerated(array, start) {
  let l = array.length;
  let n = array.length - start;
  if (n <= 1) {
    return;
  } else if (n == 2) {
    let a = array[start];
    let b = array[start + 1];
    if (compareGenerated(a, b) > 0) {
      array[start] = b;
      array[start + 1] = a;
    }
  } else if (n < 20) {
    for (let i = start; i < l; i++) {
      for (let j = i; j > start; j--) {
        let a = array[j - 1];
        let b = array[j];
        if (compareGenerated(a, b) <= 0) {
          break;
        }
        array[j - 1] = b;
        array[j] = a;
      }
    }
  } else {
    quickSort(array, compareGenerated, start);
  }
}
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    let subarrayStart = 0;
    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;

        sortGenerated(generatedMappings, subarrayStart);
        subarrayStart = generatedMappings.length;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = [];
        while (index < end) {
          base64VLQ.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }

        if (segment.length === 2) {
          throw new Error('Found a source, but no line and column');
        }

        if (segment.length === 3) {
          throw new Error('Found a source and line, but no column');
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          let currentSource = mapping.source;
          while (originalMappings.length <= currentSource) {
            originalMappings.push(null);
          }
          if (originalMappings[currentSource] === null) {
            originalMappings[currentSource] = [];
          }
          originalMappings[currentSource].push(mapping);
        }
      }
    }

    sortGenerated(generatedMappings, subarrayStart);
    this.__generatedMappings = generatedMappings;

    for (var i = 0; i < originalMappings.length; i++) {
      if (originalMappings[i] != null) {
        quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
      }
    }
    this.__originalMappings = [].concat(...originalMappings);
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

__webpack_unused_export__ = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

__webpack_unused_export__ = IndexedSourceMapConsumer;


/***/ }),

/***/ 47095:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __nccwpck_require__(825);
var util = __nccwpck_require__(63297);
var ArraySet = (__nccwpck_require__(65856)/* .ArraySet */ .I);
var MappingList = (__nccwpck_require__(32508)/* .MappingList */ .H);

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),

/***/ 29642:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = (__nccwpck_require__(47095).SourceMapGenerator);
var util = __nccwpck_require__(63297);

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;


/***/ }),

/***/ 63297:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

var MAX_CACHED_INPUTS = 32;

/**
 * Takes some function `f(input) -> result` and returns a memoized version of
 * `f`.
 *
 * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
 * memoization is a dumb-simple, linear least-recently-used cache.
 */
function lruMemoize(f) {
  var cache = [];

  return function(input) {
    for (var i = 0; i < cache.length; i++) {
      if (cache[i].input === input) {
        var temp = cache[0];
        cache[0] = cache[i];
        cache[i] = temp;
        return cache[0].result;
      }
    }

    var result = f(input);

    cache.unshift({
      input,
      result,
    });

    if (cache.length > MAX_CACHED_INPUTS) {
      cache.pop();
    }

    return result;
  };
}

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
var normalize = lruMemoize(function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);
  // Split the path into parts between `/` characters. This is much faster than
  // using `.split(/\/+/g)`.
  var parts = [];
  var start = 0;
  var i = 0;
  while (true) {
    start = i;
    i = path.indexOf("/", start);
    if (i === -1) {
      parts.push(path.slice(start));
      break;
    } else {
      parts.push(path.slice(start, i));
      while (i < path.length && path[i] === "/") {
        i++;
      }
    }
  }

  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
});
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
  var cmp

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;


/***/ }),

/***/ 26766:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __nccwpck_require__(47095).SourceMapGenerator;
exports.SourceMapConsumer = __nccwpck_require__(25146).SourceMapConsumer;
exports.SourceNode = __nccwpck_require__(29642).SourceNode;


/***/ }),

/***/ 49271:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>_default
}));
const _default = [
    "preflight",
    "container",
    "accessibility",
    "pointerEvents",
    "visibility",
    "position",
    "inset",
    "isolation",
    "zIndex",
    "order",
    "gridColumn",
    "gridColumnStart",
    "gridColumnEnd",
    "gridRow",
    "gridRowStart",
    "gridRowEnd",
    "float",
    "clear",
    "margin",
    "boxSizing",
    "display",
    "aspectRatio",
    "height",
    "maxHeight",
    "minHeight",
    "width",
    "minWidth",
    "maxWidth",
    "flex",
    "flexShrink",
    "flexGrow",
    "flexBasis",
    "tableLayout",
    "borderCollapse",
    "borderSpacing",
    "transformOrigin",
    "translate",
    "rotate",
    "skew",
    "scale",
    "transform",
    "animation",
    "cursor",
    "touchAction",
    "userSelect",
    "resize",
    "scrollSnapType",
    "scrollSnapAlign",
    "scrollSnapStop",
    "scrollMargin",
    "scrollPadding",
    "listStylePosition",
    "listStyleType",
    "appearance",
    "columns",
    "breakBefore",
    "breakInside",
    "breakAfter",
    "gridAutoColumns",
    "gridAutoFlow",
    "gridAutoRows",
    "gridTemplateColumns",
    "gridTemplateRows",
    "flexDirection",
    "flexWrap",
    "placeContent",
    "placeItems",
    "alignContent",
    "alignItems",
    "justifyContent",
    "justifyItems",
    "gap",
    "space",
    "divideWidth",
    "divideStyle",
    "divideColor",
    "divideOpacity",
    "placeSelf",
    "alignSelf",
    "justifySelf",
    "overflow",
    "overscrollBehavior",
    "scrollBehavior",
    "textOverflow",
    "whitespace",
    "wordBreak",
    "borderRadius",
    "borderWidth",
    "borderStyle",
    "borderColor",
    "borderOpacity",
    "backgroundColor",
    "backgroundOpacity",
    "backgroundImage",
    "gradientColorStops",
    "boxDecorationBreak",
    "backgroundSize",
    "backgroundAttachment",
    "backgroundClip",
    "backgroundPosition",
    "backgroundRepeat",
    "backgroundOrigin",
    "fill",
    "stroke",
    "strokeWidth",
    "objectFit",
    "objectPosition",
    "padding",
    "textAlign",
    "textIndent",
    "verticalAlign",
    "fontFamily",
    "fontSize",
    "fontWeight",
    "textTransform",
    "fontStyle",
    "fontVariantNumeric",
    "lineHeight",
    "letterSpacing",
    "textColor",
    "textOpacity",
    "textDecoration",
    "textDecorationColor",
    "textDecorationStyle",
    "textDecorationThickness",
    "textUnderlineOffset",
    "fontSmoothing",
    "placeholderColor",
    "placeholderOpacity",
    "caretColor",
    "accentColor",
    "opacity",
    "backgroundBlendMode",
    "mixBlendMode",
    "boxShadow",
    "boxShadowColor",
    "outlineStyle",
    "outlineWidth",
    "outlineOffset",
    "outlineColor",
    "ringWidth",
    "ringColor",
    "ringOpacity",
    "ringOffsetWidth",
    "ringOffsetColor",
    "blur",
    "brightness",
    "contrast",
    "dropShadow",
    "grayscale",
    "hueRotate",
    "invert",
    "saturate",
    "sepia",
    "filter",
    "backdropBlur",
    "backdropBrightness",
    "backdropContrast",
    "backdropGrayscale",
    "backdropHueRotate",
    "backdropInvert",
    "backdropOpacity",
    "backdropSaturate",
    "backdropSepia",
    "backdropFilter",
    "transitionProperty",
    "transitionDelay",
    "transitionDuration",
    "transitionTimingFunction",
    "willChange",
    "content"
];


/***/ }),

/***/ 91822:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    variantPlugins: ()=>variantPlugins,
    corePlugins: ()=>corePlugins
});
const _fs = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(57147));
const _path = /*#__PURE__*/ _interopRequireWildcard(__nccwpck_require__(71017));
const _postcss = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(77001));
const _createUtilityPlugin = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(13399));
const _buildMediaQuery = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(11321));
const _escapeClassName = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(11898));
const _parseAnimationValue = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(28307));
const _flattenColorPalette = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(21150));
const _withAlphaVariable = /*#__PURE__*/ _interopRequireWildcard(__nccwpck_require__(4195));
const _toColorValue = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(8489));
const _isPlainObject = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(20896));
const _transformThemeValue = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(71985));
const _packageJson = __nccwpck_require__(61214);
const _log = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(64368));
const _normalizeScreens = __nccwpck_require__(68617);
const _parseBoxShadowValue = __nccwpck_require__(43524);
const _removeAlphaVariables = __nccwpck_require__(49814);
const _featureFlags = __nccwpck_require__(90);
const _dataTypes = __nccwpck_require__(85921);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
let variantPlugins = {
    pseudoElementVariants: ({ addVariant  })=>{
        addVariant("first-letter", "&::first-letter");
        addVariant("first-line", "&::first-line");
        addVariant("marker", [
            ({ container  })=>{
                (0, _removeAlphaVariables.removeAlphaVariables)(container, [
                    "--tw-text-opacity"
                ]);
                return "& *::marker";
            },
            ({ container  })=>{
                (0, _removeAlphaVariables.removeAlphaVariables)(container, [
                    "--tw-text-opacity"
                ]);
                return "&::marker";
            }
        ]);
        addVariant("selection", [
            "& *::selection",
            "&::selection"
        ]);
        addVariant("file", "&::file-selector-button");
        addVariant("placeholder", "&::placeholder");
        addVariant("backdrop", "&::backdrop");
        addVariant("before", ({ container  })=>{
            container.walkRules((rule)=>{
                let foundContent = false;
                rule.walkDecls("content", ()=>{
                    foundContent = true;
                });
                if (!foundContent) {
                    rule.prepend(_postcss.default.decl({
                        prop: "content",
                        value: "var(--tw-content)"
                    }));
                }
            });
            return "&::before";
        });
        addVariant("after", ({ container  })=>{
            container.walkRules((rule)=>{
                let foundContent = false;
                rule.walkDecls("content", ()=>{
                    foundContent = true;
                });
                if (!foundContent) {
                    rule.prepend(_postcss.default.decl({
                        prop: "content",
                        value: "var(--tw-content)"
                    }));
                }
            });
            return "&::after";
        });
    },
    pseudoClassVariants: ({ addVariant , matchVariant , config  })=>{
        let pseudoVariants = [
            // Positional
            [
                "first",
                "&:first-child"
            ],
            [
                "last",
                "&:last-child"
            ],
            [
                "only",
                "&:only-child"
            ],
            [
                "odd",
                "&:nth-child(odd)"
            ],
            [
                "even",
                "&:nth-child(even)"
            ],
            "first-of-type",
            "last-of-type",
            "only-of-type",
            // State
            [
                "visited",
                ({ container  })=>{
                    (0, _removeAlphaVariables.removeAlphaVariables)(container, [
                        "--tw-text-opacity",
                        "--tw-border-opacity",
                        "--tw-bg-opacity"
                    ]);
                    return "&:visited";
                }
            ],
            "target",
            [
                "open",
                "&[open]"
            ],
            // Forms
            "default",
            "checked",
            "indeterminate",
            "placeholder-shown",
            "autofill",
            "optional",
            "required",
            "valid",
            "invalid",
            "in-range",
            "out-of-range",
            "read-only",
            // Content
            "empty",
            // Interactive
            "focus-within",
            [
                "hover",
                !(0, _featureFlags.flagEnabled)(config(), "hoverOnlyWhenSupported") ? "&:hover" : "@media (hover: hover) and (pointer: fine) { &:hover }"
            ],
            "focus",
            "focus-visible",
            "active",
            "enabled",
            "disabled"
        ].map((variant)=>Array.isArray(variant) ? variant : [
                variant,
                `&:${variant}`
            ]);
        for (let [variantName, state] of pseudoVariants){
            addVariant(variantName, (ctx)=>{
                let result = typeof state === "function" ? state(ctx) : state;
                return result;
            });
        }
        let variants = {
            group: (_, { modifier  })=>modifier ? [
                    `:merge(.group\\/${(0, _escapeClassName.default)(modifier)})`,
                    " &"
                ] : [
                    `:merge(.group)`,
                    " &"
                ],
            peer: (_, { modifier  })=>modifier ? [
                    `:merge(.peer\\/${(0, _escapeClassName.default)(modifier)})`,
                    " ~ &"
                ] : [
                    `:merge(.peer)`,
                    " ~ &"
                ]
        };
        for (let [name, fn] of Object.entries(variants)){
            matchVariant(name, (value = "", extra)=>{
                let result = (0, _dataTypes.normalize)(typeof value === "function" ? value(extra) : value);
                if (!result.includes("&")) result = "&" + result;
                let [a, b] = fn("", extra);
                let start = null;
                let end = null;
                let quotes = 0;
                for(let i = 0; i < result.length; ++i){
                    let c = result[i];
                    if (c === "&") {
                        start = i;
                    } else if (c === "'" || c === '"') {
                        quotes += 1;
                    } else if (start !== null && c === " " && !quotes) {
                        end = i;
                    }
                }
                if (start !== null && end === null) {
                    end = result.length;
                }
                // Basically this but can handle quotes:
                // result.replace(/&(\S+)?/g, (_, pseudo = '') => a + pseudo + b)
                return result.slice(0, start) + a + result.slice(start + 1, end) + b + result.slice(end);
            }, {
                values: Object.fromEntries(pseudoVariants)
            });
        }
    },
    directionVariants: ({ addVariant  })=>{
        addVariant("ltr", ()=>{
            _log.default.warn("rtl-experimental", [
                "The RTL features in Tailwind CSS are currently in preview.",
                "Preview features are not covered by semver, and may be improved in breaking ways at any time."
            ]);
            return '[dir="ltr"] &';
        });
        addVariant("rtl", ()=>{
            _log.default.warn("rtl-experimental", [
                "The RTL features in Tailwind CSS are currently in preview.",
                "Preview features are not covered by semver, and may be improved in breaking ways at any time."
            ]);
            return '[dir="rtl"] &';
        });
    },
    reducedMotionVariants: ({ addVariant  })=>{
        addVariant("motion-safe", "@media (prefers-reduced-motion: no-preference)");
        addVariant("motion-reduce", "@media (prefers-reduced-motion: reduce)");
    },
    darkVariants: ({ config , addVariant  })=>{
        let [mode, className = ".dark"] = [].concat(config("darkMode", "media"));
        if (mode === false) {
            mode = "media";
            _log.default.warn("darkmode-false", [
                "The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.",
                "Change `darkMode` to `media` or remove it entirely.",
                "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"
            ]);
        }
        if (mode === "class") {
            addVariant("dark", `${className} &`);
        } else if (mode === "media") {
            addVariant("dark", "@media (prefers-color-scheme: dark)");
        }
    },
    printVariant: ({ addVariant  })=>{
        addVariant("print", "@media print");
    },
    screenVariants: ({ theme , addVariant , matchVariant  })=>{
        var _theme;
        let rawScreens = (_theme = theme("screens")) !== null && _theme !== void 0 ? _theme : {};
        let areSimpleScreens = Object.values(rawScreens).every((v)=>typeof v === "string");
        let screens = (0, _normalizeScreens.normalizeScreens)(theme("screens"));
        /** @type {Set<string>} */ let unitCache = new Set([]);
        /** @param {string} value */ function units(value) {
            var _value_match;
            var _value_match_;
            return (_value_match_ = (_value_match = value.match(/(\D+)$/)) === null || _value_match === void 0 ? void 0 : _value_match[1]) !== null && _value_match_ !== void 0 ? _value_match_ : "(none)";
        }
        /** @param {string} value */ function recordUnits(value) {
            if (value !== undefined) {
                unitCache.add(units(value));
            }
        }
        /** @param {string} value */ function canUseUnits(value) {
            recordUnits(value);
            // If the cache was empty it'll become 1 because we've just added the current unit
            // If the cache was not empty and the units are the same the size doesn't change
            // Otherwise, if the units are different from what is already known the size will always be > 1
            return unitCache.size === 1;
        }
        for (const screen of screens){
            for (const value of screen.values){
                recordUnits(value.min);
                recordUnits(value.max);
            }
        }
        let screensUseConsistentUnits = unitCache.size <= 1;
        /**
     * @typedef {import('./util/normalizeScreens').Screen} Screen
     */ /**
     * @param {'min' | 'max'} type
     * @returns {Record<string, Screen>}
     */ function buildScreenValues(type) {
            return Object.fromEntries(screens.filter((screen)=>(0, _normalizeScreens.isScreenSortable)(screen).result).map((screen)=>{
                let { min , max  } = screen.values[0];
                if (type === "min" && min !== undefined) {
                    return screen;
                } else if (type === "min" && max !== undefined) {
                    return {
                        ...screen,
                        not: !screen.not
                    };
                } else if (type === "max" && max !== undefined) {
                    return screen;
                } else if (type === "max" && min !== undefined) {
                    return {
                        ...screen,
                        not: !screen.not
                    };
                }
            }).map((screen)=>[
                    screen.name,
                    screen
                ]));
        }
        /**
     * @param {'min' | 'max'} type
     * @returns {(a: { value: string | Screen }, z: { value: string | Screen }) => number}
     */ function buildSort(type) {
            return (a, z)=>(0, _normalizeScreens.compareScreens)(type, a.value, z.value);
        }
        let maxSort = buildSort("max");
        let minSort = buildSort("min");
        /** @param {'min'|'max'} type */ function buildScreenVariant(type) {
            return (value)=>{
                if (!areSimpleScreens) {
                    _log.default.warn("complex-screen-config", [
                        "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."
                    ]);
                    return [];
                } else if (!screensUseConsistentUnits) {
                    _log.default.warn("mixed-screen-units", [
                        "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
                    ]);
                    return [];
                } else if (typeof value === "string" && !canUseUnits(value)) {
                    _log.default.warn("minmax-have-mixed-units", [
                        "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
                    ]);
                    return [];
                }
                return [
                    `@media ${(0, _buildMediaQuery.default)((0, _normalizeScreens.toScreen)(value, type))}`
                ];
            };
        }
        matchVariant("max", buildScreenVariant("max"), {
            sort: maxSort,
            values: areSimpleScreens ? buildScreenValues("max") : {}
        });
        // screens and min-* are sorted together when they can be
        let id = "min-screens";
        for (let screen1 of screens){
            addVariant(screen1.name, `@media ${(0, _buildMediaQuery.default)(screen1)}`, {
                id,
                sort: areSimpleScreens && screensUseConsistentUnits ? minSort : undefined,
                value: screen1
            });
        }
        matchVariant("min", buildScreenVariant("min"), {
            id,
            sort: minSort
        });
    },
    supportsVariants: ({ matchVariant , theme  })=>{
        var _theme;
        matchVariant("supports", (value = "")=>{
            let check = (0, _dataTypes.normalize)(value);
            let isRaw = /^\w*\s*\(/.test(check);
            // Chrome has a bug where `(condtion1)or(condition2)` is not valid
            // But `(condition1) or (condition2)` is supported.
            check = isRaw ? check.replace(/\b(and|or|not)\b/g, " $1 ") : check;
            if (isRaw) {
                return `@supports ${check}`;
            }
            if (!check.includes(":")) {
                check = `${check}: var(--tw)`;
            }
            if (!(check.startsWith("(") && check.endsWith(")"))) {
                check = `(${check})`;
            }
            return `@supports ${check}`;
        }, {
            values: (_theme = theme("supports")) !== null && _theme !== void 0 ? _theme : {}
        });
    },
    ariaVariants: ({ matchVariant , theme  })=>{
        var _theme;
        matchVariant("aria", (value)=>`&[aria-${(0, _dataTypes.normalize)(value)}]`, {
            values: (_theme = theme("aria")) !== null && _theme !== void 0 ? _theme : {}
        });
        var _theme1;
        matchVariant("group-aria", (value, { modifier  })=>modifier ? `:merge(.group\\/${modifier})[aria-${(0, _dataTypes.normalize)(value)}] &` : `:merge(.group)[aria-${(0, _dataTypes.normalize)(value)}] &`, {
            values: (_theme1 = theme("aria")) !== null && _theme1 !== void 0 ? _theme1 : {}
        });
        var _theme2;
        matchVariant("peer-aria", (value, { modifier  })=>modifier ? `:merge(.peer\\/${modifier})[aria-${(0, _dataTypes.normalize)(value)}] ~ &` : `:merge(.peer)[aria-${(0, _dataTypes.normalize)(value)}] ~ &`, {
            values: (_theme2 = theme("aria")) !== null && _theme2 !== void 0 ? _theme2 : {}
        });
    },
    dataVariants: ({ matchVariant , theme  })=>{
        var _theme;
        matchVariant("data", (value)=>`&[data-${(0, _dataTypes.normalize)(value)}]`, {
            values: (_theme = theme("data")) !== null && _theme !== void 0 ? _theme : {}
        });
        var _theme1;
        matchVariant("group-data", (value, { modifier  })=>modifier ? `:merge(.group\\/${modifier})[data-${(0, _dataTypes.normalize)(value)}] &` : `:merge(.group)[data-${(0, _dataTypes.normalize)(value)}] &`, {
            values: (_theme1 = theme("data")) !== null && _theme1 !== void 0 ? _theme1 : {}
        });
        var _theme2;
        matchVariant("peer-data", (value, { modifier  })=>modifier ? `:merge(.peer\\/${modifier})[data-${(0, _dataTypes.normalize)(value)}] ~ &` : `:merge(.peer)[data-${(0, _dataTypes.normalize)(value)}] ~ &`, {
            values: (_theme2 = theme("data")) !== null && _theme2 !== void 0 ? _theme2 : {}
        });
    },
    orientationVariants: ({ addVariant  })=>{
        addVariant("portrait", "@media (orientation: portrait)");
        addVariant("landscape", "@media (orientation: landscape)");
    },
    prefersContrastVariants: ({ addVariant  })=>{
        addVariant("contrast-more", "@media (prefers-contrast: more)");
        addVariant("contrast-less", "@media (prefers-contrast: less)");
    }
};
let cssTransformValue = [
    "translate(var(--tw-translate-x), var(--tw-translate-y))",
    "rotate(var(--tw-rotate))",
    "skewX(var(--tw-skew-x))",
    "skewY(var(--tw-skew-y))",
    "scaleX(var(--tw-scale-x))",
    "scaleY(var(--tw-scale-y))"
].join(" ");
let cssFilterValue = [
    "var(--tw-blur)",
    "var(--tw-brightness)",
    "var(--tw-contrast)",
    "var(--tw-grayscale)",
    "var(--tw-hue-rotate)",
    "var(--tw-invert)",
    "var(--tw-saturate)",
    "var(--tw-sepia)",
    "var(--tw-drop-shadow)"
].join(" ");
let cssBackdropFilterValue = [
    "var(--tw-backdrop-blur)",
    "var(--tw-backdrop-brightness)",
    "var(--tw-backdrop-contrast)",
    "var(--tw-backdrop-grayscale)",
    "var(--tw-backdrop-hue-rotate)",
    "var(--tw-backdrop-invert)",
    "var(--tw-backdrop-opacity)",
    "var(--tw-backdrop-saturate)",
    "var(--tw-backdrop-sepia)"
].join(" ");
let corePlugins = {
    preflight: ({ addBase  })=>{
        let preflightStyles = _postcss.default.parse(_fs.default.readFileSync(_path.join(__dirname, "./css/preflight.css"), "utf8"));
        addBase([
            _postcss.default.comment({
                text: `! tailwindcss v${_packageJson.version} | MIT License | https://tailwindcss.com`
            }),
            ...preflightStyles.nodes
        ]);
    },
    container: (()=>{
        function extractMinWidths(breakpoints = []) {
            return breakpoints.flatMap((breakpoint)=>breakpoint.values.map((breakpoint)=>breakpoint.min)).filter((v)=>v !== undefined);
        }
        function mapMinWidthsToPadding(minWidths, screens, paddings) {
            if (typeof paddings === "undefined") {
                return [];
            }
            if (!(typeof paddings === "object" && paddings !== null)) {
                return [
                    {
                        screen: "DEFAULT",
                        minWidth: 0,
                        padding: paddings
                    }
                ];
            }
            let mapping = [];
            if (paddings.DEFAULT) {
                mapping.push({
                    screen: "DEFAULT",
                    minWidth: 0,
                    padding: paddings.DEFAULT
                });
            }
            for (let minWidth of minWidths){
                for (let screen of screens){
                    for (let { min  } of screen.values){
                        if (min === minWidth) {
                            mapping.push({
                                minWidth,
                                padding: paddings[screen.name]
                            });
                        }
                    }
                }
            }
            return mapping;
        }
        return function({ addComponents , theme  }) {
            let screens = (0, _normalizeScreens.normalizeScreens)(theme("container.screens", theme("screens")));
            let minWidths = extractMinWidths(screens);
            let paddings = mapMinWidthsToPadding(minWidths, screens, theme("container.padding"));
            let generatePaddingFor = (minWidth)=>{
                let paddingConfig = paddings.find((padding)=>padding.minWidth === minWidth);
                if (!paddingConfig) {
                    return {};
                }
                return {
                    paddingRight: paddingConfig.padding,
                    paddingLeft: paddingConfig.padding
                };
            };
            let atRules = Array.from(new Set(minWidths.slice().sort((a, z)=>parseInt(a) - parseInt(z)))).map((minWidth)=>({
                    [`@media (min-width: ${minWidth})`]: {
                        ".container": {
                            "max-width": minWidth,
                            ...generatePaddingFor(minWidth)
                        }
                    }
                }));
            addComponents([
                {
                    ".container": Object.assign({
                        width: "100%"
                    }, theme("container.center", false) ? {
                        marginRight: "auto",
                        marginLeft: "auto"
                    } : {}, generatePaddingFor(0))
                },
                ...atRules
            ]);
        };
    })(),
    accessibility: ({ addUtilities  })=>{
        addUtilities({
            ".sr-only": {
                position: "absolute",
                width: "1px",
                height: "1px",
                padding: "0",
                margin: "-1px",
                overflow: "hidden",
                clip: "rect(0, 0, 0, 0)",
                whiteSpace: "nowrap",
                borderWidth: "0"
            },
            ".not-sr-only": {
                position: "static",
                width: "auto",
                height: "auto",
                padding: "0",
                margin: "0",
                overflow: "visible",
                clip: "auto",
                whiteSpace: "normal"
            }
        });
    },
    pointerEvents: ({ addUtilities  })=>{
        addUtilities({
            ".pointer-events-none": {
                "pointer-events": "none"
            },
            ".pointer-events-auto": {
                "pointer-events": "auto"
            }
        });
    },
    visibility: ({ addUtilities  })=>{
        addUtilities({
            ".visible": {
                visibility: "visible"
            },
            ".invisible": {
                visibility: "hidden"
            },
            ".collapse": {
                visibility: "collapse"
            }
        });
    },
    position: ({ addUtilities  })=>{
        addUtilities({
            ".static": {
                position: "static"
            },
            ".fixed": {
                position: "fixed"
            },
            ".absolute": {
                position: "absolute"
            },
            ".relative": {
                position: "relative"
            },
            ".sticky": {
                position: "sticky"
            }
        });
    },
    inset: (0, _createUtilityPlugin.default)("inset", [
        [
            "inset",
            [
                "top",
                "right",
                "bottom",
                "left"
            ]
        ],
        [
            [
                "inset-x",
                [
                    "left",
                    "right"
                ]
            ],
            [
                "inset-y",
                [
                    "top",
                    "bottom"
                ]
            ]
        ],
        [
            [
                "top",
                [
                    "top"
                ]
            ],
            [
                "right",
                [
                    "right"
                ]
            ],
            [
                "bottom",
                [
                    "bottom"
                ]
            ],
            [
                "left",
                [
                    "left"
                ]
            ]
        ]
    ], {
        supportsNegativeValues: true
    }),
    isolation: ({ addUtilities  })=>{
        addUtilities({
            ".isolate": {
                isolation: "isolate"
            },
            ".isolation-auto": {
                isolation: "auto"
            }
        });
    },
    zIndex: (0, _createUtilityPlugin.default)("zIndex", [
        [
            "z",
            [
                "zIndex"
            ]
        ]
    ], {
        supportsNegativeValues: true
    }),
    order: (0, _createUtilityPlugin.default)("order", undefined, {
        supportsNegativeValues: true
    }),
    gridColumn: (0, _createUtilityPlugin.default)("gridColumn", [
        [
            "col",
            [
                "gridColumn"
            ]
        ]
    ]),
    gridColumnStart: (0, _createUtilityPlugin.default)("gridColumnStart", [
        [
            "col-start",
            [
                "gridColumnStart"
            ]
        ]
    ]),
    gridColumnEnd: (0, _createUtilityPlugin.default)("gridColumnEnd", [
        [
            "col-end",
            [
                "gridColumnEnd"
            ]
        ]
    ]),
    gridRow: (0, _createUtilityPlugin.default)("gridRow", [
        [
            "row",
            [
                "gridRow"
            ]
        ]
    ]),
    gridRowStart: (0, _createUtilityPlugin.default)("gridRowStart", [
        [
            "row-start",
            [
                "gridRowStart"
            ]
        ]
    ]),
    gridRowEnd: (0, _createUtilityPlugin.default)("gridRowEnd", [
        [
            "row-end",
            [
                "gridRowEnd"
            ]
        ]
    ]),
    float: ({ addUtilities  })=>{
        addUtilities({
            ".float-right": {
                float: "right"
            },
            ".float-left": {
                float: "left"
            },
            ".float-none": {
                float: "none"
            }
        });
    },
    clear: ({ addUtilities  })=>{
        addUtilities({
            ".clear-left": {
                clear: "left"
            },
            ".clear-right": {
                clear: "right"
            },
            ".clear-both": {
                clear: "both"
            },
            ".clear-none": {
                clear: "none"
            }
        });
    },
    margin: (0, _createUtilityPlugin.default)("margin", [
        [
            "m",
            [
                "margin"
            ]
        ],
        [
            [
                "mx",
                [
                    "margin-left",
                    "margin-right"
                ]
            ],
            [
                "my",
                [
                    "margin-top",
                    "margin-bottom"
                ]
            ]
        ],
        [
            [
                "mt",
                [
                    "margin-top"
                ]
            ],
            [
                "mr",
                [
                    "margin-right"
                ]
            ],
            [
                "mb",
                [
                    "margin-bottom"
                ]
            ],
            [
                "ml",
                [
                    "margin-left"
                ]
            ]
        ]
    ], {
        supportsNegativeValues: true
    }),
    boxSizing: ({ addUtilities  })=>{
        addUtilities({
            ".box-border": {
                "box-sizing": "border-box"
            },
            ".box-content": {
                "box-sizing": "content-box"
            }
        });
    },
    display: ({ addUtilities  })=>{
        addUtilities({
            ".block": {
                display: "block"
            },
            ".inline-block": {
                display: "inline-block"
            },
            ".inline": {
                display: "inline"
            },
            ".flex": {
                display: "flex"
            },
            ".inline-flex": {
                display: "inline-flex"
            },
            ".table": {
                display: "table"
            },
            ".inline-table": {
                display: "inline-table"
            },
            ".table-caption": {
                display: "table-caption"
            },
            ".table-cell": {
                display: "table-cell"
            },
            ".table-column": {
                display: "table-column"
            },
            ".table-column-group": {
                display: "table-column-group"
            },
            ".table-footer-group": {
                display: "table-footer-group"
            },
            ".table-header-group": {
                display: "table-header-group"
            },
            ".table-row-group": {
                display: "table-row-group"
            },
            ".table-row": {
                display: "table-row"
            },
            ".flow-root": {
                display: "flow-root"
            },
            ".grid": {
                display: "grid"
            },
            ".inline-grid": {
                display: "inline-grid"
            },
            ".contents": {
                display: "contents"
            },
            ".list-item": {
                display: "list-item"
            },
            ".hidden": {
                display: "none"
            }
        });
    },
    aspectRatio: (0, _createUtilityPlugin.default)("aspectRatio", [
        [
            "aspect",
            [
                "aspect-ratio"
            ]
        ]
    ]),
    height: (0, _createUtilityPlugin.default)("height", [
        [
            "h",
            [
                "height"
            ]
        ]
    ]),
    maxHeight: (0, _createUtilityPlugin.default)("maxHeight", [
        [
            "max-h",
            [
                "maxHeight"
            ]
        ]
    ]),
    minHeight: (0, _createUtilityPlugin.default)("minHeight", [
        [
            "min-h",
            [
                "minHeight"
            ]
        ]
    ]),
    width: (0, _createUtilityPlugin.default)("width", [
        [
            "w",
            [
                "width"
            ]
        ]
    ]),
    minWidth: (0, _createUtilityPlugin.default)("minWidth", [
        [
            "min-w",
            [
                "minWidth"
            ]
        ]
    ]),
    maxWidth: (0, _createUtilityPlugin.default)("maxWidth", [
        [
            "max-w",
            [
                "maxWidth"
            ]
        ]
    ]),
    flex: (0, _createUtilityPlugin.default)("flex"),
    flexShrink: (0, _createUtilityPlugin.default)("flexShrink", [
        [
            "flex-shrink",
            [
                "flex-shrink"
            ]
        ],
        [
            "shrink",
            [
                "flex-shrink"
            ]
        ]
    ]),
    flexGrow: (0, _createUtilityPlugin.default)("flexGrow", [
        [
            "flex-grow",
            [
                "flex-grow"
            ]
        ],
        [
            "grow",
            [
                "flex-grow"
            ]
        ]
    ]),
    flexBasis: (0, _createUtilityPlugin.default)("flexBasis", [
        [
            "basis",
            [
                "flex-basis"
            ]
        ]
    ]),
    tableLayout: ({ addUtilities  })=>{
        addUtilities({
            ".table-auto": {
                "table-layout": "auto"
            },
            ".table-fixed": {
                "table-layout": "fixed"
            }
        });
    },
    borderCollapse: ({ addUtilities  })=>{
        addUtilities({
            ".border-collapse": {
                "border-collapse": "collapse"
            },
            ".border-separate": {
                "border-collapse": "separate"
            }
        });
    },
    borderSpacing: ({ addDefaults , matchUtilities , theme  })=>{
        addDefaults("border-spacing", {
            "--tw-border-spacing-x": 0,
            "--tw-border-spacing-y": 0
        });
        matchUtilities({
            "border-spacing": (value)=>{
                return {
                    "--tw-border-spacing-x": value,
                    "--tw-border-spacing-y": value,
                    "@defaults border-spacing": {},
                    "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
                };
            },
            "border-spacing-x": (value)=>{
                return {
                    "--tw-border-spacing-x": value,
                    "@defaults border-spacing": {},
                    "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
                };
            },
            "border-spacing-y": (value)=>{
                return {
                    "--tw-border-spacing-y": value,
                    "@defaults border-spacing": {},
                    "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
                };
            }
        }, {
            values: theme("borderSpacing")
        });
    },
    transformOrigin: (0, _createUtilityPlugin.default)("transformOrigin", [
        [
            "origin",
            [
                "transformOrigin"
            ]
        ]
    ]),
    translate: (0, _createUtilityPlugin.default)("translate", [
        [
            [
                "translate-x",
                [
                    [
                        "@defaults transform",
                        {}
                    ],
                    "--tw-translate-x",
                    [
                        "transform",
                        cssTransformValue
                    ]
                ]
            ],
            [
                "translate-y",
                [
                    [
                        "@defaults transform",
                        {}
                    ],
                    "--tw-translate-y",
                    [
                        "transform",
                        cssTransformValue
                    ]
                ]
            ]
        ]
    ], {
        supportsNegativeValues: true
    }),
    rotate: (0, _createUtilityPlugin.default)("rotate", [
        [
            "rotate",
            [
                [
                    "@defaults transform",
                    {}
                ],
                "--tw-rotate",
                [
                    "transform",
                    cssTransformValue
                ]
            ]
        ]
    ], {
        supportsNegativeValues: true
    }),
    skew: (0, _createUtilityPlugin.default)("skew", [
        [
            [
                "skew-x",
                [
                    [
                        "@defaults transform",
                        {}
                    ],
                    "--tw-skew-x",
                    [
                        "transform",
                        cssTransformValue
                    ]
                ]
            ],
            [
                "skew-y",
                [
                    [
                        "@defaults transform",
                        {}
                    ],
                    "--tw-skew-y",
                    [
                        "transform",
                        cssTransformValue
                    ]
                ]
            ]
        ]
    ], {
        supportsNegativeValues: true
    }),
    scale: (0, _createUtilityPlugin.default)("scale", [
        [
            "scale",
            [
                [
                    "@defaults transform",
                    {}
                ],
                "--tw-scale-x",
                "--tw-scale-y",
                [
                    "transform",
                    cssTransformValue
                ]
            ]
        ],
        [
            [
                "scale-x",
                [
                    [
                        "@defaults transform",
                        {}
                    ],
                    "--tw-scale-x",
                    [
                        "transform",
                        cssTransformValue
                    ]
                ]
            ],
            [
                "scale-y",
                [
                    [
                        "@defaults transform",
                        {}
                    ],
                    "--tw-scale-y",
                    [
                        "transform",
                        cssTransformValue
                    ]
                ]
            ]
        ]
    ], {
        supportsNegativeValues: true
    }),
    transform: ({ addDefaults , addUtilities  })=>{
        addDefaults("transform", {
            "--tw-translate-x": "0",
            "--tw-translate-y": "0",
            "--tw-rotate": "0",
            "--tw-skew-x": "0",
            "--tw-skew-y": "0",
            "--tw-scale-x": "1",
            "--tw-scale-y": "1"
        });
        addUtilities({
            ".transform": {
                "@defaults transform": {},
                transform: cssTransformValue
            },
            ".transform-cpu": {
                transform: cssTransformValue
            },
            ".transform-gpu": {
                transform: cssTransformValue.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)")
            },
            ".transform-none": {
                transform: "none"
            }
        });
    },
    animation: ({ matchUtilities , theme , config  })=>{
        let prefixName = (name)=>`${config("prefix")}${(0, _escapeClassName.default)(name)}`;
        var _theme;
        let keyframes = Object.fromEntries(Object.entries((_theme = theme("keyframes")) !== null && _theme !== void 0 ? _theme : {}).map(([key, value])=>{
            return [
                key,
                {
                    [`@keyframes ${prefixName(key)}`]: value
                }
            ];
        }));
        matchUtilities({
            animate: (value)=>{
                let animations = (0, _parseAnimationValue.default)(value);
                return [
                    ...animations.flatMap((animation)=>keyframes[animation.name]),
                    {
                        animation: animations.map(({ name , value  })=>{
                            if (name === undefined || keyframes[name] === undefined) {
                                return value;
                            }
                            return value.replace(name, prefixName(name));
                        }).join(", ")
                    }
                ];
            }
        }, {
            values: theme("animation")
        });
    },
    cursor: (0, _createUtilityPlugin.default)("cursor"),
    touchAction: ({ addDefaults , addUtilities  })=>{
        addDefaults("touch-action", {
            "--tw-pan-x": " ",
            "--tw-pan-y": " ",
            "--tw-pinch-zoom": " "
        });
        let cssTouchActionValue = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
        addUtilities({
            ".touch-auto": {
                "touch-action": "auto"
            },
            ".touch-none": {
                "touch-action": "none"
            },
            ".touch-pan-x": {
                "@defaults touch-action": {},
                "--tw-pan-x": "pan-x",
                "touch-action": cssTouchActionValue
            },
            ".touch-pan-left": {
                "@defaults touch-action": {},
                "--tw-pan-x": "pan-left",
                "touch-action": cssTouchActionValue
            },
            ".touch-pan-right": {
                "@defaults touch-action": {},
                "--tw-pan-x": "pan-right",
                "touch-action": cssTouchActionValue
            },
            ".touch-pan-y": {
                "@defaults touch-action": {},
                "--tw-pan-y": "pan-y",
                "touch-action": cssTouchActionValue
            },
            ".touch-pan-up": {
                "@defaults touch-action": {},
                "--tw-pan-y": "pan-up",
                "touch-action": cssTouchActionValue
            },
            ".touch-pan-down": {
                "@defaults touch-action": {},
                "--tw-pan-y": "pan-down",
                "touch-action": cssTouchActionValue
            },
            ".touch-pinch-zoom": {
                "@defaults touch-action": {},
                "--tw-pinch-zoom": "pinch-zoom",
                "touch-action": cssTouchActionValue
            },
            ".touch-manipulation": {
                "touch-action": "manipulation"
            }
        });
    },
    userSelect: ({ addUtilities  })=>{
        addUtilities({
            ".select-none": {
                "user-select": "none"
            },
            ".select-text": {
                "user-select": "text"
            },
            ".select-all": {
                "user-select": "all"
            },
            ".select-auto": {
                "user-select": "auto"
            }
        });
    },
    resize: ({ addUtilities  })=>{
        addUtilities({
            ".resize-none": {
                resize: "none"
            },
            ".resize-y": {
                resize: "vertical"
            },
            ".resize-x": {
                resize: "horizontal"
            },
            ".resize": {
                resize: "both"
            }
        });
    },
    scrollSnapType: ({ addDefaults , addUtilities  })=>{
        addDefaults("scroll-snap-type", {
            "--tw-scroll-snap-strictness": "proximity"
        });
        addUtilities({
            ".snap-none": {
                "scroll-snap-type": "none"
            },
            ".snap-x": {
                "@defaults scroll-snap-type": {},
                "scroll-snap-type": "x var(--tw-scroll-snap-strictness)"
            },
            ".snap-y": {
                "@defaults scroll-snap-type": {},
                "scroll-snap-type": "y var(--tw-scroll-snap-strictness)"
            },
            ".snap-both": {
                "@defaults scroll-snap-type": {},
                "scroll-snap-type": "both var(--tw-scroll-snap-strictness)"
            },
            ".snap-mandatory": {
                "--tw-scroll-snap-strictness": "mandatory"
            },
            ".snap-proximity": {
                "--tw-scroll-snap-strictness": "proximity"
            }
        });
    },
    scrollSnapAlign: ({ addUtilities  })=>{
        addUtilities({
            ".snap-start": {
                "scroll-snap-align": "start"
            },
            ".snap-end": {
                "scroll-snap-align": "end"
            },
            ".snap-center": {
                "scroll-snap-align": "center"
            },
            ".snap-align-none": {
                "scroll-snap-align": "none"
            }
        });
    },
    scrollSnapStop: ({ addUtilities  })=>{
        addUtilities({
            ".snap-normal": {
                "scroll-snap-stop": "normal"
            },
            ".snap-always": {
                "scroll-snap-stop": "always"
            }
        });
    },
    scrollMargin: (0, _createUtilityPlugin.default)("scrollMargin", [
        [
            "scroll-m",
            [
                "scroll-margin"
            ]
        ],
        [
            [
                "scroll-mx",
                [
                    "scroll-margin-left",
                    "scroll-margin-right"
                ]
            ],
            [
                "scroll-my",
                [
                    "scroll-margin-top",
                    "scroll-margin-bottom"
                ]
            ]
        ],
        [
            [
                "scroll-mt",
                [
                    "scroll-margin-top"
                ]
            ],
            [
                "scroll-mr",
                [
                    "scroll-margin-right"
                ]
            ],
            [
                "scroll-mb",
                [
                    "scroll-margin-bottom"
                ]
            ],
            [
                "scroll-ml",
                [
                    "scroll-margin-left"
                ]
            ]
        ]
    ], {
        supportsNegativeValues: true
    }),
    scrollPadding: (0, _createUtilityPlugin.default)("scrollPadding", [
        [
            "scroll-p",
            [
                "scroll-padding"
            ]
        ],
        [
            [
                "scroll-px",
                [
                    "scroll-padding-left",
                    "scroll-padding-right"
                ]
            ],
            [
                "scroll-py",
                [
                    "scroll-padding-top",
                    "scroll-padding-bottom"
                ]
            ]
        ],
        [
            [
                "scroll-pt",
                [
                    "scroll-padding-top"
                ]
            ],
            [
                "scroll-pr",
                [
                    "scroll-padding-right"
                ]
            ],
            [
                "scroll-pb",
                [
                    "scroll-padding-bottom"
                ]
            ],
            [
                "scroll-pl",
                [
                    "scroll-padding-left"
                ]
            ]
        ]
    ]),
    listStylePosition: ({ addUtilities  })=>{
        addUtilities({
            ".list-inside": {
                "list-style-position": "inside"
            },
            ".list-outside": {
                "list-style-position": "outside"
            }
        });
    },
    listStyleType: (0, _createUtilityPlugin.default)("listStyleType", [
        [
            "list",
            [
                "listStyleType"
            ]
        ]
    ]),
    appearance: ({ addUtilities  })=>{
        addUtilities({
            ".appearance-none": {
                appearance: "none"
            }
        });
    },
    columns: (0, _createUtilityPlugin.default)("columns", [
        [
            "columns",
            [
                "columns"
            ]
        ]
    ]),
    breakBefore: ({ addUtilities  })=>{
        addUtilities({
            ".break-before-auto": {
                "break-before": "auto"
            },
            ".break-before-avoid": {
                "break-before": "avoid"
            },
            ".break-before-all": {
                "break-before": "all"
            },
            ".break-before-avoid-page": {
                "break-before": "avoid-page"
            },
            ".break-before-page": {
                "break-before": "page"
            },
            ".break-before-left": {
                "break-before": "left"
            },
            ".break-before-right": {
                "break-before": "right"
            },
            ".break-before-column": {
                "break-before": "column"
            }
        });
    },
    breakInside: ({ addUtilities  })=>{
        addUtilities({
            ".break-inside-auto": {
                "break-inside": "auto"
            },
            ".break-inside-avoid": {
                "break-inside": "avoid"
            },
            ".break-inside-avoid-page": {
                "break-inside": "avoid-page"
            },
            ".break-inside-avoid-column": {
                "break-inside": "avoid-column"
            }
        });
    },
    breakAfter: ({ addUtilities  })=>{
        addUtilities({
            ".break-after-auto": {
                "break-after": "auto"
            },
            ".break-after-avoid": {
                "break-after": "avoid"
            },
            ".break-after-all": {
                "break-after": "all"
            },
            ".break-after-avoid-page": {
                "break-after": "avoid-page"
            },
            ".break-after-page": {
                "break-after": "page"
            },
            ".break-after-left": {
                "break-after": "left"
            },
            ".break-after-right": {
                "break-after": "right"
            },
            ".break-after-column": {
                "break-after": "column"
            }
        });
    },
    gridAutoColumns: (0, _createUtilityPlugin.default)("gridAutoColumns", [
        [
            "auto-cols",
            [
                "gridAutoColumns"
            ]
        ]
    ]),
    gridAutoFlow: ({ addUtilities  })=>{
        addUtilities({
            ".grid-flow-row": {
                gridAutoFlow: "row"
            },
            ".grid-flow-col": {
                gridAutoFlow: "column"
            },
            ".grid-flow-dense": {
                gridAutoFlow: "dense"
            },
            ".grid-flow-row-dense": {
                gridAutoFlow: "row dense"
            },
            ".grid-flow-col-dense": {
                gridAutoFlow: "column dense"
            }
        });
    },
    gridAutoRows: (0, _createUtilityPlugin.default)("gridAutoRows", [
        [
            "auto-rows",
            [
                "gridAutoRows"
            ]
        ]
    ]),
    gridTemplateColumns: (0, _createUtilityPlugin.default)("gridTemplateColumns", [
        [
            "grid-cols",
            [
                "gridTemplateColumns"
            ]
        ]
    ]),
    gridTemplateRows: (0, _createUtilityPlugin.default)("gridTemplateRows", [
        [
            "grid-rows",
            [
                "gridTemplateRows"
            ]
        ]
    ]),
    flexDirection: ({ addUtilities  })=>{
        addUtilities({
            ".flex-row": {
                "flex-direction": "row"
            },
            ".flex-row-reverse": {
                "flex-direction": "row-reverse"
            },
            ".flex-col": {
                "flex-direction": "column"
            },
            ".flex-col-reverse": {
                "flex-direction": "column-reverse"
            }
        });
    },
    flexWrap: ({ addUtilities  })=>{
        addUtilities({
            ".flex-wrap": {
                "flex-wrap": "wrap"
            },
            ".flex-wrap-reverse": {
                "flex-wrap": "wrap-reverse"
            },
            ".flex-nowrap": {
                "flex-wrap": "nowrap"
            }
        });
    },
    placeContent: ({ addUtilities  })=>{
        addUtilities({
            ".place-content-center": {
                "place-content": "center"
            },
            ".place-content-start": {
                "place-content": "start"
            },
            ".place-content-end": {
                "place-content": "end"
            },
            ".place-content-between": {
                "place-content": "space-between"
            },
            ".place-content-around": {
                "place-content": "space-around"
            },
            ".place-content-evenly": {
                "place-content": "space-evenly"
            },
            ".place-content-baseline": {
                "place-content": "baseline"
            },
            ".place-content-stretch": {
                "place-content": "stretch"
            }
        });
    },
    placeItems: ({ addUtilities  })=>{
        addUtilities({
            ".place-items-start": {
                "place-items": "start"
            },
            ".place-items-end": {
                "place-items": "end"
            },
            ".place-items-center": {
                "place-items": "center"
            },
            ".place-items-baseline": {
                "place-items": "baseline"
            },
            ".place-items-stretch": {
                "place-items": "stretch"
            }
        });
    },
    alignContent: ({ addUtilities  })=>{
        addUtilities({
            ".content-center": {
                "align-content": "center"
            },
            ".content-start": {
                "align-content": "flex-start"
            },
            ".content-end": {
                "align-content": "flex-end"
            },
            ".content-between": {
                "align-content": "space-between"
            },
            ".content-around": {
                "align-content": "space-around"
            },
            ".content-evenly": {
                "align-content": "space-evenly"
            },
            ".content-baseline": {
                "align-content": "baseline"
            }
        });
    },
    alignItems: ({ addUtilities  })=>{
        addUtilities({
            ".items-start": {
                "align-items": "flex-start"
            },
            ".items-end": {
                "align-items": "flex-end"
            },
            ".items-center": {
                "align-items": "center"
            },
            ".items-baseline": {
                "align-items": "baseline"
            },
            ".items-stretch": {
                "align-items": "stretch"
            }
        });
    },
    justifyContent: ({ addUtilities  })=>{
        addUtilities({
            ".justify-start": {
                "justify-content": "flex-start"
            },
            ".justify-end": {
                "justify-content": "flex-end"
            },
            ".justify-center": {
                "justify-content": "center"
            },
            ".justify-between": {
                "justify-content": "space-between"
            },
            ".justify-around": {
                "justify-content": "space-around"
            },
            ".justify-evenly": {
                "justify-content": "space-evenly"
            }
        });
    },
    justifyItems: ({ addUtilities  })=>{
        addUtilities({
            ".justify-items-start": {
                "justify-items": "start"
            },
            ".justify-items-end": {
                "justify-items": "end"
            },
            ".justify-items-center": {
                "justify-items": "center"
            },
            ".justify-items-stretch": {
                "justify-items": "stretch"
            }
        });
    },
    gap: (0, _createUtilityPlugin.default)("gap", [
        [
            "gap",
            [
                "gap"
            ]
        ],
        [
            [
                "gap-x",
                [
                    "columnGap"
                ]
            ],
            [
                "gap-y",
                [
                    "rowGap"
                ]
            ]
        ]
    ]),
    space: ({ matchUtilities , addUtilities , theme  })=>{
        matchUtilities({
            "space-x": (value)=>{
                value = value === "0" ? "0px" : value;
                return {
                    "& > :not([hidden]) ~ :not([hidden])": {
                        "--tw-space-x-reverse": "0",
                        "margin-right": `calc(${value} * var(--tw-space-x-reverse))`,
                        "margin-left": `calc(${value} * calc(1 - var(--tw-space-x-reverse)))`
                    }
                };
            },
            "space-y": (value)=>{
                value = value === "0" ? "0px" : value;
                return {
                    "& > :not([hidden]) ~ :not([hidden])": {
                        "--tw-space-y-reverse": "0",
                        "margin-top": `calc(${value} * calc(1 - var(--tw-space-y-reverse)))`,
                        "margin-bottom": `calc(${value} * var(--tw-space-y-reverse))`
                    }
                };
            }
        }, {
            values: theme("space"),
            supportsNegativeValues: true
        });
        addUtilities({
            ".space-y-reverse > :not([hidden]) ~ :not([hidden])": {
                "--tw-space-y-reverse": "1"
            },
            ".space-x-reverse > :not([hidden]) ~ :not([hidden])": {
                "--tw-space-x-reverse": "1"
            }
        });
    },
    divideWidth: ({ matchUtilities , addUtilities , theme  })=>{
        matchUtilities({
            "divide-x": (value)=>{
                value = value === "0" ? "0px" : value;
                return {
                    "& > :not([hidden]) ~ :not([hidden])": {
                        "@defaults border-width": {},
                        "--tw-divide-x-reverse": "0",
                        "border-right-width": `calc(${value} * var(--tw-divide-x-reverse))`,
                        "border-left-width": `calc(${value} * calc(1 - var(--tw-divide-x-reverse)))`
                    }
                };
            },
            "divide-y": (value)=>{
                value = value === "0" ? "0px" : value;
                return {
                    "& > :not([hidden]) ~ :not([hidden])": {
                        "@defaults border-width": {},
                        "--tw-divide-y-reverse": "0",
                        "border-top-width": `calc(${value} * calc(1 - var(--tw-divide-y-reverse)))`,
                        "border-bottom-width": `calc(${value} * var(--tw-divide-y-reverse))`
                    }
                };
            }
        }, {
            values: theme("divideWidth"),
            type: [
                "line-width",
                "length",
                "any"
            ]
        });
        addUtilities({
            ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": {
                "@defaults border-width": {},
                "--tw-divide-y-reverse": "1"
            },
            ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": {
                "@defaults border-width": {},
                "--tw-divide-x-reverse": "1"
            }
        });
    },
    divideStyle: ({ addUtilities  })=>{
        addUtilities({
            ".divide-solid > :not([hidden]) ~ :not([hidden])": {
                "border-style": "solid"
            },
            ".divide-dashed > :not([hidden]) ~ :not([hidden])": {
                "border-style": "dashed"
            },
            ".divide-dotted > :not([hidden]) ~ :not([hidden])": {
                "border-style": "dotted"
            },
            ".divide-double > :not([hidden]) ~ :not([hidden])": {
                "border-style": "double"
            },
            ".divide-none > :not([hidden]) ~ :not([hidden])": {
                "border-style": "none"
            }
        });
    },
    divideColor: ({ matchUtilities , theme , corePlugins  })=>{
        matchUtilities({
            divide: (value)=>{
                if (!corePlugins("divideOpacity")) {
                    return {
                        ["& > :not([hidden]) ~ :not([hidden])"]: {
                            "border-color": (0, _toColorValue.default)(value)
                        }
                    };
                }
                return {
                    ["& > :not([hidden]) ~ :not([hidden])"]: (0, _withAlphaVariable.default)({
                        color: value,
                        property: "border-color",
                        variable: "--tw-divide-opacity"
                    })
                };
            }
        }, {
            values: (({ DEFAULT: _ , ...colors })=>colors)((0, _flattenColorPalette.default)(theme("divideColor"))),
            type: [
                "color",
                "any"
            ]
        });
    },
    divideOpacity: ({ matchUtilities , theme  })=>{
        matchUtilities({
            "divide-opacity": (value)=>{
                return {
                    [`& > :not([hidden]) ~ :not([hidden])`]: {
                        "--tw-divide-opacity": value
                    }
                };
            }
        }, {
            values: theme("divideOpacity")
        });
    },
    placeSelf: ({ addUtilities  })=>{
        addUtilities({
            ".place-self-auto": {
                "place-self": "auto"
            },
            ".place-self-start": {
                "place-self": "start"
            },
            ".place-self-end": {
                "place-self": "end"
            },
            ".place-self-center": {
                "place-self": "center"
            },
            ".place-self-stretch": {
                "place-self": "stretch"
            }
        });
    },
    alignSelf: ({ addUtilities  })=>{
        addUtilities({
            ".self-auto": {
                "align-self": "auto"
            },
            ".self-start": {
                "align-self": "flex-start"
            },
            ".self-end": {
                "align-self": "flex-end"
            },
            ".self-center": {
                "align-self": "center"
            },
            ".self-stretch": {
                "align-self": "stretch"
            },
            ".self-baseline": {
                "align-self": "baseline"
            }
        });
    },
    justifySelf: ({ addUtilities  })=>{
        addUtilities({
            ".justify-self-auto": {
                "justify-self": "auto"
            },
            ".justify-self-start": {
                "justify-self": "start"
            },
            ".justify-self-end": {
                "justify-self": "end"
            },
            ".justify-self-center": {
                "justify-self": "center"
            },
            ".justify-self-stretch": {
                "justify-self": "stretch"
            }
        });
    },
    overflow: ({ addUtilities  })=>{
        addUtilities({
            ".overflow-auto": {
                overflow: "auto"
            },
            ".overflow-hidden": {
                overflow: "hidden"
            },
            ".overflow-clip": {
                overflow: "clip"
            },
            ".overflow-visible": {
                overflow: "visible"
            },
            ".overflow-scroll": {
                overflow: "scroll"
            },
            ".overflow-x-auto": {
                "overflow-x": "auto"
            },
            ".overflow-y-auto": {
                "overflow-y": "auto"
            },
            ".overflow-x-hidden": {
                "overflow-x": "hidden"
            },
            ".overflow-y-hidden": {
                "overflow-y": "hidden"
            },
            ".overflow-x-clip": {
                "overflow-x": "clip"
            },
            ".overflow-y-clip": {
                "overflow-y": "clip"
            },
            ".overflow-x-visible": {
                "overflow-x": "visible"
            },
            ".overflow-y-visible": {
                "overflow-y": "visible"
            },
            ".overflow-x-scroll": {
                "overflow-x": "scroll"
            },
            ".overflow-y-scroll": {
                "overflow-y": "scroll"
            }
        });
    },
    overscrollBehavior: ({ addUtilities  })=>{
        addUtilities({
            ".overscroll-auto": {
                "overscroll-behavior": "auto"
            },
            ".overscroll-contain": {
                "overscroll-behavior": "contain"
            },
            ".overscroll-none": {
                "overscroll-behavior": "none"
            },
            ".overscroll-y-auto": {
                "overscroll-behavior-y": "auto"
            },
            ".overscroll-y-contain": {
                "overscroll-behavior-y": "contain"
            },
            ".overscroll-y-none": {
                "overscroll-behavior-y": "none"
            },
            ".overscroll-x-auto": {
                "overscroll-behavior-x": "auto"
            },
            ".overscroll-x-contain": {
                "overscroll-behavior-x": "contain"
            },
            ".overscroll-x-none": {
                "overscroll-behavior-x": "none"
            }
        });
    },
    scrollBehavior: ({ addUtilities  })=>{
        addUtilities({
            ".scroll-auto": {
                "scroll-behavior": "auto"
            },
            ".scroll-smooth": {
                "scroll-behavior": "smooth"
            }
        });
    },
    textOverflow: ({ addUtilities  })=>{
        addUtilities({
            ".truncate": {
                overflow: "hidden",
                "text-overflow": "ellipsis",
                "white-space": "nowrap"
            },
            ".overflow-ellipsis": {
                "text-overflow": "ellipsis"
            },
            ".text-ellipsis": {
                "text-overflow": "ellipsis"
            },
            ".text-clip": {
                "text-overflow": "clip"
            }
        });
    },
    whitespace: ({ addUtilities  })=>{
        addUtilities({
            ".whitespace-normal": {
                "white-space": "normal"
            },
            ".whitespace-nowrap": {
                "white-space": "nowrap"
            },
            ".whitespace-pre": {
                "white-space": "pre"
            },
            ".whitespace-pre-line": {
                "white-space": "pre-line"
            },
            ".whitespace-pre-wrap": {
                "white-space": "pre-wrap"
            }
        });
    },
    wordBreak: ({ addUtilities  })=>{
        addUtilities({
            ".break-normal": {
                "overflow-wrap": "normal",
                "word-break": "normal"
            },
            ".break-words": {
                "overflow-wrap": "break-word"
            },
            ".break-all": {
                "word-break": "break-all"
            },
            ".break-keep": {
                "word-break": "keep-all"
            }
        });
    },
    borderRadius: (0, _createUtilityPlugin.default)("borderRadius", [
        [
            "rounded",
            [
                "border-radius"
            ]
        ],
        [
            [
                "rounded-t",
                [
                    "border-top-left-radius",
                    "border-top-right-radius"
                ]
            ],
            [
                "rounded-r",
                [
                    "border-top-right-radius",
                    "border-bottom-right-radius"
                ]
            ],
            [
                "rounded-b",
                [
                    "border-bottom-right-radius",
                    "border-bottom-left-radius"
                ]
            ],
            [
                "rounded-l",
                [
                    "border-top-left-radius",
                    "border-bottom-left-radius"
                ]
            ]
        ],
        [
            [
                "rounded-tl",
                [
                    "border-top-left-radius"
                ]
            ],
            [
                "rounded-tr",
                [
                    "border-top-right-radius"
                ]
            ],
            [
                "rounded-br",
                [
                    "border-bottom-right-radius"
                ]
            ],
            [
                "rounded-bl",
                [
                    "border-bottom-left-radius"
                ]
            ]
        ]
    ]),
    borderWidth: (0, _createUtilityPlugin.default)("borderWidth", [
        [
            "border",
            [
                [
                    "@defaults border-width",
                    {}
                ],
                "border-width"
            ]
        ],
        [
            [
                "border-x",
                [
                    [
                        "@defaults border-width",
                        {}
                    ],
                    "border-left-width",
                    "border-right-width"
                ]
            ],
            [
                "border-y",
                [
                    [
                        "@defaults border-width",
                        {}
                    ],
                    "border-top-width",
                    "border-bottom-width"
                ]
            ]
        ],
        [
            [
                "border-t",
                [
                    [
                        "@defaults border-width",
                        {}
                    ],
                    "border-top-width"
                ]
            ],
            [
                "border-r",
                [
                    [
                        "@defaults border-width",
                        {}
                    ],
                    "border-right-width"
                ]
            ],
            [
                "border-b",
                [
                    [
                        "@defaults border-width",
                        {}
                    ],
                    "border-bottom-width"
                ]
            ],
            [
                "border-l",
                [
                    [
                        "@defaults border-width",
                        {}
                    ],
                    "border-left-width"
                ]
            ]
        ]
    ], {
        type: [
            "line-width",
            "length"
        ]
    }),
    borderStyle: ({ addUtilities  })=>{
        addUtilities({
            ".border-solid": {
                "border-style": "solid"
            },
            ".border-dashed": {
                "border-style": "dashed"
            },
            ".border-dotted": {
                "border-style": "dotted"
            },
            ".border-double": {
                "border-style": "double"
            },
            ".border-hidden": {
                "border-style": "hidden"
            },
            ".border-none": {
                "border-style": "none"
            }
        });
    },
    borderColor: ({ matchUtilities , theme , corePlugins  })=>{
        matchUtilities({
            border: (value)=>{
                if (!corePlugins("borderOpacity")) {
                    return {
                        "border-color": (0, _toColorValue.default)(value)
                    };
                }
                return (0, _withAlphaVariable.default)({
                    color: value,
                    property: "border-color",
                    variable: "--tw-border-opacity"
                });
            }
        }, {
            values: (({ DEFAULT: _ , ...colors })=>colors)((0, _flattenColorPalette.default)(theme("borderColor"))),
            type: [
                "color",
                "any"
            ]
        });
        matchUtilities({
            "border-x": (value)=>{
                if (!corePlugins("borderOpacity")) {
                    return {
                        "border-left-color": (0, _toColorValue.default)(value),
                        "border-right-color": (0, _toColorValue.default)(value)
                    };
                }
                return (0, _withAlphaVariable.default)({
                    color: value,
                    property: [
                        "border-left-color",
                        "border-right-color"
                    ],
                    variable: "--tw-border-opacity"
                });
            },
            "border-y": (value)=>{
                if (!corePlugins("borderOpacity")) {
                    return {
                        "border-top-color": (0, _toColorValue.default)(value),
                        "border-bottom-color": (0, _toColorValue.default)(value)
                    };
                }
                return (0, _withAlphaVariable.default)({
                    color: value,
                    property: [
                        "border-top-color",
                        "border-bottom-color"
                    ],
                    variable: "--tw-border-opacity"
                });
            }
        }, {
            values: (({ DEFAULT: _ , ...colors })=>colors)((0, _flattenColorPalette.default)(theme("borderColor"))),
            type: [
                "color",
                "any"
            ]
        });
        matchUtilities({
            "border-t": (value)=>{
                if (!corePlugins("borderOpacity")) {
                    return {
                        "border-top-color": (0, _toColorValue.default)(value)
                    };
                }
                return (0, _withAlphaVariable.default)({
                    color: value,
                    property: "border-top-color",
                    variable: "--tw-border-opacity"
                });
            },
            "border-r": (value)=>{
                if (!corePlugins("borderOpacity")) {
                    return {
                        "border-right-color": (0, _toColorValue.default)(value)
                    };
                }
                return (0, _withAlphaVariable.default)({
                    color: value,
                    property: "border-right-color",
                    variable: "--tw-border-opacity"
                });
            },
            "border-b": (value)=>{
                if (!corePlugins("borderOpacity")) {
                    return {
                        "border-bottom-color": (0, _toColorValue.default)(value)
                    };
                }
                return (0, _withAlphaVariable.default)({
                    color: value,
                    property: "border-bottom-color",
                    variable: "--tw-border-opacity"
                });
            },
            "border-l": (value)=>{
                if (!corePlugins("borderOpacity")) {
                    return {
                        "border-left-color": (0, _toColorValue.default)(value)
                    };
                }
                return (0, _withAlphaVariable.default)({
                    color: value,
                    property: "border-left-color",
                    variable: "--tw-border-opacity"
                });
            }
        }, {
            values: (({ DEFAULT: _ , ...colors })=>colors)((0, _flattenColorPalette.default)(theme("borderColor"))),
            type: [
                "color",
                "any"
            ]
        });
    },
    borderOpacity: (0, _createUtilityPlugin.default)("borderOpacity", [
        [
            "border-opacity",
            [
                "--tw-border-opacity"
            ]
        ]
    ]),
    backgroundColor: ({ matchUtilities , theme , corePlugins  })=>{
        matchUtilities({
            bg: (value)=>{
                if (!corePlugins("backgroundOpacity")) {
                    return {
                        "background-color": (0, _toColorValue.default)(value)
                    };
                }
                return (0, _withAlphaVariable.default)({
                    color: value,
                    property: "background-color",
                    variable: "--tw-bg-opacity"
                });
            }
        }, {
            values: (0, _flattenColorPalette.default)(theme("backgroundColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    backgroundOpacity: (0, _createUtilityPlugin.default)("backgroundOpacity", [
        [
            "bg-opacity",
            [
                "--tw-bg-opacity"
            ]
        ]
    ]),
    backgroundImage: (0, _createUtilityPlugin.default)("backgroundImage", [
        [
            "bg",
            [
                "background-image"
            ]
        ]
    ], {
        type: [
            "lookup",
            "image",
            "url"
        ]
    }),
    gradientColorStops: (()=>{
        function transparentTo(value) {
            return (0, _withAlphaVariable.withAlphaValue)(value, 0, "rgb(255 255 255 / 0)");
        }
        return function({ matchUtilities , theme  }) {
            let options = {
                values: (0, _flattenColorPalette.default)(theme("gradientColorStops")),
                type: [
                    "color",
                    "any"
                ]
            };
            matchUtilities({
                from: (value)=>{
                    let transparentToValue = transparentTo(value);
                    return {
                        "--tw-gradient-from": (0, _toColorValue.default)(value, "from"),
                        "--tw-gradient-to": transparentToValue,
                        "--tw-gradient-stops": `var(--tw-gradient-from), var(--tw-gradient-to)`
                    };
                }
            }, options);
            matchUtilities({
                via: (value)=>{
                    let transparentToValue = transparentTo(value);
                    return {
                        "--tw-gradient-to": transparentToValue,
                        "--tw-gradient-stops": `var(--tw-gradient-from), ${(0, _toColorValue.default)(value, "via")}, var(--tw-gradient-to)`
                    };
                }
            }, options);
            matchUtilities({
                to: (value)=>({
                        "--tw-gradient-to": (0, _toColorValue.default)(value, "to")
                    })
            }, options);
        };
    })(),
    boxDecorationBreak: ({ addUtilities  })=>{
        addUtilities({
            ".decoration-slice": {
                "box-decoration-break": "slice"
            },
            ".decoration-clone": {
                "box-decoration-break": "clone"
            },
            ".box-decoration-slice": {
                "box-decoration-break": "slice"
            },
            ".box-decoration-clone": {
                "box-decoration-break": "clone"
            }
        });
    },
    backgroundSize: (0, _createUtilityPlugin.default)("backgroundSize", [
        [
            "bg",
            [
                "background-size"
            ]
        ]
    ], {
        type: [
            "lookup",
            "length",
            "percentage",
            "size"
        ]
    }),
    backgroundAttachment: ({ addUtilities  })=>{
        addUtilities({
            ".bg-fixed": {
                "background-attachment": "fixed"
            },
            ".bg-local": {
                "background-attachment": "local"
            },
            ".bg-scroll": {
                "background-attachment": "scroll"
            }
        });
    },
    backgroundClip: ({ addUtilities  })=>{
        addUtilities({
            ".bg-clip-border": {
                "background-clip": "border-box"
            },
            ".bg-clip-padding": {
                "background-clip": "padding-box"
            },
            ".bg-clip-content": {
                "background-clip": "content-box"
            },
            ".bg-clip-text": {
                "background-clip": "text"
            }
        });
    },
    backgroundPosition: (0, _createUtilityPlugin.default)("backgroundPosition", [
        [
            "bg",
            [
                "background-position"
            ]
        ]
    ], {
        type: [
            "lookup",
            [
                "position",
                {
                    preferOnConflict: true
                }
            ]
        ]
    }),
    backgroundRepeat: ({ addUtilities  })=>{
        addUtilities({
            ".bg-repeat": {
                "background-repeat": "repeat"
            },
            ".bg-no-repeat": {
                "background-repeat": "no-repeat"
            },
            ".bg-repeat-x": {
                "background-repeat": "repeat-x"
            },
            ".bg-repeat-y": {
                "background-repeat": "repeat-y"
            },
            ".bg-repeat-round": {
                "background-repeat": "round"
            },
            ".bg-repeat-space": {
                "background-repeat": "space"
            }
        });
    },
    backgroundOrigin: ({ addUtilities  })=>{
        addUtilities({
            ".bg-origin-border": {
                "background-origin": "border-box"
            },
            ".bg-origin-padding": {
                "background-origin": "padding-box"
            },
            ".bg-origin-content": {
                "background-origin": "content-box"
            }
        });
    },
    fill: ({ matchUtilities , theme  })=>{
        matchUtilities({
            fill: (value)=>{
                return {
                    fill: (0, _toColorValue.default)(value)
                };
            }
        }, {
            values: (0, _flattenColorPalette.default)(theme("fill")),
            type: [
                "color",
                "any"
            ]
        });
    },
    stroke: ({ matchUtilities , theme  })=>{
        matchUtilities({
            stroke: (value)=>{
                return {
                    stroke: (0, _toColorValue.default)(value)
                };
            }
        }, {
            values: (0, _flattenColorPalette.default)(theme("stroke")),
            type: [
                "color",
                "url",
                "any"
            ]
        });
    },
    strokeWidth: (0, _createUtilityPlugin.default)("strokeWidth", [
        [
            "stroke",
            [
                "stroke-width"
            ]
        ]
    ], {
        type: [
            "length",
            "number",
            "percentage"
        ]
    }),
    objectFit: ({ addUtilities  })=>{
        addUtilities({
            ".object-contain": {
                "object-fit": "contain"
            },
            ".object-cover": {
                "object-fit": "cover"
            },
            ".object-fill": {
                "object-fit": "fill"
            },
            ".object-none": {
                "object-fit": "none"
            },
            ".object-scale-down": {
                "object-fit": "scale-down"
            }
        });
    },
    objectPosition: (0, _createUtilityPlugin.default)("objectPosition", [
        [
            "object",
            [
                "object-position"
            ]
        ]
    ]),
    padding: (0, _createUtilityPlugin.default)("padding", [
        [
            "p",
            [
                "padding"
            ]
        ],
        [
            [
                "px",
                [
                    "padding-left",
                    "padding-right"
                ]
            ],
            [
                "py",
                [
                    "padding-top",
                    "padding-bottom"
                ]
            ]
        ],
        [
            [
                "pt",
                [
                    "padding-top"
                ]
            ],
            [
                "pr",
                [
                    "padding-right"
                ]
            ],
            [
                "pb",
                [
                    "padding-bottom"
                ]
            ],
            [
                "pl",
                [
                    "padding-left"
                ]
            ]
        ]
    ]),
    textAlign: ({ addUtilities  })=>{
        addUtilities({
            ".text-left": {
                "text-align": "left"
            },
            ".text-center": {
                "text-align": "center"
            },
            ".text-right": {
                "text-align": "right"
            },
            ".text-justify": {
                "text-align": "justify"
            },
            ".text-start": {
                "text-align": "start"
            },
            ".text-end": {
                "text-align": "end"
            }
        });
    },
    textIndent: (0, _createUtilityPlugin.default)("textIndent", [
        [
            "indent",
            [
                "text-indent"
            ]
        ]
    ], {
        supportsNegativeValues: true
    }),
    verticalAlign: ({ addUtilities , matchUtilities  })=>{
        addUtilities({
            ".align-baseline": {
                "vertical-align": "baseline"
            },
            ".align-top": {
                "vertical-align": "top"
            },
            ".align-middle": {
                "vertical-align": "middle"
            },
            ".align-bottom": {
                "vertical-align": "bottom"
            },
            ".align-text-top": {
                "vertical-align": "text-top"
            },
            ".align-text-bottom": {
                "vertical-align": "text-bottom"
            },
            ".align-sub": {
                "vertical-align": "sub"
            },
            ".align-super": {
                "vertical-align": "super"
            }
        });
        matchUtilities({
            align: (value)=>({
                    "vertical-align": value
                })
        });
    },
    fontFamily: ({ matchUtilities , theme  })=>{
        matchUtilities({
            font: (value)=>{
                let [families, options = {}] = Array.isArray(value) && (0, _isPlainObject.default)(value[1]) ? value : [
                    value
                ];
                let { fontFeatureSettings  } = options;
                return {
                    "font-family": Array.isArray(families) ? families.join(", ") : families,
                    ...fontFeatureSettings === undefined ? {} : {
                        "font-feature-settings": fontFeatureSettings
                    }
                };
            }
        }, {
            values: theme("fontFamily"),
            type: [
                "lookup",
                "generic-name",
                "family-name"
            ]
        });
    },
    fontSize: ({ matchUtilities , theme  })=>{
        matchUtilities({
            text: (value)=>{
                let [fontSize, options] = Array.isArray(value) ? value : [
                    value
                ];
                let { lineHeight , letterSpacing , fontWeight  } = (0, _isPlainObject.default)(options) ? options : {
                    lineHeight: options
                };
                return {
                    "font-size": fontSize,
                    ...lineHeight === undefined ? {} : {
                        "line-height": lineHeight
                    },
                    ...letterSpacing === undefined ? {} : {
                        "letter-spacing": letterSpacing
                    },
                    ...fontWeight === undefined ? {} : {
                        "font-weight": fontWeight
                    }
                };
            }
        }, {
            values: theme("fontSize"),
            type: [
                "absolute-size",
                "relative-size",
                "length",
                "percentage"
            ]
        });
    },
    fontWeight: (0, _createUtilityPlugin.default)("fontWeight", [
        [
            "font",
            [
                "fontWeight"
            ]
        ]
    ], {
        type: [
            "lookup",
            "number",
            "any"
        ]
    }),
    textTransform: ({ addUtilities  })=>{
        addUtilities({
            ".uppercase": {
                "text-transform": "uppercase"
            },
            ".lowercase": {
                "text-transform": "lowercase"
            },
            ".capitalize": {
                "text-transform": "capitalize"
            },
            ".normal-case": {
                "text-transform": "none"
            }
        });
    },
    fontStyle: ({ addUtilities  })=>{
        addUtilities({
            ".italic": {
                "font-style": "italic"
            },
            ".not-italic": {
                "font-style": "normal"
            }
        });
    },
    fontVariantNumeric: ({ addDefaults , addUtilities  })=>{
        let cssFontVariantNumericValue = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
        addDefaults("font-variant-numeric", {
            "--tw-ordinal": " ",
            "--tw-slashed-zero": " ",
            "--tw-numeric-figure": " ",
            "--tw-numeric-spacing": " ",
            "--tw-numeric-fraction": " "
        });
        addUtilities({
            ".normal-nums": {
                "font-variant-numeric": "normal"
            },
            ".ordinal": {
                "@defaults font-variant-numeric": {},
                "--tw-ordinal": "ordinal",
                "font-variant-numeric": cssFontVariantNumericValue
            },
            ".slashed-zero": {
                "@defaults font-variant-numeric": {},
                "--tw-slashed-zero": "slashed-zero",
                "font-variant-numeric": cssFontVariantNumericValue
            },
            ".lining-nums": {
                "@defaults font-variant-numeric": {},
                "--tw-numeric-figure": "lining-nums",
                "font-variant-numeric": cssFontVariantNumericValue
            },
            ".oldstyle-nums": {
                "@defaults font-variant-numeric": {},
                "--tw-numeric-figure": "oldstyle-nums",
                "font-variant-numeric": cssFontVariantNumericValue
            },
            ".proportional-nums": {
                "@defaults font-variant-numeric": {},
                "--tw-numeric-spacing": "proportional-nums",
                "font-variant-numeric": cssFontVariantNumericValue
            },
            ".tabular-nums": {
                "@defaults font-variant-numeric": {},
                "--tw-numeric-spacing": "tabular-nums",
                "font-variant-numeric": cssFontVariantNumericValue
            },
            ".diagonal-fractions": {
                "@defaults font-variant-numeric": {},
                "--tw-numeric-fraction": "diagonal-fractions",
                "font-variant-numeric": cssFontVariantNumericValue
            },
            ".stacked-fractions": {
                "@defaults font-variant-numeric": {},
                "--tw-numeric-fraction": "stacked-fractions",
                "font-variant-numeric": cssFontVariantNumericValue
            }
        });
    },
    lineHeight: (0, _createUtilityPlugin.default)("lineHeight", [
        [
            "leading",
            [
                "lineHeight"
            ]
        ]
    ]),
    letterSpacing: (0, _createUtilityPlugin.default)("letterSpacing", [
        [
            "tracking",
            [
                "letterSpacing"
            ]
        ]
    ], {
        supportsNegativeValues: true
    }),
    textColor: ({ matchUtilities , theme , corePlugins  })=>{
        matchUtilities({
            text: (value)=>{
                if (!corePlugins("textOpacity")) {
                    return {
                        color: (0, _toColorValue.default)(value)
                    };
                }
                return (0, _withAlphaVariable.default)({
                    color: value,
                    property: "color",
                    variable: "--tw-text-opacity"
                });
            }
        }, {
            values: (0, _flattenColorPalette.default)(theme("textColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    textOpacity: (0, _createUtilityPlugin.default)("textOpacity", [
        [
            "text-opacity",
            [
                "--tw-text-opacity"
            ]
        ]
    ]),
    textDecoration: ({ addUtilities  })=>{
        addUtilities({
            ".underline": {
                "text-decoration-line": "underline"
            },
            ".overline": {
                "text-decoration-line": "overline"
            },
            ".line-through": {
                "text-decoration-line": "line-through"
            },
            ".no-underline": {
                "text-decoration-line": "none"
            }
        });
    },
    textDecorationColor: ({ matchUtilities , theme  })=>{
        matchUtilities({
            decoration: (value)=>{
                return {
                    "text-decoration-color": (0, _toColorValue.default)(value)
                };
            }
        }, {
            values: (0, _flattenColorPalette.default)(theme("textDecorationColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    textDecorationStyle: ({ addUtilities  })=>{
        addUtilities({
            ".decoration-solid": {
                "text-decoration-style": "solid"
            },
            ".decoration-double": {
                "text-decoration-style": "double"
            },
            ".decoration-dotted": {
                "text-decoration-style": "dotted"
            },
            ".decoration-dashed": {
                "text-decoration-style": "dashed"
            },
            ".decoration-wavy": {
                "text-decoration-style": "wavy"
            }
        });
    },
    textDecorationThickness: (0, _createUtilityPlugin.default)("textDecorationThickness", [
        [
            "decoration",
            [
                "text-decoration-thickness"
            ]
        ]
    ], {
        type: [
            "length",
            "percentage"
        ]
    }),
    textUnderlineOffset: (0, _createUtilityPlugin.default)("textUnderlineOffset", [
        [
            "underline-offset",
            [
                "text-underline-offset"
            ]
        ]
    ], {
        type: [
            "length",
            "percentage",
            "any"
        ]
    }),
    fontSmoothing: ({ addUtilities  })=>{
        addUtilities({
            ".antialiased": {
                "-webkit-font-smoothing": "antialiased",
                "-moz-osx-font-smoothing": "grayscale"
            },
            ".subpixel-antialiased": {
                "-webkit-font-smoothing": "auto",
                "-moz-osx-font-smoothing": "auto"
            }
        });
    },
    placeholderColor: ({ matchUtilities , theme , corePlugins  })=>{
        matchUtilities({
            placeholder: (value)=>{
                if (!corePlugins("placeholderOpacity")) {
                    return {
                        "&::placeholder": {
                            color: (0, _toColorValue.default)(value)
                        }
                    };
                }
                return {
                    "&::placeholder": (0, _withAlphaVariable.default)({
                        color: value,
                        property: "color",
                        variable: "--tw-placeholder-opacity"
                    })
                };
            }
        }, {
            values: (0, _flattenColorPalette.default)(theme("placeholderColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    placeholderOpacity: ({ matchUtilities , theme  })=>{
        matchUtilities({
            "placeholder-opacity": (value)=>{
                return {
                    ["&::placeholder"]: {
                        "--tw-placeholder-opacity": value
                    }
                };
            }
        }, {
            values: theme("placeholderOpacity")
        });
    },
    caretColor: ({ matchUtilities , theme  })=>{
        matchUtilities({
            caret: (value)=>{
                return {
                    "caret-color": (0, _toColorValue.default)(value)
                };
            }
        }, {
            values: (0, _flattenColorPalette.default)(theme("caretColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    accentColor: ({ matchUtilities , theme  })=>{
        matchUtilities({
            accent: (value)=>{
                return {
                    "accent-color": (0, _toColorValue.default)(value)
                };
            }
        }, {
            values: (0, _flattenColorPalette.default)(theme("accentColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    opacity: (0, _createUtilityPlugin.default)("opacity", [
        [
            "opacity",
            [
                "opacity"
            ]
        ]
    ]),
    backgroundBlendMode: ({ addUtilities  })=>{
        addUtilities({
            ".bg-blend-normal": {
                "background-blend-mode": "normal"
            },
            ".bg-blend-multiply": {
                "background-blend-mode": "multiply"
            },
            ".bg-blend-screen": {
                "background-blend-mode": "screen"
            },
            ".bg-blend-overlay": {
                "background-blend-mode": "overlay"
            },
            ".bg-blend-darken": {
                "background-blend-mode": "darken"
            },
            ".bg-blend-lighten": {
                "background-blend-mode": "lighten"
            },
            ".bg-blend-color-dodge": {
                "background-blend-mode": "color-dodge"
            },
            ".bg-blend-color-burn": {
                "background-blend-mode": "color-burn"
            },
            ".bg-blend-hard-light": {
                "background-blend-mode": "hard-light"
            },
            ".bg-blend-soft-light": {
                "background-blend-mode": "soft-light"
            },
            ".bg-blend-difference": {
                "background-blend-mode": "difference"
            },
            ".bg-blend-exclusion": {
                "background-blend-mode": "exclusion"
            },
            ".bg-blend-hue": {
                "background-blend-mode": "hue"
            },
            ".bg-blend-saturation": {
                "background-blend-mode": "saturation"
            },
            ".bg-blend-color": {
                "background-blend-mode": "color"
            },
            ".bg-blend-luminosity": {
                "background-blend-mode": "luminosity"
            }
        });
    },
    mixBlendMode: ({ addUtilities  })=>{
        addUtilities({
            ".mix-blend-normal": {
                "mix-blend-mode": "normal"
            },
            ".mix-blend-multiply": {
                "mix-blend-mode": "multiply"
            },
            ".mix-blend-screen": {
                "mix-blend-mode": "screen"
            },
            ".mix-blend-overlay": {
                "mix-blend-mode": "overlay"
            },
            ".mix-blend-darken": {
                "mix-blend-mode": "darken"
            },
            ".mix-blend-lighten": {
                "mix-blend-mode": "lighten"
            },
            ".mix-blend-color-dodge": {
                "mix-blend-mode": "color-dodge"
            },
            ".mix-blend-color-burn": {
                "mix-blend-mode": "color-burn"
            },
            ".mix-blend-hard-light": {
                "mix-blend-mode": "hard-light"
            },
            ".mix-blend-soft-light": {
                "mix-blend-mode": "soft-light"
            },
            ".mix-blend-difference": {
                "mix-blend-mode": "difference"
            },
            ".mix-blend-exclusion": {
                "mix-blend-mode": "exclusion"
            },
            ".mix-blend-hue": {
                "mix-blend-mode": "hue"
            },
            ".mix-blend-saturation": {
                "mix-blend-mode": "saturation"
            },
            ".mix-blend-color": {
                "mix-blend-mode": "color"
            },
            ".mix-blend-luminosity": {
                "mix-blend-mode": "luminosity"
            },
            ".mix-blend-plus-lighter": {
                "mix-blend-mode": "plus-lighter"
            }
        });
    },
    boxShadow: (()=>{
        let transformValue = (0, _transformThemeValue.default)("boxShadow");
        let defaultBoxShadow = [
            `var(--tw-ring-offset-shadow, 0 0 #0000)`,
            `var(--tw-ring-shadow, 0 0 #0000)`,
            `var(--tw-shadow)`
        ].join(", ");
        return function({ matchUtilities , addDefaults , theme  }) {
            addDefaults(" box-shadow", {
                "--tw-ring-offset-shadow": "0 0 #0000",
                "--tw-ring-shadow": "0 0 #0000",
                "--tw-shadow": "0 0 #0000",
                "--tw-shadow-colored": "0 0 #0000"
            });
            matchUtilities({
                shadow: (value)=>{
                    value = transformValue(value);
                    let ast = (0, _parseBoxShadowValue.parseBoxShadowValue)(value);
                    for (let shadow of ast){
                        // Don't override color if the whole shadow is a variable
                        if (!shadow.valid) {
                            continue;
                        }
                        shadow.color = "var(--tw-shadow-color)";
                    }
                    return {
                        "@defaults box-shadow": {},
                        "--tw-shadow": value === "none" ? "0 0 #0000" : value,
                        "--tw-shadow-colored": value === "none" ? "0 0 #0000" : (0, _parseBoxShadowValue.formatBoxShadowValue)(ast),
                        "box-shadow": defaultBoxShadow
                    };
                }
            }, {
                values: theme("boxShadow"),
                type: [
                    "shadow"
                ]
            });
        };
    })(),
    boxShadowColor: ({ matchUtilities , theme  })=>{
        matchUtilities({
            shadow: (value)=>{
                return {
                    "--tw-shadow-color": (0, _toColorValue.default)(value),
                    "--tw-shadow": "var(--tw-shadow-colored)"
                };
            }
        }, {
            values: (0, _flattenColorPalette.default)(theme("boxShadowColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    outlineStyle: ({ addUtilities  })=>{
        addUtilities({
            ".outline-none": {
                outline: "2px solid transparent",
                "outline-offset": "2px"
            },
            ".outline": {
                "outline-style": "solid"
            },
            ".outline-dashed": {
                "outline-style": "dashed"
            },
            ".outline-dotted": {
                "outline-style": "dotted"
            },
            ".outline-double": {
                "outline-style": "double"
            }
        });
    },
    outlineWidth: (0, _createUtilityPlugin.default)("outlineWidth", [
        [
            "outline",
            [
                "outline-width"
            ]
        ]
    ], {
        type: [
            "length",
            "number",
            "percentage"
        ]
    }),
    outlineOffset: (0, _createUtilityPlugin.default)("outlineOffset", [
        [
            "outline-offset",
            [
                "outline-offset"
            ]
        ]
    ], {
        type: [
            "length",
            "number",
            "percentage",
            "any"
        ],
        supportsNegativeValues: true
    }),
    outlineColor: ({ matchUtilities , theme  })=>{
        matchUtilities({
            outline: (value)=>{
                return {
                    "outline-color": (0, _toColorValue.default)(value)
                };
            }
        }, {
            values: (0, _flattenColorPalette.default)(theme("outlineColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    ringWidth: ({ matchUtilities , addDefaults , addUtilities , theme , config  })=>{
        let ringColorDefault = (()=>{
            var _theme, _theme1;
            if ((0, _featureFlags.flagEnabled)(config(), "respectDefaultRingColorOpacity")) {
                return theme("ringColor.DEFAULT");
            }
            let ringOpacityDefault = theme("ringOpacity.DEFAULT", "0.5");
            if (!((_theme = theme("ringColor")) === null || _theme === void 0 ? void 0 : _theme.DEFAULT)) {
                return `rgb(147 197 253 / ${ringOpacityDefault})`;
            }
            return (0, _withAlphaVariable.withAlphaValue)((_theme1 = theme("ringColor")) === null || _theme1 === void 0 ? void 0 : _theme1.DEFAULT, ringOpacityDefault, `rgb(147 197 253 / ${ringOpacityDefault})`);
        })();
        addDefaults("ring-width", {
            "--tw-ring-inset": " ",
            "--tw-ring-offset-width": theme("ringOffsetWidth.DEFAULT", "0px"),
            "--tw-ring-offset-color": theme("ringOffsetColor.DEFAULT", "#fff"),
            "--tw-ring-color": ringColorDefault,
            "--tw-ring-offset-shadow": "0 0 #0000",
            "--tw-ring-shadow": "0 0 #0000",
            "--tw-shadow": "0 0 #0000",
            "--tw-shadow-colored": "0 0 #0000"
        });
        matchUtilities({
            ring: (value)=>{
                return {
                    "@defaults ring-width": {},
                    "--tw-ring-offset-shadow": `var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)`,
                    "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${value} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
                    "box-shadow": [
                        `var(--tw-ring-offset-shadow)`,
                        `var(--tw-ring-shadow)`,
                        `var(--tw-shadow, 0 0 #0000)`
                    ].join(", ")
                };
            }
        }, {
            values: theme("ringWidth"),
            type: "length"
        });
        addUtilities({
            ".ring-inset": {
                "@defaults ring-width": {},
                "--tw-ring-inset": "inset"
            }
        });
    },
    ringColor: ({ matchUtilities , theme , corePlugins  })=>{
        matchUtilities({
            ring: (value)=>{
                if (!corePlugins("ringOpacity")) {
                    return {
                        "--tw-ring-color": (0, _toColorValue.default)(value)
                    };
                }
                return (0, _withAlphaVariable.default)({
                    color: value,
                    property: "--tw-ring-color",
                    variable: "--tw-ring-opacity"
                });
            }
        }, {
            values: Object.fromEntries(Object.entries((0, _flattenColorPalette.default)(theme("ringColor"))).filter(([modifier])=>modifier !== "DEFAULT")),
            type: [
                "color",
                "any"
            ]
        });
    },
    ringOpacity: (helpers)=>{
        let { config  } = helpers;
        return (0, _createUtilityPlugin.default)("ringOpacity", [
            [
                "ring-opacity",
                [
                    "--tw-ring-opacity"
                ]
            ]
        ], {
            filterDefault: !(0, _featureFlags.flagEnabled)(config(), "respectDefaultRingColorOpacity")
        })(helpers);
    },
    ringOffsetWidth: (0, _createUtilityPlugin.default)("ringOffsetWidth", [
        [
            "ring-offset",
            [
                "--tw-ring-offset-width"
            ]
        ]
    ], {
        type: "length"
    }),
    ringOffsetColor: ({ matchUtilities , theme  })=>{
        matchUtilities({
            "ring-offset": (value)=>{
                return {
                    "--tw-ring-offset-color": (0, _toColorValue.default)(value)
                };
            }
        }, {
            values: (0, _flattenColorPalette.default)(theme("ringOffsetColor")),
            type: [
                "color",
                "any"
            ]
        });
    },
    blur: ({ matchUtilities , theme  })=>{
        matchUtilities({
            blur: (value)=>{
                return {
                    "--tw-blur": `blur(${value})`,
                    "@defaults filter": {},
                    filter: cssFilterValue
                };
            }
        }, {
            values: theme("blur")
        });
    },
    brightness: ({ matchUtilities , theme  })=>{
        matchUtilities({
            brightness: (value)=>{
                return {
                    "--tw-brightness": `brightness(${value})`,
                    "@defaults filter": {},
                    filter: cssFilterValue
                };
            }
        }, {
            values: theme("brightness")
        });
    },
    contrast: ({ matchUtilities , theme  })=>{
        matchUtilities({
            contrast: (value)=>{
                return {
                    "--tw-contrast": `contrast(${value})`,
                    "@defaults filter": {},
                    filter: cssFilterValue
                };
            }
        }, {
            values: theme("contrast")
        });
    },
    dropShadow: ({ matchUtilities , theme  })=>{
        matchUtilities({
            "drop-shadow": (value)=>{
                return {
                    "--tw-drop-shadow": Array.isArray(value) ? value.map((v)=>`drop-shadow(${v})`).join(" ") : `drop-shadow(${value})`,
                    "@defaults filter": {},
                    filter: cssFilterValue
                };
            }
        }, {
            values: theme("dropShadow")
        });
    },
    grayscale: ({ matchUtilities , theme  })=>{
        matchUtilities({
            grayscale: (value)=>{
                return {
                    "--tw-grayscale": `grayscale(${value})`,
                    "@defaults filter": {},
                    filter: cssFilterValue
                };
            }
        }, {
            values: theme("grayscale")
        });
    },
    hueRotate: ({ matchUtilities , theme  })=>{
        matchUtilities({
            "hue-rotate": (value)=>{
                return {
                    "--tw-hue-rotate": `hue-rotate(${value})`,
                    "@defaults filter": {},
                    filter: cssFilterValue
                };
            }
        }, {
            values: theme("hueRotate"),
            supportsNegativeValues: true
        });
    },
    invert: ({ matchUtilities , theme  })=>{
        matchUtilities({
            invert: (value)=>{
                return {
                    "--tw-invert": `invert(${value})`,
                    "@defaults filter": {},
                    filter: cssFilterValue
                };
            }
        }, {
            values: theme("invert")
        });
    },
    saturate: ({ matchUtilities , theme  })=>{
        matchUtilities({
            saturate: (value)=>{
                return {
                    "--tw-saturate": `saturate(${value})`,
                    "@defaults filter": {},
                    filter: cssFilterValue
                };
            }
        }, {
            values: theme("saturate")
        });
    },
    sepia: ({ matchUtilities , theme  })=>{
        matchUtilities({
            sepia: (value)=>{
                return {
                    "--tw-sepia": `sepia(${value})`,
                    "@defaults filter": {},
                    filter: cssFilterValue
                };
            }
        }, {
            values: theme("sepia")
        });
    },
    filter: ({ addDefaults , addUtilities  })=>{
        addDefaults("filter", {
            "--tw-blur": " ",
            "--tw-brightness": " ",
            "--tw-contrast": " ",
            "--tw-grayscale": " ",
            "--tw-hue-rotate": " ",
            "--tw-invert": " ",
            "--tw-saturate": " ",
            "--tw-sepia": " ",
            "--tw-drop-shadow": " "
        });
        addUtilities({
            ".filter": {
                "@defaults filter": {},
                filter: cssFilterValue
            },
            ".filter-none": {
                filter: "none"
            }
        });
    },
    backdropBlur: ({ matchUtilities , theme  })=>{
        matchUtilities({
            "backdrop-blur": (value)=>{
                return {
                    "--tw-backdrop-blur": `blur(${value})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": cssBackdropFilterValue
                };
            }
        }, {
            values: theme("backdropBlur")
        });
    },
    backdropBrightness: ({ matchUtilities , theme  })=>{
        matchUtilities({
            "backdrop-brightness": (value)=>{
                return {
                    "--tw-backdrop-brightness": `brightness(${value})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": cssBackdropFilterValue
                };
            }
        }, {
            values: theme("backdropBrightness")
        });
    },
    backdropContrast: ({ matchUtilities , theme  })=>{
        matchUtilities({
            "backdrop-contrast": (value)=>{
                return {
                    "--tw-backdrop-contrast": `contrast(${value})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": cssBackdropFilterValue
                };
            }
        }, {
            values: theme("backdropContrast")
        });
    },
    backdropGrayscale: ({ matchUtilities , theme  })=>{
        matchUtilities({
            "backdrop-grayscale": (value)=>{
                return {
                    "--tw-backdrop-grayscale": `grayscale(${value})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": cssBackdropFilterValue
                };
            }
        }, {
            values: theme("backdropGrayscale")
        });
    },
    backdropHueRotate: ({ matchUtilities , theme  })=>{
        matchUtilities({
            "backdrop-hue-rotate": (value)=>{
                return {
                    "--tw-backdrop-hue-rotate": `hue-rotate(${value})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": cssBackdropFilterValue
                };
            }
        }, {
            values: theme("backdropHueRotate"),
            supportsNegativeValues: true
        });
    },
    backdropInvert: ({ matchUtilities , theme  })=>{
        matchUtilities({
            "backdrop-invert": (value)=>{
                return {
                    "--tw-backdrop-invert": `invert(${value})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": cssBackdropFilterValue
                };
            }
        }, {
            values: theme("backdropInvert")
        });
    },
    backdropOpacity: ({ matchUtilities , theme  })=>{
        matchUtilities({
            "backdrop-opacity": (value)=>{
                return {
                    "--tw-backdrop-opacity": `opacity(${value})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": cssBackdropFilterValue
                };
            }
        }, {
            values: theme("backdropOpacity")
        });
    },
    backdropSaturate: ({ matchUtilities , theme  })=>{
        matchUtilities({
            "backdrop-saturate": (value)=>{
                return {
                    "--tw-backdrop-saturate": `saturate(${value})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": cssBackdropFilterValue
                };
            }
        }, {
            values: theme("backdropSaturate")
        });
    },
    backdropSepia: ({ matchUtilities , theme  })=>{
        matchUtilities({
            "backdrop-sepia": (value)=>{
                return {
                    "--tw-backdrop-sepia": `sepia(${value})`,
                    "@defaults backdrop-filter": {},
                    "backdrop-filter": cssBackdropFilterValue
                };
            }
        }, {
            values: theme("backdropSepia")
        });
    },
    backdropFilter: ({ addDefaults , addUtilities  })=>{
        addDefaults("backdrop-filter", {
            "--tw-backdrop-blur": " ",
            "--tw-backdrop-brightness": " ",
            "--tw-backdrop-contrast": " ",
            "--tw-backdrop-grayscale": " ",
            "--tw-backdrop-hue-rotate": " ",
            "--tw-backdrop-invert": " ",
            "--tw-backdrop-opacity": " ",
            "--tw-backdrop-saturate": " ",
            "--tw-backdrop-sepia": " "
        });
        addUtilities({
            ".backdrop-filter": {
                "@defaults backdrop-filter": {},
                "backdrop-filter": cssBackdropFilterValue
            },
            ".backdrop-filter-none": {
                "backdrop-filter": "none"
            }
        });
    },
    transitionProperty: ({ matchUtilities , theme  })=>{
        let defaultTimingFunction = theme("transitionTimingFunction.DEFAULT");
        let defaultDuration = theme("transitionDuration.DEFAULT");
        matchUtilities({
            transition: (value)=>{
                return {
                    "transition-property": value,
                    ...value === "none" ? {} : {
                        "transition-timing-function": defaultTimingFunction,
                        "transition-duration": defaultDuration
                    }
                };
            }
        }, {
            values: theme("transitionProperty")
        });
    },
    transitionDelay: (0, _createUtilityPlugin.default)("transitionDelay", [
        [
            "delay",
            [
                "transitionDelay"
            ]
        ]
    ]),
    transitionDuration: (0, _createUtilityPlugin.default)("transitionDuration", [
        [
            "duration",
            [
                "transitionDuration"
            ]
        ]
    ], {
        filterDefault: true
    }),
    transitionTimingFunction: (0, _createUtilityPlugin.default)("transitionTimingFunction", [
        [
            "ease",
            [
                "transitionTimingFunction"
            ]
        ]
    ], {
        filterDefault: true
    }),
    willChange: (0, _createUtilityPlugin.default)("willChange", [
        [
            "will-change",
            [
                "will-change"
            ]
        ]
    ]),
    content: (0, _createUtilityPlugin.default)("content", [
        [
            "content",
            [
                "--tw-content",
                [
                    "content",
                    "var(--tw-content)"
                ]
            ]
        ]
    ])
};


/***/ }),

/***/ 90:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    flagEnabled: ()=>flagEnabled,
    issueFlagNotices: ()=>issueFlagNotices,
    default: ()=>_default
});
const _picocolors = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(37023));
const _log = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(64368));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let defaults = {
    optimizeUniversalDefaults: false,
    generalizedModifiers: true
};
let featureFlags = {
    future: [
        "hoverOnlyWhenSupported",
        "respectDefaultRingColorOpacity",
        "disableColorOpacityUtilitiesByDefault",
        "relativeContentPathsByDefault"
    ],
    experimental: [
        "optimizeUniversalDefaults",
        "generalizedModifiers"
    ]
};
function flagEnabled(config, flag) {
    if (featureFlags.future.includes(flag)) {
        var _config_future;
        var _config_future_flag, _ref;
        return config.future === "all" || ((_ref = (_config_future_flag = config === null || config === void 0 ? void 0 : (_config_future = config.future) === null || _config_future === void 0 ? void 0 : _config_future[flag]) !== null && _config_future_flag !== void 0 ? _config_future_flag : defaults[flag]) !== null && _ref !== void 0 ? _ref : false);
    }
    if (featureFlags.experimental.includes(flag)) {
        var _config_experimental;
        var _config_experimental_flag, _ref1;
        return config.experimental === "all" || ((_ref1 = (_config_experimental_flag = config === null || config === void 0 ? void 0 : (_config_experimental = config.experimental) === null || _config_experimental === void 0 ? void 0 : _config_experimental[flag]) !== null && _config_experimental_flag !== void 0 ? _config_experimental_flag : defaults[flag]) !== null && _ref1 !== void 0 ? _ref1 : false);
    }
    return false;
}
function experimentalFlagsEnabled(config) {
    if (config.experimental === "all") {
        return featureFlags.experimental;
    }
    var _config_experimental;
    return Object.keys((_config_experimental = config === null || config === void 0 ? void 0 : config.experimental) !== null && _config_experimental !== void 0 ? _config_experimental : {}).filter((flag)=>featureFlags.experimental.includes(flag) && config.experimental[flag]);
}
function issueFlagNotices(config) {
    if (process.env.JEST_WORKER_ID !== undefined) {
        return;
    }
    if (experimentalFlagsEnabled(config).length > 0) {
        let changes = experimentalFlagsEnabled(config).map((s)=>_picocolors.default.yellow(s)).join(", ");
        _log.default.warn("experimental-flags-enabled", [
            `You have enabled experimental features: ${changes}`,
            "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
        ]);
    }
}
const _default = featureFlags;


/***/ }),

/***/ 17483:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

if (process.env.OXIDE) {
    module.exports = __nccwpck_require__(57885);
} else {
    module.exports = __nccwpck_require__(68805);
}


/***/ }),

/***/ 21939:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "hasContentChanged", ({
    enumerable: true,
    get: ()=>hasContentChanged
}));
const _crypto = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(6113));
const _sharedState = /*#__PURE__*/ _interopRequireWildcard(__nccwpck_require__(74035));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * Calculate the hash of a string.
 *
 * This doesn't need to be cryptographically secure or
 * anything like that since it's used only to detect
 * when the CSS changes to invalidate the context.
 *
 * This is wrapped in a try/catch because it's really dependent
 * on how Node itself is build and the environment and OpenSSL
 * version / build that is installed on the user's machine.
 *
 * Based on the environment this can just outright fail.
 *
 * See https://github.com/nodejs/node/issues/40455
 *
 * @param {string} str
 */ function getHash(str) {
    try {
        return _crypto.default.createHash("md5").update(str, "utf-8").digest("binary");
    } catch (err) {
        return "";
    }
}
function hasContentChanged(sourcePath, root) {
    let css = root.toString();
    // We only care about files with @tailwind directives
    // Other files use an existing context
    if (!css.includes("@tailwind")) {
        return false;
    }
    let existingHash = _sharedState.sourceHashMap.get(sourcePath);
    let rootHash = getHash(css);
    let didChange = existingHash !== rootHash;
    _sharedState.sourceHashMap.set(sourcePath, rootHash);
    return didChange;
}


/***/ }),

/***/ 80208:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>collapseAdjacentRules
}));
let comparisonMap = {
    atrule: [
        "name",
        "params"
    ],
    rule: [
        "selector"
    ]
};
let types = new Set(Object.keys(comparisonMap));
function collapseAdjacentRules() {
    function collapseRulesIn(root) {
        let currentRule = null;
        root.each((node)=>{
            if (!types.has(node.type)) {
                currentRule = null;
                return;
            }
            if (currentRule === null) {
                currentRule = node;
                return;
            }
            let properties = comparisonMap[node.type];
            var _node_property, _currentRule_property;
            if (node.type === "atrule" && node.name === "font-face") {
                currentRule = node;
            } else if (properties.every((property)=>((_node_property = node[property]) !== null && _node_property !== void 0 ? _node_property : "").replace(/\s+/g, " ") === ((_currentRule_property = currentRule[property]) !== null && _currentRule_property !== void 0 ? _currentRule_property : "").replace(/\s+/g, " "))) {
                // An AtRule may not have children (for example if we encounter duplicate @import url(…) rules)
                if (node.nodes) {
                    currentRule.append(node.nodes);
                }
                node.remove();
            } else {
                currentRule = node;
            }
        });
        // After we've collapsed adjacent rules & at-rules, we need to collapse
        // adjacent rules & at-rules that are children of at-rules.
        // We do not care about nesting rules because Tailwind CSS
        // explicitly does not handle rule nesting on its own as
        // the user is expected to use a nesting plugin
        root.each((node)=>{
            if (node.type === "atrule") {
                collapseRulesIn(node);
            }
        });
    }
    return (root)=>{
        collapseRulesIn(root);
    };
}


/***/ }),

/***/ 33155:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>collapseDuplicateDeclarations
}));
function collapseDuplicateDeclarations() {
    return (root)=>{
        root.walkRules((node)=>{
            let seen = new Map();
            let droppable = new Set([]);
            let byProperty = new Map();
            node.walkDecls((decl)=>{
                // This could happen if we have nested selectors. In that case the
                // parent will loop over all its declarations but also the declarations
                // of nested rules. With this we ensure that we are shallowly checking
                // declarations.
                if (decl.parent !== node) {
                    return;
                }
                if (seen.has(decl.prop)) {
                    // Exact same value as what we have seen so far
                    if (seen.get(decl.prop).value === decl.value) {
                        // Keep the last one, drop the one we've seen so far
                        droppable.add(seen.get(decl.prop));
                        // Override the existing one with the new value. This is necessary
                        // so that if we happen to have more than one declaration with the
                        // same value, that we keep removing the previous one. Otherwise we
                        // will only remove the *first* one.
                        seen.set(decl.prop, decl);
                        return;
                    }
                    // Not the same value, so we need to check if we can merge it so
                    // let's collect it first.
                    if (!byProperty.has(decl.prop)) {
                        byProperty.set(decl.prop, new Set());
                    }
                    byProperty.get(decl.prop).add(seen.get(decl.prop));
                    byProperty.get(decl.prop).add(decl);
                }
                seen.set(decl.prop, decl);
            });
            // Drop all the duplicate declarations with the exact same value we've
            // already seen so far.
            for (let decl of droppable){
                decl.remove();
            }
            // Analyze the declarations based on its unit, drop all the declarations
            // with the same unit but the last one in the list.
            for (let declarations of byProperty.values()){
                let byUnit = new Map();
                for (let decl1 of declarations){
                    let unit = resolveUnit(decl1.value);
                    if (unit === null) {
                        continue;
                    }
                    if (!byUnit.has(unit)) {
                        byUnit.set(unit, new Set());
                    }
                    byUnit.get(unit).add(decl1);
                }
                for (let declarations1 of byUnit.values()){
                    // Get all but the last one
                    let removableDeclarations = Array.from(declarations1).slice(0, -1);
                    for (let decl2 of removableDeclarations){
                        decl2.remove();
                    }
                }
            }
        });
    };
}
let UNITLESS_NUMBER = Symbol("unitless-number");
function resolveUnit(input) {
    let result = /^-?\d*.?\d+([\w%]+)?$/g.exec(input);
    if (result) {
        var _result_;
        return (_result_ = result[1]) !== null && _result_ !== void 0 ? _result_ : UNITLESS_NUMBER;
    }
    return null;
}


/***/ }),

/***/ 63890:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
// @ts-check

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    parseCandidateFiles: ()=>parseCandidateFiles,
    resolvedChangedContent: ()=>resolvedChangedContent
});
const _fs = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(57147));
const _path = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(71017));
const _isGlob = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(34466));
const _fastGlob = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(43664));
const _normalizePath = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(55388));
const _parseGlob = __nccwpck_require__(88258);
const _sharedState = __nccwpck_require__(74035);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function parseCandidateFiles(context, tailwindConfig) {
    let files = tailwindConfig.content.files;
    // Normalize the file globs
    files = files.filter((filePath)=>typeof filePath === "string");
    files = files.map(_normalizePath.default);
    // Split into included and excluded globs
    let tasks = _fastGlob.default.generateTasks(files);
    /** @type {ContentPath[]} */ let included = [];
    /** @type {ContentPath[]} */ let excluded = [];
    for (const task of tasks){
        included.push(...task.positive.map((filePath)=>parseFilePath(filePath, false)));
        excluded.push(...task.negative.map((filePath)=>parseFilePath(filePath, true)));
    }
    let paths = [
        ...included,
        ...excluded
    ];
    // Resolve paths relative to the config file or cwd
    paths = resolveRelativePaths(context, paths);
    // Resolve symlinks if possible
    paths = paths.flatMap(resolvePathSymlinks);
    // Update cached patterns
    paths = paths.map(resolveGlobPattern);
    return paths;
}
/**
 *
 * @param {string} filePath
 * @param {boolean} ignore
 * @returns {ContentPath}
 */ function parseFilePath(filePath, ignore) {
    let contentPath = {
        original: filePath,
        base: filePath,
        ignore,
        pattern: filePath,
        glob: null
    };
    if ((0, _isGlob.default)(filePath)) {
        Object.assign(contentPath, (0, _parseGlob.parseGlob)(filePath));
    }
    return contentPath;
}
/**
 *
 * @param {ContentPath} contentPath
 * @returns {ContentPath}
 */ function resolveGlobPattern(contentPath) {
    // This is required for Windows support to properly pick up Glob paths.
    // Afaik, this technically shouldn't be needed but there's probably
    // some internal, direct path matching with a normalized path in
    // a package which can't handle mixed directory separators
    let base = (0, _normalizePath.default)(contentPath.base);
    // If the user's file path contains any special characters (like parens) for instance fast-glob
    // is like "OOOH SHINY" and treats them as such. So we have to escape the base path to fix this
    base = _fastGlob.default.escapePath(base);
    contentPath.pattern = contentPath.glob ? `${base}/${contentPath.glob}` : base;
    contentPath.pattern = contentPath.ignore ? `!${contentPath.pattern}` : contentPath.pattern;
    return contentPath;
}
/**
 * Resolve each path relative to the config file (when possible) if the experimental flag is enabled
 * Otherwise, resolve relative to the current working directory
 *
 * @param {any} context
 * @param {ContentPath[]} contentPaths
 * @returns {ContentPath[]}
 */ function resolveRelativePaths(context, contentPaths) {
    let resolveFrom = [];
    // Resolve base paths relative to the config file (when possible) if the experimental flag is enabled
    if (context.userConfigPath && context.tailwindConfig.content.relative) {
        resolveFrom = [
            _path.default.dirname(context.userConfigPath)
        ];
    }
    return contentPaths.map((contentPath)=>{
        contentPath.base = _path.default.resolve(...resolveFrom, contentPath.base);
        return contentPath;
    });
}
/**
 * Resolve the symlink for the base directory / file in each path
 * These are added as additional dependencies to watch for changes because
 * some tools (like webpack) will only watch the actual file or directory
 * but not the symlink itself even in projects that use monorepos.
 *
 * @param {ContentPath} contentPath
 * @returns {ContentPath[]}
 */ function resolvePathSymlinks(contentPath) {
    let paths = [
        contentPath
    ];
    try {
        let resolvedPath = _fs.default.realpathSync(contentPath.base);
        if (resolvedPath !== contentPath.base) {
            paths.push({
                ...contentPath,
                base: resolvedPath
            });
        }
    } catch  {
    // TODO: log this?
    }
    return paths;
}
function resolvedChangedContent(context, candidateFiles, fileModifiedMap) {
    let changedContent = context.tailwindConfig.content.files.filter((item)=>typeof item.raw === "string").map(({ raw , extension ="html"  })=>({
            content: raw,
            extension
        }));
    let [changedFiles, mTimesToCommit] = resolveChangedFiles(candidateFiles, fileModifiedMap);
    for (let changedFile of changedFiles){
        let extension = _path.default.extname(changedFile).slice(1);
        changedContent.push({
            file: changedFile,
            extension
        });
    }
    return [
        changedContent,
        mTimesToCommit
    ];
}
/**
 *
 * @param {ContentPath[]} candidateFiles
 * @param {Map<string, number>} fileModifiedMap
 * @returns {[Set<string>, Map<string, number>]}
 */ function resolveChangedFiles(candidateFiles, fileModifiedMap) {
    let paths = candidateFiles.map((contentPath)=>contentPath.pattern);
    let mTimesToCommit = new Map();
    let changedFiles = new Set();
    _sharedState.env.DEBUG && console.time("Finding changed files");
    let files = _fastGlob.default.sync(paths, {
        absolute: true
    });
    for (let file of files){
        let prevModified = fileModifiedMap.get(file) || -Infinity;
        let modified = _fs.default.statSync(file).mtimeMs;
        if (modified > prevModified) {
            changedFiles.add(file);
            mTimesToCommit.set(file, modified);
        }
    }
    _sharedState.env.DEBUG && console.timeEnd("Finding changed files");
    return [
        changedFiles,
        mTimesToCommit
    ];
}


/***/ }),

/***/ 18902:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "defaultExtractor", ({
    enumerable: true,
    get: ()=>defaultExtractor
}));
const _featureFlags = __nccwpck_require__(90);
const _regex = /*#__PURE__*/ _interopRequireWildcard(__nccwpck_require__(8045));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function defaultExtractor(context) {
    let patterns = Array.from(buildRegExps(context));
    /**
   * @param {string} content
   */ return (content)=>{
        /** @type {(string|string)[]} */ let results = [];
        for (let pattern of patterns){
            var _content_match;
            results = [
                ...results,
                ...(_content_match = content.match(pattern)) !== null && _content_match !== void 0 ? _content_match : []
            ];
        }
        return results.filter((v)=>v !== undefined).map(clipAtBalancedParens);
    };
}
function* buildRegExps(context) {
    let separator = context.tailwindConfig.separator;
    let variantGroupingEnabled = (0, _featureFlags.flagEnabled)(context.tailwindConfig, "variantGrouping");
    let prefix = context.tailwindConfig.prefix !== "" ? _regex.optional(_regex.pattern([
        /-?/,
        _regex.escape(context.tailwindConfig.prefix)
    ])) : "";
    let utility = _regex.any([
        // Arbitrary properties (without square brackets)
        /\[[^\s:'"`]+:[^\s\[\]]+\]/,
        // Arbitrary properties with balanced square brackets
        // This is a targeted fix to continue to allow theme()
        // with square brackets to work in arbitrary properties
        // while fixing a problem with the regex matching too much
        /\[[^\s:'"`]+:[^\s]+?\[[^\s]+?\][^\s]+?\]/,
        // Utilities
        _regex.pattern([
            // Utility Name / Group Name
            /-?(?:\w+)/,
            // Normal/Arbitrary values
            _regex.optional(_regex.any([
                _regex.pattern([
                    // Arbitrary values
                    /-(?:\w+-)*\[[^\s:]+\]/,
                    // Not immediately followed by an `{[(`
                    /(?![{([]])/,
                    // optionally followed by an opacity modifier
                    /(?:\/[^\s'"`\\><$]*)?/
                ]),
                _regex.pattern([
                    // Arbitrary values
                    /-(?:\w+-)*\[[^\s]+\]/,
                    // Not immediately followed by an `{[(`
                    /(?![{([]])/,
                    // optionally followed by an opacity modifier
                    /(?:\/[^\s'"`\\$]*)?/
                ]),
                // Normal values w/o quotes — may include an opacity modifier
                /[-\/][^\s'"`\\$={><]*/
            ]))
        ])
    ]);
    let variantPatterns = [
        // Without quotes
        _regex.any([
            // This is here to provide special support for the `@` variant
            _regex.pattern([
                /@\[[^\s"'`]+\](\/[^\s"'`]+)?/,
                separator
            ]),
            _regex.pattern([
                /([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/,
                separator
            ]),
            _regex.pattern([
                /[^\s"'`\[\\]+/,
                separator
            ])
        ]),
        // With quotes allowed
        _regex.any([
            _regex.pattern([
                /([^\s"'`\[\\]+-)?\[[^\s`]+\]/,
                separator
            ]),
            _regex.pattern([
                /[^\s`\[\\]+/,
                separator
            ])
        ])
    ];
    for (const variantPattern of variantPatterns){
        yield _regex.pattern([
            // Variants
            "((?=((",
            variantPattern,
            ")+))\\2)?",
            // Important (optional)
            /!?/,
            prefix,
            variantGroupingEnabled ? _regex.any([
                // Or any of those things but grouped separated by commas
                _regex.pattern([
                    /\(/,
                    utility,
                    _regex.zeroOrMore([
                        /,/,
                        utility
                    ]),
                    /\)/
                ]),
                // Arbitrary properties, constrained utilities, arbitrary values, etc…
                utility
            ]) : utility
        ]);
    }
    // 5. Inner matches
    yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
}
// We want to capture any "special" characters
// AND the characters immediately following them (if there is one)
let SPECIALS = /([\[\]'"`])([^\[\]'"`])?/g;
let ALLOWED_CLASS_CHARACTERS = /[^"'`\s<>\]]+/;
/**
 * Clips a string ensuring that parentheses, quotes, etc… are balanced
 * Used for arbitrary values only
 *
 * We will go past the end of the balanced parens until we find a non-class character
 *
 * Depth matching behavior:
 * w-[calc(100%-theme('spacing[some_key][1.5]'))]']
 *   ┬    ┬          ┬┬       ┬        ┬┬   ┬┬┬┬┬┬┬
 *   1    2          3        4        34   3 210 END
 *   ╰────┴──────────┴────────┴────────┴┴───┴─┴┴┴
 *
 * @param {string} input
 */ function clipAtBalancedParens(input) {
    // We are care about this for arbitrary values
    if (!input.includes("-[")) {
        return input;
    }
    let depth = 0;
    let openStringTypes = [];
    // Find all parens, brackets, quotes, etc
    // Stop when we end at a balanced pair
    // This is naive and will treat mismatched parens as balanced
    // This shouldn't be a problem in practice though
    let matches = input.matchAll(SPECIALS);
    // We can't use lookbehind assertions because we have to support Safari
    // So, instead, we've emulated it using capture groups and we'll re-work the matches to accommodate
    matches = Array.from(matches).flatMap((match)=>{
        const [, ...groups] = match;
        return groups.map((group, idx)=>Object.assign([], match, {
                index: match.index + idx,
                0: group
            }));
    });
    for (let match of matches){
        let char = match[0];
        let inStringType = openStringTypes[openStringTypes.length - 1];
        if (char === inStringType) {
            openStringTypes.pop();
        } else if (char === "'" || char === '"' || char === "`") {
            openStringTypes.push(char);
        }
        if (inStringType) {
            continue;
        } else if (char === "[") {
            depth++;
            continue;
        } else if (char === "]") {
            depth--;
            continue;
        }
        // We've gone one character past the point where we should stop
        // This means that there was an extra closing `]`
        // We'll clip to just before it
        if (depth < 0) {
            return input.substring(0, match.index - 1);
        }
        // We've finished balancing the brackets but there still may be characters that can be included
        // For example in the class `text-[#336699]/[.35]`
        // The depth goes to `0` at the closing `]` but goes up again at the `[`
        // If we're at zero and encounter a non-class character then we clip the class there
        if (depth === 0 && !ALLOWED_CLASS_CHARACTERS.test(char)) {
            return input.substring(0, match.index);
        }
    }
    return input;
} // Regular utilities
 // {{modifier}:}*{namespace}{-{suffix}}*{/{opacityModifier}}?
 // Arbitrary values
 // {{modifier}:}*{namespace}-[{arbitraryValue}]{/{opacityModifier}}?
 // arbitraryValue: no whitespace, balanced quotes unless within quotes, balanced brackets unless within quotes
 // Arbitrary properties
 // {{modifier}:}*[{validCssPropertyName}:{arbitraryValue}]


/***/ }),

/***/ 59015:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>_default
}));
function isRoot(node) {
    return node.type === "root";
}
function isAtLayer(node) {
    return node.type === "atrule" && node.name === "layer";
}
function _default(_context) {
    return (root, result)=>{
        let found = false;
        root.walkAtRules("tailwind", (node)=>{
            if (found) return false;
            if (node.parent && !(isRoot(node.parent) || isAtLayer(node.parent))) {
                found = true;
                node.warn(result, [
                    "Nested @tailwind rules were detected, but are not supported.",
                    "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix",
                    "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"
                ].join("\n"));
                return false;
            }
        });
        root.walkRules((rule)=>{
            if (found) return false;
            rule.walkRules((nestedRule)=>{
                found = true;
                nestedRule.warn(result, [
                    "Nested CSS was detected, but CSS nesting has not been configured correctly.",
                    "Please enable a CSS nesting plugin *before* Tailwind in your configuration.",
                    "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"
                ].join("\n"));
                return false;
            });
        });
    };
}


/***/ }),

/***/ 64717:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>_default
}));
const _dlv = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(34420));
const _didyoumean = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(15150));
const _transformThemeValue = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(71985));
const _postcssValueParser = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(19285));
const _normalizeScreens = __nccwpck_require__(68617);
const _buildMediaQuery = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(11321));
const _toPath = __nccwpck_require__(11402);
const _withAlphaVariable = __nccwpck_require__(4195);
const _pluginUtils = __nccwpck_require__(89244);
const _log = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(64368));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function isObject(input) {
    return typeof input === "object" && input !== null;
}
function findClosestExistingPath(theme, path) {
    let parts = (0, _toPath.toPath)(path);
    do {
        parts.pop();
        if ((0, _dlv.default)(theme, parts) !== undefined) break;
    }while (parts.length);
    return parts.length ? parts : undefined;
}
function pathToString(path) {
    if (typeof path === "string") return path;
    return path.reduce((acc, cur, i)=>{
        if (cur.includes(".")) return `${acc}[${cur}]`;
        return i === 0 ? cur : `${acc}.${cur}`;
    }, "");
}
function list(items) {
    return items.map((key)=>`'${key}'`).join(", ");
}
function listKeys(obj) {
    return list(Object.keys(obj));
}
function validatePath(config, path, defaultValue, themeOpts = {}) {
    const pathString = Array.isArray(path) ? pathToString(path) : path.replace(/^['"]+|['"]+$/g, "");
    const pathSegments = Array.isArray(path) ? path : (0, _toPath.toPath)(pathString);
    const value = (0, _dlv.default)(config.theme, pathSegments, defaultValue);
    if (value === undefined) {
        let error = `'${pathString}' does not exist in your theme config.`;
        const parentSegments = pathSegments.slice(0, -1);
        const parentValue = (0, _dlv.default)(config.theme, parentSegments);
        if (isObject(parentValue)) {
            const validKeys = Object.keys(parentValue).filter((key)=>validatePath(config, [
                    ...parentSegments,
                    key
                ]).isValid);
            const suggestion = (0, _didyoumean.default)(pathSegments[pathSegments.length - 1], validKeys);
            if (suggestion) {
                error += ` Did you mean '${pathToString([
                    ...parentSegments,
                    suggestion
                ])}'?`;
            } else if (validKeys.length > 0) {
                error += ` '${pathToString(parentSegments)}' has the following valid keys: ${list(validKeys)}`;
            }
        } else {
            const closestPath = findClosestExistingPath(config.theme, pathString);
            if (closestPath) {
                const closestValue = (0, _dlv.default)(config.theme, closestPath);
                if (isObject(closestValue)) {
                    error += ` '${pathToString(closestPath)}' has the following keys: ${listKeys(closestValue)}`;
                } else {
                    error += ` '${pathToString(closestPath)}' is not an object.`;
                }
            } else {
                error += ` Your theme has the following top-level keys: ${listKeys(config.theme)}`;
            }
        }
        return {
            isValid: false,
            error
        };
    }
    if (!(typeof value === "string" || typeof value === "number" || typeof value === "function" || value instanceof String || value instanceof Number || Array.isArray(value))) {
        let error1 = `'${pathString}' was found but does not resolve to a string.`;
        if (isObject(value)) {
            let validKeys1 = Object.keys(value).filter((key)=>validatePath(config, [
                    ...pathSegments,
                    key
                ]).isValid);
            if (validKeys1.length) {
                error1 += ` Did you mean something like '${pathToString([
                    ...pathSegments,
                    validKeys1[0]
                ])}'?`;
            }
        }
        return {
            isValid: false,
            error: error1
        };
    }
    const [themeSection] = pathSegments;
    return {
        isValid: true,
        value: (0, _transformThemeValue.default)(themeSection)(value, themeOpts)
    };
}
function extractArgs(node, vNodes, functions) {
    vNodes = vNodes.map((vNode)=>resolveVNode(node, vNode, functions));
    let args = [
        ""
    ];
    for (let vNode of vNodes){
        if (vNode.type === "div" && vNode.value === ",") {
            args.push("");
        } else {
            args[args.length - 1] += _postcssValueParser.default.stringify(vNode);
        }
    }
    return args;
}
function resolveVNode(node, vNode, functions) {
    if (vNode.type === "function" && functions[vNode.value] !== undefined) {
        let args = extractArgs(node, vNode.nodes, functions);
        vNode.type = "word";
        vNode.value = functions[vNode.value](node, ...args);
    }
    return vNode;
}
function resolveFunctions(node, input, functions) {
    return (0, _postcssValueParser.default)(input).walk((vNode)=>{
        resolveVNode(node, vNode, functions);
    }).toString();
}
let nodeTypePropertyMap = {
    atrule: "params",
    decl: "value"
};
/**
 * @param {string} path
 * @returns {Iterable<[path: string, alpha: string|undefined]>}
 */ function* toPaths(path) {
    // Strip quotes from beginning and end of string
    // This allows the alpha value to be present inside of quotes
    path = path.replace(/^['"]+|['"]+$/g, "");
    let matches = path.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/);
    let alpha = undefined;
    yield [
        path,
        undefined
    ];
    if (matches) {
        path = matches[1];
        alpha = matches[2];
        yield [
            path,
            alpha
        ];
    }
}
/**
 *
 * @param {any} config
 * @param {string} path
 * @param {any} defaultValue
 */ function resolvePath(config, path, defaultValue) {
    const results = Array.from(toPaths(path)).map(([path, alpha])=>{
        return Object.assign(validatePath(config, path, defaultValue, {
            opacityValue: alpha
        }), {
            resolvedPath: path,
            alpha
        });
    });
    var _results_find;
    return (_results_find = results.find((result)=>result.isValid)) !== null && _results_find !== void 0 ? _results_find : results[0];
}
function _default(context) {
    let config = context.tailwindConfig;
    let functions = {
        theme: (node, path, ...defaultValue)=>{
            let { isValid , value , error , alpha  } = resolvePath(config, path, defaultValue.length ? defaultValue : undefined);
            if (!isValid) {
                var _parentNode_raws_tailwind;
                let parentNode = node.parent;
                let candidate = (_parentNode_raws_tailwind = parentNode === null || parentNode === void 0 ? void 0 : parentNode.raws.tailwind) === null || _parentNode_raws_tailwind === void 0 ? void 0 : _parentNode_raws_tailwind.candidate;
                if (parentNode && candidate !== undefined) {
                    // Remove this utility from any caches
                    context.markInvalidUtilityNode(parentNode);
                    // Remove the CSS node from the markup
                    parentNode.remove();
                    // Show a warning
                    _log.default.warn("invalid-theme-key-in-class", [
                        `The utility \`${candidate}\` contains an invalid theme value and was not generated.`
                    ]);
                    return;
                }
                throw node.error(error);
            }
            let maybeColor = (0, _pluginUtils.parseColorFormat)(value);
            let isColorFunction = maybeColor !== undefined && typeof maybeColor === "function";
            if (alpha !== undefined || isColorFunction) {
                if (alpha === undefined) {
                    alpha = 1.0;
                }
                value = (0, _withAlphaVariable.withAlphaValue)(maybeColor, alpha, maybeColor);
            }
            return value;
        },
        screen: (node, screen)=>{
            screen = screen.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
            let screens = (0, _normalizeScreens.normalizeScreens)(config.theme.screens);
            let screenDefinition = screens.find(({ name  })=>name === screen);
            if (!screenDefinition) {
                throw node.error(`The '${screen}' screen does not exist in your theme.`);
            }
            return (0, _buildMediaQuery.default)(screenDefinition);
        }
    };
    return (root)=>{
        root.walk((node)=>{
            let property = nodeTypePropertyMap[node.type];
            if (property === undefined) {
                return;
            }
            node[property] = resolveFunctions(node, node[property], functions);
        });
    };
}


/***/ }),

/***/ 13464:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>expandApplyAtRules
}));
const _postcss = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(77001));
const _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(32997));
const _generateRules = __nccwpck_require__(78523);
const _escapeClassName = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(11898));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/** @typedef {Map<string, [any, import('postcss').Rule[]]>} ApplyCache */ function extractClasses(node) {
    /** @type {Map<string, Set<string>>} */ let groups = new Map();
    let container = _postcss.default.root({
        nodes: [
            node.clone()
        ]
    });
    container.walkRules((rule)=>{
        (0, _postcssSelectorParser.default)((selectors)=>{
            selectors.walkClasses((classSelector)=>{
                let parentSelector = classSelector.parent.toString();
                let classes = groups.get(parentSelector);
                if (!classes) {
                    groups.set(parentSelector, classes = new Set());
                }
                classes.add(classSelector.value);
            });
        }).processSync(rule.selector);
    });
    let normalizedGroups = Array.from(groups.values(), (classes)=>Array.from(classes));
    let classes = normalizedGroups.flat();
    return Object.assign(classes, {
        groups: normalizedGroups
    });
}
let selectorExtractor = (0, _postcssSelectorParser.default)();
/**
 * @param {string} ruleSelectors
 */ function extractSelectors(ruleSelectors) {
    return selectorExtractor.astSync(ruleSelectors);
}
function extractBaseCandidates(candidates, separator) {
    let baseClasses = new Set();
    for (let candidate of candidates){
        baseClasses.add(candidate.split(separator).pop());
    }
    return Array.from(baseClasses);
}
function prefix(context, selector) {
    let prefix = context.tailwindConfig.prefix;
    return typeof prefix === "function" ? prefix(selector) : prefix + selector;
}
function* pathToRoot(node) {
    yield node;
    while(node.parent){
        yield node.parent;
        node = node.parent;
    }
}
/**
 * Only clone the node itself and not its children
 *
 * @param {*} node
 * @param {*} overrides
 * @returns
 */ function shallowClone(node, overrides = {}) {
    let children = node.nodes;
    node.nodes = [];
    let tmp = node.clone(overrides);
    node.nodes = children;
    return tmp;
}
/**
 * Clone just the nodes all the way to the top that are required to represent
 * this singular rule in the tree.
 *
 * For example, if we have CSS like this:
 * ```css
 * @media (min-width: 768px) {
 *   @supports (display: grid) {
 *     .foo {
 *       display: grid;
 *       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
 *     }
 *   }
 *
 *   @supports (backdrop-filter: blur(1px)) {
 *     .bar {
 *       backdrop-filter: blur(1px);
 *     }
 *   }
 *
 *   .baz {
 *     color: orange;
 *   }
 * }
 * ```
 *
 * And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:
 *
 * ```css
 * @media (min-width: 768px) {
 *   @supports (backdrop-filter: blur(1px)) {
 *     .bar {
 *       backdrop-filter: blur(1px);
 *     }
 *   }
 * }
 * ```
 *
 * @param {import('postcss').Node} node
 */ function nestedClone(node) {
    for (let parent of pathToRoot(node)){
        if (node === parent) {
            continue;
        }
        if (parent.type === "root") {
            break;
        }
        node = shallowClone(parent, {
            nodes: [
                node
            ]
        });
    }
    return node;
}
/**
 * @param {import('postcss').Root} root
 */ function buildLocalApplyCache(root, context) {
    /** @type {ApplyCache} */ let cache = new Map();
    root.walkRules((rule)=>{
        // Ignore rules generated by Tailwind
        for (let node of pathToRoot(rule)){
            var _node_raws_tailwind;
            if (((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.layer) !== undefined) {
                return;
            }
        }
        // Clone what's required to represent this singular rule in the tree
        let container = nestedClone(rule);
        let sort = context.offsets.create("user");
        for (let className of extractClasses(rule)){
            let list = cache.get(className) || [];
            cache.set(className, list);
            list.push([
                {
                    layer: "user",
                    sort,
                    important: false
                },
                container
            ]);
        }
    });
    return cache;
}
/**
 * @returns {ApplyCache}
 */ function buildApplyCache(applyCandidates, context) {
    for (let candidate of applyCandidates){
        if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {
            continue;
        }
        if (context.classCache.has(candidate)) {
            context.applyClassCache.set(candidate, context.classCache.get(candidate).map(([meta, rule])=>[
                    meta,
                    rule.clone()
                ]));
            continue;
        }
        let matches = Array.from((0, _generateRules.resolveMatches)(candidate, context));
        if (matches.length === 0) {
            context.notClassCache.add(candidate);
            continue;
        }
        context.applyClassCache.set(candidate, matches);
    }
    return context.applyClassCache;
}
/**
 * Build a cache only when it's first used
 *
 * @param {() => ApplyCache} buildCacheFn
 * @returns {ApplyCache}
 */ function lazyCache(buildCacheFn) {
    let cache = null;
    return {
        get: (name)=>{
            cache = cache || buildCacheFn();
            return cache.get(name);
        },
        has: (name)=>{
            cache = cache || buildCacheFn();
            return cache.has(name);
        }
    };
}
/**
 * Take a series of multiple caches and merge
 * them so they act like one large cache
 *
 * @param {ApplyCache[]} caches
 * @returns {ApplyCache}
 */ function combineCaches(caches) {
    return {
        get: (name)=>caches.flatMap((cache)=>cache.get(name) || []),
        has: (name)=>caches.some((cache)=>cache.has(name))
    };
}
function extractApplyCandidates(params) {
    let candidates = params.split(/[\s\t\n]+/g);
    if (candidates[candidates.length - 1] === "!important") {
        return [
            candidates.slice(0, -1),
            true
        ];
    }
    return [
        candidates,
        false
    ];
}
function processApply(root, context, localCache) {
    let applyCandidates = new Set();
    // Collect all @apply rules and candidates
    let applies = [];
    root.walkAtRules("apply", (rule)=>{
        let [candidates] = extractApplyCandidates(rule.params);
        for (let util of candidates){
            applyCandidates.add(util);
        }
        applies.push(rule);
    });
    // Start the @apply process if we have rules with @apply in them
    if (applies.length === 0) {
        return;
    }
    // Fill up some caches!
    let applyClassCache = combineCaches([
        localCache,
        buildApplyCache(applyCandidates, context)
    ]);
    /**
   * When we have an apply like this:
   *
   * .abc {
   *    @apply hover:font-bold;
   * }
   *
   * What we essentially will do is resolve to this:
   *
   * .abc {
   *    @apply .hover\:font-bold:hover {
   *      font-weight: 500;
   *    }
   * }
   *
   * Notice that the to-be-applied class is `.hover\:font-bold:hover` and that the utility candidate was `hover:font-bold`.
   * What happens in this function is that we prepend a `.` and escape the candidate.
   * This will result in `.hover\:font-bold`
   * Which means that we can replace `.hover\:font-bold` with `.abc` in `.hover\:font-bold:hover` resulting in `.abc:hover`
   *
   * @param {string} selector
   * @param {string} utilitySelectors
   * @param {string} candidate
   */ function replaceSelector(selector, utilitySelectors, candidate) {
        let selectorList = extractSelectors(selector);
        let utilitySelectorsList = extractSelectors(utilitySelectors);
        let candidateList = extractSelectors(`.${(0, _escapeClassName.default)(candidate)}`);
        let candidateClass = candidateList.nodes[0].nodes[0];
        selectorList.each((sel)=>{
            /** @type {Set<import('postcss-selector-parser').Selector>} */ let replaced = new Set();
            utilitySelectorsList.each((utilitySelector)=>{
                let hasReplaced = false;
                utilitySelector = utilitySelector.clone();
                utilitySelector.walkClasses((node)=>{
                    if (node.value !== candidateClass.value) {
                        return;
                    }
                    // Don't replace multiple instances of the same class
                    // This is theoretically correct but only partially
                    // We'd need to generate every possible permutation of the replacement
                    // For example with `.foo + .foo { … }` and `section { @apply foo; }`
                    // We'd need to generate all of these:
                    // - `.foo + .foo`
                    // - `.foo + section`
                    // - `section + .foo`
                    // - `section + section`
                    if (hasReplaced) {
                        return;
                    }
                    // Since you can only `@apply` class names this is sufficient
                    // We want to replace the matched class name with the selector the user is using
                    // Ex: Replace `.text-blue-500` with `.foo.bar:is(.something-cool)`
                    node.replaceWith(...sel.nodes.map((node)=>node.clone()));
                    // Record that we did something and we want to use this new selector
                    replaced.add(utilitySelector);
                    hasReplaced = true;
                });
            });
            // Sort tag names before class names (but only sort each group (separated by a combinator)
            // separately and not in total)
            // This happens when replacing `.bar` in `.foo.bar` with a tag like `section`
            for (let sel1 of replaced){
                let groups = [
                    []
                ];
                for (let node of sel1.nodes){
                    if (node.type === "combinator") {
                        groups.push(node);
                        groups.push([]);
                    } else {
                        let last = groups[groups.length - 1];
                        last.push(node);
                    }
                }
                sel1.nodes = [];
                for (let group of groups){
                    if (Array.isArray(group)) {
                        group.sort((a, b)=>{
                            if (a.type === "tag" && b.type === "class") {
                                return -1;
                            } else if (a.type === "class" && b.type === "tag") {
                                return 1;
                            } else if (a.type === "class" && b.type === "pseudo" && b.value.startsWith("::")) {
                                return -1;
                            } else if (a.type === "pseudo" && a.value.startsWith("::") && b.type === "class") {
                                return 1;
                            }
                            return 0;
                        });
                    }
                    sel1.nodes = sel1.nodes.concat(group);
                }
            }
            sel.replaceWith(...replaced);
        });
        return selectorList.toString();
    }
    let perParentApplies = new Map();
    // Collect all apply candidates and their rules
    for (let apply of applies){
        let [candidates] = perParentApplies.get(apply.parent) || [
            [],
            apply.source
        ];
        perParentApplies.set(apply.parent, [
            candidates,
            apply.source
        ]);
        let [applyCandidates1, important] = extractApplyCandidates(apply.params);
        if (apply.parent.type === "atrule") {
            if (apply.parent.name === "screen") {
                let screenType = apply.parent.params;
                throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates1.map((c)=>`${screenType}:${c}`).join(" ")} instead.`);
            }
            throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);
        }
        for (let applyCandidate of applyCandidates1){
            if ([
                prefix(context, "group"),
                prefix(context, "peer")
            ].includes(applyCandidate)) {
                // TODO: Link to specific documentation page with error code.
                throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);
            }
            if (!applyClassCache.has(applyCandidate)) {
                throw apply.error(`The \`${applyCandidate}\` class does not exist. If \`${applyCandidate}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
            }
            let rules = applyClassCache.get(applyCandidate);
            candidates.push([
                applyCandidate,
                important,
                rules
            ]);
        }
    }
    for (let [parent, [candidates1, atApplySource]] of perParentApplies){
        let siblings = [];
        for (let [applyCandidate1, important1, rules1] of candidates1){
            let potentialApplyCandidates = [
                applyCandidate1,
                ...extractBaseCandidates([
                    applyCandidate1
                ], context.tailwindConfig.separator)
            ];
            for (let [meta, node] of rules1){
                let parentClasses = extractClasses(parent);
                let nodeClasses = extractClasses(node);
                // When we encounter a rule like `.dark .a, .b { … }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`
                // So we've split them into groups
                nodeClasses = nodeClasses.groups.filter((classList)=>classList.some((className)=>potentialApplyCandidates.includes(className))).flat();
                // Add base utility classes from the @apply node to the list of
                // classes to check whether it intersects and therefore results in a
                // circular dependency or not.
                //
                // E.g.:
                // .foo {
                //   @apply hover:a; // This applies "a" but with a modifier
                // }
                //
                // We only have to do that with base classes of the `node`, not of the `parent`
                // E.g.:
                // .hover\:foo {
                //   @apply bar;
                // }
                // .bar {
                //   @apply foo;
                // }
                //
                // This should not result in a circular dependency because we are
                // just applying `.foo` and the rule above is `.hover\:foo` which is
                // unrelated. However, if we were to apply `hover:foo` then we _did_
                // have to include this one.
                nodeClasses = nodeClasses.concat(extractBaseCandidates(nodeClasses, context.tailwindConfig.separator));
                let intersects = parentClasses.some((selector)=>nodeClasses.includes(selector));
                if (intersects) {
                    throw node.error(`You cannot \`@apply\` the \`${applyCandidate1}\` utility here because it creates a circular dependency.`);
                }
                let root1 = _postcss.default.root({
                    nodes: [
                        node.clone()
                    ]
                });
                // Make sure every node in the entire tree points back at the @apply rule that generated it
                root1.walk((node)=>{
                    node.source = atApplySource;
                });
                let canRewriteSelector = node.type !== "atrule" || node.type === "atrule" && node.name !== "keyframes";
                if (canRewriteSelector) {
                    root1.walkRules((rule)=>{
                        // Let's imagine you have the following structure:
                        //
                        // .foo {
                        //   @apply bar;
                        // }
                        //
                        // @supports (a: b) {
                        //   .bar {
                        //     color: blue
                        //   }
                        //
                        //   .something-unrelated {}
                        // }
                        //
                        // In this case we want to apply `.bar` but it happens to be in
                        // an atrule node. We clone that node instead of the nested one
                        // because we still want that @supports rule to be there once we
                        // applied everything.
                        //
                        // However it happens to be that the `.something-unrelated` is
                        // also in that same shared @supports atrule. This is not good,
                        // and this should not be there. The good part is that this is
                        // a clone already and it can be safely removed. The question is
                        // how do we know we can remove it. Basically what we can do is
                        // match it against the applyCandidate that you want to apply. If
                        // it doesn't match the we can safely delete it.
                        //
                        // If we didn't do this, then the `replaceSelector` function
                        // would have replaced this with something that didn't exist and
                        // therefore it removed the selector altogether. In this specific
                        // case it would result in `{}` instead of `.something-unrelated {}`
                        if (!extractClasses(rule).some((candidate)=>candidate === applyCandidate1)) {
                            rule.remove();
                            return;
                        }
                        // Strip the important selector from the parent selector if at the beginning
                        let importantSelector = typeof context.tailwindConfig.important === "string" ? context.tailwindConfig.important : null;
                        // We only want to move the "important" selector if this is a Tailwind-generated utility
                        // We do *not* want to do this for user CSS that happens to be structured the same
                        let isGenerated = parent.raws.tailwind !== undefined;
                        let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;
                        rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate1);
                        // And then re-add it if it was removed
                        if (importantSelector && parentSelector !== parent.selector) {
                            rule.selector = `${importantSelector} ${rule.selector}`;
                        }
                        rule.walkDecls((d)=>{
                            d.important = meta.important || important1;
                        });
                    });
                }
                // It could be that the node we were inserted was removed because the class didn't match
                // If that was the *only* rule in the parent, then we have nothing add so we skip it
                if (!root1.nodes[0]) {
                    continue;
                }
                // Insert it
                siblings.push([
                    meta.sort,
                    root1.nodes[0]
                ]);
            }
        }
        // Inject the rules, sorted, correctly
        let nodes = context.offsets.sort(siblings).map((s)=>s[1]);
        // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }
        parent.after(nodes);
    }
    for (let apply1 of applies){
        // If there are left-over declarations, just remove the @apply
        if (apply1.parent.nodes.length > 1) {
            apply1.remove();
        } else {
            // The node is empty, drop the full node
            apply1.parent.remove();
        }
    }
    // Do it again, in case we have other `@apply` rules
    processApply(root, context, localCache);
}
function expandApplyAtRules(context) {
    return (root)=>{
        // Build a cache of the user's CSS so we can use it to resolve classes used by @apply
        let localCache = lazyCache(()=>buildLocalApplyCache(root, context));
        processApply(root, context, localCache);
    };
}


/***/ }),

/***/ 84421:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>expandTailwindAtRules
}));
const _fs = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(57147));
const _quickLru = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(49273));
const _sharedState = /*#__PURE__*/ _interopRequireWildcard(__nccwpck_require__(74035));
const _generateRules = __nccwpck_require__(78523);
const _log = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(64368));
const _cloneNodes = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(39811));
const _defaultExtractor = __nccwpck_require__(18902);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
let env = _sharedState.env;
const builtInExtractors = {
    DEFAULT: _defaultExtractor.defaultExtractor
};
const builtInTransformers = {
    DEFAULT: (content)=>content,
    svelte: (content)=>content.replace(/(?:^|\s)class:/g, " ")
};
function getExtractor(context, fileExtension) {
    let extractors = context.tailwindConfig.content.extract;
    return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);
}
function getTransformer(tailwindConfig, fileExtension) {
    let transformers = tailwindConfig.content.transform;
    return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;
}
let extractorCache = new WeakMap();
// Scans template contents for possible classes. This is a hot path on initial build but
// not too important for subsequent builds. The faster the better though — if we can speed
// up these regexes by 50% that could cut initial build time by like 20%.
function getClassCandidates(content, extractor, candidates, seen) {
    if (!extractorCache.has(extractor)) {
        extractorCache.set(extractor, new _quickLru.default({
            maxSize: 25000
        }));
    }
    for (let line of content.split("\n")){
        line = line.trim();
        if (seen.has(line)) {
            continue;
        }
        seen.add(line);
        if (extractorCache.get(extractor).has(line)) {
            for (let match of extractorCache.get(extractor).get(line)){
                candidates.add(match);
            }
        } else {
            let extractorMatches = extractor(line).filter((s)=>s !== "!*");
            let lineMatchesSet = new Set(extractorMatches);
            for (let match1 of lineMatchesSet){
                candidates.add(match1);
            }
            extractorCache.get(extractor).set(line, lineMatchesSet);
        }
    }
}
/**
 *
 * @param {[import('./offsets.js').RuleOffset, import('postcss').Node][]} rules
 * @param {*} context
 */ function buildStylesheet(rules, context) {
    let sortedRules = context.offsets.sort(rules);
    let returnValue = {
        base: new Set(),
        defaults: new Set(),
        components: new Set(),
        utilities: new Set(),
        variants: new Set()
    };
    for (let [sort, rule] of sortedRules){
        returnValue[sort.layer].add(rule);
    }
    return returnValue;
}
function expandTailwindAtRules(context) {
    return (root)=>{
        let layerNodes = {
            base: null,
            components: null,
            utilities: null,
            variants: null
        };
        root.walkAtRules((rule)=>{
            // Make sure this file contains Tailwind directives. If not, we can save
            // a lot of work and bail early. Also we don't have to register our touch
            // file as a dependency since the output of this CSS does not depend on
            // the source of any templates. Think Vue <style> blocks for example.
            if (rule.name === "tailwind") {
                if (Object.keys(layerNodes).includes(rule.params)) {
                    layerNodes[rule.params] = rule;
                }
            }
        });
        if (Object.values(layerNodes).every((n)=>n === null)) {
            return root;
        }
        var _context_candidates;
        // ---
        // Find potential rules in changed files
        let candidates = new Set([
            ...(_context_candidates = context.candidates) !== null && _context_candidates !== void 0 ? _context_candidates : [],
            _sharedState.NOT_ON_DEMAND
        ]);
        let seen = new Set();
        env.DEBUG && console.time("Reading changed files");
        if (env.OXIDE) {
            // TODO: Pass through or implement `extractor`
            for (let candidate of (__nccwpck_require__(34850).parseCandidateStringsFromFiles)(context.changedContent)){
                candidates.add(candidate);
            }
        // for (let { file, content, extension } of context.changedContent) {
        //   let transformer = getTransformer(context.tailwindConfig, extension)
        //   let extractor = getExtractor(context, extension)
        //   getClassCandidatesOxide(file, transformer(content), extractor, candidates, seen)
        // }
        } else {
            for (let { file , content , extension  } of context.changedContent){
                let transformer = getTransformer(context.tailwindConfig, extension);
                let extractor = getExtractor(context, extension);
                content = file ? _fs.default.readFileSync(file, "utf8") : content;
                getClassCandidates(transformer(content), extractor, candidates, seen);
            }
        }
        env.DEBUG && console.timeEnd("Reading changed files");
        // ---
        // Generate the actual CSS
        let classCacheCount = context.classCache.size;
        env.DEBUG && console.time("Generate rules");
        env.DEBUG && console.time("Sorting candidates");
        let sortedCandidates = env.OXIDE ? candidates : new Set([
            ...candidates
        ].sort((a, z)=>{
            if (a === z) return 0;
            if (a < z) return -1;
            return 1;
        }));
        env.DEBUG && console.timeEnd("Sorting candidates");
        (0, _generateRules.generateRules)(sortedCandidates, context);
        env.DEBUG && console.timeEnd("Generate rules");
        // We only ever add to the classCache, so if it didn't grow, there is nothing new.
        env.DEBUG && console.time("Build stylesheet");
        if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {
            context.stylesheetCache = buildStylesheet([
                ...context.ruleCache
            ], context);
        }
        env.DEBUG && console.timeEnd("Build stylesheet");
        let { defaults: defaultNodes , base: baseNodes , components: componentNodes , utilities: utilityNodes , variants: screenNodes  } = context.stylesheetCache;
        // ---
        // Replace any Tailwind directives with generated CSS
        if (layerNodes.base) {
            layerNodes.base.before((0, _cloneNodes.default)([
                ...baseNodes,
                ...defaultNodes
            ], layerNodes.base.source, {
                layer: "base"
            }));
            layerNodes.base.remove();
        }
        if (layerNodes.components) {
            layerNodes.components.before((0, _cloneNodes.default)([
                ...componentNodes
            ], layerNodes.components.source, {
                layer: "components"
            }));
            layerNodes.components.remove();
        }
        if (layerNodes.utilities) {
            layerNodes.utilities.before((0, _cloneNodes.default)([
                ...utilityNodes
            ], layerNodes.utilities.source, {
                layer: "utilities"
            }));
            layerNodes.utilities.remove();
        }
        // We do post-filtering to not alter the emitted order of the variants
        const variantNodes = Array.from(screenNodes).filter((node)=>{
            var _node_raws_tailwind;
            const parentLayer = (_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer;
            if (parentLayer === "components") {
                return layerNodes.components !== null;
            }
            if (parentLayer === "utilities") {
                return layerNodes.utilities !== null;
            }
            return true;
        });
        if (layerNodes.variants) {
            layerNodes.variants.before((0, _cloneNodes.default)(variantNodes, layerNodes.variants.source, {
                layer: "variants"
            }));
            layerNodes.variants.remove();
        } else if (variantNodes.length > 0) {
            root.append((0, _cloneNodes.default)(variantNodes, root.source, {
                layer: "variants"
            }));
        }
        // If we've got a utility layer and no utilities are generated there's likely something wrong
        const hasUtilityVariants = variantNodes.some((node)=>{
            var _node_raws_tailwind;
            return ((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer) === "utilities";
        });
        if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {
            _log.default.warn("content-problems", [
                "No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.",
                "https://tailwindcss.com/docs/content-configuration"
            ]);
        }
        // ---
        if (env.DEBUG) {
            console.log("Potential classes: ", candidates.size);
            console.log("Active contexts: ", _sharedState.contextSourcesMap.size);
        }
        // Clear the cache for the changed files
        context.changedContent = [];
        // Cleanup any leftover @layer atrules
        root.walkAtRules("layer", (rule)=>{
            if (Object.keys(layerNodes).includes(rule.params)) {
                rule.remove();
            }
        });
    };
}


/***/ }),

/***/ 11496:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "findAtConfigPath", ({
    enumerable: true,
    get: ()=>findAtConfigPath
}));
const _fs = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(57147));
const _path = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(71017));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function findAtConfigPath(root, result) {
    let configPath = null;
    let relativeTo = null;
    root.walkAtRules("config", (rule)=>{
        var _rule_source;
        var _rule_source_input_file, _ref;
        relativeTo = (_ref = (_rule_source_input_file = (_rule_source = rule.source) === null || _rule_source === void 0 ? void 0 : _rule_source.input.file) !== null && _rule_source_input_file !== void 0 ? _rule_source_input_file : result.opts.from) !== null && _ref !== void 0 ? _ref : null;
        if (relativeTo === null) {
            throw rule.error("The `@config` directive cannot be used without setting `from` in your PostCSS config.");
        }
        if (configPath) {
            throw rule.error("Only one `@config` directive is allowed per file.");
        }
        let matches = rule.params.match(/(['"])(.*?)\1/);
        if (!matches) {
            throw rule.error("A path is required when using the `@config` directive.");
        }
        let inputPath = matches[2];
        if (_path.default.isAbsolute(inputPath)) {
            throw rule.error("The `@config` directive cannot be used with an absolute path.");
        }
        configPath = _path.default.resolve(_path.default.dirname(relativeTo), inputPath);
        if (!_fs.default.existsSync(configPath)) {
            throw rule.error(`The config file at "${inputPath}" does not exist. Make sure the path is correct and the file exists.`);
        }
        rule.remove();
    });
    return configPath ? configPath : null;
}


/***/ }),

/***/ 78523:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    getClassNameFromSelector: ()=>getClassNameFromSelector,
    resolveMatches: ()=>resolveMatches,
    generateRules: ()=>generateRules
});
const _postcss = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(77001));
const _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(32997));
const _parseObjectStyles = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(52375));
const _isPlainObject = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(20896));
const _prefixSelector = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(74710));
const _pluginUtils = __nccwpck_require__(89244);
const _log = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(64368));
const _sharedState = /*#__PURE__*/ _interopRequireWildcard(__nccwpck_require__(74035));
const _formatVariantSelector = __nccwpck_require__(43514);
const _nameClass = __nccwpck_require__(66104);
const _dataTypes = __nccwpck_require__(85921);
const _setupContextUtils = __nccwpck_require__(61555);
const _isSyntacticallyValidPropertyValue = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(8449));
const _splitAtTopLevelOnlyJs = __nccwpck_require__(5721);
const _featureFlags = __nccwpck_require__(90);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
let classNameParser = (0, _postcssSelectorParser.default)((selectors)=>{
    return selectors.first.filter(({ type  })=>type === "class").pop().value;
});
function getClassNameFromSelector(selector) {
    return classNameParser.transformSync(selector);
}
// Generate match permutations for a class candidate, like:
// ['ring-offset-blue', '100']
// ['ring-offset', 'blue-100']
// ['ring', 'offset-blue-100']
// Example with dynamic classes:
// ['grid-cols', '[[linename],1fr,auto]']
// ['grid', 'cols-[[linename],1fr,auto]']
function* candidatePermutations(candidate) {
    let lastIndex = Infinity;
    while(lastIndex >= 0){
        let dashIdx;
        let wasSlash = false;
        if (lastIndex === Infinity && candidate.endsWith("]")) {
            let bracketIdx = candidate.indexOf("[");
            // If character before `[` isn't a dash or a slash, this isn't a dynamic class
            // eg. string[]
            if (candidate[bracketIdx - 1] === "-") {
                dashIdx = bracketIdx - 1;
            } else if (candidate[bracketIdx - 1] === "/") {
                dashIdx = bracketIdx - 1;
                wasSlash = true;
            } else {
                dashIdx = -1;
            }
        } else if (lastIndex === Infinity && candidate.includes("/")) {
            dashIdx = candidate.lastIndexOf("/");
            wasSlash = true;
        } else {
            dashIdx = candidate.lastIndexOf("-", lastIndex);
        }
        if (dashIdx < 0) {
            break;
        }
        let prefix = candidate.slice(0, dashIdx);
        let modifier = candidate.slice(wasSlash ? dashIdx : dashIdx + 1);
        lastIndex = dashIdx - 1;
        // TODO: This feels a bit hacky
        if (prefix === "" || modifier === "/") {
            continue;
        }
        yield [
            prefix,
            modifier
        ];
    }
}
function applyPrefix(matches, context) {
    if (matches.length === 0 || context.tailwindConfig.prefix === "") {
        return matches;
    }
    for (let match of matches){
        let [meta] = match;
        if (meta.options.respectPrefix) {
            let container = _postcss.default.root({
                nodes: [
                    match[1].clone()
                ]
            });
            let classCandidate = match[1].raws.tailwind.classCandidate;
            container.walkRules((r)=>{
                // If this is a negative utility with a dash *before* the prefix we
                // have to ensure that the generated selector matches the candidate
                // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`
                // The disconnect between candidate <-> class can cause @apply to hard crash.
                let shouldPrependNegative = classCandidate.startsWith("-");
                r.selector = (0, _prefixSelector.default)(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);
            });
            match[1] = container.nodes[0];
        }
    }
    return matches;
}
function applyImportant(matches, classCandidate) {
    if (matches.length === 0) {
        return matches;
    }
    let result = [];
    for (let [meta, rule] of matches){
        let container = _postcss.default.root({
            nodes: [
                rule.clone()
            ]
        });
        container.walkRules((r)=>{
            let ast = (0, _postcssSelectorParser.default)().astSync(r.selector);
            // Remove extraneous selectors that do not include the base candidate
            ast.each((sel)=>(0, _formatVariantSelector.eliminateIrrelevantSelectors)(sel, classCandidate));
            // Update all instances of the base candidate to include the important marker
            (0, _pluginUtils.updateAllClasses)(ast, (className)=>className === classCandidate ? `!${className}` : className);
            r.selector = ast.toString();
            r.walkDecls((d)=>d.important = true);
        });
        result.push([
            {
                ...meta,
                important: true
            },
            container.nodes[0]
        ]);
    }
    return result;
}
// Takes a list of rule tuples and applies a variant like `hover`, sm`,
// whatever to it. We used to do some extra caching here to avoid generating
// a variant of the same rule more than once, but this was never hit because
// we cache at the entire selector level further up the tree.
//
// Technically you can get a cache hit if you have `hover:focus:text-center`
// and `focus:hover:text-center` in the same project, but it doesn't feel
// worth the complexity for that case.
function applyVariant(variant, matches, context) {
    if (matches.length === 0) {
        return matches;
    }
    /** @type {{modifier: string | null, value: string | null}} */ let args = {
        modifier: null,
        value: _sharedState.NONE
    };
    // Retrieve "modifier"
    {
        let [baseVariant, ...modifiers] = (0, _splitAtTopLevelOnlyJs.splitAtTopLevelOnly)(variant, "/");
        // This is a hack to support variants with `/` in them, like `ar-1/10/20:text-red-500`
        // In this case 1/10 is a value but /20 is a modifier
        if (modifiers.length > 1) {
            baseVariant = baseVariant + "/" + modifiers.slice(0, -1).join("/");
            modifiers = modifiers.slice(-1);
        }
        if (modifiers.length && !context.variantMap.has(variant)) {
            variant = baseVariant;
            args.modifier = modifiers[0];
            if (!(0, _featureFlags.flagEnabled)(context.tailwindConfig, "generalizedModifiers")) {
                return [];
            }
        }
    }
    // Retrieve "arbitrary value"
    if (variant.endsWith("]") && !variant.startsWith("[")) {
        // We either have:
        //   @[200px]
        //   group-[:hover]
        //
        // But we don't want:
        //   @-[200px]        (`-` is incorrect)
        //   group[:hover]    (`-` is missing)
        let match = /(.)(-?)\[(.*)\]/g.exec(variant);
        if (match) {
            let [, char, seperator, value] = match;
            // @-[200px] case
            if (char === "@" && seperator === "-") return [];
            // group[:hover] case
            if (char !== "@" && seperator === "") return [];
            variant = variant.replace(`${seperator}[${value}]`, "");
            args.value = value;
        }
    }
    // Register arbitrary variants
    if (isArbitraryValue(variant) && !context.variantMap.has(variant)) {
        let selector = (0, _dataTypes.normalize)(variant.slice(1, -1));
        if (!(0, _setupContextUtils.isValidVariantFormatString)(selector)) {
            return [];
        }
        let fn = (0, _setupContextUtils.parseVariant)(selector);
        let sort = context.offsets.recordVariant(variant);
        context.variantMap.set(variant, [
            [
                sort,
                fn
            ]
        ]);
    }
    if (context.variantMap.has(variant)) {
        let isArbitraryVariant = isArbitraryValue(variant);
        let variantFunctionTuples = context.variantMap.get(variant).slice();
        let result = [];
        for (let [meta, rule] of matches){
            // Don't generate variants for user css
            if (meta.layer === "user") {
                continue;
            }
            let container = _postcss.default.root({
                nodes: [
                    rule.clone()
                ]
            });
            for (let [variantSort, variantFunction, containerFromArray] of variantFunctionTuples){
                let clone = (containerFromArray !== null && containerFromArray !== void 0 ? containerFromArray : container).clone();
                let collectedFormats = [];
                function prepareBackup() {
                    // Already prepared, chicken out
                    if (clone.raws.neededBackup) {
                        return;
                    }
                    clone.raws.neededBackup = true;
                    clone.walkRules((rule)=>rule.raws.originalSelector = rule.selector);
                }
                function modifySelectors(modifierFunction) {
                    prepareBackup();
                    clone.each((rule)=>{
                        if (rule.type !== "rule") {
                            return;
                        }
                        rule.selectors = rule.selectors.map((selector)=>{
                            return modifierFunction({
                                get className () {
                                    return getClassNameFromSelector(selector);
                                },
                                selector
                            });
                        });
                    });
                    return clone;
                }
                let ruleWithVariant = variantFunction({
                    // Public API
                    get container () {
                        prepareBackup();
                        return clone;
                    },
                    separator: context.tailwindConfig.separator,
                    modifySelectors,
                    // Private API for now
                    wrap (wrapper) {
                        let nodes = clone.nodes;
                        clone.removeAll();
                        wrapper.append(nodes);
                        clone.append(wrapper);
                    },
                    format (selectorFormat) {
                        collectedFormats.push({
                            format: selectorFormat,
                            isArbitraryVariant
                        });
                    },
                    args
                });
                // It can happen that a list of format strings is returned from within the function. In that
                // case, we have to process them as well. We can use the existing `variantSort`.
                if (Array.isArray(ruleWithVariant)) {
                    for (let [idx, variantFunction1] of ruleWithVariant.entries()){
                        // This is a little bit scary since we are pushing to an array of items that we are
                        // currently looping over. However, you can also think of it like a processing queue
                        // where you keep handling jobs until everything is done and each job can queue more
                        // jobs if needed.
                        variantFunctionTuples.push([
                            context.offsets.applyParallelOffset(variantSort, idx),
                            variantFunction1,
                            // If the clone has been modified we have to pass that back
                            // though so each rule can use the modified container
                            clone.clone()
                        ]);
                    }
                    continue;
                }
                if (typeof ruleWithVariant === "string") {
                    collectedFormats.push({
                        format: ruleWithVariant,
                        isArbitraryVariant
                    });
                }
                if (ruleWithVariant === null) {
                    continue;
                }
                // We had to backup selectors, therefore we assume that somebody touched
                // `container` or `modifySelectors`. Let's see if they did, so that we
                // can restore the selectors, and collect the format strings.
                if (clone.raws.neededBackup) {
                    delete clone.raws.neededBackup;
                    clone.walkRules((rule)=>{
                        let before = rule.raws.originalSelector;
                        if (!before) return;
                        delete rule.raws.originalSelector;
                        if (before === rule.selector) return; // No mutation happened
                        let modified = rule.selector;
                        // Rebuild the base selector, this is what plugin authors would do
                        // as well. E.g.: `${variant}${separator}${className}`.
                        // However, plugin authors probably also prepend or append certain
                        // classes, pseudos, ids, ...
                        let rebuiltBase = (0, _postcssSelectorParser.default)((selectors)=>{
                            selectors.walkClasses((classNode)=>{
                                classNode.value = `${variant}${context.tailwindConfig.separator}${classNode.value}`;
                            });
                        }).processSync(before);
                        // Now that we know the original selector, the new selector, and
                        // the rebuild part in between, we can replace the part that plugin
                        // authors need to rebuild with `&`, and eventually store it in the
                        // collectedFormats. Similar to what `format('...')` would do.
                        //
                        // E.g.:
                        //                   variant: foo
                        //                  selector: .markdown > p
                        //      modified (by plugin): .foo .foo\\:markdown > p
                        //    rebuiltBase (internal): .foo\\:markdown > p
                        //                    format: .foo &
                        collectedFormats.push({
                            format: modified.replace(rebuiltBase, "&"),
                            isArbitraryVariant
                        });
                        rule.selector = before;
                    });
                }
                // This tracks the originating layer for the variant
                // For example:
                // .sm:underline {} is a variant of something in the utilities layer
                // .sm:container {} is a variant of the container component
                clone.nodes[0].raws.tailwind = {
                    ...clone.nodes[0].raws.tailwind,
                    parentLayer: meta.layer
                };
                var _meta_collectedFormats;
                let withOffset = [
                    {
                        ...meta,
                        sort: context.offsets.applyVariantOffset(meta.sort, variantSort, Object.assign(args, context.variantOptions.get(variant))),
                        collectedFormats: ((_meta_collectedFormats = meta.collectedFormats) !== null && _meta_collectedFormats !== void 0 ? _meta_collectedFormats : []).concat(collectedFormats)
                    },
                    clone.nodes[0]
                ];
                result.push(withOffset);
            }
        }
        return result;
    }
    return [];
}
function parseRules(rule, cache, options = {}) {
    // PostCSS node
    if (!(0, _isPlainObject.default)(rule) && !Array.isArray(rule)) {
        return [
            [
                rule
            ],
            options
        ];
    }
    // Tuple
    if (Array.isArray(rule)) {
        return parseRules(rule[0], cache, rule[1]);
    }
    // Simple object
    if (!cache.has(rule)) {
        cache.set(rule, (0, _parseObjectStyles.default)(rule));
    }
    return [
        cache.get(rule),
        options
    ];
}
const IS_VALID_PROPERTY_NAME = /^[a-z_-]/;
function isValidPropName(name) {
    return IS_VALID_PROPERTY_NAME.test(name);
}
/**
 * @param {string} declaration
 * @returns {boolean}
 */ function looksLikeUri(declaration) {
    // Quick bailout for obvious non-urls
    // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem
    if (!declaration.includes("://")) {
        return false;
    }
    try {
        const url = new URL(declaration);
        return url.scheme !== "" && url.host !== "";
    } catch (err) {
        // Definitely not a valid url
        return false;
    }
}
function isParsableNode(node) {
    let isParsable = true;
    node.walkDecls((decl)=>{
        if (!isParsableCssValue(decl.prop, decl.value)) {
            isParsable = false;
            return false;
        }
    });
    return isParsable;
}
function isParsableCssValue(property, value) {
    // We don't want to to treat [https://example.com] as a custom property
    // Even though, according to the CSS grammar, it's a totally valid CSS declaration
    // So we short-circuit here by checking if the custom property looks like a url
    if (looksLikeUri(`${property}:${value}`)) {
        return false;
    }
    try {
        _postcss.default.parse(`a{${property}:${value}}`).toResult();
        return true;
    } catch (err) {
        return false;
    }
}
function extractArbitraryProperty(classCandidate, context) {
    var _classCandidate_match;
    let [, property, value] = (_classCandidate_match = classCandidate.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) !== null && _classCandidate_match !== void 0 ? _classCandidate_match : [];
    if (value === undefined) {
        return null;
    }
    if (!isValidPropName(property)) {
        return null;
    }
    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {
        return null;
    }
    let normalized = (0, _dataTypes.normalize)(value);
    if (!isParsableCssValue(property, normalized)) {
        return null;
    }
    let sort = context.offsets.arbitraryProperty();
    return [
        [
            {
                sort,
                layer: "utilities"
            },
            ()=>({
                    [(0, _nameClass.asClass)(classCandidate)]: {
                        [property]: normalized
                    }
                })
        ]
    ];
}
function* resolveMatchedPlugins(classCandidate, context) {
    if (context.candidateRuleMap.has(classCandidate)) {
        yield [
            context.candidateRuleMap.get(classCandidate),
            "DEFAULT"
        ];
    }
    yield* function*(arbitraryPropertyRule) {
        if (arbitraryPropertyRule !== null) {
            yield [
                arbitraryPropertyRule,
                "DEFAULT"
            ];
        }
    }(extractArbitraryProperty(classCandidate, context));
    let candidatePrefix = classCandidate;
    let negative = false;
    const twConfigPrefix = context.tailwindConfig.prefix;
    const twConfigPrefixLen = twConfigPrefix.length;
    const hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith(`-${twConfigPrefix}`);
    if (candidatePrefix[twConfigPrefixLen] === "-" && hasMatchingPrefix) {
        negative = true;
        candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);
    }
    if (negative && context.candidateRuleMap.has(candidatePrefix)) {
        yield [
            context.candidateRuleMap.get(candidatePrefix),
            "-DEFAULT"
        ];
    }
    for (let [prefix, modifier] of candidatePermutations(candidatePrefix)){
        if (context.candidateRuleMap.has(prefix)) {
            yield [
                context.candidateRuleMap.get(prefix),
                negative ? `-${modifier}` : modifier
            ];
        }
    }
}
function splitWithSeparator(input, separator) {
    if (input === _sharedState.NOT_ON_DEMAND) {
        return [
            _sharedState.NOT_ON_DEMAND
        ];
    }
    return (0, _splitAtTopLevelOnlyJs.splitAtTopLevelOnly)(input, separator);
}
function* recordCandidates(matches, classCandidate) {
    for (const match of matches){
        var _match__options;
        var _match__options_preserveSource;
        match[1].raws.tailwind = {
            ...match[1].raws.tailwind,
            classCandidate,
            preserveSource: (_match__options_preserveSource = (_match__options = match[0].options) === null || _match__options === void 0 ? void 0 : _match__options.preserveSource) !== null && _match__options_preserveSource !== void 0 ? _match__options_preserveSource : false
        };
        yield match;
    }
}
function* resolveMatches(candidate, context, original = candidate) {
    let separator = context.tailwindConfig.separator;
    let [classCandidate, ...variants] = splitWithSeparator(candidate, separator).reverse();
    let important = false;
    if (classCandidate.startsWith("!")) {
        important = true;
        classCandidate = classCandidate.slice(1);
    }
    if ((0, _featureFlags.flagEnabled)(context.tailwindConfig, "variantGrouping")) {
        if (classCandidate.startsWith("(") && classCandidate.endsWith(")")) {
            let base = variants.slice().reverse().join(separator);
            for (let part of (0, _splitAtTopLevelOnlyJs.splitAtTopLevelOnly)(classCandidate.slice(1, -1), ",")){
                yield* resolveMatches(base + separator + part, context, original);
            }
        }
    }
    // TODO: Reintroduce this in ways that doesn't break on false positives
    // function sortAgainst(toSort, against) {
    //   return toSort.slice().sort((a, z) => {
    //     return bigSign(against.get(a)[0] - against.get(z)[0])
    //   })
    // }
    // let sorted = sortAgainst(variants, context.variantMap)
    // if (sorted.toString() !== variants.toString()) {
    //   let corrected = sorted.reverse().concat(classCandidate).join(':')
    //   throw new Error(`Class ${candidate} should be written as ${corrected}`)
    // }
    for (let matchedPlugins of resolveMatchedPlugins(classCandidate, context)){
        let matches = [];
        let typesByMatches = new Map();
        let [plugins, modifier] = matchedPlugins;
        let isOnlyPlugin = plugins.length === 1;
        for (let [sort, plugin] of plugins){
            let matchesPerPlugin = [];
            if (typeof plugin === "function") {
                for (let ruleSet of [].concat(plugin(modifier, {
                    isOnlyPlugin
                }))){
                    let [rules, options] = parseRules(ruleSet, context.postCssNodeCache);
                    for (let rule of rules){
                        matchesPerPlugin.push([
                            {
                                ...sort,
                                options: {
                                    ...sort.options,
                                    ...options
                                }
                            },
                            rule
                        ]);
                    }
                }
            } else if (modifier === "DEFAULT" || modifier === "-DEFAULT") {
                let ruleSet1 = plugin;
                let [rules1, options1] = parseRules(ruleSet1, context.postCssNodeCache);
                for (let rule1 of rules1){
                    matchesPerPlugin.push([
                        {
                            ...sort,
                            options: {
                                ...sort.options,
                                ...options1
                            }
                        },
                        rule1
                    ]);
                }
            }
            if (matchesPerPlugin.length > 0) {
                var _sort_options;
                var _sort_options_types, _sort_options1;
                let matchingTypes = Array.from((0, _pluginUtils.getMatchingTypes)((_sort_options_types = (_sort_options = sort.options) === null || _sort_options === void 0 ? void 0 : _sort_options.types) !== null && _sort_options_types !== void 0 ? _sort_options_types : [], modifier, (_sort_options1 = sort.options) !== null && _sort_options1 !== void 0 ? _sort_options1 : {}, context.tailwindConfig)).map(([_, type])=>type);
                if (matchingTypes.length > 0) {
                    typesByMatches.set(matchesPerPlugin, matchingTypes);
                }
                matches.push(matchesPerPlugin);
            }
        }
        if (isArbitraryValue(modifier)) {
            if (matches.length > 1) {
                // Partition plugins in 2 categories so that we can start searching in the plugins that
                // don't have `any` as a type first.
                let [withAny, withoutAny] = matches.reduce((group, plugin)=>{
                    let hasAnyType = plugin.some(([{ options  }])=>options.types.some(({ type  })=>type === "any"));
                    if (hasAnyType) {
                        group[0].push(plugin);
                    } else {
                        group[1].push(plugin);
                    }
                    return group;
                }, [
                    [],
                    []
                ]);
                function findFallback(matches) {
                    // If only a single plugin matches, let's take that one
                    if (matches.length === 1) {
                        return matches[0];
                    }
                    // Otherwise, find the plugin that creates a valid rule given the arbitrary value, and
                    // also has the correct type which preferOnConflicts the plugin in case of clashes.
                    return matches.find((rules)=>{
                        let matchingTypes = typesByMatches.get(rules);
                        return rules.some(([{ options  }, rule])=>{
                            if (!isParsableNode(rule)) {
                                return false;
                            }
                            return options.types.some(({ type , preferOnConflict  })=>matchingTypes.includes(type) && preferOnConflict);
                        });
                    });
                }
                var _findFallback;
                // Try to find a fallback plugin, because we already know that multiple plugins matched for
                // the given arbitrary value.
                let fallback = (_findFallback = findFallback(withoutAny)) !== null && _findFallback !== void 0 ? _findFallback : findFallback(withAny);
                if (fallback) {
                    matches = [
                        fallback
                    ];
                } else {
                    var _typesByMatches_get;
                    let typesPerPlugin = matches.map((match)=>new Set([
                            ...(_typesByMatches_get = typesByMatches.get(match)) !== null && _typesByMatches_get !== void 0 ? _typesByMatches_get : []
                        ]));
                    // Remove duplicates, so that we can detect proper unique types for each plugin.
                    for (let pluginTypes of typesPerPlugin){
                        for (let type of pluginTypes){
                            let removeFromOwnGroup = false;
                            for (let otherGroup of typesPerPlugin){
                                if (pluginTypes === otherGroup) continue;
                                if (otherGroup.has(type)) {
                                    otherGroup.delete(type);
                                    removeFromOwnGroup = true;
                                }
                            }
                            if (removeFromOwnGroup) pluginTypes.delete(type);
                        }
                    }
                    let messages = [];
                    for (let [idx, group] of typesPerPlugin.entries()){
                        for (let type1 of group){
                            let rules2 = matches[idx].map(([, rule])=>rule).flat().map((rule)=>rule.toString().split("\n").slice(1, -1) // Remove selector and closing '}'
                                .map((line)=>line.trim()).map((x)=>`      ${x}`) // Re-indent
                                .join("\n")).join("\n\n");
                            messages.push(`  Use \`${candidate.replace("[", `[${type1}:`)}\` for \`${rules2.trim()}\``);
                            break;
                        }
                    }
                    _log.default.warn([
                        `The class \`${candidate}\` is ambiguous and matches multiple utilities.`,
                        ...messages,
                        `If this is content and not a class, replace it with \`${candidate.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`
                    ]);
                    continue;
                }
            }
            matches = matches.map((list)=>list.filter((match)=>isParsableNode(match[1])));
        }
        matches = matches.flat();
        matches = Array.from(recordCandidates(matches, classCandidate));
        matches = applyPrefix(matches, context);
        if (important) {
            matches = applyImportant(matches, classCandidate);
        }
        for (let variant of variants){
            matches = applyVariant(variant, matches, context);
        }
        for (let match of matches){
            match[1].raws.tailwind = {
                ...match[1].raws.tailwind,
                candidate
            };
            // Apply final format selector
            match = applyFinalFormat(match, {
                context,
                candidate,
                original
            });
            // Skip rules with invalid selectors
            // This will cause the candidate to be added to the "not class"
            // cache skipping it entirely for future builds
            if (match === null) {
                continue;
            }
            yield match;
        }
    }
}
function applyFinalFormat(match, { context , candidate , original  }) {
    if (!match[0].collectedFormats) {
        return match;
    }
    let isValid = true;
    let finalFormat;
    try {
        finalFormat = (0, _formatVariantSelector.formatVariantSelector)(match[0].collectedFormats, {
            context,
            candidate
        });
    } catch  {
        // The format selector we produced is invalid
        // This could be because:
        // - A bug exists
        // - A plugin introduced an invalid variant selector (ex: `addVariant('foo', '&;foo')`)
        // - The user used an invalid arbitrary variant (ex: `[&;foo]:underline`)
        // Either way the build will fail because of this
        // We would rather that the build pass "silently" given that this could
        // happen because of picking up invalid things when scanning content
        // So we'll throw out the candidate instead
        return null;
    }
    let container = _postcss.default.root({
        nodes: [
            match[1].clone()
        ]
    });
    container.walkRules((rule)=>{
        if (inKeyframes(rule)) {
            return;
        }
        try {
            rule.selector = (0, _formatVariantSelector.finalizeSelector)(rule.selector, finalFormat, {
                candidate: original,
                context
            });
        } catch  {
            // If this selector is invalid we also want to skip it
            // But it's likely that being invalid here means there's a bug in a plugin rather than too loosely matching content
            isValid = false;
            return false;
        }
    });
    if (!isValid) {
        return null;
    }
    match[1] = container.nodes[0];
    return match;
}
function inKeyframes(rule) {
    return rule.parent && rule.parent.type === "atrule" && rule.parent.name === "keyframes";
}
function getImportantStrategy(important) {
    if (important === true) {
        return (rule)=>{
            if (inKeyframes(rule)) {
                return;
            }
            rule.walkDecls((d)=>{
                if (d.parent.type === "rule" && !inKeyframes(d.parent)) {
                    d.important = true;
                }
            });
        };
    }
    if (typeof important === "string") {
        return (rule)=>{
            if (inKeyframes(rule)) {
                return;
            }
            rule.selectors = rule.selectors.map((selector)=>{
                return `${important} ${selector}`;
            });
        };
    }
}
function generateRules(candidates, context) {
    let allRules = [];
    let strategy = getImportantStrategy(context.tailwindConfig.important);
    for (let candidate of candidates){
        if (context.notClassCache.has(candidate)) {
            continue;
        }
        if (context.candidateRuleCache.has(candidate)) {
            allRules = allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));
            continue;
        }
        let matches = Array.from(resolveMatches(candidate, context));
        if (matches.length === 0) {
            context.notClassCache.add(candidate);
            continue;
        }
        context.classCache.set(candidate, matches);
        var _context_candidateRuleCache_get;
        let rules = (_context_candidateRuleCache_get = context.candidateRuleCache.get(candidate)) !== null && _context_candidateRuleCache_get !== void 0 ? _context_candidateRuleCache_get : new Set();
        context.candidateRuleCache.set(candidate, rules);
        for (const match of matches){
            let [{ sort , options  }, rule] = match;
            if (options.respectImportant && strategy) {
                let container = _postcss.default.root({
                    nodes: [
                        rule.clone()
                    ]
                });
                container.walkRules(strategy);
                rule = container.nodes[0];
            }
            let newEntry = [
                sort,
                rule
            ];
            rules.add(newEntry);
            context.ruleCache.add(newEntry);
            allRules.push(newEntry);
        }
    }
    return allRules;
}
function isArbitraryValue(input) {
    return input.startsWith("[") && input.endsWith("]");
}


/***/ }),

/***/ 70528:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>getModuleDependencies
}));
const _fs = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(57147));
const _path = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(71017));
const _resolve = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(39283));
const _detective = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(58339));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function createModule(file) {
    const source = _fs.default.readFileSync(file, "utf-8");
    const requires = (0, _detective.default)(source);
    return {
        file,
        requires
    };
}
function getModuleDependencies(entryFile) {
    const rootModule = createModule(entryFile);
    const modules = [
        rootModule
    ];
    // Iterate over the modules, even when new
    // ones are being added
    for (const mdl of modules){
        mdl.requires.filter((dep)=>{
            // Only track local modules, not node_modules
            return dep.startsWith("./") || dep.startsWith("../");
        }).forEach((dep)=>{
            try {
                const basedir = _path.default.dirname(mdl.file);
                const depPath = _resolve.default.sync(dep, {
                    basedir
                });
                const depModule = createModule(depPath);
                modules.push(depModule);
            } catch (_err) {
            // eslint-disable-next-line no-empty
            }
        });
    }
    return modules;
}


/***/ }),

/***/ 87165:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>normalizeTailwindDirectives
}));
const _log = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(64368));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function normalizeTailwindDirectives(root) {
    let tailwindDirectives = new Set();
    let layerDirectives = new Set();
    let applyDirectives = new Set();
    root.walkAtRules((atRule)=>{
        if (atRule.name === "apply") {
            applyDirectives.add(atRule);
        }
        if (atRule.name === "import") {
            if (atRule.params === '"tailwindcss/base"' || atRule.params === "'tailwindcss/base'") {
                atRule.name = "tailwind";
                atRule.params = "base";
            } else if (atRule.params === '"tailwindcss/components"' || atRule.params === "'tailwindcss/components'") {
                atRule.name = "tailwind";
                atRule.params = "components";
            } else if (atRule.params === '"tailwindcss/utilities"' || atRule.params === "'tailwindcss/utilities'") {
                atRule.name = "tailwind";
                atRule.params = "utilities";
            } else if (atRule.params === '"tailwindcss/screens"' || atRule.params === "'tailwindcss/screens'" || atRule.params === '"tailwindcss/variants"' || atRule.params === "'tailwindcss/variants'") {
                atRule.name = "tailwind";
                atRule.params = "variants";
            }
        }
        if (atRule.name === "tailwind") {
            if (atRule.params === "screens") {
                atRule.params = "variants";
            }
            tailwindDirectives.add(atRule.params);
        }
        if ([
            "layer",
            "responsive",
            "variants"
        ].includes(atRule.name)) {
            if ([
                "responsive",
                "variants"
            ].includes(atRule.name)) {
                _log.default.warn(`${atRule.name}-at-rule-deprecated`, [
                    `The \`@${atRule.name}\` directive has been deprecated in Tailwind CSS v3.0.`,
                    `Use \`@layer utilities\` or \`@layer components\` instead.`,
                    "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"
                ]);
            }
            layerDirectives.add(atRule);
        }
    });
    if (!tailwindDirectives.has("base") || !tailwindDirectives.has("components") || !tailwindDirectives.has("utilities")) {
        for (let rule of layerDirectives){
            if (rule.name === "layer" && [
                "base",
                "components",
                "utilities"
            ].includes(rule.params)) {
                if (!tailwindDirectives.has(rule.params)) {
                    throw rule.error(`\`@layer ${rule.params}\` is used but no matching \`@tailwind ${rule.params}\` directive is present.`);
                }
            } else if (rule.name === "responsive") {
                if (!tailwindDirectives.has("utilities")) {
                    throw rule.error("`@responsive` is used but `@tailwind utilities` is missing.");
                }
            } else if (rule.name === "variants") {
                if (!tailwindDirectives.has("utilities")) {
                    throw rule.error("`@variants` is used but `@tailwind utilities` is missing.");
                }
            }
        }
    }
    return {
        tailwindDirectives,
        applyDirectives
    };
}


/***/ }),

/***/ 95736:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
// @ts-check

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "Offsets", ({
    enumerable: true,
    get: ()=>Offsets
}));
const _bigSign = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(30674));
const _remapBitfieldJs = __nccwpck_require__(19705);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class Offsets {
    constructor(){
        /**
     * Offsets for the next rule in a given layer
     *
     * @type {Record<Layer, bigint>}
     */ this.offsets = {
            defaults: 0n,
            base: 0n,
            components: 0n,
            utilities: 0n,
            variants: 0n,
            user: 0n
        };
        /**
     * Positions for a given layer
     *
     * @type {Record<Layer, bigint>}
     */ this.layerPositions = {
            defaults: 0n,
            base: 1n,
            components: 2n,
            utilities: 3n,
            // There isn't technically a "user" layer, but we need to give it a position
            // Because it's used for ordering user-css from @apply
            user: 4n,
            variants: 5n
        };
        /**
     * The total number of functions currently registered across all variants (including arbitrary variants)
     *
     * @type {bigint}
     */ this.reservedVariantBits = 0n;
        /**
     * Positions for a given variant
     *
     * @type {Map<string, bigint>}
     */ this.variantOffsets = new Map();
    }
    /**
   * @param {Layer} layer
   * @returns {RuleOffset}
   */ create(layer) {
        return {
            layer,
            parentLayer: layer,
            arbitrary: 0n,
            variants: 0n,
            parallelIndex: 0n,
            index: this.offsets[layer]++,
            options: []
        };
    }
    /**
   * @returns {RuleOffset}
   */ arbitraryProperty() {
        return {
            ...this.create("utilities"),
            arbitrary: 1n
        };
    }
    /**
   * Get the offset for a variant
   *
   * @param {string} variant
   * @param {number} index
   * @returns {RuleOffset}
   */ forVariant(variant, index = 0) {
        let offset = this.variantOffsets.get(variant);
        if (offset === undefined) {
            throw new Error(`Cannot find offset for unknown variant ${variant}`);
        }
        return {
            ...this.create("variants"),
            variants: offset << BigInt(index)
        };
    }
    /**
   * @param {RuleOffset} rule
   * @param {RuleOffset} variant
   * @param {VariantOption} options
   * @returns {RuleOffset}
   */ applyVariantOffset(rule, variant, options) {
        options.variant = variant.variants;
        return {
            ...rule,
            layer: "variants",
            parentLayer: rule.layer === "variants" ? rule.parentLayer : rule.layer,
            variants: rule.variants | variant.variants,
            options: options.sort ? [].concat(options, rule.options) : rule.options,
            // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.
            // We'll take the max of all the parallel indexes for now.
            // @ts-ignore
            parallelIndex: max([
                rule.parallelIndex,
                variant.parallelIndex
            ])
        };
    }
    /**
   * @param {RuleOffset} offset
   * @param {number} parallelIndex
   * @returns {RuleOffset}
   */ applyParallelOffset(offset, parallelIndex) {
        return {
            ...offset,
            parallelIndex: BigInt(parallelIndex)
        };
    }
    /**
   * Each variant gets 1 bit per function / rule registered.
   * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.
   * Additionally, every unique group of variants is grouped together in the stylesheet.
   *
   * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.
   *
   * @param {string[]} variants
   * @param {(name: string) => number} getLength
   */ recordVariants(variants, getLength) {
        for (let variant of variants){
            this.recordVariant(variant, getLength(variant));
        }
    }
    /**
   * The same as `recordVariants` but for a single arbitrary variant at runtime.
   * @param {string} variant
   * @param {number} fnCount
   *
   * @returns {RuleOffset} The highest offset for this variant
   */ recordVariant(variant, fnCount = 1) {
        this.variantOffsets.set(variant, 1n << this.reservedVariantBits);
        // Ensure space is reserved for each "function" in the parallel variant
        // by offsetting the next variant by the number of parallel variants
        // in the one we just added.
        // Single functions that return parallel variants are NOT handled separately here
        // They're offset by 1 (or the number of functions) as usual
        // And each rule returned is tracked separately since the functions are evaluated lazily.
        // @see `RuleOffset.parallelIndex`
        this.reservedVariantBits += BigInt(fnCount);
        return {
            ...this.create("variants"),
            variants: this.variantOffsets.get(variant)
        };
    }
    /**
   * @param {RuleOffset} a
   * @param {RuleOffset} b
   * @returns {bigint}
   */ compare(a, b) {
        // Sort layers together
        if (a.layer !== b.layer) {
            return this.layerPositions[a.layer] - this.layerPositions[b.layer];
        }
        // When sorting the `variants` layer, we need to sort based on the parent layer as well within
        // this variants layer.
        if (a.parentLayer !== b.parentLayer) {
            return this.layerPositions[a.parentLayer] - this.layerPositions[b.parentLayer];
        }
        // Sort based on the sorting function
        for (let aOptions of a.options){
            for (let bOptions of b.options){
                if (aOptions.id !== bOptions.id) continue;
                if (!aOptions.sort || !bOptions.sort) continue;
                var _max;
                let maxFnVariant = (_max = max([
                    aOptions.variant,
                    bOptions.variant
                ])) !== null && _max !== void 0 ? _max : 0n;
                // Create a mask of 0s from bits 1..N where N represents the mask of the Nth bit
                let mask = ~(maxFnVariant | maxFnVariant - 1n);
                let aVariantsAfterFn = a.variants & mask;
                let bVariantsAfterFn = b.variants & mask;
                // If the variants the same, we _can_ sort them
                if (aVariantsAfterFn !== bVariantsAfterFn) {
                    continue;
                }
                let result = aOptions.sort({
                    value: aOptions.value,
                    modifier: aOptions.modifier
                }, {
                    value: bOptions.value,
                    modifier: bOptions.modifier
                });
                if (result !== 0) return result;
            }
        }
        // Sort variants in the order they were registered
        if (a.variants !== b.variants) {
            return a.variants - b.variants;
        }
        // Make sure each rule returned by a parallel variant is sorted in ascending order
        if (a.parallelIndex !== b.parallelIndex) {
            return a.parallelIndex - b.parallelIndex;
        }
        // Always sort arbitrary properties after other utilities
        if (a.arbitrary !== b.arbitrary) {
            return a.arbitrary - b.arbitrary;
        }
        // Sort utilities, components, etc… in the order they were registered
        return a.index - b.index;
    }
    /**
   * Arbitrary variants are recorded in the order they're encountered.
   * This means that the order is not stable between environments and sets of content files.
   *
   * In order to make the order stable, we need to remap the arbitrary variant offsets to
   * be in alphabetical order starting from the offset of the first arbitrary variant.
   */ recalculateVariantOffsets() {
        // Sort the variants by their name
        let variants = Array.from(this.variantOffsets.entries()).filter(([v])=>v.startsWith("[")).sort(([a], [z])=>fastCompare(a, z));
        // Sort the list of offsets
        // This is not necessarily a discrete range of numbers which is why
        // we're using sort instead of creating a range from min/max
        let newOffsets = variants.map(([, offset])=>offset).sort((a, z)=>(0, _bigSign.default)(a - z));
        // Create a map from the old offsets to the new offsets in the new sort order
        /** @type {[bigint, bigint][]} */ let mapping = variants.map(([, oldOffset], i)=>[
                oldOffset,
                newOffsets[i]
            ]);
        // Remove any variants that will not move letting us skip
        // remapping if everything happens to be in order
        return mapping.filter(([a, z])=>a !== z);
    }
    /**
   * @template T
   * @param {[RuleOffset, T][]} list
   * @returns {[RuleOffset, T][]}
   */ remapArbitraryVariantOffsets(list) {
        let mapping = this.recalculateVariantOffsets();
        // No arbitrary variants? Nothing to do.
        // Everyhing already in order? Nothing to do.
        if (mapping.length === 0) {
            return list;
        }
        // Remap every variant offset in the list
        return list.map((item)=>{
            let [offset, rule] = item;
            offset = {
                ...offset,
                variants: (0, _remapBitfieldJs.remapBitfield)(offset.variants, mapping)
            };
            return [
                offset,
                rule
            ];
        });
    }
    /**
   * @template T
   * @param {[RuleOffset, T][]} list
   * @returns {[RuleOffset, T][]}
   */ sort(list) {
        list = this.remapArbitraryVariantOffsets(list);
        return list.sort(([a], [b])=>(0, _bigSign.default)(this.compare(a, b)));
    }
}
/**
 *
 * @param {bigint[]} nums
 * @returns {bigint|null}
 */ function max(nums) {
    let max = null;
    for (const num of nums){
        max = max !== null && max !== void 0 ? max : num;
        max = max > num ? max : num;
    }
    return max;
}
/**
 * A fast ASCII order string comparison function.
 *
 * Using `.sort()` without a custom compare function is faster
 * But you can only use that if you're sorting an array of
 * only strings. If you're sorting strings inside objects
 * or arrays, you need must use a custom compare function.
 *
 * @param {string} a
 * @param {string} b
 */ function fastCompare(a, b) {
    let aLen = a.length;
    let bLen = b.length;
    let minLen = aLen < bLen ? aLen : bLen;
    for(let i = 0; i < minLen; i++){
        let cmp = a.charCodeAt(i) - b.charCodeAt(i);
        if (cmp !== 0) return cmp;
    }
    return aLen - bLen;
}


/***/ }),

/***/ 24769:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>expandApplyAtRules
}));
function partitionRules(root) {
    if (!root.walkAtRules) return;
    let applyParents = new Set();
    root.walkAtRules("apply", (rule)=>{
        applyParents.add(rule.parent);
    });
    if (applyParents.size === 0) {
        return;
    }
    for (let rule of applyParents){
        let nodeGroups = [];
        let lastGroup = [];
        for (let node of rule.nodes){
            if (node.type === "atrule" && node.name === "apply") {
                if (lastGroup.length > 0) {
                    nodeGroups.push(lastGroup);
                    lastGroup = [];
                }
                nodeGroups.push([
                    node
                ]);
            } else {
                lastGroup.push(node);
            }
        }
        if (lastGroup.length > 0) {
            nodeGroups.push(lastGroup);
        }
        if (nodeGroups.length === 1) {
            continue;
        }
        for (let group of [
            ...nodeGroups
        ].reverse()){
            let clone = rule.clone({
                nodes: []
            });
            clone.append(group);
            rule.after(clone);
        }
        rule.remove();
    }
}
function expandApplyAtRules() {
    return (root)=>{
        partitionRules(root);
    };
}


/***/ }),

/***/ 8045:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    pattern: ()=>pattern,
    withoutCapturing: ()=>withoutCapturing,
    any: ()=>any,
    optional: ()=>optional,
    zeroOrMore: ()=>zeroOrMore,
    nestedBrackets: ()=>nestedBrackets,
    escape: ()=>escape
});
const REGEX_SPECIAL = /[\\^$.*+?()[\]{}|]/g;
const REGEX_HAS_SPECIAL = RegExp(REGEX_SPECIAL.source);
/**
 * @param {string|RegExp|Array<string|RegExp>} source
 */ function toSource(source) {
    source = Array.isArray(source) ? source : [
        source
    ];
    source = source.map((item)=>item instanceof RegExp ? item.source : item);
    return source.join("");
}
function pattern(source) {
    return new RegExp(toSource(source), "g");
}
function withoutCapturing(source) {
    return new RegExp(`(?:${toSource(source)})`, "g");
}
function any(sources) {
    return `(?:${sources.map(toSource).join("|")})`;
}
function optional(source) {
    return `(?:${toSource(source)})?`;
}
function zeroOrMore(source) {
    return `(?:${toSource(source)})*`;
}
function nestedBrackets(open, close, depth = 1) {
    return withoutCapturing([
        escape(open),
        /[^\s]*/,
        depth === 1 ? `[^${escape(open)}${escape(close)}\s]*` : any([
            `[^${escape(open)}${escape(close)}\s]*`,
            nestedBrackets(open, close, depth - 1)
        ]),
        /[^\s]*/,
        escape(close)
    ]);
}
function escape(string) {
    return string && REGEX_HAS_SPECIAL.test(string) ? string.replace(REGEX_SPECIAL, "\\$&") : string || "";
}


/***/ }),

/***/ 19705:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
// @ts-check
/**
 * We must remap all the old bits to new bits for each set variant
 * Only arbitrary variants are considered as those are the only
 * ones that need to be re-sorted at this time
 *
 * An iterated process that removes and sets individual bits simultaneously
 * will not work because we may have a new bit that is also a later old bit
 * This means that we would be removing a previously set bit which we don't
 * want to do
 *
 * For example (assume `bN` = `1<<N`)
 * Given the "total" mapping `[[b1, b3], [b2, b4], [b3, b1], [b4, b2]]`
 * The mapping is "total" because:
 * 1. Every input and output is accounted for
 * 2. All combinations are unique
 * 3. No one input maps to multiple outputs and vice versa
 * And, given an offset with all bits set:
 * V = b1 | b2 | b3 | b4
 *
 * Let's explore the issue with removing and setting bits simultaneously:
 * V & ~b1 | b3 = b2 | b3 | b4
 * V & ~b2 | b4 = b3 | b4
 * V & ~b3 | b1 = b1 | b4
 * V & ~b4 | b2 = b1 | b2
 *
 * As you can see, we end up with the wrong result.
 * This is because we're removing a bit that was previously set.
 * And, thus the final result is missing b3 and b4.
 *
 * Now, let's explore the issue with removing the bits first:
 * V & ~b1 = b2 | b3 | b4
 * V & ~b2 = b3 | b4
 * V & ~b3 = b4
 * V & ~b4 = 0
 *
 * And then setting the bits:
 * V | b3 = b3
 * V | b4 = b3 | b4
 * V | b1 = b1 | b3 | b4
 * V | b2 = b1 | b2 | b3 | b4
 *
 * We get the correct result because we're not removing any bits that were
 * previously set thus properly remapping the bits to the new order
 *
 * To collect this into a single operation that can be done simultaneously
 * we must first create a mask for the old bits that are set and a mask for
 * the new bits that are set. Then we can remove the old bits and set the new
 * bits simultaneously in a "single" operation like so:
 * OldMask = b1 | b2 | b3 | b4
 * NewMask = b3 | b4 | b1 | b2
 *
 * So this:
 * V & ~oldMask | newMask
 *
 * Expands to this:
 * V & ~b1 & ~b2 & ~b3 & ~b4 | b3 | b4 | b1 | b2
 *
 * Which becomes this:
 * b1 | b2 | b3 | b4
 *
 * Which is the correct result!
 *
 * @param {bigint} num
 * @param {[bigint, bigint][]} mapping
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "remapBitfield", ({
    enumerable: true,
    get: ()=>remapBitfield
}));
function remapBitfield(num, mapping) {
    // Create masks for the old and new bits that are set
    let oldMask = 0n;
    let newMask = 0n;
    for (let [oldBit, newBit] of mapping){
        if (num & oldBit) {
            oldMask = oldMask | oldBit;
            newMask = newMask | newBit;
        }
    }
    // Remove all old bits
    // Set all new bits
    return num & ~oldMask | newMask;
}


/***/ }),

/***/ 63318:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    elementSelectorParser: ()=>elementSelectorParser,
    default: ()=>resolveDefaultsAtRules
});
const _postcss = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(77001));
const _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(32997));
const _featureFlags = __nccwpck_require__(90);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let getNode = {
    id (node) {
        return _postcssSelectorParser.default.attribute({
            attribute: "id",
            operator: "=",
            value: node.value,
            quoteMark: '"'
        });
    }
};
function minimumImpactSelector(nodes) {
    let rest = nodes.filter((node)=>{
        // Keep non-pseudo nodes
        if (node.type !== "pseudo") return true;
        // Keep pseudo nodes that have subnodes
        // E.g.: `:not()` contains subnodes inside the parentheses
        if (node.nodes.length > 0) return true;
        // Keep pseudo `elements`
        // This implicitly means that we ignore pseudo `classes`
        return node.value.startsWith("::") || [
            ":before",
            ":after",
            ":first-line",
            ":first-letter"
        ].includes(node.value);
    }).reverse();
    let searchFor = new Set([
        "tag",
        "class",
        "id",
        "attribute"
    ]);
    let splitPointIdx = rest.findIndex((n)=>searchFor.has(n.type));
    if (splitPointIdx === -1) return rest.reverse().join("").trim();
    let node = rest[splitPointIdx];
    let bestNode = getNode[node.type] ? getNode[node.type](node) : node;
    rest = rest.slice(0, splitPointIdx);
    let combinatorIdx = rest.findIndex((n)=>n.type === "combinator" && n.value === ">");
    if (combinatorIdx !== -1) {
        rest.splice(0, combinatorIdx);
        rest.unshift(_postcssSelectorParser.default.universal());
    }
    return [
        bestNode,
        ...rest.reverse()
    ].join("").trim();
}
let elementSelectorParser = (0, _postcssSelectorParser.default)((selectors)=>{
    return selectors.map((s)=>{
        let nodes = s.split((n)=>n.type === "combinator" && n.value === " ").pop();
        return minimumImpactSelector(nodes);
    });
});
let cache = new Map();
function extractElementSelector(selector) {
    if (!cache.has(selector)) {
        cache.set(selector, elementSelectorParser.transformSync(selector));
    }
    return cache.get(selector);
}
function resolveDefaultsAtRules({ tailwindConfig  }) {
    return (root)=>{
        let variableNodeMap = new Map();
        /** @type {Set<import('postcss').AtRule>} */ let universals = new Set();
        root.walkAtRules("defaults", (rule)=>{
            if (rule.nodes && rule.nodes.length > 0) {
                universals.add(rule);
                return;
            }
            let variable = rule.params;
            if (!variableNodeMap.has(variable)) {
                variableNodeMap.set(variable, new Set());
            }
            variableNodeMap.get(variable).add(rule.parent);
            rule.remove();
        });
        if ((0, _featureFlags.flagEnabled)(tailwindConfig, "optimizeUniversalDefaults")) {
            for (let universal of universals){
                /** @type {Map<string, Set<string>>} */ let selectorGroups = new Map();
                var _variableNodeMap_get;
                let rules = (_variableNodeMap_get = variableNodeMap.get(universal.params)) !== null && _variableNodeMap_get !== void 0 ? _variableNodeMap_get : [];
                for (let rule of rules){
                    for (let selector of extractElementSelector(rule.selector)){
                        // If selector contains a vendor prefix after a pseudo element or class,
                        // we consider them separately because merging the declarations into
                        // a single rule will cause browsers that do not understand the
                        // vendor prefix to throw out the whole rule
                        let selectorGroupName = selector.includes(":-") || selector.includes("::-") ? selector : "__DEFAULT__";
                        var _selectorGroups_get;
                        let selectors = (_selectorGroups_get = selectorGroups.get(selectorGroupName)) !== null && _selectorGroups_get !== void 0 ? _selectorGroups_get : new Set();
                        selectorGroups.set(selectorGroupName, selectors);
                        selectors.add(selector);
                    }
                }
                if ((0, _featureFlags.flagEnabled)(tailwindConfig, "optimizeUniversalDefaults")) {
                    if (selectorGroups.size === 0) {
                        universal.remove();
                        continue;
                    }
                    for (let [, selectors1] of selectorGroups){
                        let universalRule = _postcss.default.rule({
                            source: universal.source
                        });
                        universalRule.selectors = [
                            ...selectors1
                        ];
                        universalRule.append(universal.nodes.map((node)=>node.clone()));
                        universal.before(universalRule);
                    }
                }
                universal.remove();
            }
        } else if (universals.size) {
            let universalRule1 = _postcss.default.rule({
                selectors: [
                    "*",
                    "::before",
                    "::after"
                ]
            });
            for (let universal1 of universals){
                universalRule1.append(universal1.nodes);
                if (!universalRule1.parent) {
                    universal1.before(universalRule1);
                }
                if (!universalRule1.source) {
                    universalRule1.source = universal1.source;
                }
                universal1.remove();
            }
            let backdropRule = universalRule1.clone({
                selectors: [
                    "::backdrop"
                ]
            });
            universalRule1.after(backdropRule);
        }
    };
}


/***/ }),

/***/ 61555:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    isValidVariantFormatString: ()=>isValidVariantFormatString,
    parseVariant: ()=>parseVariant,
    getFileModifiedMap: ()=>getFileModifiedMap,
    createContext: ()=>createContext,
    getContext: ()=>getContext
});
const _fs = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(57147));
const _url = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(57310));
const _postcss = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(77001));
const _dlv = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(34420));
const _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(32997));
const _transformThemeValue = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(71985));
const _parseObjectStyles = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(52375));
const _prefixSelector = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(74710));
const _isPlainObject = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(20896));
const _escapeClassName = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(11898));
const _nameClass = /*#__PURE__*/ _interopRequireWildcard(__nccwpck_require__(66104));
const _pluginUtils = __nccwpck_require__(89244);
const _corePlugins = __nccwpck_require__(91822);
const _sharedState = /*#__PURE__*/ _interopRequireWildcard(__nccwpck_require__(74035));
const _toPath = __nccwpck_require__(11402);
const _log = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(64368));
const _negateValue = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(76164));
const _isSyntacticallyValidPropertyValue = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(8449));
const _generateRules = __nccwpck_require__(78523);
const _cacheInvalidationJs = __nccwpck_require__(21939);
const _offsetsJs = __nccwpck_require__(95736);
const _featureFlagsJs = __nccwpck_require__(90);
const _formatVariantSelector = __nccwpck_require__(43514);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const VARIANT_TYPES = {
    AddVariant: Symbol.for("ADD_VARIANT"),
    MatchVariant: Symbol.for("MATCH_VARIANT")
};
const VARIANT_INFO = {
    Base: 1 << 0,
    Dynamic: 1 << 1
};
function prefix(context, selector) {
    let prefix = context.tailwindConfig.prefix;
    return typeof prefix === "function" ? prefix(selector) : prefix + selector;
}
function normalizeOptionTypes({ type ="any" , ...options }) {
    let types = [].concat(type);
    return {
        ...options,
        types: types.map((type)=>{
            if (Array.isArray(type)) {
                return {
                    type: type[0],
                    ...type[1]
                };
            }
            return {
                type,
                preferOnConflict: false
            };
        })
    };
}
function parseVariantFormatString(input) {
    /** @type {string[]} */ let parts = [];
    // When parsing whitespace around special characters are insignificant
    // However, _inside_ of a variant they could be
    // Because the selector could look like this
    // @media { &[data-name="foo bar"] }
    // This is why we do not skip whitespace
    let current = "";
    let depth = 0;
    for(let idx = 0; idx < input.length; idx++){
        let char = input[idx];
        if (char === "\\") {
            // Escaped characters are not special
            current += "\\" + input[++idx];
        } else if (char === "{") {
            // Nested rule: start
            ++depth;
            parts.push(current.trim());
            current = "";
        } else if (char === "}") {
            // Nested rule: end
            if (--depth < 0) {
                throw new Error(`Your { and } are unbalanced.`);
            }
            parts.push(current.trim());
            current = "";
        } else {
            // Normal character
            current += char;
        }
    }
    if (current.length > 0) {
        parts.push(current.trim());
    }
    parts = parts.filter((part)=>part !== "");
    return parts;
}
function insertInto(list, value, { before =[]  } = {}) {
    before = [].concat(before);
    if (before.length <= 0) {
        list.push(value);
        return;
    }
    let idx = list.length - 1;
    for (let other of before){
        let iidx = list.indexOf(other);
        if (iidx === -1) continue;
        idx = Math.min(idx, iidx);
    }
    list.splice(idx, 0, value);
}
function parseStyles(styles) {
    if (!Array.isArray(styles)) {
        return parseStyles([
            styles
        ]);
    }
    return styles.flatMap((style)=>{
        let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);
        return isNode ? style : (0, _parseObjectStyles.default)(style);
    });
}
function getClasses(selector, mutate) {
    let parser = (0, _postcssSelectorParser.default)((selectors)=>{
        let allClasses = [];
        if (mutate) {
            mutate(selectors);
        }
        selectors.walkClasses((classNode)=>{
            allClasses.push(classNode.value);
        });
        return allClasses;
    });
    return parser.transformSync(selector);
}
function extractCandidates(node, state = {
    containsNonOnDemandable: false
}, depth = 0) {
    let classes = [];
    // Handle normal rules
    if (node.type === "rule") {
        // Ignore everything inside a :not(...). This allows you to write code like
        // `div:not(.foo)`. If `.foo` is never found in your code, then we used to
        // not generated it. But now we will ignore everything inside a `:not`, so
        // that it still gets generated.
        function ignoreNot(selectors) {
            selectors.walkPseudos((pseudo)=>{
                if (pseudo.value === ":not") {
                    pseudo.remove();
                }
            });
        }
        for (let selector of node.selectors){
            let classCandidates = getClasses(selector, ignoreNot);
            // At least one of the selectors contains non-"on-demandable" candidates.
            if (classCandidates.length === 0) {
                state.containsNonOnDemandable = true;
            }
            for (let classCandidate of classCandidates){
                classes.push(classCandidate);
            }
        }
    } else if (node.type === "atrule") {
        node.walkRules((rule)=>{
            for (let classCandidate of rule.selectors.flatMap((selector)=>getClasses(selector))){
                classes.push(classCandidate);
            }
        });
    }
    if (depth === 0) {
        return [
            state.containsNonOnDemandable || classes.length === 0,
            classes
        ];
    }
    return classes;
}
function withIdentifiers(styles) {
    return parseStyles(styles).flatMap((node)=>{
        let nodeMap = new Map();
        let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);
        // If this isn't "on-demandable", assign it a universal candidate to always include it.
        if (containsNonOnDemandableSelectors) {
            candidates.unshift(_sharedState.NOT_ON_DEMAND);
        }
        // However, it could be that it also contains "on-demandable" candidates.
        // E.g.: `span, .foo {}`, in that case it should still be possible to use
        // `@apply foo` for example.
        return candidates.map((c)=>{
            if (!nodeMap.has(node)) {
                nodeMap.set(node, node);
            }
            return [
                c,
                nodeMap.get(node)
            ];
        });
    });
}
function isValidVariantFormatString(format) {
    return format.startsWith("@") || format.includes("&");
}
function parseVariant(variant) {
    variant = variant.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
    let fns = parseVariantFormatString(variant).map((str)=>{
        if (!str.startsWith("@")) {
            return ({ format  })=>format(str);
        }
        let [, name, params] = /@(.*?)( .+|[({].*)/g.exec(str);
        return ({ wrap  })=>wrap(_postcss.default.atRule({
                name,
                params: params.trim()
            }));
    }).reverse();
    return (api)=>{
        for (let fn of fns){
            fn(api);
        }
    };
}
/**
 *
 * @param {any} tailwindConfig
 * @param {any} context
 * @param {object} param2
 * @param {Offsets} param2.offsets
 */ function buildPluginApi(tailwindConfig, context, { variantList , variantMap , offsets , classList  }) {
    function getConfigValue(path, defaultValue) {
        return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;
    }
    function applyConfiguredPrefix(selector) {
        return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);
    }
    function prefixIdentifier(identifier, options) {
        if (identifier === _sharedState.NOT_ON_DEMAND) {
            return _sharedState.NOT_ON_DEMAND;
        }
        if (!options.respectPrefix) {
            return identifier;
        }
        return context.tailwindConfig.prefix + identifier;
    }
    function resolveThemeValue(path, defaultValue, opts = {}) {
        let parts = (0, _toPath.toPath)(path);
        let value = getConfigValue([
            "theme",
            ...parts
        ], defaultValue);
        return (0, _transformThemeValue.default)(parts[0])(value, opts);
    }
    let variantIdentifier = 0;
    let api = {
        postcss: _postcss.default,
        prefix: applyConfiguredPrefix,
        e: _escapeClassName.default,
        config: getConfigValue,
        theme: resolveThemeValue,
        corePlugins: (path)=>{
            if (Array.isArray(tailwindConfig.corePlugins)) {
                return tailwindConfig.corePlugins.includes(path);
            }
            return getConfigValue([
                "corePlugins",
                path
            ], true);
        },
        variants: ()=>{
            // Preserved for backwards compatibility but not used in v3.0+
            return [];
        },
        addBase (base) {
            for (let [identifier, rule] of withIdentifiers(base)){
                let prefixedIdentifier = prefixIdentifier(identifier, {});
                let offset = offsets.create("base");
                if (!context.candidateRuleMap.has(prefixedIdentifier)) {
                    context.candidateRuleMap.set(prefixedIdentifier, []);
                }
                context.candidateRuleMap.get(prefixedIdentifier).push([
                    {
                        sort: offset,
                        layer: "base"
                    },
                    rule
                ]);
            }
        },
        /**
     * @param {string} group
     * @param {Record<string, string | string[]>} declarations
     */ addDefaults (group, declarations) {
            const groups = {
                [`@defaults ${group}`]: declarations
            };
            for (let [identifier, rule] of withIdentifiers(groups)){
                let prefixedIdentifier = prefixIdentifier(identifier, {});
                if (!context.candidateRuleMap.has(prefixedIdentifier)) {
                    context.candidateRuleMap.set(prefixedIdentifier, []);
                }
                context.candidateRuleMap.get(prefixedIdentifier).push([
                    {
                        sort: offsets.create("defaults"),
                        layer: "defaults"
                    },
                    rule
                ]);
            }
        },
        addComponents (components, options) {
            let defaultOptions = {
                preserveSource: false,
                respectPrefix: true,
                respectImportant: false
            };
            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
            for (let [identifier, rule] of withIdentifiers(components)){
                let prefixedIdentifier = prefixIdentifier(identifier, options);
                classList.add(prefixedIdentifier);
                if (!context.candidateRuleMap.has(prefixedIdentifier)) {
                    context.candidateRuleMap.set(prefixedIdentifier, []);
                }
                context.candidateRuleMap.get(prefixedIdentifier).push([
                    {
                        sort: offsets.create("components"),
                        layer: "components",
                        options
                    },
                    rule
                ]);
            }
        },
        addUtilities (utilities, options) {
            let defaultOptions = {
                preserveSource: false,
                respectPrefix: true,
                respectImportant: true
            };
            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
            for (let [identifier, rule] of withIdentifiers(utilities)){
                let prefixedIdentifier = prefixIdentifier(identifier, options);
                classList.add(prefixedIdentifier);
                if (!context.candidateRuleMap.has(prefixedIdentifier)) {
                    context.candidateRuleMap.set(prefixedIdentifier, []);
                }
                context.candidateRuleMap.get(prefixedIdentifier).push([
                    {
                        sort: offsets.create("utilities"),
                        layer: "utilities",
                        options
                    },
                    rule
                ]);
            }
        },
        matchUtilities: function(utilities, options) {
            let defaultOptions = {
                respectPrefix: true,
                respectImportant: true,
                modifiers: false
            };
            options = normalizeOptionTypes({
                ...defaultOptions,
                ...options
            });
            let offset = offsets.create("utilities");
            for(let identifier in utilities){
                let prefixedIdentifier = prefixIdentifier(identifier, options);
                let rule = utilities[identifier];
                classList.add([
                    prefixedIdentifier,
                    options
                ]);
                function wrapped(modifier, { isOnlyPlugin  }) {
                    let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);
                    if (value === undefined) {
                        return [];
                    }
                    if (!options.types.some(({ type  })=>type === coercedType)) {
                        if (isOnlyPlugin) {
                            _log.default.warn([
                                `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                                `You can safely update it to \`${identifier}-${modifier.replace(coercedType + ":", "")}\`.`
                            ]);
                        } else {
                            return [];
                        }
                    }
                    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {
                        return [];
                    }
                    let extras = {
                        get modifier () {
                            if (!options.modifiers) {
                                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [
                                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                                ]);
                            }
                            return utilityModifier;
                        }
                    };
                    let modifiersEnabled = (0, _featureFlagsJs.flagEnabled)(tailwindConfig, "generalizedModifiers");
                    let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration)=>({
                            [(0, _nameClass.default)(identifier, modifier)]: declaration
                        }));
                    return ruleSets;
                }
                let withOffsets = [
                    {
                        sort: offset,
                        layer: "utilities",
                        options
                    },
                    wrapped
                ];
                if (!context.candidateRuleMap.has(prefixedIdentifier)) {
                    context.candidateRuleMap.set(prefixedIdentifier, []);
                }
                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
            }
        },
        matchComponents: function(components, options) {
            let defaultOptions = {
                respectPrefix: true,
                respectImportant: false,
                modifiers: false
            };
            options = normalizeOptionTypes({
                ...defaultOptions,
                ...options
            });
            let offset = offsets.create("components");
            for(let identifier in components){
                let prefixedIdentifier = prefixIdentifier(identifier, options);
                let rule = components[identifier];
                classList.add([
                    prefixedIdentifier,
                    options
                ]);
                function wrapped(modifier, { isOnlyPlugin  }) {
                    let [value, coercedType, utilityModifier] = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig);
                    if (value === undefined) {
                        return [];
                    }
                    if (!options.types.some(({ type  })=>type === coercedType)) {
                        if (isOnlyPlugin) {
                            _log.default.warn([
                                `Unnecessary typehint \`${coercedType}\` in \`${identifier}-${modifier}\`.`,
                                `You can safely update it to \`${identifier}-${modifier.replace(coercedType + ":", "")}\`.`
                            ]);
                        } else {
                            return [];
                        }
                    }
                    if (!(0, _isSyntacticallyValidPropertyValue.default)(value)) {
                        return [];
                    }
                    let extras = {
                        get modifier () {
                            if (!options.modifiers) {
                                _log.default.warn(`modifier-used-without-options-for-${identifier}`, [
                                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                                ]);
                            }
                            return utilityModifier;
                        }
                    };
                    let modifiersEnabled = (0, _featureFlagsJs.flagEnabled)(tailwindConfig, "generalizedModifiers");
                    let ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map((declaration)=>({
                            [(0, _nameClass.default)(identifier, modifier)]: declaration
                        }));
                    return ruleSets;
                }
                let withOffsets = [
                    {
                        sort: offset,
                        layer: "components",
                        options
                    },
                    wrapped
                ];
                if (!context.candidateRuleMap.has(prefixedIdentifier)) {
                    context.candidateRuleMap.set(prefixedIdentifier, []);
                }
                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
            }
        },
        addVariant (variantName, variantFunctions, options = {}) {
            variantFunctions = [].concat(variantFunctions).map((variantFunction)=>{
                if (typeof variantFunction !== "string") {
                    // Safelist public API functions
                    return (api = {})=>{
                        let { args , modifySelectors , container , separator , wrap , format  } = api;
                        let result = variantFunction(Object.assign({
                            modifySelectors,
                            container,
                            separator
                        }, options.type === VARIANT_TYPES.MatchVariant && {
                            args,
                            wrap,
                            format
                        }));
                        if (typeof result === "string" && !isValidVariantFormatString(result)) {
                            throw new Error(`Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
                        }
                        if (Array.isArray(result)) {
                            return result.filter((variant)=>typeof variant === "string").map((variant)=>parseVariant(variant));
                        }
                        // result may be undefined with legacy variants that use APIs like `modifySelectors`
                        // result may also be a postcss node if someone was returning the result from `modifySelectors`
                        return result && typeof result === "string" && parseVariant(result)(api);
                    };
                }
                if (!isValidVariantFormatString(variantFunction)) {
                    throw new Error(`Your custom variant \`${variantName}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
                }
                return parseVariant(variantFunction);
            });
            insertInto(variantList, variantName, options);
            variantMap.set(variantName, variantFunctions);
            context.variantOptions.set(variantName, options);
        },
        matchVariant (variant, variantFn, options) {
            var _options_id;
            // A unique identifier that "groups" these variants together.
            // This is for internal use only which is why it is not present in the types
            let id = (_options_id = options === null || options === void 0 ? void 0 : options.id) !== null && _options_id !== void 0 ? _options_id : ++variantIdentifier;
            let isSpecial = variant === "@";
            let modifiersEnabled = (0, _featureFlagsJs.flagEnabled)(tailwindConfig, "generalizedModifiers");
            var _options_values;
            for (let [key, value] of Object.entries((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {})){
                if (key === "DEFAULT") continue;
                api.addVariant(isSpecial ? `${variant}${key}` : `${variant}-${key}`, ({ args , container  })=>{
                    return variantFn(value, modifiersEnabled ? {
                        modifier: args === null || args === void 0 ? void 0 : args.modifier,
                        container
                    } : {
                        container
                    });
                }, {
                    ...options,
                    value,
                    id,
                    type: VARIANT_TYPES.MatchVariant,
                    variantInfo: VARIANT_INFO.Base
                });
            }
            var _options_values1;
            let hasDefault = "DEFAULT" in ((_options_values1 = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {});
            api.addVariant(variant, ({ args , container  })=>{
                if ((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE && !hasDefault) {
                    return null;
                }
                var // (JetBrains) plugins.
                _args_value;
                return variantFn((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE ? options.values.DEFAULT : (_args_value = args === null || args === void 0 ? void 0 : args.value) !== null && _args_value !== void 0 ? _args_value : typeof args === "string" ? args : "", modifiersEnabled ? {
                    modifier: args === null || args === void 0 ? void 0 : args.modifier,
                    container
                } : {
                    container
                });
            }, {
                ...options,
                id,
                type: VARIANT_TYPES.MatchVariant,
                variantInfo: VARIANT_INFO.Dynamic
            });
        }
    };
    return api;
}
let fileModifiedMapCache = new WeakMap();
function getFileModifiedMap(context) {
    if (!fileModifiedMapCache.has(context)) {
        fileModifiedMapCache.set(context, new Map());
    }
    return fileModifiedMapCache.get(context);
}
function trackModified(files, fileModifiedMap) {
    let changed = false;
    let mtimesToCommit = new Map();
    for (let file of files){
        var _fs_statSync;
        if (!file) continue;
        let parsed = _url.default.parse(file);
        let pathname = parsed.hash ? parsed.href.replace(parsed.hash, "") : parsed.href;
        pathname = parsed.search ? pathname.replace(parsed.search, "") : pathname;
        let newModified = (_fs_statSync = _fs.default.statSync(decodeURIComponent(pathname), {
            throwIfNoEntry: false
        })) === null || _fs_statSync === void 0 ? void 0 : _fs_statSync.mtimeMs;
        if (!newModified) {
            continue;
        }
        if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {
            changed = true;
        }
        mtimesToCommit.set(file, newModified);
    }
    return [
        changed,
        mtimesToCommit
    ];
}
function extractVariantAtRules(node) {
    node.walkAtRules((atRule)=>{
        if ([
            "responsive",
            "variants"
        ].includes(atRule.name)) {
            extractVariantAtRules(atRule);
            atRule.before(atRule.nodes);
            atRule.remove();
        }
    });
}
function collectLayerPlugins(root) {
    let layerPlugins = [];
    root.each((node)=>{
        if (node.type === "atrule" && [
            "responsive",
            "variants"
        ].includes(node.name)) {
            node.name = "layer";
            node.params = "utilities";
        }
    });
    // Walk @layer rules and treat them like plugins
    root.walkAtRules("layer", (layerRule)=>{
        extractVariantAtRules(layerRule);
        if (layerRule.params === "base") {
            for (let node of layerRule.nodes){
                layerPlugins.push(function({ addBase  }) {
                    addBase(node, {
                        respectPrefix: false
                    });
                });
            }
            layerRule.remove();
        } else if (layerRule.params === "components") {
            for (let node1 of layerRule.nodes){
                layerPlugins.push(function({ addComponents  }) {
                    addComponents(node1, {
                        respectPrefix: false,
                        preserveSource: true
                    });
                });
            }
            layerRule.remove();
        } else if (layerRule.params === "utilities") {
            for (let node2 of layerRule.nodes){
                layerPlugins.push(function({ addUtilities  }) {
                    addUtilities(node2, {
                        respectPrefix: false,
                        preserveSource: true
                    });
                });
            }
            layerRule.remove();
        }
    });
    return layerPlugins;
}
function resolvePlugins(context, root) {
    let corePluginList = Object.entries({
        ..._corePlugins.variantPlugins,
        ..._corePlugins.corePlugins
    }).map(([name, plugin])=>{
        if (!context.tailwindConfig.corePlugins.includes(name)) {
            return null;
        }
        return plugin;
    }).filter(Boolean);
    let userPlugins = context.tailwindConfig.plugins.map((plugin)=>{
        if (plugin.__isOptionsFunction) {
            plugin = plugin();
        }
        return typeof plugin === "function" ? plugin : plugin.handler;
    });
    let layerPlugins = collectLayerPlugins(root);
    // TODO: This is a workaround for backwards compatibility, since custom variants
    // were historically sorted before screen/stackable variants.
    let beforeVariants = [
        _corePlugins.variantPlugins["pseudoElementVariants"],
        _corePlugins.variantPlugins["pseudoClassVariants"],
        _corePlugins.variantPlugins["ariaVariants"],
        _corePlugins.variantPlugins["dataVariants"]
    ];
    let afterVariants = [
        _corePlugins.variantPlugins["supportsVariants"],
        _corePlugins.variantPlugins["directionVariants"],
        _corePlugins.variantPlugins["reducedMotionVariants"],
        _corePlugins.variantPlugins["prefersContrastVariants"],
        _corePlugins.variantPlugins["darkVariants"],
        _corePlugins.variantPlugins["printVariant"],
        _corePlugins.variantPlugins["screenVariants"],
        _corePlugins.variantPlugins["orientationVariants"]
    ];
    return [
        ...corePluginList,
        ...beforeVariants,
        ...userPlugins,
        ...afterVariants,
        ...layerPlugins
    ];
}
function registerPlugins(plugins, context) {
    let variantList = [];
    let variantMap = new Map();
    context.variantMap = variantMap;
    let offsets = new _offsetsJs.Offsets();
    context.offsets = offsets;
    let classList = new Set();
    let pluginApi = buildPluginApi(context.tailwindConfig, context, {
        variantList,
        variantMap,
        offsets,
        classList
    });
    for (let plugin of plugins){
        if (Array.isArray(plugin)) {
            for (let pluginItem of plugin){
                pluginItem(pluginApi);
            }
        } else {
            plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);
        }
    }
    // Make sure to record bit masks for every variant
    offsets.recordVariants(variantList, (variant)=>variantMap.get(variant).length);
    // Build variantMap
    for (let [variantName, variantFunctions] of variantMap.entries()){
        context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx)=>[
                offsets.forVariant(variantName, idx),
                variantFunction
            ]));
    }
    var _context_tailwindConfig_safelist;
    let safelist = ((_context_tailwindConfig_safelist = context.tailwindConfig.safelist) !== null && _context_tailwindConfig_safelist !== void 0 ? _context_tailwindConfig_safelist : []).filter(Boolean);
    if (safelist.length > 0) {
        let checks = [];
        for (let value of safelist){
            if (typeof value === "string") {
                context.changedContent.push({
                    content: value,
                    extension: "html"
                });
                continue;
            }
            if (value instanceof RegExp) {
                _log.default.warn("root-regex", [
                    "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
                    "Update your `safelist` configuration to eliminate this warning.",
                    "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
                ]);
                continue;
            }
            checks.push(value);
        }
        if (checks.length > 0) {
            let patternMatchingCount = new Map();
            let prefixLength = context.tailwindConfig.prefix.length;
            let checkImportantUtils = checks.some((check)=>check.pattern.source.includes("!"));
            for (let util of classList){
                let utils = Array.isArray(util) ? (()=>{
                    let [utilName, options] = util;
                    var _options_values;
                    let values = Object.keys((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {});
                    let classes = values.map((value)=>(0, _nameClass.formatClass)(utilName, value));
                    if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {
                        // This is the normal negated version
                        // e.g. `-inset-1` or `-tw-inset-1`
                        classes = [
                            ...classes,
                            ...classes.map((cls)=>"-" + cls)
                        ];
                        // This is the negated version *after* the prefix
                        // e.g. `tw--inset-1`
                        // The prefix is already attached to util name
                        // So we add the negative after the prefix
                        classes = [
                            ...classes,
                            ...classes.map((cls)=>cls.slice(0, prefixLength) + "-" + cls.slice(prefixLength))
                        ];
                    }
                    if (options.types.some(({ type  })=>type === "color")) {
                        classes = [
                            ...classes,
                            ...classes.flatMap((cls)=>Object.keys(context.tailwindConfig.theme.opacity).map((opacity)=>`${cls}/${opacity}`))
                        ];
                    }
                    if (checkImportantUtils && (options === null || options === void 0 ? void 0 : options.respectImportant)) {
                        classes = [
                            ...classes,
                            ...classes.map((cls)=>"!" + cls)
                        ];
                    }
                    return classes;
                })() : [
                    util
                ];
                for (let util1 of utils){
                    for (let { pattern , variants =[]  } of checks){
                        // RegExp with the /g flag are stateful, so let's reset the last
                        // index pointer to reset the state.
                        pattern.lastIndex = 0;
                        if (!patternMatchingCount.has(pattern)) {
                            patternMatchingCount.set(pattern, 0);
                        }
                        if (!pattern.test(util1)) continue;
                        patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);
                        context.changedContent.push({
                            content: util1,
                            extension: "html"
                        });
                        for (let variant of variants){
                            context.changedContent.push({
                                content: variant + context.tailwindConfig.separator + util1,
                                extension: "html"
                            });
                        }
                    }
                }
            }
            for (let [regex, count] of patternMatchingCount.entries()){
                if (count !== 0) continue;
                _log.default.warn([
                    `The safelist pattern \`${regex}\` doesn't match any Tailwind CSS classes.`,
                    "Fix this pattern or remove it from your `safelist` configuration.",
                    "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
                ]);
            }
        }
    }
    var _context_tailwindConfig_darkMode, _concat_;
    let darkClassName = (_concat_ = [].concat((_context_tailwindConfig_darkMode = context.tailwindConfig.darkMode) !== null && _context_tailwindConfig_darkMode !== void 0 ? _context_tailwindConfig_darkMode : "media")[1]) !== null && _concat_ !== void 0 ? _concat_ : "dark";
    // A list of utilities that are used by certain Tailwind CSS utilities but
    // that don't exist on their own. This will result in them "not existing" and
    // sorting could be weird since you still require them in order to make the
    // host utilities work properly. (Thanks Biology)
    let parasiteUtilities = [
        prefix(context, darkClassName),
        prefix(context, "group"),
        prefix(context, "peer")
    ];
    context.getClassOrder = function getClassOrder(classes) {
        // Non-util classes won't be generated, so we default them to null
        let sortedClassNames = new Map(classes.map((className)=>[
                className,
                null
            ]));
        // Sort all classes in order
        // Non-tailwind classes won't be generated and will be left as `null`
        let rules = (0, _generateRules.generateRules)(new Set(classes), context);
        rules = context.offsets.sort(rules);
        let idx = BigInt(parasiteUtilities.length);
        for (const [, rule] of rules){
            sortedClassNames.set(rule.raws.tailwind.candidate, idx++);
        }
        return classes.map((className)=>{
            var _sortedClassNames_get;
            let order = (_sortedClassNames_get = sortedClassNames.get(className)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : null;
            let parasiteIndex = parasiteUtilities.indexOf(className);
            if (order === null && parasiteIndex !== -1) {
                // This will make sure that it is at the very beginning of the
                // `components` layer which technically means 'before any
                // components'.
                order = BigInt(parasiteIndex);
            }
            return [
                className,
                order
            ];
        });
    };
    // Generate a list of strings for autocompletion purposes, e.g.
    // ['uppercase', 'lowercase', ...]
    context.getClassList = function getClassList(options = {}) {
        let output = [];
        for (let util of classList){
            if (Array.isArray(util)) {
                var _utilOptions_types;
                let [utilName, utilOptions] = util;
                let negativeClasses = [];
                var _utilOptions_modifiers;
                let modifiers = Object.keys((_utilOptions_modifiers = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.modifiers) !== null && _utilOptions_modifiers !== void 0 ? _utilOptions_modifiers : {});
                if (utilOptions === null || utilOptions === void 0 ? void 0 : (_utilOptions_types = utilOptions.types) === null || _utilOptions_types === void 0 ? void 0 : _utilOptions_types.some(({ type  })=>type === "color")) {
                    var _context_tailwindConfig_theme_opacity;
                    modifiers.push(...Object.keys((_context_tailwindConfig_theme_opacity = context.tailwindConfig.theme.opacity) !== null && _context_tailwindConfig_theme_opacity !== void 0 ? _context_tailwindConfig_theme_opacity : {}));
                }
                let metadata = {
                    modifiers
                };
                let includeMetadata = options.includeMetadata && modifiers.length > 0;
                var _utilOptions_values;
                for (let [key, value] of Object.entries((_utilOptions_values = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.values) !== null && _utilOptions_values !== void 0 ? _utilOptions_values : {})){
                    // Ignore undefined and null values
                    if (value == null) {
                        continue;
                    }
                    let cls = (0, _nameClass.formatClass)(utilName, key);
                    output.push(includeMetadata ? [
                        cls,
                        metadata
                    ] : cls);
                    if ((utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.supportsNegativeValues) && (0, _negateValue.default)(value)) {
                        let cls1 = (0, _nameClass.formatClass)(utilName, `-${key}`);
                        negativeClasses.push(includeMetadata ? [
                            cls1,
                            metadata
                        ] : cls1);
                    }
                }
                output.push(...negativeClasses);
            } else {
                output.push(util);
            }
        }
        return output;
    };
    // Generate a list of available variants with meta information of the type of variant.
    context.getVariants = function getVariants() {
        let result = [];
        for (let [name, options] of context.variantOptions.entries()){
            if (options.variantInfo === VARIANT_INFO.Base) continue;
            var _options_values;
            result.push({
                name,
                isArbitrary: options.type === Symbol.for("MATCH_VARIANT"),
                values: Object.keys((_options_values = options.values) !== null && _options_values !== void 0 ? _options_values : {}),
                hasDash: name !== "@",
                selectors ({ modifier , value  } = {}) {
                    let candidate = "__TAILWIND_PLACEHOLDER__";
                    let rule = _postcss.default.rule({
                        selector: `.${candidate}`
                    });
                    let container = _postcss.default.root({
                        nodes: [
                            rule.clone()
                        ]
                    });
                    let before = container.toString();
                    var _context_variantMap_get;
                    let fns = ((_context_variantMap_get = context.variantMap.get(name)) !== null && _context_variantMap_get !== void 0 ? _context_variantMap_get : []).flatMap(([_, fn])=>fn);
                    let formatStrings = [];
                    for (let fn of fns){
                        var _options_values;
                        let localFormatStrings = [];
                        var _options_values_value;
                        let api = {
                            args: {
                                modifier,
                                value: (_options_values_value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[value]) !== null && _options_values_value !== void 0 ? _options_values_value : value
                            },
                            separator: context.tailwindConfig.separator,
                            modifySelectors (modifierFunction) {
                                // Run the modifierFunction over each rule
                                container.each((rule)=>{
                                    if (rule.type !== "rule") {
                                        return;
                                    }
                                    rule.selectors = rule.selectors.map((selector)=>{
                                        return modifierFunction({
                                            get className () {
                                                return (0, _generateRules.getClassNameFromSelector)(selector);
                                            },
                                            selector
                                        });
                                    });
                                });
                                return container;
                            },
                            format (str) {
                                localFormatStrings.push(str);
                            },
                            wrap (wrapper) {
                                localFormatStrings.push(`@${wrapper.name} ${wrapper.params} { & }`);
                            },
                            container
                        };
                        let ruleWithVariant = fn(api);
                        if (localFormatStrings.length > 0) {
                            formatStrings.push(localFormatStrings);
                        }
                        if (Array.isArray(ruleWithVariant)) {
                            for (let variantFunction of ruleWithVariant){
                                localFormatStrings = [];
                                variantFunction(api);
                                formatStrings.push(localFormatStrings);
                            }
                        }
                    }
                    // Reverse engineer the result of the `container`
                    let manualFormatStrings = [];
                    let after = container.toString();
                    if (before !== after) {
                        // Figure out all selectors
                        container.walkRules((rule)=>{
                            let modified = rule.selector;
                            // Rebuild the base selector, this is what plugin authors would do
                            // as well. E.g.: `${variant}${separator}${className}`.
                            // However, plugin authors probably also prepend or append certain
                            // classes, pseudos, ids, ...
                            let rebuiltBase = (0, _postcssSelectorParser.default)((selectors)=>{
                                selectors.walkClasses((classNode)=>{
                                    classNode.value = `${name}${context.tailwindConfig.separator}${classNode.value}`;
                                });
                            }).processSync(modified);
                            // Now that we know the original selector, the new selector, and
                            // the rebuild part in between, we can replace the part that plugin
                            // authors need to rebuild with `&`, and eventually store it in the
                            // collectedFormats. Similar to what `format('...')` would do.
                            //
                            // E.g.:
                            //                   variant: foo
                            //                  selector: .markdown > p
                            //      modified (by plugin): .foo .foo\\:markdown > p
                            //    rebuiltBase (internal): .foo\\:markdown > p
                            //                    format: .foo &
                            manualFormatStrings.push(modified.replace(rebuiltBase, "&").replace(candidate, "&"));
                        });
                        // Figure out all atrules
                        container.walkAtRules((atrule)=>{
                            manualFormatStrings.push(`@${atrule.name} (${atrule.params}) { & }`);
                        });
                    }
                    var _options_values1;
                    let isArbitraryVariant = !(value in ((_options_values1 = options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {}));
                    formatStrings = formatStrings.map((format)=>format.map((str)=>({
                                format: str,
                                isArbitraryVariant
                            })));
                    manualFormatStrings = manualFormatStrings.map((format)=>({
                            format,
                            isArbitraryVariant
                        }));
                    let opts = {
                        candidate,
                        context
                    };
                    let result = formatStrings.map((formats)=>(0, _formatVariantSelector.finalizeSelector)(`.${candidate}`, (0, _formatVariantSelector.formatVariantSelector)(formats, opts), opts).replace(`.${candidate}`, "&").replace("{ & }", "").trim());
                    if (manualFormatStrings.length > 0) {
                        result.push((0, _formatVariantSelector.formatVariantSelector)(manualFormatStrings, opts).toString().replace(`.${candidate}`, "&"));
                    }
                    return result;
                }
            });
        }
        return result;
    };
}
/**
 * Mark as class as retroactively invalid
 *
 *
 * @param {string} candidate
 */ function markInvalidUtilityCandidate(context, candidate) {
    if (!context.classCache.has(candidate)) {
        return;
    }
    // Mark this as not being a real utility
    context.notClassCache.add(candidate);
    // Remove it from any candidate-specific caches
    context.classCache.delete(candidate);
    context.applyClassCache.delete(candidate);
    context.candidateRuleMap.delete(candidate);
    context.candidateRuleCache.delete(candidate);
    // Ensure the stylesheet gets rebuilt
    context.stylesheetCache = null;
}
/**
 * Mark as class as retroactively invalid
 *
 * @param {import('postcss').Node} node
 */ function markInvalidUtilityNode(context, node) {
    let candidate = node.raws.tailwind.candidate;
    if (!candidate) {
        return;
    }
    for (const entry of context.ruleCache){
        if (entry[1].raws.tailwind.candidate === candidate) {
            context.ruleCache.delete(entry);
        // context.postCssNodeCache.delete(node)
        }
    }
    markInvalidUtilityCandidate(context, candidate);
}
function createContext(tailwindConfig, changedContent = [], root = _postcss.default.root()) {
    var _tailwindConfig_blocklist;
    let context = {
        disposables: [],
        ruleCache: new Set(),
        candidateRuleCache: new Map(),
        classCache: new Map(),
        applyClassCache: new Map(),
        // Seed the not class cache with the blocklist (which is only strings)
        notClassCache: new Set((_tailwindConfig_blocklist = tailwindConfig.blocklist) !== null && _tailwindConfig_blocklist !== void 0 ? _tailwindConfig_blocklist : []),
        postCssNodeCache: new Map(),
        candidateRuleMap: new Map(),
        tailwindConfig,
        changedContent: changedContent,
        variantMap: new Map(),
        stylesheetCache: null,
        variantOptions: new Map(),
        markInvalidUtilityCandidate: (candidate)=>markInvalidUtilityCandidate(context, candidate),
        markInvalidUtilityNode: (node)=>markInvalidUtilityNode(context, node)
    };
    let resolvedPlugins = resolvePlugins(context, root);
    registerPlugins(resolvedPlugins, context);
    return context;
}
let contextMap = _sharedState.contextMap;
let configContextMap = _sharedState.configContextMap;
let contextSourcesMap = _sharedState.contextSourcesMap;
function getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {
    let sourcePath = result.opts.from;
    let isConfigFile = userConfigPath !== null;
    _sharedState.env.DEBUG && console.log("Source path:", sourcePath);
    let existingContext;
    if (isConfigFile && contextMap.has(sourcePath)) {
        existingContext = contextMap.get(sourcePath);
    } else if (configContextMap.has(tailwindConfigHash)) {
        let context = configContextMap.get(tailwindConfigHash);
        contextSourcesMap.get(context).add(sourcePath);
        contextMap.set(sourcePath, context);
        existingContext = context;
    }
    let cssDidChange = (0, _cacheInvalidationJs.hasContentChanged)(sourcePath, root);
    // If there's already a context in the cache and we don't need to
    // reset the context, return the cached context.
    if (existingContext) {
        let [contextDependenciesChanged, mtimesToCommit] = trackModified([
            ...contextDependencies
        ], getFileModifiedMap(existingContext));
        if (!contextDependenciesChanged && !cssDidChange) {
            return [
                existingContext,
                false,
                mtimesToCommit
            ];
        }
    }
    // If this source is in the context map, get the old context.
    // Remove this source from the context sources for the old context,
    // and clean up that context if no one else is using it. This can be
    // called by many processes in rapid succession, so we check for presence
    // first because the first process to run this code will wipe it out first.
    if (contextMap.has(sourcePath)) {
        let oldContext = contextMap.get(sourcePath);
        if (contextSourcesMap.has(oldContext)) {
            contextSourcesMap.get(oldContext).delete(sourcePath);
            if (contextSourcesMap.get(oldContext).size === 0) {
                contextSourcesMap.delete(oldContext);
                for (let [tailwindConfigHash1, context1] of configContextMap){
                    if (context1 === oldContext) {
                        configContextMap.delete(tailwindConfigHash1);
                    }
                }
                for (let disposable of oldContext.disposables.splice(0)){
                    disposable(oldContext);
                }
            }
        }
    }
    _sharedState.env.DEBUG && console.log("Setting up new context...");
    let context2 = createContext(tailwindConfig, [], root);
    Object.assign(context2, {
        userConfigPath
    });
    let [, mtimesToCommit1] = trackModified([
        ...contextDependencies
    ], getFileModifiedMap(context2));
    // ---
    // Update all context tracking state
    configContextMap.set(tailwindConfigHash, context2);
    contextMap.set(sourcePath, context2);
    if (!contextSourcesMap.has(context2)) {
        contextSourcesMap.set(context2, new Set());
    }
    contextSourcesMap.get(context2).add(sourcePath);
    return [
        context2,
        true,
        mtimesToCommit1
    ];
}


/***/ }),

/***/ 68326:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
// @ts-check

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>setupTrackingContext
}));
const _fs = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(57147));
const _quickLru = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(49273));
const _hashConfig = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(66608));
const _getModuleDependencies = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(70528));
const _resolveConfig = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(65528));
const _resolveConfigPath = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(10184));
const _setupContextUtils = __nccwpck_require__(61555);
const _parseDependency = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(71315));
const _validateConfigJs = __nccwpck_require__(97277);
const _contentJs = __nccwpck_require__(63890);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let configPathCache = new _quickLru.default({
    maxSize: 100
});
let candidateFilesCache = new WeakMap();
function getCandidateFiles(context, tailwindConfig) {
    if (candidateFilesCache.has(context)) {
        return candidateFilesCache.get(context);
    }
    let candidateFiles = (0, _contentJs.parseCandidateFiles)(context, tailwindConfig);
    return candidateFilesCache.set(context, candidateFiles).get(context);
}
// Get the config object based on a path
function getTailwindConfig(configOrPath) {
    let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);
    if (userConfigPath !== null) {
        let [prevConfig, prevConfigHash, prevDeps, prevModified] = configPathCache.get(userConfigPath) || [];
        let newDeps = (0, _getModuleDependencies.default)(userConfigPath).map((dep)=>dep.file);
        let modified = false;
        let newModified = new Map();
        for (let file of newDeps){
            let time = _fs.default.statSync(file).mtimeMs;
            newModified.set(file, time);
            if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {
                modified = true;
            }
        }
        // It hasn't changed (based on timestamps)
        if (!modified) {
            return [
                prevConfig,
                userConfigPath,
                prevConfigHash,
                prevDeps
            ];
        }
        // It has changed (based on timestamps), or first run
        for (let file1 of newDeps){
            delete require.cache[file1];
        }
        let newConfig = (0, _resolveConfig.default)(require(userConfigPath));
        newConfig = (0, _validateConfigJs.validateConfig)(newConfig);
        let newHash = (0, _hashConfig.default)(newConfig);
        configPathCache.set(userConfigPath, [
            newConfig,
            newHash,
            newDeps,
            newModified
        ]);
        return [
            newConfig,
            userConfigPath,
            newHash,
            newDeps
        ];
    }
    // It's a plain object, not a path
    let newConfig1 = (0, _resolveConfig.default)(configOrPath.config === undefined ? configOrPath : configOrPath.config);
    newConfig1 = (0, _validateConfigJs.validateConfig)(newConfig1);
    return [
        newConfig1,
        null,
        (0, _hashConfig.default)(newConfig1),
        []
    ];
}
function setupTrackingContext(configOrPath) {
    return ({ tailwindDirectives , registerDependency  })=>{
        return (root, result)=>{
            let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);
            let contextDependencies = new Set(configDependencies);
            // If there are no @tailwind or @apply rules, we don't consider this CSS
            // file or its dependencies to be dependencies of the context. Can reuse
            // the context even if they change. We may want to think about `@layer`
            // being part of this trigger too, but it's tough because it's impossible
            // for a layer in one file to end up in the actual @tailwind rule in
            // another file since independent sources are effectively isolated.
            if (tailwindDirectives.size > 0) {
                // Add current css file as a context dependencies.
                contextDependencies.add(result.opts.from);
                // Add all css @import dependencies as context dependencies.
                for (let message of result.messages){
                    if (message.type === "dependency") {
                        contextDependencies.add(message.file);
                    }
                }
            }
            let [context, , mTimesToCommit] = (0, _setupContextUtils.getContext)(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);
            let fileModifiedMap = (0, _setupContextUtils.getFileModifiedMap)(context);
            let candidateFiles = getCandidateFiles(context, tailwindConfig);
            // If there are no @tailwind or @apply rules, we don't consider this CSS file or it's
            // dependencies to be dependencies of the context. Can reuse the context even if they change.
            // We may want to think about `@layer` being part of this trigger too, but it's tough
            // because it's impossible for a layer in one file to end up in the actual @tailwind rule
            // in another file since independent sources are effectively isolated.
            if (tailwindDirectives.size > 0) {
                // Add template paths as postcss dependencies.
                for (let contentPath of candidateFiles){
                    for (let dependency of (0, _parseDependency.default)(contentPath)){
                        registerDependency(dependency);
                    }
                }
                let [changedContent, contentMTimesToCommit] = (0, _contentJs.resolvedChangedContent)(context, candidateFiles, fileModifiedMap);
                for (let content of changedContent){
                    context.changedContent.push(content);
                }
                // Add the mtimes of the content files to the commit list
                // We can overwrite the existing values because unconditionally
                // This is because:
                // 1. Most of the files here won't be in the map yet
                // 2. If they are that means it's a context dependency
                // and we're reading this after the context. This means
                // that the mtime we just read is strictly >= the context
                // mtime. Unless the user / os is doing something weird
                // in which the mtime would be going backwards. If that
                // happens there's already going to be problems.
                for (let [path, mtime] of contentMTimesToCommit.entries()){
                    mTimesToCommit.set(path, mtime);
                }
            }
            for (let file of configDependencies){
                registerDependency({
                    type: "dependency",
                    file
                });
            }
            // "commit" the new modified time for all context deps
            // We do this here because we want content tracking to
            // read the "old" mtime even when it's a context dependency.
            for (let [path1, mtime1] of mTimesToCommit.entries()){
                fileModifiedMap.set(path1, mtime1);
            }
            return context;
        };
    };
}


/***/ }),

/***/ 74035:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    env: ()=>env,
    contextMap: ()=>contextMap,
    configContextMap: ()=>configContextMap,
    contextSourcesMap: ()=>contextSourcesMap,
    sourceHashMap: ()=>sourceHashMap,
    NOT_ON_DEMAND: ()=>NOT_ON_DEMAND,
    NONE: ()=>NONE,
    resolveDebug: ()=>resolveDebug
});
const _packageJson = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(61214));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let OXIDE_DEFAULT_ENABLED = _packageJson.default.tailwindcss.engine === "oxide";
const env = {
    NODE_ENV: process.env.NODE_ENV,
    DEBUG: resolveDebug(process.env.DEBUG),
    ENGINE: _packageJson.default.tailwindcss.engine,
    OXIDE: resolveBoolean(process.env.OXIDE, OXIDE_DEFAULT_ENABLED)
};
const contextMap = new Map();
const configContextMap = new Map();
const contextSourcesMap = new Map();
const sourceHashMap = new Map();
const NOT_ON_DEMAND = new String("*");
const NONE = Symbol("__NONE__");
function resolveBoolean(value, defaultValue) {
    if (value === undefined) {
        return defaultValue;
    }
    if (value === "0" || value === "false") {
        return false;
    }
    return true;
}
function resolveDebug(debug) {
    if (debug === undefined) {
        return false;
    }
    // Environment variables are strings, so convert to boolean
    if (debug === "true" || debug === "1") {
        return true;
    }
    if (debug === "false" || debug === "0") {
        return false;
    }
    // Keep the debug convention into account:
    // DEBUG=* -> This enables all debug modes
    // DEBUG=projectA,projectB,projectC -> This enables debug for projectA, projectB and projectC
    // DEBUG=projectA:* -> This enables all debug modes for projectA (if you have sub-types)
    // DEBUG=projectA,-projectB -> This enables debug for projectA and explicitly disables it for projectB
    if (debug === "*") {
        return true;
    }
    let debuggers = debug.split(",").map((d)=>d.split(":")[0]);
    // Ignoring tailwindcss
    if (debuggers.includes("-tailwindcss")) {
        return false;
    }
    // Including tailwindcss
    if (debuggers.includes("tailwindcss")) {
        return true;
    }
    return false;
}


/***/ }),

/***/ 79342:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>_default
}));
const _normalizeScreens = __nccwpck_require__(68617);
const _buildMediaQuery = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(11321));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _default({ tailwindConfig: { theme  }  }) {
    return function(css) {
        css.walkAtRules("screen", (atRule)=>{
            let screen = atRule.params;
            let screens = (0, _normalizeScreens.normalizeScreens)(theme.screens);
            let screenDefinition = screens.find(({ name  })=>name === screen);
            if (!screenDefinition) {
                throw atRule.error(`No \`${screen}\` screen found.`);
            }
            atRule.name = "media";
            atRule.params = (0, _buildMediaQuery.default)(screenDefinition);
        });
    };
}


/***/ }),

/***/ 57885:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

module.exports = __nccwpck_require__(68805);


/***/ }),

/***/ 68805:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const _setupTrackingContext = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(68326));
const _processTailwindFeatures = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(76383));
const _sharedState = __nccwpck_require__(74035);
const _findAtConfigPath = __nccwpck_require__(11496);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
module.exports = function tailwindcss(configOrPath) {
    return {
        postcssPlugin: "tailwindcss",
        plugins: [
            _sharedState.env.DEBUG && function(root) {
                console.log("\n");
                console.time("JIT TOTAL");
                return root;
            },
            function(root, result) {
                var _findAtConfigPath1;
                // Use the path for the `@config` directive if it exists, otherwise use the
                // path for the file being processed
                configOrPath = (_findAtConfigPath1 = (0, _findAtConfigPath.findAtConfigPath)(root, result)) !== null && _findAtConfigPath1 !== void 0 ? _findAtConfigPath1 : configOrPath;
                let context = (0, _setupTrackingContext.default)(configOrPath);
                if (root.type === "document") {
                    let roots = root.nodes.filter((node)=>node.type === "root");
                    for (const root1 of roots){
                        if (root1.type === "root") {
                            (0, _processTailwindFeatures.default)(context)(root1, result);
                        }
                    }
                    return;
                }
                (0, _processTailwindFeatures.default)(context)(root, result);
            },
            _sharedState.env.OXIDE && function lightningCssPlugin(_root, result) {
                let postcss = __nccwpck_require__(77001);
                let lightningcss = __nccwpck_require__(10309);
                let browserslist = __nccwpck_require__(55478);
                try {
                    let transformed = lightningcss.transform({
                        filename: result.opts.from,
                        code: Buffer.from(result.root.toString()),
                        minify: false,
                        sourceMap: !!result.map,
                        inputSourceMap: result.map ? result.map.toString() : undefined,
                        targets: typeof process !== "undefined" && process.env.JEST_WORKER_ID ? {
                            chrome: 106 << 16
                        } : lightningcss.browserslistToTargets(browserslist((__nccwpck_require__(61214).browserslist))),
                        drafts: {
                            nesting: true,
                            customMedia: true
                        }
                    });
                    var _result_map;
                    result.map = Object.assign((_result_map = result.map) !== null && _result_map !== void 0 ? _result_map : {}, {
                        toJSON () {
                            return transformed.map.toJSON();
                        },
                        toString () {
                            return transformed.map.toString();
                        }
                    });
                    result.root = postcss.parse(transformed.code.toString("utf8"));
                } catch (err) {
                    if (typeof process !== "undefined" && process.env.JEST_WORKER_ID) {
                        let lines = err.source.split("\n");
                        err = new Error([
                            "Error formatting using Lightning CSS:",
                            "",
                            ...[
                                "```css",
                                ...lines.slice(Math.max(err.loc.line - 3, 0), err.loc.line),
                                " ".repeat(err.loc.column - 1) + "^-- " + err.toString(),
                                ...lines.slice(err.loc.line, err.loc.line + 2),
                                "```"
                            ]
                        ].join("\n"));
                    }
                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(err, lightningCssPlugin);
                    }
                    throw err;
                }
            },
            _sharedState.env.DEBUG && function(root) {
                console.timeEnd("JIT TOTAL");
                console.log("\n");
                return root;
            }
        ].filter(Boolean)
    };
};
module.exports.postcss = true;


/***/ }),

/***/ 76383:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>processTailwindFeatures
}));
const _normalizeTailwindDirectives = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(87165));
const _expandTailwindAtRules = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(84421));
const _expandApplyAtRules = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(13464));
const _evaluateTailwindFunctions = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(64717));
const _substituteScreenAtRules = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(79342));
const _resolveDefaultsAtRules = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(63318));
const _collapseAdjacentRules = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(80208));
const _collapseDuplicateDeclarations = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(33155));
const _partitionApplyAtRules = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(24769));
const _detectNesting = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(59015));
const _setupContextUtils = __nccwpck_require__(61555);
const _featureFlags = __nccwpck_require__(90);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function processTailwindFeatures(setupContext) {
    return function(root, result) {
        let { tailwindDirectives , applyDirectives  } = (0, _normalizeTailwindDirectives.default)(root);
        (0, _detectNesting.default)()(root, result);
        // Partition apply rules that are found in the css
        // itself.
        (0, _partitionApplyAtRules.default)()(root, result);
        let context = setupContext({
            tailwindDirectives,
            applyDirectives,
            registerDependency (dependency) {
                result.messages.push({
                    plugin: "tailwindcss",
                    parent: result.opts.from,
                    ...dependency
                });
            },
            createContext (tailwindConfig, changedContent) {
                return (0, _setupContextUtils.createContext)(tailwindConfig, changedContent, root);
            }
        })(root, result);
        if (context.tailwindConfig.separator === "-") {
            throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
        }
        (0, _featureFlags.issueFlagNotices)(context.tailwindConfig);
        (0, _expandTailwindAtRules.default)(context)(root, result);
        // Partition apply rules that are generated by
        // addComponents, addUtilities and so on.
        (0, _partitionApplyAtRules.default)()(root, result);
        (0, _expandApplyAtRules.default)(context)(root, result);
        (0, _evaluateTailwindFunctions.default)(context)(root, result);
        (0, _substituteScreenAtRules.default)(context)(root, result);
        (0, _resolveDefaultsAtRules.default)(context)(root, result);
        (0, _collapseAdjacentRules.default)(context)(root, result);
        (0, _collapseDuplicateDeclarations.default)(context)(root, result);
    };
}


/***/ }),

/***/ 90906:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>_default
}));
const _log = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(64368));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function warn({ version , from , to  }) {
    _log.default.warn(`${from}-color-renamed`, [
        `As of Tailwind CSS ${version}, \`${from}\` has been renamed to \`${to}\`.`,
        "Update your configuration file to silence this warning."
    ]);
}
const _default = {
    inherit: "inherit",
    current: "currentColor",
    transparent: "transparent",
    black: "#000",
    white: "#fff",
    slate: {
        50: "#f8fafc",
        100: "#f1f5f9",
        200: "#e2e8f0",
        300: "#cbd5e1",
        400: "#94a3b8",
        500: "#64748b",
        600: "#475569",
        700: "#334155",
        800: "#1e293b",
        900: "#0f172a"
    },
    gray: {
        50: "#f9fafb",
        100: "#f3f4f6",
        200: "#e5e7eb",
        300: "#d1d5db",
        400: "#9ca3af",
        500: "#6b7280",
        600: "#4b5563",
        700: "#374151",
        800: "#1f2937",
        900: "#111827"
    },
    zinc: {
        50: "#fafafa",
        100: "#f4f4f5",
        200: "#e4e4e7",
        300: "#d4d4d8",
        400: "#a1a1aa",
        500: "#71717a",
        600: "#52525b",
        700: "#3f3f46",
        800: "#27272a",
        900: "#18181b"
    },
    neutral: {
        50: "#fafafa",
        100: "#f5f5f5",
        200: "#e5e5e5",
        300: "#d4d4d4",
        400: "#a3a3a3",
        500: "#737373",
        600: "#525252",
        700: "#404040",
        800: "#262626",
        900: "#171717"
    },
    stone: {
        50: "#fafaf9",
        100: "#f5f5f4",
        200: "#e7e5e4",
        300: "#d6d3d1",
        400: "#a8a29e",
        500: "#78716c",
        600: "#57534e",
        700: "#44403c",
        800: "#292524",
        900: "#1c1917"
    },
    red: {
        50: "#fef2f2",
        100: "#fee2e2",
        200: "#fecaca",
        300: "#fca5a5",
        400: "#f87171",
        500: "#ef4444",
        600: "#dc2626",
        700: "#b91c1c",
        800: "#991b1b",
        900: "#7f1d1d"
    },
    orange: {
        50: "#fff7ed",
        100: "#ffedd5",
        200: "#fed7aa",
        300: "#fdba74",
        400: "#fb923c",
        500: "#f97316",
        600: "#ea580c",
        700: "#c2410c",
        800: "#9a3412",
        900: "#7c2d12"
    },
    amber: {
        50: "#fffbeb",
        100: "#fef3c7",
        200: "#fde68a",
        300: "#fcd34d",
        400: "#fbbf24",
        500: "#f59e0b",
        600: "#d97706",
        700: "#b45309",
        800: "#92400e",
        900: "#78350f"
    },
    yellow: {
        50: "#fefce8",
        100: "#fef9c3",
        200: "#fef08a",
        300: "#fde047",
        400: "#facc15",
        500: "#eab308",
        600: "#ca8a04",
        700: "#a16207",
        800: "#854d0e",
        900: "#713f12"
    },
    lime: {
        50: "#f7fee7",
        100: "#ecfccb",
        200: "#d9f99d",
        300: "#bef264",
        400: "#a3e635",
        500: "#84cc16",
        600: "#65a30d",
        700: "#4d7c0f",
        800: "#3f6212",
        900: "#365314"
    },
    green: {
        50: "#f0fdf4",
        100: "#dcfce7",
        200: "#bbf7d0",
        300: "#86efac",
        400: "#4ade80",
        500: "#22c55e",
        600: "#16a34a",
        700: "#15803d",
        800: "#166534",
        900: "#14532d"
    },
    emerald: {
        50: "#ecfdf5",
        100: "#d1fae5",
        200: "#a7f3d0",
        300: "#6ee7b7",
        400: "#34d399",
        500: "#10b981",
        600: "#059669",
        700: "#047857",
        800: "#065f46",
        900: "#064e3b"
    },
    teal: {
        50: "#f0fdfa",
        100: "#ccfbf1",
        200: "#99f6e4",
        300: "#5eead4",
        400: "#2dd4bf",
        500: "#14b8a6",
        600: "#0d9488",
        700: "#0f766e",
        800: "#115e59",
        900: "#134e4a"
    },
    cyan: {
        50: "#ecfeff",
        100: "#cffafe",
        200: "#a5f3fc",
        300: "#67e8f9",
        400: "#22d3ee",
        500: "#06b6d4",
        600: "#0891b2",
        700: "#0e7490",
        800: "#155e75",
        900: "#164e63"
    },
    sky: {
        50: "#f0f9ff",
        100: "#e0f2fe",
        200: "#bae6fd",
        300: "#7dd3fc",
        400: "#38bdf8",
        500: "#0ea5e9",
        600: "#0284c7",
        700: "#0369a1",
        800: "#075985",
        900: "#0c4a6e"
    },
    blue: {
        50: "#eff6ff",
        100: "#dbeafe",
        200: "#bfdbfe",
        300: "#93c5fd",
        400: "#60a5fa",
        500: "#3b82f6",
        600: "#2563eb",
        700: "#1d4ed8",
        800: "#1e40af",
        900: "#1e3a8a"
    },
    indigo: {
        50: "#eef2ff",
        100: "#e0e7ff",
        200: "#c7d2fe",
        300: "#a5b4fc",
        400: "#818cf8",
        500: "#6366f1",
        600: "#4f46e5",
        700: "#4338ca",
        800: "#3730a3",
        900: "#312e81"
    },
    violet: {
        50: "#f5f3ff",
        100: "#ede9fe",
        200: "#ddd6fe",
        300: "#c4b5fd",
        400: "#a78bfa",
        500: "#8b5cf6",
        600: "#7c3aed",
        700: "#6d28d9",
        800: "#5b21b6",
        900: "#4c1d95"
    },
    purple: {
        50: "#faf5ff",
        100: "#f3e8ff",
        200: "#e9d5ff",
        300: "#d8b4fe",
        400: "#c084fc",
        500: "#a855f7",
        600: "#9333ea",
        700: "#7e22ce",
        800: "#6b21a8",
        900: "#581c87"
    },
    fuchsia: {
        50: "#fdf4ff",
        100: "#fae8ff",
        200: "#f5d0fe",
        300: "#f0abfc",
        400: "#e879f9",
        500: "#d946ef",
        600: "#c026d3",
        700: "#a21caf",
        800: "#86198f",
        900: "#701a75"
    },
    pink: {
        50: "#fdf2f8",
        100: "#fce7f3",
        200: "#fbcfe8",
        300: "#f9a8d4",
        400: "#f472b6",
        500: "#ec4899",
        600: "#db2777",
        700: "#be185d",
        800: "#9d174d",
        900: "#831843"
    },
    rose: {
        50: "#fff1f2",
        100: "#ffe4e6",
        200: "#fecdd3",
        300: "#fda4af",
        400: "#fb7185",
        500: "#f43f5e",
        600: "#e11d48",
        700: "#be123c",
        800: "#9f1239",
        900: "#881337"
    },
    get lightBlue () {
        warn({
            version: "v2.2",
            from: "lightBlue",
            to: "sky"
        });
        return this.sky;
    },
    get warmGray () {
        warn({
            version: "v3.0",
            from: "warmGray",
            to: "stone"
        });
        return this.stone;
    },
    get trueGray () {
        warn({
            version: "v3.0",
            from: "trueGray",
            to: "neutral"
        });
        return this.neutral;
    },
    get coolGray () {
        warn({
            version: "v3.0",
            from: "coolGray",
            to: "gray"
        });
        return this.gray;
    },
    get blueGray () {
        warn({
            version: "v3.0",
            from: "blueGray",
            to: "slate"
        });
        return this.slate;
    }
};


/***/ }),

/***/ 65528:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>resolveConfig
}));
const _resolveConfig = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(55530));
const _getAllConfigs = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(94867));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function resolveConfig(...configs) {
    let [, ...defaultConfigs] = (0, _getAllConfigs.default)(configs[0]);
    return (0, _resolveConfig.default)([
        ...configs,
        ...defaultConfigs
    ]);
}


/***/ }),

/***/ 30674:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>bigSign
}));
function bigSign(bigIntValue) {
    return (bigIntValue > 0n) - (bigIntValue < 0n);
}


/***/ }),

/***/ 11321:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>buildMediaQuery
}));
function buildMediaQuery(screens) {
    screens = Array.isArray(screens) ? screens : [
        screens
    ];
    return screens.map((screen)=>{
        let values = screen.values.map((screen)=>{
            if (screen.raw !== undefined) {
                return screen.raw;
            }
            return [
                screen.min && `(min-width: ${screen.min})`,
                screen.max && `(max-width: ${screen.max})`
            ].filter(Boolean).join(" and ");
        });
        return screen.not ? `not all and ${values}` : values;
    }).join(", ");
}


/***/ }),

/***/ 45706:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "cloneDeep", ({
    enumerable: true,
    get: ()=>cloneDeep
}));
function cloneDeep(value) {
    if (Array.isArray(value)) {
        return value.map((child)=>cloneDeep(child));
    }
    if (typeof value === "object" && value !== null) {
        return Object.fromEntries(Object.entries(value).map(([k, v])=>[
                k,
                cloneDeep(v)
            ]));
    }
    return value;
}


/***/ }),

/***/ 39811:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>cloneNodes
}));
function cloneNodes(nodes, source = undefined, raws = undefined) {
    return nodes.map((node)=>{
        var _node_raws_tailwind;
        let cloned = node.clone();
        // We always want override the source map
        // except when explicitly told not to
        let shouldOverwriteSource = ((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.preserveSource) !== true || !cloned.source;
        if (source !== undefined && shouldOverwriteSource) {
            cloned.source = source;
            if ("walk" in cloned) {
                cloned.walk((child)=>{
                    child.source = source;
                });
            }
        }
        if (raws !== undefined) {
            cloned.raws.tailwind = {
                ...cloned.raws.tailwind,
                ...raws
            };
        }
        return cloned;
    });
}


/***/ }),

/***/ 82451:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    parseColor: ()=>parseColor,
    formatColor: ()=>formatColor
});
const _colorName = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(78510));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let HEX = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
let SHORT_HEX = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
let VALUE = /(?:\d+|\d*\.\d+)%?/;
let SEP = /(?:\s*,\s*|\s+)/;
let ALPHA_SEP = /\s*[,/]\s*/;
let CUSTOM_PROPERTY = /var\(--(?:[^ )]*?)\)/;
let RGB = new RegExp(`^(rgba?)\\(\\s*(${VALUE.source}|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`);
let HSL = new RegExp(`^(hsla?)\\(\\s*((?:${VALUE.source})(?:deg|rad|grad|turn)?|${CUSTOM_PROPERTY.source})(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?(?:${ALPHA_SEP.source}(${VALUE.source}|${CUSTOM_PROPERTY.source}))?\\s*\\)$`);
function parseColor(value, { loose =false  } = {}) {
    var _match_, _match__toString;
    if (typeof value !== "string") {
        return null;
    }
    value = value.trim();
    if (value === "transparent") {
        return {
            mode: "rgb",
            color: [
                "0",
                "0",
                "0"
            ],
            alpha: "0"
        };
    }
    if (value in _colorName.default) {
        return {
            mode: "rgb",
            color: _colorName.default[value].map((v)=>v.toString())
        };
    }
    let hex = value.replace(SHORT_HEX, (_, r, g, b, a)=>[
            "#",
            r,
            r,
            g,
            g,
            b,
            b,
            a ? a + a : ""
        ].join("")).match(HEX);
    if (hex !== null) {
        return {
            mode: "rgb",
            color: [
                parseInt(hex[1], 16),
                parseInt(hex[2], 16),
                parseInt(hex[3], 16)
            ].map((v)=>v.toString()),
            alpha: hex[4] ? (parseInt(hex[4], 16) / 255).toString() : undefined
        };
    }
    var _value_match;
    let match = (_value_match = value.match(RGB)) !== null && _value_match !== void 0 ? _value_match : value.match(HSL);
    if (match === null) {
        return null;
    }
    let color = [
        match[2],
        match[3],
        match[4]
    ].filter(Boolean).map((v)=>v.toString());
    // rgba(var(--my-color), 0.1)
    // hsla(var(--my-color), 0.1)
    if (color.length === 2 && color[0].startsWith("var(")) {
        return {
            mode: match[1],
            color: [
                color[0]
            ],
            alpha: color[1]
        };
    }
    if (!loose && color.length !== 3) {
        return null;
    }
    if (color.length < 3 && !color.some((part)=>/^var\(.*?\)$/.test(part))) {
        return null;
    }
    return {
        mode: match[1],
        color,
        alpha: (_match_ = match[5]) === null || _match_ === void 0 ? void 0 : (_match__toString = _match_.toString) === null || _match__toString === void 0 ? void 0 : _match__toString.call(_match_)
    };
}
function formatColor({ mode , color , alpha  }) {
    let hasAlpha = alpha !== undefined;
    if (mode === "rgba" || mode === "hsla") {
        return `${mode}(${color.join(", ")}${hasAlpha ? `, ${alpha}` : ""})`;
    }
    return `${mode}(${color.join(" ")}${hasAlpha ? ` / ${alpha}` : ""})`;
}


/***/ }),

/***/ 75928:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>_default
}));
function _default(pluginConfig, plugins) {
    if (pluginConfig === undefined) {
        return plugins;
    }
    const pluginNames = Array.isArray(pluginConfig) ? pluginConfig : [
        ...new Set(plugins.filter((pluginName)=>{
            return pluginConfig !== false && pluginConfig[pluginName] !== false;
        }).concat(Object.keys(pluginConfig).filter((pluginName)=>{
            return pluginConfig[pluginName] !== false;
        })))
    ];
    return pluginNames;
}


/***/ }),

/***/ 13399:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>createUtilityPlugin
}));
const _transformThemeValue = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(71985));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function createUtilityPlugin(themeKey, utilityVariations = [
    [
        themeKey,
        [
            themeKey
        ]
    ]
], { filterDefault =false , ...options } = {}) {
    let transformValue = (0, _transformThemeValue.default)(themeKey);
    return function({ matchUtilities , theme  }) {
        for (let utilityVariation of utilityVariations){
            let group = Array.isArray(utilityVariation[0]) ? utilityVariation : [
                utilityVariation
            ];
            var _theme;
            matchUtilities(group.reduce((obj, [classPrefix, properties])=>{
                return Object.assign(obj, {
                    [classPrefix]: (value)=>{
                        return properties.reduce((obj, name)=>{
                            if (Array.isArray(name)) {
                                return Object.assign(obj, {
                                    [name[0]]: name[1]
                                });
                            }
                            return Object.assign(obj, {
                                [name]: transformValue(value)
                            });
                        }, {});
                    }
                });
            }, {}), {
                ...options,
                values: filterDefault ? Object.fromEntries(Object.entries((_theme = theme(themeKey)) !== null && _theme !== void 0 ? _theme : {}).filter(([modifier])=>modifier !== "DEFAULT")) : theme(themeKey)
            });
        }
    };
}


/***/ }),

/***/ 85921:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    normalize: ()=>normalize,
    url: ()=>url,
    number: ()=>number,
    percentage: ()=>percentage,
    length: ()=>length,
    lineWidth: ()=>lineWidth,
    shadow: ()=>shadow,
    color: ()=>color,
    image: ()=>image,
    gradient: ()=>gradient,
    position: ()=>position,
    familyName: ()=>familyName,
    genericName: ()=>genericName,
    absoluteSize: ()=>absoluteSize,
    relativeSize: ()=>relativeSize
});
const _color = __nccwpck_require__(82451);
const _parseBoxShadowValue = __nccwpck_require__(43524);
const _splitAtTopLevelOnly = __nccwpck_require__(5721);
let cssFunctions = [
    "min",
    "max",
    "clamp",
    "calc"
];
// Ref: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Types
function isCSSFunction(value) {
    return cssFunctions.some((fn)=>new RegExp(`^${fn}\\(.*\\)`).test(value));
}
const placeholder = "--tw-placeholder";
const placeholderRe = new RegExp(placeholder, "g");
function normalize(value, isRoot = true) {
    // Keep raw strings if it starts with `url(`
    if (value.includes("url(")) {
        return value.split(/(url\(.*?\))/g).filter(Boolean).map((part)=>{
            if (/^url\(.*?\)$/.test(part)) {
                return part;
            }
            return normalize(part, false);
        }).join("");
    }
    // Convert `_` to ` `, except for escaped underscores `\_`
    value = value.replace(/([^\\])_+/g, (fullMatch, characterBefore)=>characterBefore + " ".repeat(fullMatch.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_");
    // Remove leftover whitespace
    if (isRoot) {
        value = value.trim();
    }
    // Add spaces around operators inside math functions like calc() that do not follow an operator
    // or '('.
    value = value.replace(/(calc|min|max|clamp)\(.+\)/g, (match)=>{
        let vars = [];
        return match.replace(/var\((--.+?)[,)]/g, (match, g1)=>{
            vars.push(g1);
            return match.replace(g1, placeholder);
        }).replace(/(-?\d*\.?\d(?!\b-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(placeholderRe, ()=>vars.shift());
    });
    return value;
}
function url(value) {
    return value.startsWith("url(");
}
function number(value) {
    return !isNaN(Number(value)) || isCSSFunction(value);
}
function percentage(value) {
    return value.endsWith("%") && number(value.slice(0, -1)) || isCSSFunction(value);
}
// Please refer to MDN when updating this list:
// https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units
// https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Container_Queries#container_query_length_units
let lengthUnits = [
    "cm",
    "mm",
    "Q",
    "in",
    "pc",
    "pt",
    "px",
    "em",
    "ex",
    "ch",
    "rem",
    "lh",
    "rlh",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "vb",
    "vi",
    "svw",
    "svh",
    "lvw",
    "lvh",
    "dvw",
    "dvh",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
];
let lengthUnitsPattern = `(?:${lengthUnits.join("|")})`;
function length(value) {
    return value === "0" || new RegExp(`^[+-]?[0-9]*\.?[0-9]+(?:[eE][+-]?[0-9]+)?${lengthUnitsPattern}$`).test(value) || isCSSFunction(value);
}
let lineWidths = new Set([
    "thin",
    "medium",
    "thick"
]);
function lineWidth(value) {
    return lineWidths.has(value);
}
function shadow(value) {
    let parsedShadows = (0, _parseBoxShadowValue.parseBoxShadowValue)(normalize(value));
    for (let parsedShadow of parsedShadows){
        if (!parsedShadow.valid) {
            return false;
        }
    }
    return true;
}
function color(value) {
    let colors = 0;
    let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, "_").every((part)=>{
        part = normalize(part);
        if (part.startsWith("var(")) return true;
        if ((0, _color.parseColor)(part, {
            loose: true
        }) !== null) return colors++, true;
        return false;
    });
    if (!result) return false;
    return colors > 0;
}
function image(value) {
    let images = 0;
    let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, ",").every((part)=>{
        part = normalize(part);
        if (part.startsWith("var(")) return true;
        if (url(part) || gradient(part) || [
            "element(",
            "image(",
            "cross-fade(",
            "image-set("
        ].some((fn)=>part.startsWith(fn))) {
            images++;
            return true;
        }
        return false;
    });
    if (!result) return false;
    return images > 0;
}
let gradientTypes = new Set([
    "linear-gradient",
    "radial-gradient",
    "repeating-linear-gradient",
    "repeating-radial-gradient",
    "conic-gradient"
]);
function gradient(value) {
    value = normalize(value);
    for (let type of gradientTypes){
        if (value.startsWith(`${type}(`)) {
            return true;
        }
    }
    return false;
}
let validPositions = new Set([
    "center",
    "top",
    "right",
    "bottom",
    "left"
]);
function position(value) {
    let positions = 0;
    let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, "_").every((part)=>{
        part = normalize(part);
        if (part.startsWith("var(")) return true;
        if (validPositions.has(part) || length(part) || percentage(part)) {
            positions++;
            return true;
        }
        return false;
    });
    if (!result) return false;
    return positions > 0;
}
function familyName(value) {
    let fonts = 0;
    let result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, ",").every((part)=>{
        part = normalize(part);
        if (part.startsWith("var(")) return true;
        // If it contains spaces, then it should be quoted
        if (part.includes(" ")) {
            if (!/(['"])([^"']+)\1/g.test(part)) {
                return false;
            }
        }
        // If it starts with a number, it's invalid
        if (/^\d/g.test(part)) {
            return false;
        }
        fonts++;
        return true;
    });
    if (!result) return false;
    return fonts > 0;
}
let genericNames = new Set([
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
    "ui-serif",
    "ui-sans-serif",
    "ui-monospace",
    "ui-rounded",
    "math",
    "emoji",
    "fangsong"
]);
function genericName(value) {
    return genericNames.has(value);
}
let absoluteSizes = new Set([
    "xx-small",
    "x-small",
    "small",
    "medium",
    "large",
    "x-large",
    "x-large",
    "xxx-large"
]);
function absoluteSize(value) {
    return absoluteSizes.has(value);
}
let relativeSizes = new Set([
    "larger",
    "smaller"
]);
function relativeSize(value) {
    return relativeSizes.has(value);
}


/***/ }),

/***/ 86330:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "defaults", ({
    enumerable: true,
    get: ()=>defaults
}));
function defaults(target, ...sources) {
    for (let source of sources){
        for(let k in source){
            var _target_hasOwnProperty;
            if (!(target === null || target === void 0 ? void 0 : (_target_hasOwnProperty = target.hasOwnProperty) === null || _target_hasOwnProperty === void 0 ? void 0 : _target_hasOwnProperty.call(target, k))) {
                target[k] = source[k];
            }
        }
        for (let k1 of Object.getOwnPropertySymbols(source)){
            var _target_hasOwnProperty1;
            if (!(target === null || target === void 0 ? void 0 : (_target_hasOwnProperty1 = target.hasOwnProperty) === null || _target_hasOwnProperty1 === void 0 ? void 0 : _target_hasOwnProperty1.call(target, k1))) {
                target[k1] = source[k1];
            }
        }
    }
    return target;
}


/***/ }),

/***/ 11898:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>escapeClassName
}));
const _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(32997));
const _escapeCommas = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(38854));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function escapeClassName(className) {
    var _node_raws;
    let node = _postcssSelectorParser.default.className();
    node.value = className;
    var _node_raws_value;
    return (0, _escapeCommas.default)((_node_raws_value = node === null || node === void 0 ? void 0 : (_node_raws = node.raws) === null || _node_raws === void 0 ? void 0 : _node_raws.value) !== null && _node_raws_value !== void 0 ? _node_raws_value : node.value);
}


/***/ }),

/***/ 38854:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>escapeCommas
}));
function escapeCommas(className) {
    return className.replace(/\\,/g, "\\2c ");
}


/***/ }),

/***/ 21150:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>_default
}));
const flattenColorPalette = (colors)=>Object.assign({}, ...Object.entries(colors !== null && colors !== void 0 ? colors : {}).flatMap(([color, values])=>typeof values == "object" ? Object.entries(flattenColorPalette(values)).map(([number, hex])=>({
                [color + (number === "DEFAULT" ? "" : `-${number}`)]: hex
            })) : [
            {
                [`${color}`]: values
            }
        ]));
const _default = flattenColorPalette;


/***/ }),

/***/ 43514:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    formatVariantSelector: ()=>formatVariantSelector,
    eliminateIrrelevantSelectors: ()=>eliminateIrrelevantSelectors,
    finalizeSelector: ()=>finalizeSelector,
    handleMergePseudo: ()=>handleMergePseudo
});
const _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(32997));
const _unesc = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(2897));
const _escapeClassName = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(11898));
const _prefixSelector = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(74710));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/** @typedef {import('postcss-selector-parser').Root} Root */ /** @typedef {import('postcss-selector-parser').Selector} Selector */ /** @typedef {import('postcss-selector-parser').Pseudo} Pseudo */ /** @typedef {import('postcss-selector-parser').Node} Node */ /** @typedef {{format: string, isArbitraryVariant: boolean}[]} RawFormats */ /** @typedef {import('postcss-selector-parser').Root} ParsedFormats */ /** @typedef {RawFormats | ParsedFormats} AcceptedFormats */ let MERGE = ":merge";
function formatVariantSelector(formats, { context , candidate  }) {
    var _context_tailwindConfig_prefix;
    let prefix = (_context_tailwindConfig_prefix = context === null || context === void 0 ? void 0 : context.tailwindConfig.prefix) !== null && _context_tailwindConfig_prefix !== void 0 ? _context_tailwindConfig_prefix : "";
    // Parse the format selector into an AST
    let parsedFormats = formats.map((format)=>{
        let ast = (0, _postcssSelectorParser.default)().astSync(format.format);
        return {
            ...format,
            ast: format.isArbitraryVariant ? ast : (0, _prefixSelector.default)(prefix, ast)
        };
    });
    // We start with the candidate selector
    let formatAst = _postcssSelectorParser.default.root({
        nodes: [
            _postcssSelectorParser.default.selector({
                nodes: [
                    _postcssSelectorParser.default.className({
                        value: (0, _escapeClassName.default)(candidate)
                    })
                ]
            })
        ]
    });
    // And iteratively merge each format selector into the candidate selector
    for (let { ast  } of parsedFormats){
        [formatAst, ast] = handleMergePseudo(formatAst, ast);
        // 2. Merge the format selector into the current selector AST
        ast.walkNesting((nesting)=>nesting.replaceWith(...formatAst.nodes[0].nodes));
        // 3. Keep going!
        formatAst = ast;
    }
    return formatAst;
}
/**
 * Given any node in a selector this gets the "simple" selector it's a part of
 * A simple selector is just a list of nodes without any combinators
 * Technically :is(), :not(), :has(), etc… can have combinators but those are nested
 * inside the relevant node and won't be picked up so they're fine to ignore
 *
 * @param {Node} node
 * @returns {Node[]}
 **/ function simpleSelectorForNode(node) {
    /** @type {Node[]} */ let nodes = [];
    // Walk backwards until we hit a combinator node (or the start)
    while(node.prev() && node.prev().type !== "combinator"){
        node = node.prev();
    }
    // Now record all non-combinator nodes until we hit one (or the end)
    while(node && node.type !== "combinator"){
        nodes.push(node);
        node = node.next();
    }
    return nodes;
}
/**
 * Resorts the nodes in a selector to ensure they're in the correct order
 * Tags go before classes, and pseudo classes go after classes
 *
 * @param {Selector} sel
 * @returns {Selector}
 **/ function resortSelector(sel) {
    sel.sort((a, b)=>{
        if (a.type === "tag" && b.type === "class") {
            return -1;
        } else if (a.type === "class" && b.type === "tag") {
            return 1;
        } else if (a.type === "class" && b.type === "pseudo" && b.value.startsWith("::")) {
            return -1;
        } else if (a.type === "pseudo" && a.value.startsWith("::") && b.type === "class") {
            return 1;
        }
        return sel.index(a) - sel.index(b);
    });
    return sel;
}
function eliminateIrrelevantSelectors(sel, base) {
    let hasClassesMatchingCandidate = false;
    sel.walk((child)=>{
        if (child.type === "class" && child.value === base) {
            hasClassesMatchingCandidate = true;
            return false // Stop walking
            ;
        }
    });
    if (!hasClassesMatchingCandidate) {
        sel.remove();
    }
// We do NOT recursively eliminate sub selectors that don't have the base class
// as this is NOT a safe operation. For example, if we have:
// `.space-x-2 > :not([hidden]) ~ :not([hidden])`
// We cannot remove the [hidden] from the :not() because it would change the
// meaning of the selector.
// TODO: Can we do this for :matches, :is, and :where?
}
function finalizeSelector(current, formats, { context , candidate , base  }) {
    var _context_tailwindConfig;
    var _context_tailwindConfig_separator;
    let separator = (_context_tailwindConfig_separator = context === null || context === void 0 ? void 0 : (_context_tailwindConfig = context.tailwindConfig) === null || _context_tailwindConfig === void 0 ? void 0 : _context_tailwindConfig.separator) !== null && _context_tailwindConfig_separator !== void 0 ? _context_tailwindConfig_separator : ":";
    // Split by the separator, but ignore the separator inside square brackets:
    //
    // E.g.: dark:lg:hover:[paint-order:markers]
    //           ┬  ┬     ┬            ┬
    //           │  │     │            ╰── We will not split here
    //           ╰──┴─────┴─────────────── We will split here
    //
    base = base !== null && base !== void 0 ? base : candidate.split(new RegExp(`\\${separator}(?![^[]*\\])`)).pop();
    // Parse the selector into an AST
    let selector = (0, _postcssSelectorParser.default)().astSync(current);
    // Normalize escaped classes, e.g.:
    //
    // The idea would be to replace the escaped `base` in the selector with the
    // `format`. However, in css you can escape the same selector in a few
    // different ways. This would result in different strings and therefore we
    // can't replace it properly.
    //
    //               base: bg-[rgb(255,0,0)]
    //   base in selector: bg-\\[rgb\\(255\\,0\\,0\\)\\]
    //       escaped base: bg-\\[rgb\\(255\\2c 0\\2c 0\\)\\]
    //
    selector.walkClasses((node)=>{
        if (node.raws && node.value.includes(base)) {
            node.raws.value = (0, _escapeClassName.default)((0, _unesc.default)(node.raws.value));
        }
    });
    // Remove extraneous selectors that do not include the base candidate
    selector.each((sel)=>eliminateIrrelevantSelectors(sel, base));
    // If there are no formats that means there were no variants added to the candidate
    // so we can just return the selector as-is
    let formatAst = Array.isArray(formats) ? formatVariantSelector(formats, {
        context,
        candidate
    }) : formats;
    if (formatAst === null) {
        return selector.toString();
    }
    let simpleStart = _postcssSelectorParser.default.comment({
        value: "/*__simple__*/"
    });
    let simpleEnd = _postcssSelectorParser.default.comment({
        value: "/*__simple__*/"
    });
    // We can safely replace the escaped base now, since the `base` section is
    // now in a normalized escaped value.
    selector.walkClasses((node)=>{
        if (node.value !== base) {
            return;
        }
        let parent = node.parent;
        let formatNodes = formatAst.nodes[0].nodes;
        // Perf optimization: if the parent is a single class we can just replace it and be done
        if (parent.nodes.length === 1) {
            node.replaceWith(...formatNodes);
            return;
        }
        let simpleSelector = simpleSelectorForNode(node);
        parent.insertBefore(simpleSelector[0], simpleStart);
        parent.insertAfter(simpleSelector[simpleSelector.length - 1], simpleEnd);
        for (let child of formatNodes){
            parent.insertBefore(simpleSelector[0], child.clone());
        }
        node.remove();
        // Re-sort the simple selector to ensure it's in the correct order
        simpleSelector = simpleSelectorForNode(simpleStart);
        let firstNode = parent.index(simpleStart);
        parent.nodes.splice(firstNode, simpleSelector.length, ...resortSelector(_postcssSelectorParser.default.selector({
            nodes: simpleSelector
        })).nodes);
        simpleStart.remove();
        simpleEnd.remove();
    });
    // Remove unnecessary pseudo selectors that we used as placeholders
    selector.walkPseudos((p)=>{
        if (p.value === MERGE) {
            p.replaceWith(p.nodes);
        }
    });
    // Move pseudo elements to the end of the selector (if necessary)
    selector.each((sel)=>{
        let pseudoElements = collectPseudoElements(sel);
        if (pseudoElements.length > 0) {
            sel.nodes.push(pseudoElements.sort(sortSelector));
        }
    });
    return selector.toString();
}
function handleMergePseudo(selector, format) {
    /** @type {{pseudo: Pseudo, value: string}[]} */ let merges = [];
    // Find all :merge() pseudo-classes in `selector`
    selector.walkPseudos((pseudo)=>{
        if (pseudo.value === MERGE) {
            merges.push({
                pseudo,
                value: pseudo.nodes[0].toString()
            });
        }
    });
    // Find all :merge() "attachments" in `format` and attach them to the matching selector in `selector`
    format.walkPseudos((pseudo)=>{
        if (pseudo.value !== MERGE) {
            return;
        }
        let value = pseudo.nodes[0].toString();
        // Does `selector` contain a :merge() pseudo-class with the same value?
        let existing = merges.find((merge)=>merge.value === value);
        // Nope so there's nothing to do
        if (!existing) {
            return;
        }
        // Everything after `:merge()` up to the next combinator is what is attached to the merged selector
        let attachments = [];
        let next = pseudo.next();
        while(next && next.type !== "combinator"){
            attachments.push(next);
            next = next.next();
        }
        let combinator = next;
        existing.pseudo.parent.insertAfter(existing.pseudo, _postcssSelectorParser.default.selector({
            nodes: attachments.map((node)=>node.clone())
        }));
        pseudo.remove();
        attachments.forEach((node)=>node.remove());
        // What about this case:
        // :merge(.group):focus > &
        // :merge(.group):hover &
        if (combinator && combinator.type === "combinator") {
            combinator.remove();
        }
    });
    return [
        selector,
        format
    ];
}
// Note: As a rule, double colons (::) should be used instead of a single colon
// (:). This distinguishes pseudo-classes from pseudo-elements. However, since
// this distinction was not present in older versions of the W3C spec, most
// browsers support both syntaxes for the original pseudo-elements.
let pseudoElementsBC = [
    ":before",
    ":after",
    ":first-line",
    ":first-letter"
];
// These pseudo-elements _can_ be combined with other pseudo selectors AND the order does matter.
let pseudoElementExceptions = [
    "::file-selector-button",
    // Webkit scroll bar pseudo elements can be combined with user-action pseudo classes
    "::-webkit-scrollbar",
    "::-webkit-scrollbar-button",
    "::-webkit-scrollbar-thumb",
    "::-webkit-scrollbar-track",
    "::-webkit-scrollbar-track-piece",
    "::-webkit-scrollbar-corner",
    "::-webkit-resizer"
];
/**
 * This will make sure to move pseudo's to the correct spot (the end for
 * pseudo elements) because otherwise the selector will never work
 * anyway.
 *
 * E.g.:
 *  - `before:hover:text-center` would result in `.before\:hover\:text-center:hover::before`
 *  - `hover:before:text-center` would result in `.hover\:before\:text-center:hover::before`
 *
 * `::before:hover` doesn't work, which means that we can make it work for you by flipping the order.
 *
 * @param {Selector} selector
 **/ function collectPseudoElements(selector) {
    /** @type {Node[]} */ let nodes = [];
    for (let node of selector.nodes){
        if (isPseudoElement(node)) {
            nodes.push(node);
            selector.removeChild(node);
        }
        if (node === null || node === void 0 ? void 0 : node.nodes) {
            nodes.push(...collectPseudoElements(node));
        }
    }
    return nodes;
}
// This will make sure to move pseudo's to the correct spot (the end for
// pseudo elements) because otherwise the selector will never work
// anyway.
//
// E.g.:
//  - `before:hover:text-center` would result in `.before\:hover\:text-center:hover::before`
//  - `hover:before:text-center` would result in `.hover\:before\:text-center:hover::before`
//
// `::before:hover` doesn't work, which means that we can make it work
// for you by flipping the order.
function sortSelector(a, z) {
    // Both nodes are non-pseudo's so we can safely ignore them and keep
    // them in the same order.
    if (a.type !== "pseudo" && z.type !== "pseudo") {
        return 0;
    }
    // If one of them is a combinator, we need to keep it in the same order
    // because that means it will start a new "section" in the selector.
    if (a.type === "combinator" ^ z.type === "combinator") {
        return 0;
    }
    // One of the items is a pseudo and the other one isn't. Let's move
    // the pseudo to the right.
    if (a.type === "pseudo" ^ z.type === "pseudo") {
        return (a.type === "pseudo") - (z.type === "pseudo");
    }
    // Both are pseudo's, move the pseudo elements (except for
    // ::file-selector-button) to the right.
    return isPseudoElement(a) - isPseudoElement(z);
}
function isPseudoElement(node) {
    if (node.type !== "pseudo") return false;
    if (pseudoElementExceptions.includes(node.value)) return false;
    return node.value.startsWith("::") || pseudoElementsBC.includes(node.value);
}


/***/ }),

/***/ 94867:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>getAllConfigs
}));
const _defaultConfigStubJs = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(93088));
const _featureFlags = __nccwpck_require__(90);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function getAllConfigs(config) {
    var _config_presets;
    const configs = ((_config_presets = config === null || config === void 0 ? void 0 : config.presets) !== null && _config_presets !== void 0 ? _config_presets : [
        _defaultConfigStubJs.default
    ]).slice().reverse().flatMap((preset)=>getAllConfigs(preset instanceof Function ? preset() : preset));
    const features = {
        // Add experimental configs here...
        respectDefaultRingColorOpacity: {
            theme: {
                ringColor: ({ theme  })=>({
                        DEFAULT: "#3b82f67f",
                        ...theme("colors")
                    })
            }
        },
        disableColorOpacityUtilitiesByDefault: {
            corePlugins: {
                backgroundOpacity: false,
                borderOpacity: false,
                divideOpacity: false,
                placeholderOpacity: false,
                ringOpacity: false,
                textOpacity: false
            }
        }
    };
    const experimentals = Object.keys(features).filter((feature)=>(0, _featureFlags.flagEnabled)(config, feature)).map((feature)=>features[feature]);
    return [
        config,
        ...experimentals,
        ...configs
    ];
}


/***/ }),

/***/ 66608:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>hashConfig
}));
const _objectHash = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(24856));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function hashConfig(config) {
    return (0, _objectHash.default)(config, {
        ignoreUnknown: true
    });
}


/***/ }),

/***/ 20896:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>isPlainObject
}));
function isPlainObject(value) {
    if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
}


/***/ }),

/***/ 8449:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>isSyntacticallyValidPropertyValue
}));
let matchingBrackets = new Map([
    [
        "{",
        "}"
    ],
    [
        "[",
        "]"
    ],
    [
        "(",
        ")"
    ]
]);
let inverseMatchingBrackets = new Map(Array.from(matchingBrackets.entries()).map(([k, v])=>[
        v,
        k
    ]));
let quotes = new Set([
    '"',
    "'",
    "`"
]);
function isSyntacticallyValidPropertyValue(value) {
    let stack = [];
    let inQuotes = false;
    for(let i = 0; i < value.length; i++){
        let char = value[i];
        if (char === ":" && !inQuotes && stack.length === 0) {
            return false;
        }
        // Non-escaped quotes allow us to "allow" anything in between
        if (quotes.has(char) && value[i - 1] !== "\\") {
            inQuotes = !inQuotes;
        }
        if (inQuotes) continue;
        if (value[i - 1] === "\\") continue; // Escaped
        if (matchingBrackets.has(char)) {
            stack.push(char);
        } else if (inverseMatchingBrackets.has(char)) {
            let inverse = inverseMatchingBrackets.get(char);
            // Nothing to pop from, therefore it is unbalanced
            if (stack.length <= 0) {
                return false;
            }
            // Popped value must match the inverse value, otherwise it is unbalanced
            if (stack.pop() !== inverse) {
                return false;
            }
        }
    }
    // If there is still something on the stack, it is also unbalanced
    if (stack.length > 0) {
        return false;
    }
    // All good, totally balanced!
    return true;
}


/***/ }),

/***/ 64368:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    dim: ()=>dim,
    default: ()=>_default
});
const _picocolors = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(37023));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let alreadyShown = new Set();
function log(type, messages, key) {
    if (typeof process !== "undefined" && process.env.JEST_WORKER_ID) return;
    if (key && alreadyShown.has(key)) return;
    if (key) alreadyShown.add(key);
    console.warn("");
    messages.forEach((message)=>console.warn(type, "-", message));
}
function dim(input) {
    return _picocolors.default.dim(input);
}
const _default = {
    info (key, messages) {
        log(_picocolors.default.bold(_picocolors.default.cyan("info")), ...Array.isArray(key) ? [
            key
        ] : [
            messages,
            key
        ]);
    },
    warn (key, messages) {
        log(_picocolors.default.bold(_picocolors.default.yellow("warn")), ...Array.isArray(key) ? [
            key
        ] : [
            messages,
            key
        ]);
    },
    risk (key, messages) {
        log(_picocolors.default.bold(_picocolors.default.magenta("risk")), ...Array.isArray(key) ? [
            key
        ] : [
            messages,
            key
        ]);
    }
};


/***/ }),

/***/ 66104:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    asClass: ()=>asClass,
    default: ()=>nameClass,
    formatClass: ()=>formatClass
});
const _escapeClassName = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(11898));
const _escapeCommas = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(38854));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function asClass(name) {
    return (0, _escapeCommas.default)(`.${(0, _escapeClassName.default)(name)}`);
}
function nameClass(classPrefix, key) {
    return asClass(formatClass(classPrefix, key));
}
function formatClass(classPrefix, key) {
    if (key === "DEFAULT") {
        return classPrefix;
    }
    if (key === "-" || key === "-DEFAULT") {
        return `-${classPrefix}`;
    }
    if (key.startsWith("-")) {
        return `-${classPrefix}${key}`;
    }
    if (key.startsWith("/")) {
        return `${classPrefix}${key}`;
    }
    return `${classPrefix}-${key}`;
}


/***/ }),

/***/ 76164:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>negateValue
}));
function negateValue(value) {
    value = `${value}`;
    if (value === "0") {
        return "0";
    }
    // Flip sign of numbers
    if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(value)) {
        return value.replace(/^[+-]?/, (sign)=>sign === "-" ? "" : "-");
    }
    // What functions we support negating numeric values for
    // var() isn't inherently a numeric function but we support it anyway
    // The trigonometric functions are omitted because you'll need to use calc(…) with them _anyway_
    // to produce generally useful results and that will be covered already
    let numericFunctions = [
        "var",
        "calc",
        "min",
        "max",
        "clamp"
    ];
    for (const fn of numericFunctions){
        if (value.includes(`${fn}(`)) {
            return `calc(${value} * -1)`;
        }
    }
}


/***/ }),

/***/ 42937:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "normalizeConfig", ({
    enumerable: true,
    get: ()=>normalizeConfig
}));
const _log = /*#__PURE__*/ _interopRequireWildcard(__nccwpck_require__(64368));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function normalizeConfig(config) {
    // Quick structure validation
    /**
   * type FilePath = string
   * type RawFile = { raw: string, extension?: string }
   * type ExtractorFn = (content: string) => Array<string>
   * type TransformerFn = (content: string) => string
   *
   * type Content =
   *   | Array<FilePath | RawFile>
   *   | {
   *       files: Array<FilePath | RawFile>,
   *       extract?: ExtractorFn | { [extension: string]: ExtractorFn }
   *       transform?: TransformerFn | { [extension: string]: TransformerFn }
   *   }
   */ let valid = (()=>{
        // `config.purge` should not exist anymore
        if (config.purge) {
            return false;
        }
        // `config.content` should exist
        if (!config.content) {
            return false;
        }
        // `config.content` should be an object or an array
        if (!Array.isArray(config.content) && !(typeof config.content === "object" && config.content !== null)) {
            return false;
        }
        // When `config.content` is an array, it should consist of FilePaths or RawFiles
        if (Array.isArray(config.content)) {
            return config.content.every((path)=>{
                // `path` can be a string
                if (typeof path === "string") return true;
                // `path` can be an object { raw: string, extension?: string }
                // `raw` must be a string
                if (typeof (path === null || path === void 0 ? void 0 : path.raw) !== "string") return false;
                // `extension` (if provided) should also be a string
                if ((path === null || path === void 0 ? void 0 : path.extension) && typeof (path === null || path === void 0 ? void 0 : path.extension) !== "string") {
                    return false;
                }
                return true;
            });
        }
        // When `config.content` is an object
        if (typeof config.content === "object" && config.content !== null) {
            // Only `files`, `relative`, `extract`, and `transform` can exist in `config.content`
            if (Object.keys(config.content).some((key)=>![
                    "files",
                    "relative",
                    "extract",
                    "transform"
                ].includes(key))) {
                return false;
            }
            // `config.content.files` should exist of FilePaths or RawFiles
            if (Array.isArray(config.content.files)) {
                if (!config.content.files.every((path)=>{
                    // `path` can be a string
                    if (typeof path === "string") return true;
                    // `path` can be an object { raw: string, extension?: string }
                    // `raw` must be a string
                    if (typeof (path === null || path === void 0 ? void 0 : path.raw) !== "string") return false;
                    // `extension` (if provided) should also be a string
                    if ((path === null || path === void 0 ? void 0 : path.extension) && typeof (path === null || path === void 0 ? void 0 : path.extension) !== "string") {
                        return false;
                    }
                    return true;
                })) {
                    return false;
                }
                // `config.content.extract` is optional, and can be a Function or a Record<String, Function>
                if (typeof config.content.extract === "object") {
                    for (let value of Object.values(config.content.extract)){
                        if (typeof value !== "function") {
                            return false;
                        }
                    }
                } else if (!(config.content.extract === undefined || typeof config.content.extract === "function")) {
                    return false;
                }
                // `config.content.transform` is optional, and can be a Function or a Record<String, Function>
                if (typeof config.content.transform === "object") {
                    for (let value1 of Object.values(config.content.transform)){
                        if (typeof value1 !== "function") {
                            return false;
                        }
                    }
                } else if (!(config.content.transform === undefined || typeof config.content.transform === "function")) {
                    return false;
                }
                // `config.content.relative` is optional and can be a boolean
                if (typeof config.content.relative !== "boolean" && typeof config.content.relative !== "undefined") {
                    return false;
                }
            }
            return true;
        }
        return false;
    })();
    if (!valid) {
        _log.default.warn("purge-deprecation", [
            "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
            "Update your configuration file to eliminate this warning.",
            "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
        ]);
    }
    // Normalize the `safelist`
    config.safelist = (()=>{
        var _purge_options;
        let { content , purge , safelist  } = config;
        if (Array.isArray(safelist)) return safelist;
        if (Array.isArray(content === null || content === void 0 ? void 0 : content.safelist)) return content.safelist;
        if (Array.isArray(purge === null || purge === void 0 ? void 0 : purge.safelist)) return purge.safelist;
        if (Array.isArray(purge === null || purge === void 0 ? void 0 : (_purge_options = purge.options) === null || _purge_options === void 0 ? void 0 : _purge_options.safelist)) return purge.options.safelist;
        return [];
    })();
    // Normalize the `blocklist`
    config.blocklist = (()=>{
        let { blocklist  } = config;
        if (Array.isArray(blocklist)) {
            if (blocklist.every((item)=>typeof item === "string")) {
                return blocklist;
            }
            _log.default.warn("blocklist-invalid", [
                "The `blocklist` option must be an array of strings.",
                "https://tailwindcss.com/docs/content-configuration#discarding-classes"
            ]);
        }
        return [];
    })();
    // Normalize prefix option
    if (typeof config.prefix === "function") {
        _log.default.warn("prefix-function", [
            "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
            "Update `prefix` in your configuration to be a string to eliminate this warning.",
            "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
        ]);
        config.prefix = "";
    } else {
        var _config_prefix;
        config.prefix = (_config_prefix = config.prefix) !== null && _config_prefix !== void 0 ? _config_prefix : "";
    }
    // Normalize the `content`
    config.content = {
        relative: (()=>{
            var _config_future;
            let { content  } = config;
            if (content === null || content === void 0 ? void 0 : content.relative) {
                return content.relative;
            }
            var _config_future_relativeContentPathsByDefault;
            return (_config_future_relativeContentPathsByDefault = (_config_future = config.future) === null || _config_future === void 0 ? void 0 : _config_future.relativeContentPathsByDefault) !== null && _config_future_relativeContentPathsByDefault !== void 0 ? _config_future_relativeContentPathsByDefault : false;
        })(),
        files: (()=>{
            let { content , purge  } = config;
            if (Array.isArray(purge)) return purge;
            if (Array.isArray(purge === null || purge === void 0 ? void 0 : purge.content)) return purge.content;
            if (Array.isArray(content)) return content;
            if (Array.isArray(content === null || content === void 0 ? void 0 : content.content)) return content.content;
            if (Array.isArray(content === null || content === void 0 ? void 0 : content.files)) return content.files;
            return [];
        })(),
        extract: (()=>{
            let extract = (()=>{
                var _config_purge, _config_content, _config_purge1, _config_purge_extract, _config_content1, _config_content_extract, _config_purge2, _config_purge_options, _config_content2, _config_content_options;
                if ((_config_purge = config.purge) === null || _config_purge === void 0 ? void 0 : _config_purge.extract) return config.purge.extract;
                if ((_config_content = config.content) === null || _config_content === void 0 ? void 0 : _config_content.extract) return config.content.extract;
                if ((_config_purge1 = config.purge) === null || _config_purge1 === void 0 ? void 0 : (_config_purge_extract = _config_purge1.extract) === null || _config_purge_extract === void 0 ? void 0 : _config_purge_extract.DEFAULT) return config.purge.extract.DEFAULT;
                if ((_config_content1 = config.content) === null || _config_content1 === void 0 ? void 0 : (_config_content_extract = _config_content1.extract) === null || _config_content_extract === void 0 ? void 0 : _config_content_extract.DEFAULT) return config.content.extract.DEFAULT;
                if ((_config_purge2 = config.purge) === null || _config_purge2 === void 0 ? void 0 : (_config_purge_options = _config_purge2.options) === null || _config_purge_options === void 0 ? void 0 : _config_purge_options.extractors) return config.purge.options.extractors;
                if ((_config_content2 = config.content) === null || _config_content2 === void 0 ? void 0 : (_config_content_options = _config_content2.options) === null || _config_content_options === void 0 ? void 0 : _config_content_options.extractors) return config.content.options.extractors;
                return {};
            })();
            let extractors = {};
            let defaultExtractor = (()=>{
                var _config_purge, _config_purge_options, _config_content, _config_content_options;
                if ((_config_purge = config.purge) === null || _config_purge === void 0 ? void 0 : (_config_purge_options = _config_purge.options) === null || _config_purge_options === void 0 ? void 0 : _config_purge_options.defaultExtractor) {
                    return config.purge.options.defaultExtractor;
                }
                if ((_config_content = config.content) === null || _config_content === void 0 ? void 0 : (_config_content_options = _config_content.options) === null || _config_content_options === void 0 ? void 0 : _config_content_options.defaultExtractor) {
                    return config.content.options.defaultExtractor;
                }
                return undefined;
            })();
            if (defaultExtractor !== undefined) {
                extractors.DEFAULT = defaultExtractor;
            }
            // Functions
            if (typeof extract === "function") {
                extractors.DEFAULT = extract;
            } else if (Array.isArray(extract)) {
                for (let { extensions , extractor  } of extract !== null && extract !== void 0 ? extract : []){
                    for (let extension of extensions){
                        extractors[extension] = extractor;
                    }
                }
            } else if (typeof extract === "object" && extract !== null) {
                Object.assign(extractors, extract);
            }
            return extractors;
        })(),
        transform: (()=>{
            let transform = (()=>{
                var _config_purge, _config_content, _config_purge1, _config_purge_transform, _config_content1, _config_content_transform;
                if ((_config_purge = config.purge) === null || _config_purge === void 0 ? void 0 : _config_purge.transform) return config.purge.transform;
                if ((_config_content = config.content) === null || _config_content === void 0 ? void 0 : _config_content.transform) return config.content.transform;
                if ((_config_purge1 = config.purge) === null || _config_purge1 === void 0 ? void 0 : (_config_purge_transform = _config_purge1.transform) === null || _config_purge_transform === void 0 ? void 0 : _config_purge_transform.DEFAULT) return config.purge.transform.DEFAULT;
                if ((_config_content1 = config.content) === null || _config_content1 === void 0 ? void 0 : (_config_content_transform = _config_content1.transform) === null || _config_content_transform === void 0 ? void 0 : _config_content_transform.DEFAULT) return config.content.transform.DEFAULT;
                return {};
            })();
            let transformers = {};
            if (typeof transform === "function") {
                transformers.DEFAULT = transform;
            }
            if (typeof transform === "object" && transform !== null) {
                Object.assign(transformers, transform);
            }
            return transformers;
        })()
    };
    // Validate globs to prevent bogus globs.
    // E.g.: `./src/*.{html}` is invalid, the `{html}` should just be `html`
    for (let file of config.content.files){
        if (typeof file === "string" && /{([^,]*?)}/g.test(file)) {
            _log.default.warn("invalid-glob-braces", [
                `The glob pattern ${(0, _log.dim)(file)} in your Tailwind CSS configuration is invalid.`,
                `Update it to ${(0, _log.dim)(file.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
            ]);
            break;
        }
    }
    return config;
}


/***/ }),

/***/ 68617:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @typedef {object} ScreenValue
 * @property {number|undefined} min
 * @property {number|undefined} max
 * @property {string|undefined} raw
 */ /**
 * @typedef {object} Screen
 * @property {string} name
 * @property {boolean} not
 * @property {ScreenValue[]} values
 */ /**
 * A function that normalizes the various forms that the screens object can be
 * provided in.
 *
 * Input(s):
 *   - ['100px', '200px'] // Raw strings
 *   - { sm: '100px', md: '200px' } // Object with string values
 *   - { sm: { min: '100px' }, md: { max: '100px' } } // Object with object values
 *   - { sm: [{ min: '100px' }, { max: '200px' }] } // Object with object array (multiple values)
 *
 * Output(s):
 *   - [{ name: 'sm', values: [{ min: '100px', max: '200px' }] }] // List of objects, that contains multiple values
 *
 * @returns {Screen[]}
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    normalizeScreens: ()=>normalizeScreens,
    isScreenSortable: ()=>isScreenSortable,
    compareScreens: ()=>compareScreens,
    toScreen: ()=>toScreen
});
function normalizeScreens(screens, root = true) {
    if (Array.isArray(screens)) {
        return screens.map((screen)=>{
            if (root && Array.isArray(screen)) {
                throw new Error("The tuple syntax is not supported for `screens`.");
            }
            if (typeof screen === "string") {
                return {
                    name: screen.toString(),
                    not: false,
                    values: [
                        {
                            min: screen,
                            max: undefined
                        }
                    ]
                };
            }
            let [name, options] = screen;
            name = name.toString();
            if (typeof options === "string") {
                return {
                    name,
                    not: false,
                    values: [
                        {
                            min: options,
                            max: undefined
                        }
                    ]
                };
            }
            if (Array.isArray(options)) {
                return {
                    name,
                    not: false,
                    values: options.map((option)=>resolveValue(option))
                };
            }
            return {
                name,
                not: false,
                values: [
                    resolveValue(options)
                ]
            };
        });
    }
    return normalizeScreens(Object.entries(screens !== null && screens !== void 0 ? screens : {}), false);
}
function isScreenSortable(screen) {
    if (screen.values.length !== 1) {
        return {
            result: false,
            reason: "multiple-values"
        };
    } else if (screen.values[0].raw !== undefined) {
        return {
            result: false,
            reason: "raw-values"
        };
    } else if (screen.values[0].min !== undefined && screen.values[0].max !== undefined) {
        return {
            result: false,
            reason: "min-and-max"
        };
    }
    return {
        result: true,
        reason: null
    };
}
function compareScreens(type, a, z) {
    let aScreen = toScreen(a, type);
    let zScreen = toScreen(z, type);
    let aSorting = isScreenSortable(aScreen);
    let bSorting = isScreenSortable(zScreen);
    // These cases should never happen and indicate a bug in Tailwind CSS itself
    if (aSorting.reason === "multiple-values" || bSorting.reason === "multiple-values") {
        throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
    } else if (aSorting.reason === "raw-values" || bSorting.reason === "raw-values") {
        throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
    } else if (aSorting.reason === "min-and-max" || bSorting.reason === "min-and-max") {
        throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
    }
    // Let the sorting begin
    let { min: aMin , max: aMax  } = aScreen.values[0];
    let { min: zMin , max: zMax  } = zScreen.values[0];
    // Negating screens flip their behavior. Basically `not min-width` is `max-width`
    if (a.not) [aMin, aMax] = [
        aMax,
        aMin
    ];
    if (z.not) [zMin, zMax] = [
        zMax,
        zMin
    ];
    aMin = aMin === undefined ? aMin : parseFloat(aMin);
    aMax = aMax === undefined ? aMax : parseFloat(aMax);
    zMin = zMin === undefined ? zMin : parseFloat(zMin);
    zMax = zMax === undefined ? zMax : parseFloat(zMax);
    let [aValue, zValue] = type === "min" ? [
        aMin,
        zMin
    ] : [
        zMax,
        aMax
    ];
    return aValue - zValue;
}
function toScreen(value, type) {
    if (typeof value === "object") {
        return value;
    }
    return {
        name: "arbitrary-screen",
        values: [
            {
                [type]: value
            }
        ]
    };
}
function resolveValue({ "min-width": _minWidth , min =_minWidth , max , raw  } = {}) {
    return {
        min,
        max,
        raw
    };
}


/***/ }),

/***/ 28307:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>parseAnimationValue
}));
const DIRECTIONS = new Set([
    "normal",
    "reverse",
    "alternate",
    "alternate-reverse"
]);
const PLAY_STATES = new Set([
    "running",
    "paused"
]);
const FILL_MODES = new Set([
    "none",
    "forwards",
    "backwards",
    "both"
]);
const ITERATION_COUNTS = new Set([
    "infinite"
]);
const TIMINGS = new Set([
    "linear",
    "ease",
    "ease-in",
    "ease-out",
    "ease-in-out",
    "step-start",
    "step-end"
]);
const TIMING_FNS = [
    "cubic-bezier",
    "steps"
];
const COMMA = /\,(?![^(]*\))/g // Comma separator that is not located between brackets. E.g.: `cubiz-bezier(a, b, c)` these don't count.
;
const SPACE = /\ +(?![^(]*\))/g // Similar to the one above, but with spaces instead.
;
const TIME = /^(-?[\d.]+m?s)$/;
const DIGIT = /^(\d+)$/;
function parseAnimationValue(input) {
    let animations = input.split(COMMA);
    return animations.map((animation)=>{
        let value = animation.trim();
        let result = {
            value
        };
        let parts = value.split(SPACE);
        let seen = new Set();
        for (let part of parts){
            if (!seen.has("DIRECTIONS") && DIRECTIONS.has(part)) {
                result.direction = part;
                seen.add("DIRECTIONS");
            } else if (!seen.has("PLAY_STATES") && PLAY_STATES.has(part)) {
                result.playState = part;
                seen.add("PLAY_STATES");
            } else if (!seen.has("FILL_MODES") && FILL_MODES.has(part)) {
                result.fillMode = part;
                seen.add("FILL_MODES");
            } else if (!seen.has("ITERATION_COUNTS") && (ITERATION_COUNTS.has(part) || DIGIT.test(part))) {
                result.iterationCount = part;
                seen.add("ITERATION_COUNTS");
            } else if (!seen.has("TIMING_FUNCTION") && TIMINGS.has(part)) {
                result.timingFunction = part;
                seen.add("TIMING_FUNCTION");
            } else if (!seen.has("TIMING_FUNCTION") && TIMING_FNS.some((f)=>part.startsWith(`${f}(`))) {
                result.timingFunction = part;
                seen.add("TIMING_FUNCTION");
            } else if (!seen.has("DURATION") && TIME.test(part)) {
                result.duration = part;
                seen.add("DURATION");
            } else if (!seen.has("DELAY") && TIME.test(part)) {
                result.delay = part;
                seen.add("DELAY");
            } else if (!seen.has("NAME")) {
                result.name = part;
                seen.add("NAME");
            } else {
                if (!result.unknown) result.unknown = [];
                result.unknown.push(part);
            }
        }
        return result;
    });
}


/***/ }),

/***/ 43524:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    parseBoxShadowValue: ()=>parseBoxShadowValue,
    formatBoxShadowValue: ()=>formatBoxShadowValue
});
const _splitAtTopLevelOnly = __nccwpck_require__(5721);
let KEYWORDS = new Set([
    "inset",
    "inherit",
    "initial",
    "revert",
    "unset"
]);
let SPACE = /\ +(?![^(]*\))/g // Similar to the one above, but with spaces instead.
;
let LENGTH = /^-?(\d+|\.\d+)(.*?)$/g;
function parseBoxShadowValue(input) {
    let shadows = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(input, ",");
    return shadows.map((shadow)=>{
        let value = shadow.trim();
        let result = {
            raw: value
        };
        let parts = value.split(SPACE);
        let seen = new Set();
        for (let part of parts){
            // Reset index, since the regex is stateful.
            LENGTH.lastIndex = 0;
            // Keyword
            if (!seen.has("KEYWORD") && KEYWORDS.has(part)) {
                result.keyword = part;
                seen.add("KEYWORD");
            } else if (LENGTH.test(part)) {
                if (!seen.has("X")) {
                    result.x = part;
                    seen.add("X");
                } else if (!seen.has("Y")) {
                    result.y = part;
                    seen.add("Y");
                } else if (!seen.has("BLUR")) {
                    result.blur = part;
                    seen.add("BLUR");
                } else if (!seen.has("SPREAD")) {
                    result.spread = part;
                    seen.add("SPREAD");
                }
            } else {
                if (!result.color) {
                    result.color = part;
                } else {
                    if (!result.unknown) result.unknown = [];
                    result.unknown.push(part);
                }
            }
        }
        // Check if valid
        result.valid = result.x !== undefined && result.y !== undefined;
        return result;
    });
}
function formatBoxShadowValue(shadows) {
    return shadows.map((shadow)=>{
        if (!shadow.valid) {
            return shadow.raw;
        }
        return [
            shadow.keyword,
            shadow.x,
            shadow.y,
            shadow.blur,
            shadow.spread,
            shadow.color
        ].filter(Boolean).join(" ");
    }).join(", ");
}


/***/ }),

/***/ 71315:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
// @ts-check
/**
 * @typedef {{type: 'dependency', file: string} | {type: 'dir-dependency', dir: string, glob: string}} Dependency
 */ /**
 *
 * @param {import('../lib/content.js').ContentPath} contentPath
 * @returns {Dependency[]}
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>parseDependency
}));
function parseDependency(contentPath) {
    if (contentPath.ignore) {
        return [];
    }
    if (!contentPath.glob) {
        return [
            {
                type: "dependency",
                file: contentPath.base
            }
        ];
    }
    if (process.env.ROLLUP_WATCH === "true") {
        // rollup-plugin-postcss does not support dir-dependency messages
        // but directories can be watched in the same way as files
        return [
            {
                type: "dependency",
                file: contentPath.base
            }
        ];
    }
    return [
        {
            type: "dir-dependency",
            dir: contentPath.base,
            glob: contentPath.glob
        }
    ];
}


/***/ }),

/***/ 88258:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "parseGlob", ({
    enumerable: true,
    get: ()=>parseGlob
}));
const _globParent = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(44025));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function parseGlob(pattern) {
    let glob = pattern;
    let base = (0, _globParent.default)(pattern);
    if (base !== ".") {
        glob = pattern.substr(base.length);
        if (glob.charAt(0) === "/") {
            glob = glob.substr(1);
        }
    }
    if (glob.substr(0, 2) === "./") {
        glob = glob.substr(2);
    }
    if (glob.charAt(0) === "/") {
        glob = glob.substr(1);
    }
    return {
        base,
        glob
    };
}


/***/ }),

/***/ 52375:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>parseObjectStyles
}));
const _postcss = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(77001));
const _postcssNested = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(90124));
const _postcssJs = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(70481));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function parseObjectStyles(styles) {
    if (!Array.isArray(styles)) {
        return parseObjectStyles([
            styles
        ]);
    }
    return styles.flatMap((style)=>{
        return (0, _postcss.default)([
            (0, _postcssNested.default)({
                bubble: [
                    "screen"
                ]
            })
        ]).process(style, {
            parser: _postcssJs.default
        }).root.nodes;
    });
}


/***/ }),

/***/ 89244:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    updateAllClasses: ()=>updateAllClasses,
    asValue: ()=>asValue,
    parseColorFormat: ()=>parseColorFormat,
    asColor: ()=>asColor,
    asLookupValue: ()=>asLookupValue,
    typeMap: ()=>typeMap,
    coerceValue: ()=>coerceValue,
    getMatchingTypes: ()=>getMatchingTypes
});
const _escapeCommas = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(38854));
const _withAlphaVariable = __nccwpck_require__(4195);
const _dataTypes = __nccwpck_require__(85921);
const _negateValue = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(76164));
const _validateFormalSyntax = __nccwpck_require__(83487);
const _featureFlagsJs = __nccwpck_require__(90);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function updateAllClasses(selectors, updateClass) {
    selectors.walkClasses((sel)=>{
        sel.value = updateClass(sel.value);
        if (sel.raws && sel.raws.value) {
            sel.raws.value = (0, _escapeCommas.default)(sel.raws.value);
        }
    });
}
function resolveArbitraryValue(modifier, validate) {
    if (!isArbitraryValue(modifier)) {
        return undefined;
    }
    let value = modifier.slice(1, -1);
    if (!validate(value)) {
        return undefined;
    }
    return (0, _dataTypes.normalize)(value);
}
function asNegativeValue(modifier, lookup = {}, validate) {
    let positiveValue = lookup[modifier];
    if (positiveValue !== undefined) {
        return (0, _negateValue.default)(positiveValue);
    }
    if (isArbitraryValue(modifier)) {
        let resolved = resolveArbitraryValue(modifier, validate);
        if (resolved === undefined) {
            return undefined;
        }
        return (0, _negateValue.default)(resolved);
    }
}
function asValue(modifier, options = {}, { validate =()=>true  } = {}) {
    var _options_values;
    let value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];
    if (value !== undefined) {
        return value;
    }
    if (options.supportsNegativeValues && modifier.startsWith("-")) {
        return asNegativeValue(modifier.slice(1), options.values, validate);
    }
    return resolveArbitraryValue(modifier, validate);
}
function isArbitraryValue(input) {
    return input.startsWith("[") && input.endsWith("]");
}
function splitUtilityModifier(modifier) {
    let slashIdx = modifier.lastIndexOf("/");
    if (slashIdx === -1 || slashIdx === modifier.length - 1) {
        return [
            modifier,
            undefined
        ];
    }
    let arbitrary = isArbitraryValue(modifier);
    // The modifier could be of the form `[foo]/[bar]`
    // We want to handle this case properly
    // without affecting `[foo/bar]`
    if (arbitrary && !modifier.includes("]/[")) {
        return [
            modifier,
            undefined
        ];
    }
    return [
        modifier.slice(0, slashIdx),
        modifier.slice(slashIdx + 1)
    ];
}
function parseColorFormat(value) {
    if (typeof value === "string" && value.includes("<alpha-value>")) {
        let oldValue = value;
        return ({ opacityValue =1  })=>oldValue.replace("<alpha-value>", opacityValue);
    }
    return value;
}
function asColor(modifier, options = {}, { tailwindConfig ={}  } = {}) {
    var _options_values;
    if (((_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier]) !== undefined) {
        var _options_values1;
        return parseColorFormat((_options_values1 = options.values) === null || _options_values1 === void 0 ? void 0 : _options_values1[modifier]);
    }
    // TODO: Hoist this up to getMatchingTypes or something
    // We do this here because we need the alpha value (if any)
    let [color, alpha] = splitUtilityModifier(modifier);
    if (alpha !== undefined) {
        var _options_values2, _tailwindConfig_theme, _tailwindConfig_theme_opacity;
        var _options_values_color;
        let normalizedColor = (_options_values_color = (_options_values2 = options.values) === null || _options_values2 === void 0 ? void 0 : _options_values2[color]) !== null && _options_values_color !== void 0 ? _options_values_color : isArbitraryValue(color) ? color.slice(1, -1) : undefined;
        if (normalizedColor === undefined) {
            return undefined;
        }
        normalizedColor = parseColorFormat(normalizedColor);
        if (isArbitraryValue(alpha)) {
            return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, alpha.slice(1, -1));
        }
        if (((_tailwindConfig_theme = tailwindConfig.theme) === null || _tailwindConfig_theme === void 0 ? void 0 : (_tailwindConfig_theme_opacity = _tailwindConfig_theme.opacity) === null || _tailwindConfig_theme_opacity === void 0 ? void 0 : _tailwindConfig_theme_opacity[alpha]) === undefined) {
            return undefined;
        }
        return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, tailwindConfig.theme.opacity[alpha]);
    }
    return asValue(modifier, options, {
        validate: _dataTypes.color
    });
}
function asLookupValue(modifier, options = {}) {
    var _options_values;
    return (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];
}
function guess(validate) {
    return (modifier, options)=>{
        return asValue(modifier, options, {
            validate
        });
    };
}
let typeMap = {
    any: asValue,
    color: asColor,
    url: guess(_dataTypes.url),
    image: guess(_dataTypes.image),
    length: guess(_dataTypes.length),
    percentage: guess(_dataTypes.percentage),
    position: guess(_dataTypes.position),
    lookup: asLookupValue,
    "generic-name": guess(_dataTypes.genericName),
    "family-name": guess(_dataTypes.familyName),
    number: guess(_dataTypes.number),
    "line-width": guess(_dataTypes.lineWidth),
    "absolute-size": guess(_dataTypes.absoluteSize),
    "relative-size": guess(_dataTypes.relativeSize),
    shadow: guess(_dataTypes.shadow),
    size: guess(_validateFormalSyntax.backgroundSize)
};
let supportedTypes = Object.keys(typeMap);
function splitAtFirst(input, delim) {
    let idx = input.indexOf(delim);
    if (idx === -1) return [
        undefined,
        input
    ];
    return [
        input.slice(0, idx),
        input.slice(idx + 1)
    ];
}
function coerceValue(types, modifier, options, tailwindConfig) {
    if (options.values && modifier in options.values) {
        for (let { type  } of types !== null && types !== void 0 ? types : []){
            let result = typeMap[type](modifier, options, {
                tailwindConfig
            });
            if (result === undefined) {
                continue;
            }
            return [
                result,
                type,
                null
            ];
        }
    }
    if (isArbitraryValue(modifier)) {
        let arbitraryValue = modifier.slice(1, -1);
        let [explicitType, value] = splitAtFirst(arbitraryValue, ":");
        // It could be that this resolves to `url(https` which is not a valid
        // identifier. We currently only support "simple" words with dashes or
        // underscores. E.g.: family-name
        if (!/^[\w-_]+$/g.test(explicitType)) {
            value = arbitraryValue;
        } else if (explicitType !== undefined && !supportedTypes.includes(explicitType)) {
            return [];
        }
        if (value.length > 0 && supportedTypes.includes(explicitType)) {
            return [
                asValue(`[${value}]`, options),
                explicitType,
                null
            ];
        }
    }
    let matches = getMatchingTypes(types, modifier, options, tailwindConfig);
    // Find first matching type
    for (let match of matches){
        return match;
    }
    return [];
}
function* getMatchingTypes(types, rawModifier, options, tailwindConfig) {
    let modifiersEnabled = (0, _featureFlagsJs.flagEnabled)(tailwindConfig, "generalizedModifiers");
    let [modifier, utilityModifier] = splitUtilityModifier(rawModifier);
    let canUseUtilityModifier = modifiersEnabled && options.modifiers != null && (options.modifiers === "any" || typeof options.modifiers === "object" && (utilityModifier && isArbitraryValue(utilityModifier) || utilityModifier in options.modifiers));
    if (!canUseUtilityModifier) {
        modifier = rawModifier;
        utilityModifier = undefined;
    }
    if (utilityModifier !== undefined && modifier === "") {
        modifier = "DEFAULT";
    }
    // Check the full value first
    // TODO: Move to asValue… somehow
    if (utilityModifier !== undefined) {
        if (typeof options.modifiers === "object") {
            var _options_modifiers;
            var _options_modifiers_utilityModifier;
            let configValue = (_options_modifiers_utilityModifier = (_options_modifiers = options.modifiers) === null || _options_modifiers === void 0 ? void 0 : _options_modifiers[utilityModifier]) !== null && _options_modifiers_utilityModifier !== void 0 ? _options_modifiers_utilityModifier : null;
            if (configValue !== null) {
                utilityModifier = configValue;
            } else if (isArbitraryValue(utilityModifier)) {
                utilityModifier = utilityModifier.slice(1, -1);
            }
        }
    }
    for (let { type  } of types !== null && types !== void 0 ? types : []){
        let result = typeMap[type](modifier, options, {
            tailwindConfig
        });
        if (result === undefined) {
            continue;
        }
        yield [
            result,
            type,
            utilityModifier !== null && utilityModifier !== void 0 ? utilityModifier : null
        ];
    }
}


/***/ }),

/***/ 74710:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>_default
}));
const _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(32997));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _default(prefix, selector, prependNegative = false) {
    if (prefix === "") {
        return selector;
    }
    let ast = typeof selector === "string" ? (0, _postcssSelectorParser.default)().astSync(selector) : selector;
    ast.walkClasses((classSelector)=>{
        let baseClass = classSelector.value;
        let shouldPlaceNegativeBeforePrefix = prependNegative && baseClass.startsWith("-");
        classSelector.value = shouldPlaceNegativeBeforePrefix ? `-${prefix}${baseClass.slice(1)}` : `${prefix}${baseClass}`;
    });
    return typeof selector === "string" ? ast.toString() : ast;
}


/***/ }),

/***/ 49814:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * This function removes any uses of CSS variables used as an alpha channel
 *
 * This is required for selectors like `:visited` which do not allow
 * changes in opacity or external control using CSS variables.
 *
 * @param {import('postcss').Container} container
 * @param {string[]} toRemove
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "removeAlphaVariables", ({
    enumerable: true,
    get: ()=>removeAlphaVariables
}));
function removeAlphaVariables(container, toRemove) {
    container.walkDecls((decl)=>{
        if (toRemove.includes(decl.prop)) {
            decl.remove();
            return;
        }
        for (let varName of toRemove){
            if (decl.value.includes(`/ var(${varName})`)) {
                decl.value = decl.value.replace(`/ var(${varName})`, "");
            }
        }
    });
}


/***/ }),

/***/ 55530:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>resolveConfig
}));
const _negateValue = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(76164));
const _corePluginList = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(49271));
const _configurePlugins = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(75928));
const _colors = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(90906));
const _defaults = __nccwpck_require__(86330);
const _toPath = __nccwpck_require__(11402);
const _normalizeConfig = __nccwpck_require__(42937);
const _isPlainObject = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(20896));
const _cloneDeep = __nccwpck_require__(45706);
const _pluginUtils = __nccwpck_require__(89244);
const _withAlphaVariable = __nccwpck_require__(4195);
const _toColorValue = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(8489));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function isFunction(input) {
    return typeof input === "function";
}
function mergeWith(target, ...sources) {
    let customizer = sources.pop();
    for (let source of sources){
        for(let k in source){
            let merged = customizer(target[k], source[k]);
            if (merged === undefined) {
                if ((0, _isPlainObject.default)(target[k]) && (0, _isPlainObject.default)(source[k])) {
                    target[k] = mergeWith({}, target[k], source[k], customizer);
                } else {
                    target[k] = source[k];
                }
            } else {
                target[k] = merged;
            }
        }
    }
    return target;
}
const configUtils = {
    colors: _colors.default,
    negative (scale) {
        // TODO: Log that this function isn't really needed anymore?
        return Object.keys(scale).filter((key)=>scale[key] !== "0").reduce((negativeScale, key)=>{
            let negativeValue = (0, _negateValue.default)(scale[key]);
            if (negativeValue !== undefined) {
                negativeScale[`-${key}`] = negativeValue;
            }
            return negativeScale;
        }, {});
    },
    breakpoints (screens) {
        return Object.keys(screens).filter((key)=>typeof screens[key] === "string").reduce((breakpoints, key)=>({
                ...breakpoints,
                [`screen-${key}`]: screens[key]
            }), {});
    }
};
function value(valueToResolve, ...args) {
    return isFunction(valueToResolve) ? valueToResolve(...args) : valueToResolve;
}
function collectExtends(items) {
    return items.reduce((merged, { extend  })=>{
        return mergeWith(merged, extend, (mergedValue, extendValue)=>{
            if (mergedValue === undefined) {
                return [
                    extendValue
                ];
            }
            if (Array.isArray(mergedValue)) {
                return [
                    extendValue,
                    ...mergedValue
                ];
            }
            return [
                extendValue,
                mergedValue
            ];
        });
    }, {});
}
function mergeThemes(themes) {
    return {
        ...themes.reduce((merged, theme)=>(0, _defaults.defaults)(merged, theme), {}),
        // In order to resolve n config objects, we combine all of their `extend` properties
        // into arrays instead of objects so they aren't overridden.
        extend: collectExtends(themes)
    };
}
function mergeExtensionCustomizer(merged, value) {
    // When we have an array of objects, we do want to merge it
    if (Array.isArray(merged) && (0, _isPlainObject.default)(merged[0])) {
        return merged.concat(value);
    }
    // When the incoming value is an array, and the existing config is an object, prepend the existing object
    if (Array.isArray(value) && (0, _isPlainObject.default)(value[0]) && (0, _isPlainObject.default)(merged)) {
        return [
            merged,
            ...value
        ];
    }
    // Override arrays (for example for font-families, box-shadows, ...)
    if (Array.isArray(value)) {
        return value;
    }
    // Execute default behaviour
    return undefined;
}
function mergeExtensions({ extend , ...theme }) {
    return mergeWith(theme, extend, (themeValue, extensions)=>{
        // The `extend` property is an array, so we need to check if it contains any functions
        if (!isFunction(themeValue) && !extensions.some(isFunction)) {
            return mergeWith({}, themeValue, ...extensions, mergeExtensionCustomizer);
        }
        return (resolveThemePath, utils)=>mergeWith({}, ...[
                themeValue,
                ...extensions
            ].map((e)=>value(e, resolveThemePath, utils)), mergeExtensionCustomizer);
    });
}
/**
 *
 * @param {string} key
 * @return {Iterable<string[] & {alpha: string | undefined}>}
 */ function* toPaths(key) {
    let path = (0, _toPath.toPath)(key);
    if (path.length === 0) {
        return;
    }
    yield path;
    if (Array.isArray(key)) {
        return;
    }
    let pattern = /^(.*?)\s*\/\s*([^/]+)$/;
    let matches = key.match(pattern);
    if (matches !== null) {
        let [, prefix, alpha] = matches;
        let newPath = (0, _toPath.toPath)(prefix);
        newPath.alpha = alpha;
        yield newPath;
    }
}
function resolveFunctionKeys(object) {
    // theme('colors.red.500 / 0.5') -> ['colors', 'red', '500 / 0', '5]
    const resolvePath = (key, defaultValue)=>{
        for (const path of toPaths(key)){
            let index = 0;
            let val = object;
            while(val !== undefined && val !== null && index < path.length){
                val = val[path[index++]];
                let shouldResolveAsFn = isFunction(val) && (path.alpha === undefined || index <= path.length - 1);
                val = shouldResolveAsFn ? val(resolvePath, configUtils) : val;
            }
            if (val !== undefined) {
                if (path.alpha !== undefined) {
                    let normalized = (0, _pluginUtils.parseColorFormat)(val);
                    return (0, _withAlphaVariable.withAlphaValue)(normalized, path.alpha, (0, _toColorValue.default)(normalized));
                }
                if ((0, _isPlainObject.default)(val)) {
                    return (0, _cloneDeep.cloneDeep)(val);
                }
                return val;
            }
        }
        return defaultValue;
    };
    Object.assign(resolvePath, {
        theme: resolvePath,
        ...configUtils
    });
    return Object.keys(object).reduce((resolved, key)=>{
        resolved[key] = isFunction(object[key]) ? object[key](resolvePath, configUtils) : object[key];
        return resolved;
    }, {});
}
function extractPluginConfigs(configs) {
    let allConfigs = [];
    configs.forEach((config)=>{
        allConfigs = [
            ...allConfigs,
            config
        ];
        var _config_plugins;
        const plugins = (_config_plugins = config === null || config === void 0 ? void 0 : config.plugins) !== null && _config_plugins !== void 0 ? _config_plugins : [];
        if (plugins.length === 0) {
            return;
        }
        plugins.forEach((plugin)=>{
            if (plugin.__isOptionsFunction) {
                plugin = plugin();
            }
            var _plugin_config;
            allConfigs = [
                ...allConfigs,
                ...extractPluginConfigs([
                    (_plugin_config = plugin === null || plugin === void 0 ? void 0 : plugin.config) !== null && _plugin_config !== void 0 ? _plugin_config : {}
                ])
            ];
        });
    });
    return allConfigs;
}
function resolveCorePlugins(corePluginConfigs) {
    const result = [
        ...corePluginConfigs
    ].reduceRight((resolved, corePluginConfig)=>{
        if (isFunction(corePluginConfig)) {
            return corePluginConfig({
                corePlugins: resolved
            });
        }
        return (0, _configurePlugins.default)(corePluginConfig, resolved);
    }, _corePluginList.default);
    return result;
}
function resolvePluginLists(pluginLists) {
    const result = [
        ...pluginLists
    ].reduceRight((resolved, pluginList)=>{
        return [
            ...resolved,
            ...pluginList
        ];
    }, []);
    return result;
}
function resolveConfig(configs) {
    let allConfigs = [
        ...extractPluginConfigs(configs),
        {
            prefix: "",
            important: false,
            separator: ":"
        }
    ];
    var _t_theme, _c_plugins;
    return (0, _normalizeConfig.normalizeConfig)((0, _defaults.defaults)({
        theme: resolveFunctionKeys(mergeExtensions(mergeThemes(allConfigs.map((t)=>{
            return (_t_theme = t === null || t === void 0 ? void 0 : t.theme) !== null && _t_theme !== void 0 ? _t_theme : {};
        })))),
        corePlugins: resolveCorePlugins(allConfigs.map((c)=>c.corePlugins)),
        plugins: resolvePluginLists(configs.map((c)=>{
            return (_c_plugins = c === null || c === void 0 ? void 0 : c.plugins) !== null && _c_plugins !== void 0 ? _c_plugins : [];
        }))
    }, ...allConfigs));
}


/***/ }),

/***/ 10184:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>resolveConfigPath
}));
const _fs = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(57147));
const _path = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(71017));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isEmpty(obj) {
    return Object.keys(obj).length === 0;
}
function isString(value) {
    return typeof value === "string" || value instanceof String;
}
function resolveConfigPath(pathOrConfig) {
    // require('tailwindcss')({ theme: ..., variants: ... })
    if (isObject(pathOrConfig) && pathOrConfig.config === undefined && !isEmpty(pathOrConfig)) {
        return null;
    }
    // require('tailwindcss')({ config: 'custom-config.js' })
    if (isObject(pathOrConfig) && pathOrConfig.config !== undefined && isString(pathOrConfig.config)) {
        return _path.default.resolve(pathOrConfig.config);
    }
    // require('tailwindcss')({ config: { theme: ..., variants: ... } })
    if (isObject(pathOrConfig) && pathOrConfig.config !== undefined && isObject(pathOrConfig.config)) {
        return null;
    }
    // require('tailwindcss')('custom-config.js')
    if (isString(pathOrConfig)) {
        return _path.default.resolve(pathOrConfig);
    }
    // require('tailwindcss')
    for (const configFile of [
        "./tailwind.config.js",
        "./tailwind.config.cjs"
    ]){
        try {
            const configPath = _path.default.resolve(configFile);
            _fs.default.accessSync(configPath);
            return configPath;
        } catch (err) {}
    }
    return null;
}


/***/ }),

/***/ 5721:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * This splits a string on a top-level character.
 *
 * Regex doesn't support recursion (at least not the JS-flavored version).
 * So we have to use a tiny state machine to keep track of paren placement.
 *
 * Expected behavior using commas:
 * var(--a, 0 0 1px rgb(0, 0, 0)), 0 0 1px rgb(0, 0, 0)
 *       ─┬─             ┬  ┬    ┬
 *        x              x  x    ╰──────── Split because top-level
 *        ╰──────────────┴──┴───────────── Ignored b/c inside >= 1 levels of parens
 *
 * @param {string} input
 * @param {string} separator
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "splitAtTopLevelOnly", ({
    enumerable: true,
    get: ()=>splitAtTopLevelOnly
}));
function splitAtTopLevelOnly(input, separator) {
    let stack = [];
    let parts = [];
    let lastPos = 0;
    for(let idx = 0; idx < input.length; idx++){
        let char = input[idx];
        if (stack.length === 0 && char === separator[0]) {
            if (separator.length === 1 || input.slice(idx, idx + separator.length) === separator) {
                parts.push(input.slice(lastPos, idx));
                lastPos = idx + separator.length;
            }
        }
        if (char === "(" || char === "[" || char === "{") {
            stack.push(char);
        } else if (char === ")" && stack[stack.length - 1] === "(" || char === "]" && stack[stack.length - 1] === "[" || char === "}" && stack[stack.length - 1] === "{") {
            stack.pop();
        }
    }
    parts.push(input.slice(lastPos));
    return parts;
}


/***/ }),

/***/ 8489:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>toColorValue
}));
function toColorValue(maybeFunction) {
    return typeof maybeFunction === "function" ? maybeFunction({}) : maybeFunction;
}


/***/ }),

/***/ 11402:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * Parse a path string into an array of path segments.
 *
 * Square bracket notation `a[b]` may be used to "escape" dots that would otherwise be interpreted as path separators.
 *
 * Example:
 * a -> ['a']
 * a.b.c -> ['a', 'b', 'c']
 * a[b].c -> ['a', 'b', 'c']
 * a[b.c].e.f -> ['a', 'b.c', 'e', 'f']
 * a[b][c][d] -> ['a', 'b', 'c', 'd']
 *
 * @param {string|string[]} path
 **/ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "toPath", ({
    enumerable: true,
    get: ()=>toPath
}));
function toPath(path) {
    if (Array.isArray(path)) return path;
    let openBrackets = path.split("[").length - 1;
    let closedBrackets = path.split("]").length - 1;
    if (openBrackets !== closedBrackets) {
        throw new Error(`Path is invalid. Has unbalanced brackets: ${path}`);
    }
    return path.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
}


/***/ }),

/***/ 71985:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: ()=>transformThemeValue
}));
const _postcss = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(77001));
const _isPlainObject = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(20896));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function transformThemeValue(themeSection) {
    if ([
        "fontSize",
        "outline"
    ].includes(themeSection)) {
        return (value)=>{
            if (typeof value === "function") value = value({});
            if (Array.isArray(value)) value = value[0];
            return value;
        };
    }
    if (themeSection === "fontFamily") {
        return (value)=>{
            if (typeof value === "function") value = value({});
            let families = Array.isArray(value) && (0, _isPlainObject.default)(value[1]) ? value[0] : value;
            return Array.isArray(families) ? families.join(", ") : families;
        };
    }
    if ([
        "boxShadow",
        "transitionProperty",
        "transitionDuration",
        "transitionDelay",
        "transitionTimingFunction",
        "backgroundImage",
        "backgroundSize",
        "backgroundColor",
        "cursor",
        "animation"
    ].includes(themeSection)) {
        return (value)=>{
            if (typeof value === "function") value = value({});
            if (Array.isArray(value)) value = value.join(", ");
            return value;
        };
    }
    // For backwards compatibility reasons, before we switched to underscores
    // instead of commas for arbitrary values.
    if ([
        "gridTemplateColumns",
        "gridTemplateRows",
        "objectPosition"
    ].includes(themeSection)) {
        return (value)=>{
            if (typeof value === "function") value = value({});
            if (typeof value === "string") value = _postcss.default.list.comma(value).join(" ");
            return value;
        };
    }
    return (value, opts = {})=>{
        if (typeof value === "function") {
            value = value(opts);
        }
        return value;
    };
}


/***/ }),

/***/ 97277:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "validateConfig", ({
    enumerable: true,
    get: ()=>validateConfig
}));
const _log = /*#__PURE__*/ _interopRequireDefault(__nccwpck_require__(64368));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function validateConfig(config) {
    if (config.content.files.length === 0) {
        _log.default.warn("content-problems", [
            "The `content` option in your Tailwind CSS configuration is missing or empty.",
            "Configure your content sources or your generated CSS will be missing styles.",
            "https://tailwindcss.com/docs/content-configuration"
        ]);
    }
    return config;
}


/***/ }),

/***/ 83487:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "backgroundSize", ({
    enumerable: true,
    get: ()=>backgroundSize
}));
const _dataTypes = __nccwpck_require__(85921);
const _splitAtTopLevelOnly = __nccwpck_require__(5721);
function backgroundSize(value) {
    let keywordValues = [
        "cover",
        "contain"
    ];
    // the <length-percentage> type will probably be a css function
    // so we have to use `splitAtTopLevelOnly`
    return (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, ",").every((part)=>{
        let sizes = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(part, "_").filter(Boolean);
        if (sizes.length === 1 && keywordValues.includes(sizes[0])) return true;
        if (sizes.length !== 1 && sizes.length !== 2) return false;
        return sizes.every((size)=>(0, _dataTypes.length)(size) || (0, _dataTypes.percentage)(size) || size === "auto");
    });
}


/***/ }),

/***/ 4195:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    withAlphaValue: ()=>withAlphaValue,
    default: ()=>withAlphaVariable
});
const _color = __nccwpck_require__(82451);
function withAlphaValue(color, alphaValue, defaultValue) {
    if (typeof color === "function") {
        return color({
            opacityValue: alphaValue
        });
    }
    let parsed = (0, _color.parseColor)(color, {
        loose: true
    });
    if (parsed === null) {
        return defaultValue;
    }
    return (0, _color.formatColor)({
        ...parsed,
        alpha: alphaValue
    });
}
function withAlphaVariable({ color , property , variable  }) {
    let properties = [].concat(property);
    if (typeof color === "function") {
        return {
            [variable]: "1",
            ...Object.fromEntries(properties.map((p)=>{
                return [
                    p,
                    color({
                        opacityVariable: variable,
                        opacityValue: `var(${variable})`
                    })
                ];
            }))
        };
    }
    const parsed = (0, _color.parseColor)(color);
    if (parsed === null) {
        return Object.fromEntries(properties.map((p)=>[
                p,
                color
            ]));
    }
    if (parsed.alpha !== undefined) {
        // Has an alpha value, return color as-is
        return Object.fromEntries(properties.map((p)=>[
                p,
                color
            ]));
    }
    return {
        [variable]: "1",
        ...Object.fromEntries(properties.map((p)=>{
            return [
                p,
                (0, _color.formatColor)({
                    ...parsed,
                    alpha: `var(${variable})`
                })
            ];
        }))
    };
}


/***/ }),

/***/ 44025:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var isGlob = __nccwpck_require__(34466);
var pathPosixDirname = (__nccwpck_require__(71017).posix.dirname);
var isWin32 = (__nccwpck_require__(22037).platform)() === 'win32';

var slash = '/';
var backslash = /\\/g;
var escaped = /\\([!*?|[\](){}])/g;

/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 */
module.exports = function globParent(str, opts) {
  var options = Object.assign({ flipBackslashes: true }, opts);

  // flip windows path separators
  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
    str = str.replace(backslash, slash);
  }

  // special case for strings ending in enclosure containing path separator
  if (isEnclosure(str)) {
    str += slash;
  }

  // preserves full path in case of trailing path separator
  str += 'a';

  // remove path parts that are globby
  do {
    str = pathPosixDirname(str);
  } while (isGlobby(str));

  // remove escape chars and return result
  return str.replace(escaped, '$1');
};

function isEnclosure(str) {
  var lastChar = str.slice(-1);

  var enclosureStart;
  switch (lastChar) {
    case '}':
      enclosureStart = '{';
      break;
    case ']':
      enclosureStart = '[';
      break;
    default:
      return false;
  }

  var foundIndex = str.indexOf(enclosureStart);
  if (foundIndex < 0) {
    return false;
  }

  return str.slice(foundIndex + 1, -1).includes(slash);
}

function isGlobby(str) {
  if (/\([^()]+$/.test(str)) {
    return true;
  }
  if (str[0] === '{' || str[0] === '[') {
    return true;
  }
  if (/[^\\][{[]/.test(str)) {
    return true;
  }
  return isGlob(str);
}


/***/ }),

/***/ 93088:
/***/ ((module) => {

/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [],
  presets: [],
  darkMode: 'media', // or 'class'
  theme: {
    accentColor: ({ theme }) => ({
      ...theme('colors'),
      auto: 'auto',
    }),
    animation: {
      none: 'none',
      spin: 'spin 1s linear infinite',
      ping: 'ping 1s cubic-bezier(0, 0, 0.2, 1) infinite',
      pulse: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
      bounce: 'bounce 1s infinite',
    },
    aria: {
      checked: 'checked="true"',
      disabled: 'disabled="true"',
      expanded: 'expanded="true"',
      hidden: 'hidden="true"',
      pressed: 'pressed="true"',
      readonly: 'readonly="true"',
      required: 'required="true"',
      selected: 'selected="true"',
    },
    aspectRatio: {
      auto: 'auto',
      square: '1 / 1',
      video: '16 / 9',
    },
    backdropBlur: ({ theme }) => theme('blur'),
    backdropBrightness: ({ theme }) => theme('brightness'),
    backdropContrast: ({ theme }) => theme('contrast'),
    backdropGrayscale: ({ theme }) => theme('grayscale'),
    backdropHueRotate: ({ theme }) => theme('hueRotate'),
    backdropInvert: ({ theme }) => theme('invert'),
    backdropOpacity: ({ theme }) => theme('opacity'),
    backdropSaturate: ({ theme }) => theme('saturate'),
    backdropSepia: ({ theme }) => theme('sepia'),
    backgroundColor: ({ theme }) => theme('colors'),
    backgroundImage: {
      none: 'none',
      'gradient-to-t': 'linear-gradient(to top, var(--tw-gradient-stops))',
      'gradient-to-tr': 'linear-gradient(to top right, var(--tw-gradient-stops))',
      'gradient-to-r': 'linear-gradient(to right, var(--tw-gradient-stops))',
      'gradient-to-br': 'linear-gradient(to bottom right, var(--tw-gradient-stops))',
      'gradient-to-b': 'linear-gradient(to bottom, var(--tw-gradient-stops))',
      'gradient-to-bl': 'linear-gradient(to bottom left, var(--tw-gradient-stops))',
      'gradient-to-l': 'linear-gradient(to left, var(--tw-gradient-stops))',
      'gradient-to-tl': 'linear-gradient(to top left, var(--tw-gradient-stops))',
    },
    backgroundOpacity: ({ theme }) => theme('opacity'),
    backgroundPosition: {
      bottom: 'bottom',
      center: 'center',
      left: 'left',
      'left-bottom': 'left bottom',
      'left-top': 'left top',
      right: 'right',
      'right-bottom': 'right bottom',
      'right-top': 'right top',
      top: 'top',
    },
    backgroundSize: {
      auto: 'auto',
      cover: 'cover',
      contain: 'contain',
    },
    blur: {
      0: '0',
      none: '0',
      sm: '4px',
      DEFAULT: '8px',
      md: '12px',
      lg: '16px',
      xl: '24px',
      '2xl': '40px',
      '3xl': '64px',
    },
    borderColor: ({ theme }) => ({
      ...theme('colors'),
      DEFAULT: theme('colors.gray.200', 'currentColor'),
    }),
    borderOpacity: ({ theme }) => theme('opacity'),
    borderRadius: {
      none: '0px',
      sm: '0.125rem',
      DEFAULT: '0.25rem',
      md: '0.375rem',
      lg: '0.5rem',
      xl: '0.75rem',
      '2xl': '1rem',
      '3xl': '1.5rem',
      full: '9999px',
    },
    borderSpacing: ({ theme }) => ({
      ...theme('spacing'),
    }),
    borderWidth: {
      DEFAULT: '1px',
      0: '0px',
      2: '2px',
      4: '4px',
      8: '8px',
    },
    boxShadow: {
      sm: '0 1px 2px 0 rgb(0 0 0 / 0.05)',
      DEFAULT: '0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)',
      md: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
      lg: '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)',
      xl: '0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)',
      '2xl': '0 25px 50px -12px rgb(0 0 0 / 0.25)',
      inner: 'inset 0 2px 4px 0 rgb(0 0 0 / 0.05)',
      none: 'none',
    },
    boxShadowColor: ({ theme }) => theme('colors'),
    brightness: {
      0: '0',
      50: '.5',
      75: '.75',
      90: '.9',
      95: '.95',
      100: '1',
      105: '1.05',
      110: '1.1',
      125: '1.25',
      150: '1.5',
      200: '2',
    },
    caretColor: ({ theme }) => theme('colors'),
    colors: ({ colors }) => ({
      inherit: colors.inherit,
      current: colors.current,
      transparent: colors.transparent,
      black: colors.black,
      white: colors.white,
      slate: colors.slate,
      gray: colors.gray,
      zinc: colors.zinc,
      neutral: colors.neutral,
      stone: colors.stone,
      red: colors.red,
      orange: colors.orange,
      amber: colors.amber,
      yellow: colors.yellow,
      lime: colors.lime,
      green: colors.green,
      emerald: colors.emerald,
      teal: colors.teal,
      cyan: colors.cyan,
      sky: colors.sky,
      blue: colors.blue,
      indigo: colors.indigo,
      violet: colors.violet,
      purple: colors.purple,
      fuchsia: colors.fuchsia,
      pink: colors.pink,
      rose: colors.rose,
    }),
    columns: {
      auto: 'auto',
      1: '1',
      2: '2',
      3: '3',
      4: '4',
      5: '5',
      6: '6',
      7: '7',
      8: '8',
      9: '9',
      10: '10',
      11: '11',
      12: '12',
      '3xs': '16rem',
      '2xs': '18rem',
      xs: '20rem',
      sm: '24rem',
      md: '28rem',
      lg: '32rem',
      xl: '36rem',
      '2xl': '42rem',
      '3xl': '48rem',
      '4xl': '56rem',
      '5xl': '64rem',
      '6xl': '72rem',
      '7xl': '80rem',
    },
    container: {},
    content: {
      none: 'none',
    },
    contrast: {
      0: '0',
      50: '.5',
      75: '.75',
      100: '1',
      125: '1.25',
      150: '1.5',
      200: '2',
    },
    cursor: {
      auto: 'auto',
      default: 'default',
      pointer: 'pointer',
      wait: 'wait',
      text: 'text',
      move: 'move',
      help: 'help',
      'not-allowed': 'not-allowed',
      none: 'none',
      'context-menu': 'context-menu',
      progress: 'progress',
      cell: 'cell',
      crosshair: 'crosshair',
      'vertical-text': 'vertical-text',
      alias: 'alias',
      copy: 'copy',
      'no-drop': 'no-drop',
      grab: 'grab',
      grabbing: 'grabbing',
      'all-scroll': 'all-scroll',
      'col-resize': 'col-resize',
      'row-resize': 'row-resize',
      'n-resize': 'n-resize',
      'e-resize': 'e-resize',
      's-resize': 's-resize',
      'w-resize': 'w-resize',
      'ne-resize': 'ne-resize',
      'nw-resize': 'nw-resize',
      'se-resize': 'se-resize',
      'sw-resize': 'sw-resize',
      'ew-resize': 'ew-resize',
      'ns-resize': 'ns-resize',
      'nesw-resize': 'nesw-resize',
      'nwse-resize': 'nwse-resize',
      'zoom-in': 'zoom-in',
      'zoom-out': 'zoom-out',
    },
    divideColor: ({ theme }) => theme('borderColor'),
    divideOpacity: ({ theme }) => theme('borderOpacity'),
    divideWidth: ({ theme }) => theme('borderWidth'),
    dropShadow: {
      sm: '0 1px 1px rgb(0 0 0 / 0.05)',
      DEFAULT: ['0 1px 2px rgb(0 0 0 / 0.1)', '0 1px 1px rgb(0 0 0 / 0.06)'],
      md: ['0 4px 3px rgb(0 0 0 / 0.07)', '0 2px 2px rgb(0 0 0 / 0.06)'],
      lg: ['0 10px 8px rgb(0 0 0 / 0.04)', '0 4px 3px rgb(0 0 0 / 0.1)'],
      xl: ['0 20px 13px rgb(0 0 0 / 0.03)', '0 8px 5px rgb(0 0 0 / 0.08)'],
      '2xl': '0 25px 25px rgb(0 0 0 / 0.15)',
      none: '0 0 #0000',
    },
    fill: ({ theme }) => ({
      none: 'none',
      ...theme('colors'),
    }),
    flex: {
      1: '1 1 0%',
      auto: '1 1 auto',
      initial: '0 1 auto',
      none: 'none',
    },
    flexBasis: ({ theme }) => ({
      auto: 'auto',
      ...theme('spacing'),
      '1/2': '50%',
      '1/3': '33.333333%',
      '2/3': '66.666667%',
      '1/4': '25%',
      '2/4': '50%',
      '3/4': '75%',
      '1/5': '20%',
      '2/5': '40%',
      '3/5': '60%',
      '4/5': '80%',
      '1/6': '16.666667%',
      '2/6': '33.333333%',
      '3/6': '50%',
      '4/6': '66.666667%',
      '5/6': '83.333333%',
      '1/12': '8.333333%',
      '2/12': '16.666667%',
      '3/12': '25%',
      '4/12': '33.333333%',
      '5/12': '41.666667%',
      '6/12': '50%',
      '7/12': '58.333333%',
      '8/12': '66.666667%',
      '9/12': '75%',
      '10/12': '83.333333%',
      '11/12': '91.666667%',
      full: '100%',
    }),
    flexGrow: {
      0: '0',
      DEFAULT: '1',
    },
    flexShrink: {
      0: '0',
      DEFAULT: '1',
    },
    fontFamily: {
      sans: [
        'ui-sans-serif',
        'system-ui',
        '-apple-system',
        'BlinkMacSystemFont',
        '"Segoe UI"',
        'Roboto',
        '"Helvetica Neue"',
        'Arial',
        '"Noto Sans"',
        'sans-serif',
        '"Apple Color Emoji"',
        '"Segoe UI Emoji"',
        '"Segoe UI Symbol"',
        '"Noto Color Emoji"',
      ],
      serif: ['ui-serif', 'Georgia', 'Cambria', '"Times New Roman"', 'Times', 'serif'],
      mono: [
        'ui-monospace',
        'SFMono-Regular',
        'Menlo',
        'Monaco',
        'Consolas',
        '"Liberation Mono"',
        '"Courier New"',
        'monospace',
      ],
    },
    fontSize: {
      xs: ['0.75rem', { lineHeight: '1rem' }],
      sm: ['0.875rem', { lineHeight: '1.25rem' }],
      base: ['1rem', { lineHeight: '1.5rem' }],
      lg: ['1.125rem', { lineHeight: '1.75rem' }],
      xl: ['1.25rem', { lineHeight: '1.75rem' }],
      '2xl': ['1.5rem', { lineHeight: '2rem' }],
      '3xl': ['1.875rem', { lineHeight: '2.25rem' }],
      '4xl': ['2.25rem', { lineHeight: '2.5rem' }],
      '5xl': ['3rem', { lineHeight: '1' }],
      '6xl': ['3.75rem', { lineHeight: '1' }],
      '7xl': ['4.5rem', { lineHeight: '1' }],
      '8xl': ['6rem', { lineHeight: '1' }],
      '9xl': ['8rem', { lineHeight: '1' }],
    },
    fontWeight: {
      thin: '100',
      extralight: '200',
      light: '300',
      normal: '400',
      medium: '500',
      semibold: '600',
      bold: '700',
      extrabold: '800',
      black: '900',
    },
    gap: ({ theme }) => theme('spacing'),
    gradientColorStops: ({ theme }) => theme('colors'),
    grayscale: {
      0: '0',
      DEFAULT: '100%',
    },
    gridAutoColumns: {
      auto: 'auto',
      min: 'min-content',
      max: 'max-content',
      fr: 'minmax(0, 1fr)',
    },
    gridAutoRows: {
      auto: 'auto',
      min: 'min-content',
      max: 'max-content',
      fr: 'minmax(0, 1fr)',
    },
    gridColumn: {
      auto: 'auto',
      'span-1': 'span 1 / span 1',
      'span-2': 'span 2 / span 2',
      'span-3': 'span 3 / span 3',
      'span-4': 'span 4 / span 4',
      'span-5': 'span 5 / span 5',
      'span-6': 'span 6 / span 6',
      'span-7': 'span 7 / span 7',
      'span-8': 'span 8 / span 8',
      'span-9': 'span 9 / span 9',
      'span-10': 'span 10 / span 10',
      'span-11': 'span 11 / span 11',
      'span-12': 'span 12 / span 12',
      'span-full': '1 / -1',
    },
    gridColumnEnd: {
      auto: 'auto',
      1: '1',
      2: '2',
      3: '3',
      4: '4',
      5: '5',
      6: '6',
      7: '7',
      8: '8',
      9: '9',
      10: '10',
      11: '11',
      12: '12',
      13: '13',
    },
    gridColumnStart: {
      auto: 'auto',
      1: '1',
      2: '2',
      3: '3',
      4: '4',
      5: '5',
      6: '6',
      7: '7',
      8: '8',
      9: '9',
      10: '10',
      11: '11',
      12: '12',
      13: '13',
    },
    gridRow: {
      auto: 'auto',
      'span-1': 'span 1 / span 1',
      'span-2': 'span 2 / span 2',
      'span-3': 'span 3 / span 3',
      'span-4': 'span 4 / span 4',
      'span-5': 'span 5 / span 5',
      'span-6': 'span 6 / span 6',
      'span-full': '1 / -1',
    },
    gridRowEnd: {
      auto: 'auto',
      1: '1',
      2: '2',
      3: '3',
      4: '4',
      5: '5',
      6: '6',
      7: '7',
    },
    gridRowStart: {
      auto: 'auto',
      1: '1',
      2: '2',
      3: '3',
      4: '4',
      5: '5',
      6: '6',
      7: '7',
    },
    gridTemplateColumns: {
      none: 'none',
      1: 'repeat(1, minmax(0, 1fr))',
      2: 'repeat(2, minmax(0, 1fr))',
      3: 'repeat(3, minmax(0, 1fr))',
      4: 'repeat(4, minmax(0, 1fr))',
      5: 'repeat(5, minmax(0, 1fr))',
      6: 'repeat(6, minmax(0, 1fr))',
      7: 'repeat(7, minmax(0, 1fr))',
      8: 'repeat(8, minmax(0, 1fr))',
      9: 'repeat(9, minmax(0, 1fr))',
      10: 'repeat(10, minmax(0, 1fr))',
      11: 'repeat(11, minmax(0, 1fr))',
      12: 'repeat(12, minmax(0, 1fr))',
    },
    gridTemplateRows: {
      none: 'none',
      1: 'repeat(1, minmax(0, 1fr))',
      2: 'repeat(2, minmax(0, 1fr))',
      3: 'repeat(3, minmax(0, 1fr))',
      4: 'repeat(4, minmax(0, 1fr))',
      5: 'repeat(5, minmax(0, 1fr))',
      6: 'repeat(6, minmax(0, 1fr))',
    },
    height: ({ theme }) => ({
      auto: 'auto',
      ...theme('spacing'),
      '1/2': '50%',
      '1/3': '33.333333%',
      '2/3': '66.666667%',
      '1/4': '25%',
      '2/4': '50%',
      '3/4': '75%',
      '1/5': '20%',
      '2/5': '40%',
      '3/5': '60%',
      '4/5': '80%',
      '1/6': '16.666667%',
      '2/6': '33.333333%',
      '3/6': '50%',
      '4/6': '66.666667%',
      '5/6': '83.333333%',
      full: '100%',
      screen: '100vh',
      min: 'min-content',
      max: 'max-content',
      fit: 'fit-content',
    }),
    hueRotate: {
      0: '0deg',
      15: '15deg',
      30: '30deg',
      60: '60deg',
      90: '90deg',
      180: '180deg',
    },
    inset: ({ theme }) => ({
      auto: 'auto',
      ...theme('spacing'),
      '1/2': '50%',
      '1/3': '33.333333%',
      '2/3': '66.666667%',
      '1/4': '25%',
      '2/4': '50%',
      '3/4': '75%',
      full: '100%',
    }),
    invert: {
      0: '0',
      DEFAULT: '100%',
    },
    keyframes: {
      spin: {
        to: {
          transform: 'rotate(360deg)',
        },
      },
      ping: {
        '75%, 100%': {
          transform: 'scale(2)',
          opacity: '0',
        },
      },
      pulse: {
        '50%': {
          opacity: '.5',
        },
      },
      bounce: {
        '0%, 100%': {
          transform: 'translateY(-25%)',
          animationTimingFunction: 'cubic-bezier(0.8,0,1,1)',
        },
        '50%': {
          transform: 'none',
          animationTimingFunction: 'cubic-bezier(0,0,0.2,1)',
        },
      },
    },
    letterSpacing: {
      tighter: '-0.05em',
      tight: '-0.025em',
      normal: '0em',
      wide: '0.025em',
      wider: '0.05em',
      widest: '0.1em',
    },
    lineHeight: {
      none: '1',
      tight: '1.25',
      snug: '1.375',
      normal: '1.5',
      relaxed: '1.625',
      loose: '2',
      3: '.75rem',
      4: '1rem',
      5: '1.25rem',
      6: '1.5rem',
      7: '1.75rem',
      8: '2rem',
      9: '2.25rem',
      10: '2.5rem',
    },
    listStyleType: {
      none: 'none',
      disc: 'disc',
      decimal: 'decimal',
    },
    margin: ({ theme }) => ({
      auto: 'auto',
      ...theme('spacing'),
    }),
    maxHeight: ({ theme }) => ({
      ...theme('spacing'),
      none: 'none',
      full: '100%',
      screen: '100vh',
      min: 'min-content',
      max: 'max-content',
      fit: 'fit-content',
    }),
    maxWidth: ({ theme, breakpoints }) => ({
      none: 'none',
      0: '0rem',
      xs: '20rem',
      sm: '24rem',
      md: '28rem',
      lg: '32rem',
      xl: '36rem',
      '2xl': '42rem',
      '3xl': '48rem',
      '4xl': '56rem',
      '5xl': '64rem',
      '6xl': '72rem',
      '7xl': '80rem',
      full: '100%',
      min: 'min-content',
      max: 'max-content',
      fit: 'fit-content',
      prose: '65ch',
      ...breakpoints(theme('screens')),
    }),
    minHeight: {
      0: '0px',
      full: '100%',
      screen: '100vh',
      min: 'min-content',
      max: 'max-content',
      fit: 'fit-content',
    },
    minWidth: {
      0: '0px',
      full: '100%',
      min: 'min-content',
      max: 'max-content',
      fit: 'fit-content',
    },
    objectPosition: {
      bottom: 'bottom',
      center: 'center',
      left: 'left',
      'left-bottom': 'left bottom',
      'left-top': 'left top',
      right: 'right',
      'right-bottom': 'right bottom',
      'right-top': 'right top',
      top: 'top',
    },
    opacity: {
      0: '0',
      5: '0.05',
      10: '0.1',
      20: '0.2',
      25: '0.25',
      30: '0.3',
      40: '0.4',
      50: '0.5',
      60: '0.6',
      70: '0.7',
      75: '0.75',
      80: '0.8',
      90: '0.9',
      95: '0.95',
      100: '1',
    },
    order: {
      first: '-9999',
      last: '9999',
      none: '0',
      1: '1',
      2: '2',
      3: '3',
      4: '4',
      5: '5',
      6: '6',
      7: '7',
      8: '8',
      9: '9',
      10: '10',
      11: '11',
      12: '12',
    },
    outlineColor: ({ theme }) => theme('colors'),
    outlineOffset: {
      0: '0px',
      1: '1px',
      2: '2px',
      4: '4px',
      8: '8px',
    },
    outlineWidth: {
      0: '0px',
      1: '1px',
      2: '2px',
      4: '4px',
      8: '8px',
    },
    padding: ({ theme }) => theme('spacing'),
    placeholderColor: ({ theme }) => theme('colors'),
    placeholderOpacity: ({ theme }) => theme('opacity'),
    ringColor: ({ theme }) => ({
      DEFAULT: theme('colors.blue.500', '#3b82f6'),
      ...theme('colors'),
    }),
    ringOffsetColor: ({ theme }) => theme('colors'),
    ringOffsetWidth: {
      0: '0px',
      1: '1px',
      2: '2px',
      4: '4px',
      8: '8px',
    },
    ringOpacity: ({ theme }) => ({
      DEFAULT: '0.5',
      ...theme('opacity'),
    }),
    ringWidth: {
      DEFAULT: '3px',
      0: '0px',
      1: '1px',
      2: '2px',
      4: '4px',
      8: '8px',
    },
    rotate: {
      0: '0deg',
      1: '1deg',
      2: '2deg',
      3: '3deg',
      6: '6deg',
      12: '12deg',
      45: '45deg',
      90: '90deg',
      180: '180deg',
    },
    saturate: {
      0: '0',
      50: '.5',
      100: '1',
      150: '1.5',
      200: '2',
    },
    scale: {
      0: '0',
      50: '.5',
      75: '.75',
      90: '.9',
      95: '.95',
      100: '1',
      105: '1.05',
      110: '1.1',
      125: '1.25',
      150: '1.5',
    },
    screens: {
      sm: '640px',
      md: '768px',
      lg: '1024px',
      xl: '1280px',
      '2xl': '1536px',
    },
    scrollMargin: ({ theme }) => ({
      ...theme('spacing'),
    }),
    scrollPadding: ({ theme }) => theme('spacing'),
    sepia: {
      0: '0',
      DEFAULT: '100%',
    },
    skew: {
      0: '0deg',
      1: '1deg',
      2: '2deg',
      3: '3deg',
      6: '6deg',
      12: '12deg',
    },
    space: ({ theme }) => ({
      ...theme('spacing'),
    }),
    spacing: {
      px: '1px',
      0: '0px',
      0.5: '0.125rem',
      1: '0.25rem',
      1.5: '0.375rem',
      2: '0.5rem',
      2.5: '0.625rem',
      3: '0.75rem',
      3.5: '0.875rem',
      4: '1rem',
      5: '1.25rem',
      6: '1.5rem',
      7: '1.75rem',
      8: '2rem',
      9: '2.25rem',
      10: '2.5rem',
      11: '2.75rem',
      12: '3rem',
      14: '3.5rem',
      16: '4rem',
      20: '5rem',
      24: '6rem',
      28: '7rem',
      32: '8rem',
      36: '9rem',
      40: '10rem',
      44: '11rem',
      48: '12rem',
      52: '13rem',
      56: '14rem',
      60: '15rem',
      64: '16rem',
      72: '18rem',
      80: '20rem',
      96: '24rem',
    },
    stroke: ({ theme }) => ({
      none: 'none',
      ...theme('colors'),
    }),
    strokeWidth: {
      0: '0',
      1: '1',
      2: '2',
    },
    supports: {},
    data: {},
    textColor: ({ theme }) => theme('colors'),
    textDecorationColor: ({ theme }) => theme('colors'),
    textDecorationThickness: {
      auto: 'auto',
      'from-font': 'from-font',
      0: '0px',
      1: '1px',
      2: '2px',
      4: '4px',
      8: '8px',
    },
    textIndent: ({ theme }) => ({
      ...theme('spacing'),
    }),
    textOpacity: ({ theme }) => theme('opacity'),
    textUnderlineOffset: {
      auto: 'auto',
      0: '0px',
      1: '1px',
      2: '2px',
      4: '4px',
      8: '8px',
    },
    transformOrigin: {
      center: 'center',
      top: 'top',
      'top-right': 'top right',
      right: 'right',
      'bottom-right': 'bottom right',
      bottom: 'bottom',
      'bottom-left': 'bottom left',
      left: 'left',
      'top-left': 'top left',
    },
    transitionDelay: {
      75: '75ms',
      100: '100ms',
      150: '150ms',
      200: '200ms',
      300: '300ms',
      500: '500ms',
      700: '700ms',
      1000: '1000ms',
    },
    transitionDuration: {
      DEFAULT: '150ms',
      75: '75ms',
      100: '100ms',
      150: '150ms',
      200: '200ms',
      300: '300ms',
      500: '500ms',
      700: '700ms',
      1000: '1000ms',
    },
    transitionProperty: {
      none: 'none',
      all: 'all',
      DEFAULT:
        'color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter',
      colors: 'color, background-color, border-color, text-decoration-color, fill, stroke',
      opacity: 'opacity',
      shadow: 'box-shadow',
      transform: 'transform',
    },
    transitionTimingFunction: {
      DEFAULT: 'cubic-bezier(0.4, 0, 0.2, 1)',
      linear: 'linear',
      in: 'cubic-bezier(0.4, 0, 1, 1)',
      out: 'cubic-bezier(0, 0, 0.2, 1)',
      'in-out': 'cubic-bezier(0.4, 0, 0.2, 1)',
    },
    translate: ({ theme }) => ({
      ...theme('spacing'),
      '1/2': '50%',
      '1/3': '33.333333%',
      '2/3': '66.666667%',
      '1/4': '25%',
      '2/4': '50%',
      '3/4': '75%',
      full: '100%',
    }),
    width: ({ theme }) => ({
      auto: 'auto',
      ...theme('spacing'),
      '1/2': '50%',
      '1/3': '33.333333%',
      '2/3': '66.666667%',
      '1/4': '25%',
      '2/4': '50%',
      '3/4': '75%',
      '1/5': '20%',
      '2/5': '40%',
      '3/5': '60%',
      '4/5': '80%',
      '1/6': '16.666667%',
      '2/6': '33.333333%',
      '3/6': '50%',
      '4/6': '66.666667%',
      '5/6': '83.333333%',
      '1/12': '8.333333%',
      '2/12': '16.666667%',
      '3/12': '25%',
      '4/12': '33.333333%',
      '5/12': '41.666667%',
      '6/12': '50%',
      '7/12': '58.333333%',
      '8/12': '66.666667%',
      '9/12': '75%',
      '10/12': '83.333333%',
      '11/12': '91.666667%',
      full: '100%',
      screen: '100vw',
      min: 'min-content',
      max: 'max-content',
      fit: 'fit-content',
    }),
    willChange: {
      auto: 'auto',
      scroll: 'scroll-position',
      contents: 'contents',
      transform: 'transform',
    },
    zIndex: {
      auto: 'auto',
      0: '0',
      10: '10',
      20: '20',
      30: '30',
      40: '40',
      50: '50',
    },
  },
  plugins: [],
}


/***/ }),

/***/ 1861:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */



const isNumber = __nccwpck_require__(75680);

const toRegexRange = (min, max, options) => {
  if (isNumber(min) === false) {
    throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
    return String(min);
  }

  if (isNumber(max) === false) {
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  let opts = { relaxZeros: true, ...options };
  if (typeof opts.strictZeros === 'boolean') {
    opts.relaxZeros = opts.strictZeros === false;
  }

  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap = String(opts.wrap);
  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange.cache[cacheKey].result;
  }

  let a = Math.min(min, max);
  let b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    let result = min + '|' + max;
    if (opts.capture) {
      return `(${result})`;
    }
    if (opts.wrap === false) {
      return result;
    }
    return `(?:${result})`;
  }

  let isPadded = hasPadding(min) || hasPadding(max);
  let state = { min, max, a, b };
  let positives = [];
  let negatives = [];

  if (isPadded) {
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
  }

  if (a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives, opts);

  if (opts.capture === true) {
    state.result = `(${state.result})`;
  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {
    state.result = `(?:${state.result})`;
  }

  toRegexRange.cache[cacheKey] = state;
  return state.result;
};

function collatePatterns(neg, pos, options) {
  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  let nines = 1;
  let zeros = 1;

  let stop = countNines(min, nines);
  let stops = new Set([max]);

  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
  }

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops = [...stops];
  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }

  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern = '';
  let count = 0;

  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];

    if (startDigit === stopDigit) {
      pattern += startDigit;

    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit, options);

    } else {
      count++;
    }
  }

  if (count) {
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return { pattern, count: [count], digits };
}

function splitToPatterns(min, max, tok, options) {
  let ranges = splitToRanges(min, max);
  let tokens = [];
  let start = min;
  let prev;

  for (let i = 0; i < ranges.length; i++) {
    let max = ranges[i];
    let obj = rangeToPattern(String(start), String(max), options);
    let zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(max, tok, options);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  let result = [];

  for (let ele of arr) {
    let { string } = ele;

    // only push if _both_ are negative...
    if (!intersection && !contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }

    // or _both_ are positive
    if (intersection && contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }
  }
  return result;
}

/**
 * Zip strings
 */

function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function contains(arr, key, val) {
  return arr.some(ele => ele[key] === val);
}

function countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  let [start = 0, stop = ''] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? ',' + stop : '')}}`;
  }
  return '';
}

function toCharacterClass(a, b, options) {
  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;
}

function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function padZeros(value, tok, options) {
  if (!tok.isPadded) {
    return value;
  }

  let diff = Math.abs(tok.maxLen - String(value).length);
  let relax = options.relaxZeros !== false;

  switch (diff) {
    case 0:
      return '';
    case 1:
      return relax ? '0?' : '0';
    case 2:
      return relax ? '0{0,2}' : '00';
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}

/**
 * Cache
 */

toRegexRange.cache = {};
toRegexRange.clearCache = () => (toRegexRange.cache = {});

/**
 * Expose `toRegexRange`
 */

module.exports = toRegexRange;


/***/ }),

/***/ 74294:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(54219);


/***/ }),

/***/ 54219:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var net = __nccwpck_require__(41808);
var tls = __nccwpck_require__(24404);
var http = __nccwpck_require__(13685);
var https = __nccwpck_require__(95687);
var events = __nccwpck_require__(82361);
var assert = __nccwpck_require__(39491);
var util = __nccwpck_require__(73837);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ 65278:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {


/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */

module.exports = __nccwpck_require__(73837).deprecate;


/***/ }),

/***/ 75840:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function () {
    return _v.default;
  }
}));
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function () {
    return _v2.default;
  }
}));
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function () {
    return _v3.default;
  }
}));
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function () {
    return _v4.default;
  }
}));
Object.defineProperty(exports, "NIL", ({
  enumerable: true,
  get: function () {
    return _nil.default;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return _version.default;
  }
}));
Object.defineProperty(exports, "validate", ({
  enumerable: true,
  get: function () {
    return _validate.default;
  }
}));
Object.defineProperty(exports, "stringify", ({
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
}));
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function () {
    return _parse.default;
  }
}));

var _v = _interopRequireDefault(__nccwpck_require__(78628));

var _v2 = _interopRequireDefault(__nccwpck_require__(86409));

var _v3 = _interopRequireDefault(__nccwpck_require__(85122));

var _v4 = _interopRequireDefault(__nccwpck_require__(79120));

var _nil = _interopRequireDefault(__nccwpck_require__(25332));

var _version = _interopRequireDefault(__nccwpck_require__(81595));

var _validate = _interopRequireDefault(__nccwpck_require__(66900));

var _stringify = _interopRequireDefault(__nccwpck_require__(18950));

var _parse = _interopRequireDefault(__nccwpck_require__(62746));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 4569:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('md5').update(bytes).digest();
}

var _default = md5;
exports["default"] = _default;

/***/ }),

/***/ 25332:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports["default"] = _default;

/***/ }),

/***/ 62746:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(66900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports["default"] = _default;

/***/ }),

/***/ 40814:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports["default"] = _default;

/***/ }),

/***/ 50807:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;

function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    _crypto.default.randomFillSync(rnds8Pool);

    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

/***/ }),

/***/ 85274:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('sha1').update(bytes).digest();
}

var _default = sha1;
exports["default"] = _default;

/***/ }),

/***/ 18950:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(66900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports["default"] = _default;

/***/ }),

/***/ 78628:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(50807));

var _stringify = _interopRequireDefault(__nccwpck_require__(18950));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports["default"] = _default;

/***/ }),

/***/ 86409:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(65998));

var _md = _interopRequireDefault(__nccwpck_require__(4569));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports["default"] = _default;

/***/ }),

/***/ 65998:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(__nccwpck_require__(18950));

var _parse = _interopRequireDefault(__nccwpck_require__(62746));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ 85122:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(50807));

var _stringify = _interopRequireDefault(__nccwpck_require__(18950));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports["default"] = _default;

/***/ }),

/***/ 79120:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(65998));

var _sha = _interopRequireDefault(__nccwpck_require__(85274));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports["default"] = _default;

/***/ }),

/***/ 66900:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _regex = _interopRequireDefault(__nccwpck_require__(40814));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports["default"] = _default;

/***/ }),

/***/ 81595:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(66900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports["default"] = _default;

/***/ }),

/***/ 91208:
/***/ ((module) => {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),

/***/ 50881:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const tailwind = __nccwpck_require__(17483);
const autoprefixer = __nccwpck_require__(1376);
const postcss = __nccwpck_require__(77001);
const fs = __nccwpck_require__(57147);

// const inputCss = require.resolve('./main.css');
// const inputCss = require('./main.css');

const inputCss = `
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  h1 {
    @apply text-2xl font-bold;
  }
  ul {
    @apply list-disc pl-5 mb-2;
  }
  p {
    @apply mb-2;
  }
  code {
    @apply text-slate-600 bg-amber-100;
  }
  a code {
    @apply bg-inherit hover:text-amber-700 hover:font-semibold;
  }
  a {
    @apply hover:underline hover:text-amber-700;
  }
  .tooltip-contents {
    @apply invisible rounded-md shadow-lg py-1 px-2 bg-gray-200 border-2 border-amber-500 absolute -mt-9 -ml-2;
  }
  .tooltip-container {
    @apply cursor-default;
  }
  .tooltip-container:hover .tooltip-contents {
    @apply visible z-50;
  }
  .tooltip-container:hover {
    @apply bg-amber-100;
  }

  /*
   * btn styles taken from:
   * https://v1.tailwindcss.com/components/buttons#simple
   * Adding inline-block here for a element.
   */
  a.btn {
    @apply inline-block;
  }
  .btn {
    @apply font-bold py-1 px-2 rounded;
  }
  .btn-blue {
    @apply bg-blue-500 text-white;
  }
  .btn-blue:hover {
    @apply bg-blue-700 text-white;
  }
}

/*
 * TODO consider why this class is defined in this layer, not base.
 * Clearly, Stackoverflow told me to, but I need to learn more about Tailwind to see why or if needed.
 */
@layer components {
  /*
   * We need this to combine with border-seperate, in order not to have gaps between
   * borders of cells within a table.
   * It's seemingly not a utility offered, out-of-the-box, by Tailwind - see:
   * https://stackoverflow.com/a/70326229/392847
   */
  .zero-border-spacing {
    border-spacing: 0;
  }
}
`;

// const configJs = require('./tailwind.config.js.txt');

const configJs = `
// eslint-disable-next-line import/no-extraneous-dependencies
const plugin = require('tailwindcss/plugin');

module.exports = {
  content: ['./output/*.html'],
  theme: {
    extend: {},
  },
  plugins: [
    plugin(({ addUtilities: addAblyUtilities }) => {
      const newUtilities = {
        '.vertical-lr': {
          writingMode: 'vertical-lr',
        },
      };
      addAblyUtilities(newUtilities);
    }),
  ],
};
`;

async function wrapper() {
  // see:
  // - https://github.com/postcss/postcss/tree/main#js-api
  // - https://postcss.org/api/#processor
  const processor = postcss([tailwind, autoprefixer]);
  const outputPath = 'output/tailwind.css';
  fs.writeFileSync('tailwind.config.js', configJs);
  const result = await processor.process(inputCss, {
    from: 'main.css',
    to: outputPath,
  });
  fs.writeFileSync(outputPath, result.css);
}

module.exports = {
  tailwindBuild: wrapper,
};


/***/ }),

/***/ 34850:
/***/ ((module) => {

module.exports = eval("require")("@tailwindcss/oxide");


/***/ }),

/***/ 10309:
/***/ ((module) => {

module.exports = eval("require")("lightningcss");


/***/ }),

/***/ 28440:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 28440;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 39491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 82361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 57147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 13685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 95687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 41808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 22286:
/***/ ((module) => {

"use strict";
module.exports = require("node:https");

/***/ }),

/***/ 22037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 71017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 12781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 24404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 76224:
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ 57310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 73837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 60525:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var PlainValue = __nccwpck_require__(24941);
var resolveSeq = __nccwpck_require__(39914);
var Schema = __nccwpck_require__(51387);

const defaultOptions = {
  anchorPrefix: 'a',
  customTags: null,
  indent: 2,
  indentSeq: true,
  keepCstNodes: false,
  keepNodeTypes: true,
  keepBlobsInJSON: true,
  mapAsMap: false,
  maxAliasCount: 100,
  prettyErrors: false,
  // TODO Set true in v2
  simpleKeys: false,
  version: '1.2'
};
const scalarOptions = {
  get binary() {
    return resolveSeq.binaryOptions;
  },

  set binary(opt) {
    Object.assign(resolveSeq.binaryOptions, opt);
  },

  get bool() {
    return resolveSeq.boolOptions;
  },

  set bool(opt) {
    Object.assign(resolveSeq.boolOptions, opt);
  },

  get int() {
    return resolveSeq.intOptions;
  },

  set int(opt) {
    Object.assign(resolveSeq.intOptions, opt);
  },

  get null() {
    return resolveSeq.nullOptions;
  },

  set null(opt) {
    Object.assign(resolveSeq.nullOptions, opt);
  },

  get str() {
    return resolveSeq.strOptions;
  },

  set str(opt) {
    Object.assign(resolveSeq.strOptions, opt);
  }

};
const documentOptions = {
  '1.0': {
    schema: 'yaml-1.1',
    merge: true,
    tagPrefixes: [{
      handle: '!',
      prefix: PlainValue.defaultTagPrefix
    }, {
      handle: '!!',
      prefix: 'tag:private.yaml.org,2002:'
    }]
  },
  1.1: {
    schema: 'yaml-1.1',
    merge: true,
    tagPrefixes: [{
      handle: '!',
      prefix: '!'
    }, {
      handle: '!!',
      prefix: PlainValue.defaultTagPrefix
    }]
  },
  1.2: {
    schema: 'core',
    merge: false,
    tagPrefixes: [{
      handle: '!',
      prefix: '!'
    }, {
      handle: '!!',
      prefix: PlainValue.defaultTagPrefix
    }]
  }
};

function stringifyTag(doc, tag) {
  if ((doc.version || doc.options.version) === '1.0') {
    const priv = tag.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
    if (priv) return '!' + priv[1];
    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
    return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;
  }

  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);

  if (!p) {
    const dtp = doc.getDefaults().tagPrefixes;
    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);
  }

  if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;
  const suffix = tag.substr(p.prefix.length).replace(/[!,[\]{}]/g, ch => ({
    '!': '%21',
    ',': '%2C',
    '[': '%5B',
    ']': '%5D',
    '{': '%7B',
    '}': '%7D'
  })[ch]);
  return p.handle + suffix;
}

function getTagObject(tags, item) {
  if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;

  if (item.tag) {
    const match = tags.filter(t => t.tag === item.tag);
    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];
  }

  let tagObj, obj;

  if (item instanceof resolveSeq.Scalar) {
    obj = item.value; // TODO: deprecate/remove class check

    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);
    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);
  } else {
    obj = item;
    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
  }

  if (!tagObj) {
    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }

  return tagObj;
} // needs to be called before value stringifier to allow for circular anchor refs


function stringifyProps(node, tagObj, {
  anchors,
  doc
}) {
  const props = [];
  const anchor = doc.anchors.getName(node);

  if (anchor) {
    anchors[anchor] = node;
    props.push(`&${anchor}`);
  }

  if (node.tag) {
    props.push(stringifyTag(doc, node.tag));
  } else if (!tagObj.default) {
    props.push(stringifyTag(doc, tagObj.tag));
  }

  return props.join(' ');
}

function stringify(item, ctx, onComment, onChompKeep) {
  const {
    anchors,
    schema
  } = ctx.doc;
  let tagObj;

  if (!(item instanceof resolveSeq.Node)) {
    const createCtx = {
      aliasNodes: [],
      onTagObj: o => tagObj = o,
      prevObjects: new Map()
    };
    item = schema.createNode(item, true, null, createCtx);

    for (const alias of createCtx.aliasNodes) {
      alias.source = alias.source.node;
      let name = anchors.getName(alias.source);

      if (!name) {
        name = anchors.newName();
        anchors.map[name] = alias.source;
      }
    }
  }

  if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);
  if (!tagObj) tagObj = getTagObject(schema.tags, item);
  const props = stringifyProps(item, tagObj, ctx);
  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);
  if (!props) return str;
  return item instanceof resolveSeq.Scalar || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\n${ctx.indent}${str}`;
}

class Anchors {
  static validAnchorNode(node) {
    return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;
  }

  constructor(prefix) {
    PlainValue._defineProperty(this, "map", Object.create(null));

    this.prefix = prefix;
  }

  createAlias(node, name) {
    this.setAnchor(node, name);
    return new resolveSeq.Alias(node);
  }

  createMergePair(...sources) {
    const merge = new resolveSeq.Merge();
    merge.value.items = sources.map(s => {
      if (s instanceof resolveSeq.Alias) {
        if (s.source instanceof resolveSeq.YAMLMap) return s;
      } else if (s instanceof resolveSeq.YAMLMap) {
        return this.createAlias(s);
      }

      throw new Error('Merge sources must be Map nodes or their Aliases');
    });
    return merge;
  }

  getName(node) {
    const {
      map
    } = this;
    return Object.keys(map).find(a => map[a] === node);
  }

  getNames() {
    return Object.keys(this.map);
  }

  getNode(name) {
    return this.map[name];
  }

  newName(prefix) {
    if (!prefix) prefix = this.prefix;
    const names = Object.keys(this.map);

    for (let i = 1; true; ++i) {
      const name = `${prefix}${i}`;
      if (!names.includes(name)) return name;
    }
  } // During parsing, map & aliases contain CST nodes


  resolveNodes() {
    const {
      map,
      _cstAliases
    } = this;
    Object.keys(map).forEach(a => {
      map[a] = map[a].resolved;
    });

    _cstAliases.forEach(a => {
      a.source = a.source.resolved;
    });

    delete this._cstAliases;
  }

  setAnchor(node, name) {
    if (node != null && !Anchors.validAnchorNode(node)) {
      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');
    }

    if (name && /[\x00-\x19\s,[\]{}]/.test(name)) {
      throw new Error('Anchor names must not contain whitespace or control characters');
    }

    const {
      map
    } = this;
    const prev = node && Object.keys(map).find(a => map[a] === node);

    if (prev) {
      if (!name) {
        return prev;
      } else if (prev !== name) {
        delete map[prev];
        map[name] = node;
      }
    } else {
      if (!name) {
        if (!node) return null;
        name = this.newName();
      }

      map[name] = node;
    }

    return name;
  }

}

const visit = (node, tags) => {
  if (node && typeof node === 'object') {
    const {
      tag
    } = node;

    if (node instanceof resolveSeq.Collection) {
      if (tag) tags[tag] = true;
      node.items.forEach(n => visit(n, tags));
    } else if (node instanceof resolveSeq.Pair) {
      visit(node.key, tags);
      visit(node.value, tags);
    } else if (node instanceof resolveSeq.Scalar) {
      if (tag) tags[tag] = true;
    }
  }

  return tags;
};

const listTagNames = node => Object.keys(visit(node, {}));

function parseContents(doc, contents) {
  const comments = {
    before: [],
    after: []
  };
  let body = undefined;
  let spaceBefore = false;

  for (const node of contents) {
    if (node.valueRange) {
      if (body !== undefined) {
        const msg = 'Document contains trailing content not separated by a ... or --- line';
        doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));
        break;
      }

      const res = resolveSeq.resolveNode(doc, node);

      if (spaceBefore) {
        res.spaceBefore = true;
        spaceBefore = false;
      }

      body = res;
    } else if (node.comment !== null) {
      const cc = body === undefined ? comments.before : comments.after;
      cc.push(node.comment);
    } else if (node.type === PlainValue.Type.BLANK_LINE) {
      spaceBefore = true;

      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {
        // space-separated comments at start are parsed as document comments
        doc.commentBefore = comments.before.join('\n');
        comments.before = [];
      }
    }
  }

  doc.contents = body || null;

  if (!body) {
    doc.comment = comments.before.concat(comments.after).join('\n') || null;
  } else {
    const cb = comments.before.join('\n');

    if (cb) {
      const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;
      cbNode.commentBefore = cbNode.commentBefore ? `${cb}\n${cbNode.commentBefore}` : cb;
    }

    doc.comment = comments.after.join('\n') || null;
  }
}

function resolveTagDirective({
  tagPrefixes
}, directive) {
  const [handle, prefix] = directive.parameters;

  if (!handle || !prefix) {
    const msg = 'Insufficient parameters given for %TAG directive';
    throw new PlainValue.YAMLSemanticError(directive, msg);
  }

  if (tagPrefixes.some(p => p.handle === handle)) {
    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';
    throw new PlainValue.YAMLSemanticError(directive, msg);
  }

  return {
    handle,
    prefix
  };
}

function resolveYamlDirective(doc, directive) {
  let [version] = directive.parameters;
  if (directive.name === 'YAML:1.0') version = '1.0';

  if (!version) {
    const msg = 'Insufficient parameters given for %YAML directive';
    throw new PlainValue.YAMLSemanticError(directive, msg);
  }

  if (!documentOptions[version]) {
    const v0 = doc.version || doc.options.version;
    const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;
    doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
  }

  return version;
}

function parseDirectives(doc, directives, prevDoc) {
  const directiveComments = [];
  let hasDirectives = false;

  for (const directive of directives) {
    const {
      comment,
      name
    } = directive;

    switch (name) {
      case 'TAG':
        try {
          doc.tagPrefixes.push(resolveTagDirective(doc, directive));
        } catch (error) {
          doc.errors.push(error);
        }

        hasDirectives = true;
        break;

      case 'YAML':
      case 'YAML:1.0':
        if (doc.version) {
          const msg = 'The %YAML directive must only be given at most once per document.';
          doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));
        }

        try {
          doc.version = resolveYamlDirective(doc, directive);
        } catch (error) {
          doc.errors.push(error);
        }

        hasDirectives = true;
        break;

      default:
        if (name) {
          const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;
          doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));
        }

    }

    if (comment) directiveComments.push(comment);
  }

  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {
    const copyTagPrefix = ({
      handle,
      prefix
    }) => ({
      handle,
      prefix
    });

    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);
    doc.version = prevDoc.version;
  }

  doc.commentBefore = directiveComments.join('\n') || null;
}

function assertCollection(contents) {
  if (contents instanceof resolveSeq.Collection) return true;
  throw new Error('Expected a YAML collection as document contents');
}

class Document {
  constructor(options) {
    this.anchors = new Anchors(options.anchorPrefix);
    this.commentBefore = null;
    this.comment = null;
    this.contents = null;
    this.directivesEndMarker = null;
    this.errors = [];
    this.options = options;
    this.schema = null;
    this.tagPrefixes = [];
    this.version = null;
    this.warnings = [];
  }

  add(value) {
    assertCollection(this.contents);
    return this.contents.add(value);
  }

  addIn(path, value) {
    assertCollection(this.contents);
    this.contents.addIn(path, value);
  }

  delete(key) {
    assertCollection(this.contents);
    return this.contents.delete(key);
  }

  deleteIn(path) {
    if (resolveSeq.isEmptyPath(path)) {
      if (this.contents == null) return false;
      this.contents = null;
      return true;
    }

    assertCollection(this.contents);
    return this.contents.deleteIn(path);
  }

  getDefaults() {
    return Document.defaults[this.version] || Document.defaults[this.options.version] || {};
  }

  get(key, keepScalar) {
    return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : undefined;
  }

  getIn(path, keepScalar) {
    if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;
    return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : undefined;
  }

  has(key) {
    return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;
  }

  hasIn(path) {
    if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined;
    return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;
  }

  set(key, value) {
    assertCollection(this.contents);
    this.contents.set(key, value);
  }

  setIn(path, value) {
    if (resolveSeq.isEmptyPath(path)) this.contents = value;else {
      assertCollection(this.contents);
      this.contents.setIn(path, value);
    }
  }

  setSchema(id, customTags) {
    if (!id && !customTags && this.schema) return;
    if (typeof id === 'number') id = id.toFixed(1);

    if (id === '1.0' || id === '1.1' || id === '1.2') {
      if (this.version) this.version = id;else this.options.version = id;
      delete this.options.schema;
    } else if (id && typeof id === 'string') {
      this.options.schema = id;
    }

    if (Array.isArray(customTags)) this.options.customTags = customTags;
    const opt = Object.assign({}, this.getDefaults(), this.options);
    this.schema = new Schema.Schema(opt);
  }

  parse(node, prevDoc) {
    if (this.options.keepCstNodes) this.cstNode = node;
    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';
    const {
      directives = [],
      contents = [],
      directivesEndMarker,
      error,
      valueRange
    } = node;

    if (error) {
      if (!error.source) error.source = this;
      this.errors.push(error);
    }

    parseDirectives(this, directives, prevDoc);
    if (directivesEndMarker) this.directivesEndMarker = true;
    this.range = valueRange ? [valueRange.start, valueRange.end] : null;
    this.setSchema();
    this.anchors._cstAliases = [];
    parseContents(this, contents);
    this.anchors.resolveNodes();

    if (this.options.prettyErrors) {
      for (const error of this.errors) if (error instanceof PlainValue.YAMLError) error.makePretty();

      for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();
    }

    return this;
  }

  listNonDefaultTags() {
    return listTagNames(this.contents).filter(t => t.indexOf(Schema.Schema.defaultPrefix) !== 0);
  }

  setTagPrefix(handle, prefix) {
    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');

    if (prefix) {
      const prev = this.tagPrefixes.find(p => p.handle === handle);
      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({
        handle,
        prefix
      });
    } else {
      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);
    }
  }

  toJSON(arg, onAnchor) {
    const {
      keepBlobsInJSON,
      mapAsMap,
      maxAliasCount
    } = this.options;
    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq.Scalar));
    const ctx = {
      doc: this,
      indentStep: '  ',
      keep,
      mapAsMap: keep && !!mapAsMap,
      maxAliasCount,
      stringify // Requiring directly in Pair would create circular dependencies

    };
    const anchorNames = Object.keys(this.anchors.map);
    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {
      alias: [],
      aliasCount: 0,
      count: 1
    }]));
    const res = resolveSeq.toJSON(this.contents, arg, ctx);
    if (typeof onAnchor === 'function' && ctx.anchors) for (const {
      count,
      res
    } of ctx.anchors.values()) onAnchor(res, count);
    return res;
  }

  toString() {
    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');
    const indentSize = this.options.indent;

    if (!Number.isInteger(indentSize) || indentSize <= 0) {
      const s = JSON.stringify(indentSize);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }

    this.setSchema();
    const lines = [];
    let hasDirectives = false;

    if (this.version) {
      let vd = '%YAML 1.2';

      if (this.schema.name === 'yaml-1.1') {
        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';
      }

      lines.push(vd);
      hasDirectives = true;
    }

    const tagNames = this.listNonDefaultTags();
    this.tagPrefixes.forEach(({
      handle,
      prefix
    }) => {
      if (tagNames.some(t => t.indexOf(prefix) === 0)) {
        lines.push(`%TAG ${handle} ${prefix}`);
        hasDirectives = true;
      }
    });
    if (hasDirectives || this.directivesEndMarker) lines.push('---');

    if (this.commentBefore) {
      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');
      lines.unshift(this.commentBefore.replace(/^/gm, '#'));
    }

    const ctx = {
      anchors: Object.create(null),
      doc: this,
      indent: '',
      indentStep: ' '.repeat(indentSize),
      stringify // Requiring directly in nodes would create circular dependencies

    };
    let chompKeep = false;
    let contentComment = null;

    if (this.contents) {
      if (this.contents instanceof resolveSeq.Node) {
        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');
        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment

        ctx.forceBlockIndent = !!this.comment;
        contentComment = this.contents.comment;
      }

      const onChompKeep = contentComment ? null : () => chompKeep = true;
      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);
      lines.push(resolveSeq.addComment(body, '', contentComment));
    } else if (this.contents !== undefined) {
      lines.push(stringify(this.contents, ctx));
    }

    if (this.comment) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');
      lines.push(this.comment.replace(/^/gm, '#'));
    }

    return lines.join('\n') + '\n';
  }

}

PlainValue._defineProperty(Document, "defaults", documentOptions);

exports.Document = Document;
exports.defaultOptions = defaultOptions;
exports.scalarOptions = scalarOptions;


/***/ }),

/***/ 24941:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const Char = {
  ANCHOR: '&',
  COMMENT: '#',
  TAG: '!',
  DIRECTIVES_END: '-',
  DOCUMENT_END: '.'
};
const Type = {
  ALIAS: 'ALIAS',
  BLANK_LINE: 'BLANK_LINE',
  BLOCK_FOLDED: 'BLOCK_FOLDED',
  BLOCK_LITERAL: 'BLOCK_LITERAL',
  COMMENT: 'COMMENT',
  DIRECTIVE: 'DIRECTIVE',
  DOCUMENT: 'DOCUMENT',
  FLOW_MAP: 'FLOW_MAP',
  FLOW_SEQ: 'FLOW_SEQ',
  MAP: 'MAP',
  MAP_KEY: 'MAP_KEY',
  MAP_VALUE: 'MAP_VALUE',
  PLAIN: 'PLAIN',
  QUOTE_DOUBLE: 'QUOTE_DOUBLE',
  QUOTE_SINGLE: 'QUOTE_SINGLE',
  SEQ: 'SEQ',
  SEQ_ITEM: 'SEQ_ITEM'
};
const defaultTagPrefix = 'tag:yaml.org,2002:';
const defaultTags = {
  MAP: 'tag:yaml.org,2002:map',
  SEQ: 'tag:yaml.org,2002:seq',
  STR: 'tag:yaml.org,2002:str'
};

function findLineStarts(src) {
  const ls = [0];
  let offset = src.indexOf('\n');

  while (offset !== -1) {
    offset += 1;
    ls.push(offset);
    offset = src.indexOf('\n', offset);
  }

  return ls;
}

function getSrcInfo(cst) {
  let lineStarts, src;

  if (typeof cst === 'string') {
    lineStarts = findLineStarts(cst);
    src = cst;
  } else {
    if (Array.isArray(cst)) cst = cst[0];

    if (cst && cst.context) {
      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);
      lineStarts = cst.lineStarts;
      src = cst.context.src;
    }
  }

  return {
    lineStarts,
    src
  };
}
/**
 * @typedef {Object} LinePos - One-indexed position in the source
 * @property {number} line
 * @property {number} col
 */

/**
 * Determine the line/col position matching a character offset.
 *
 * Accepts a source string or a CST document as the second parameter. With
 * the latter, starting indices for lines are cached in the document as
 * `lineStarts: number[]`.
 *
 * Returns a one-indexed `{ line, col }` location if found, or
 * `undefined` otherwise.
 *
 * @param {number} offset
 * @param {string|Document|Document[]} cst
 * @returns {?LinePos}
 */


function getLinePos(offset, cst) {
  if (typeof offset !== 'number' || offset < 0) return null;
  const {
    lineStarts,
    src
  } = getSrcInfo(cst);
  if (!lineStarts || !src || offset > src.length) return null;

  for (let i = 0; i < lineStarts.length; ++i) {
    const start = lineStarts[i];

    if (offset < start) {
      return {
        line: i,
        col: offset - lineStarts[i - 1] + 1
      };
    }

    if (offset === start) return {
      line: i + 1,
      col: 1
    };
  }

  const line = lineStarts.length;
  return {
    line,
    col: offset - lineStarts[line - 1] + 1
  };
}
/**
 * Get a specified line from the source.
 *
 * Accepts a source string or a CST document as the second parameter. With
 * the latter, starting indices for lines are cached in the document as
 * `lineStarts: number[]`.
 *
 * Returns the line as a string if found, or `null` otherwise.
 *
 * @param {number} line One-indexed line number
 * @param {string|Document|Document[]} cst
 * @returns {?string}
 */

function getLine(line, cst) {
  const {
    lineStarts,
    src
  } = getSrcInfo(cst);
  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;
  const start = lineStarts[line - 1];
  let end = lineStarts[line]; // undefined for last line; that's ok for slice()

  while (end && end > start && src[end - 1] === '\n') --end;

  return src.slice(start, end);
}
/**
 * Pretty-print the starting line from the source indicated by the range `pos`
 *
 * Trims output to `maxWidth` chars while keeping the starting column visible,
 * using `…` at either end to indicate dropped characters.
 *
 * Returns a two-line string (or `null`) with `\n` as separator; the second line
 * will hold appropriately indented `^` marks indicating the column range.
 *
 * @param {Object} pos
 * @param {LinePos} pos.start
 * @param {LinePos} [pos.end]
 * @param {string|Document|Document[]*} cst
 * @param {number} [maxWidth=80]
 * @returns {?string}
 */

function getPrettyContext({
  start,
  end
}, cst, maxWidth = 80) {
  let src = getLine(start.line, cst);
  if (!src) return null;
  let {
    col
  } = start;

  if (src.length > maxWidth) {
    if (col <= maxWidth - 10) {
      src = src.substr(0, maxWidth - 1) + '…';
    } else {
      const halfWidth = Math.round(maxWidth / 2);
      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';
      col -= src.length - maxWidth;
      src = '…' + src.substr(1 - maxWidth);
    }
  }

  let errLen = 1;
  let errEnd = '';

  if (end) {
    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {
      errLen = end.col - start.col;
    } else {
      errLen = Math.min(src.length + 1, maxWidth) - col;
      errEnd = '…';
    }
  }

  const offset = col > 1 ? ' '.repeat(col - 1) : '';
  const err = '^'.repeat(errLen);
  return `${src}\n${offset}${err}${errEnd}`;
}

class Range {
  static copy(orig) {
    return new Range(orig.start, orig.end);
  }

  constructor(start, end) {
    this.start = start;
    this.end = end || start;
  }

  isEmpty() {
    return typeof this.start !== 'number' || !this.end || this.end <= this.start;
  }
  /**
   * Set `origStart` and `origEnd` to point to the original source range for
   * this node, which may differ due to dropped CR characters.
   *
   * @param {number[]} cr - Positions of dropped CR characters
   * @param {number} offset - Starting index of `cr` from the last call
   * @returns {number} - The next offset, matching the one found for `origStart`
   */


  setOrigRange(cr, offset) {
    const {
      start,
      end
    } = this;

    if (cr.length === 0 || end <= cr[0]) {
      this.origStart = start;
      this.origEnd = end;
      return offset;
    }

    let i = offset;

    while (i < cr.length) {
      if (cr[i] > start) break;else ++i;
    }

    this.origStart = start + i;
    const nextOffset = i;

    while (i < cr.length) {
      // if end was at \n, it should now be at \r
      if (cr[i] >= end) break;else ++i;
    }

    this.origEnd = end + i;
    return nextOffset;
  }

}

/** Root class of all nodes */

class Node {
  static addStringTerminator(src, offset, str) {
    if (str[str.length - 1] === '\n') return str;
    const next = Node.endOfWhiteSpace(src, offset);
    return next >= src.length || src[next] === '\n' ? str + '\n' : str;
  } // ^(---|...)


  static atDocumentBoundary(src, offset, sep) {
    const ch0 = src[offset];
    if (!ch0) return true;
    const prev = src[offset - 1];
    if (prev && prev !== '\n') return false;

    if (sep) {
      if (ch0 !== sep) return false;
    } else {
      if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;
    }

    const ch1 = src[offset + 1];
    const ch2 = src[offset + 2];
    if (ch1 !== ch0 || ch2 !== ch0) return false;
    const ch3 = src[offset + 3];
    return !ch3 || ch3 === '\n' || ch3 === '\t' || ch3 === ' ';
  }

  static endOfIdentifier(src, offset) {
    let ch = src[offset];
    const isVerbatim = ch === '<';
    const notOk = isVerbatim ? ['\n', '\t', ' ', '>'] : ['\n', '\t', ' ', '[', ']', '{', '}', ','];

    while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];

    if (isVerbatim && ch === '>') offset += 1;
    return offset;
  }

  static endOfIndent(src, offset) {
    let ch = src[offset];

    while (ch === ' ') ch = src[offset += 1];

    return offset;
  }

  static endOfLine(src, offset) {
    let ch = src[offset];

    while (ch && ch !== '\n') ch = src[offset += 1];

    return offset;
  }

  static endOfWhiteSpace(src, offset) {
    let ch = src[offset];

    while (ch === '\t' || ch === ' ') ch = src[offset += 1];

    return offset;
  }

  static startOfLine(src, offset) {
    let ch = src[offset - 1];
    if (ch === '\n') return offset;

    while (ch && ch !== '\n') ch = src[offset -= 1];

    return offset + 1;
  }
  /**
   * End of indentation, or null if the line's indent level is not more
   * than `indent`
   *
   * @param {string} src
   * @param {number} indent
   * @param {number} lineStart
   * @returns {?number}
   */


  static endOfBlockIndent(src, indent, lineStart) {
    const inEnd = Node.endOfIndent(src, lineStart);

    if (inEnd > lineStart + indent) {
      return inEnd;
    } else {
      const wsEnd = Node.endOfWhiteSpace(src, inEnd);
      const ch = src[wsEnd];
      if (!ch || ch === '\n') return wsEnd;
    }

    return null;
  }

  static atBlank(src, offset, endAsBlank) {
    const ch = src[offset];
    return ch === '\n' || ch === '\t' || ch === ' ' || endAsBlank && !ch;
  }

  static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {
    if (!ch || indentDiff < 0) return false;
    if (indentDiff > 0) return true;
    return indicatorAsIndent && ch === '-';
  } // should be at line or string end, or at next non-whitespace char


  static normalizeOffset(src, offset) {
    const ch = src[offset];
    return !ch ? offset : ch !== '\n' && src[offset - 1] === '\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);
  } // fold single newline into space, multiple newlines to N - 1 newlines
  // presumes src[offset] === '\n'


  static foldNewline(src, offset, indent) {
    let inCount = 0;
    let error = false;
    let fold = '';
    let ch = src[offset + 1];

    while (ch === ' ' || ch === '\t' || ch === '\n') {
      switch (ch) {
        case '\n':
          inCount = 0;
          offset += 1;
          fold += '\n';
          break;

        case '\t':
          if (inCount <= indent) error = true;
          offset = Node.endOfWhiteSpace(src, offset + 2) - 1;
          break;

        case ' ':
          inCount += 1;
          offset += 1;
          break;
      }

      ch = src[offset + 1];
    }

    if (!fold) fold = ' ';
    if (ch && inCount <= indent) error = true;
    return {
      fold,
      offset,
      error
    };
  }

  constructor(type, props, context) {
    Object.defineProperty(this, 'context', {
      value: context || null,
      writable: true
    });
    this.error = null;
    this.range = null;
    this.valueRange = null;
    this.props = props || [];
    this.type = type;
    this.value = null;
  }

  getPropValue(idx, key, skipKey) {
    if (!this.context) return null;
    const {
      src
    } = this.context;
    const prop = this.props[idx];
    return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;
  }

  get anchor() {
    for (let i = 0; i < this.props.length; ++i) {
      const anchor = this.getPropValue(i, Char.ANCHOR, true);
      if (anchor != null) return anchor;
    }

    return null;
  }

  get comment() {
    const comments = [];

    for (let i = 0; i < this.props.length; ++i) {
      const comment = this.getPropValue(i, Char.COMMENT, true);
      if (comment != null) comments.push(comment);
    }

    return comments.length > 0 ? comments.join('\n') : null;
  }

  commentHasRequiredWhitespace(start) {
    const {
      src
    } = this.context;
    if (this.header && start === this.header.end) return false;
    if (!this.valueRange) return false;
    const {
      end
    } = this.valueRange;
    return start !== end || Node.atBlank(src, end - 1);
  }

  get hasComment() {
    if (this.context) {
      const {
        src
      } = this.context;

      for (let i = 0; i < this.props.length; ++i) {
        if (src[this.props[i].start] === Char.COMMENT) return true;
      }
    }

    return false;
  }

  get hasProps() {
    if (this.context) {
      const {
        src
      } = this.context;

      for (let i = 0; i < this.props.length; ++i) {
        if (src[this.props[i].start] !== Char.COMMENT) return true;
      }
    }

    return false;
  }

  get includesTrailingLines() {
    return false;
  }

  get jsonLike() {
    const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];
    return jsonLikeTypes.indexOf(this.type) !== -1;
  }

  get rangeAsLinePos() {
    if (!this.range || !this.context) return undefined;
    const start = getLinePos(this.range.start, this.context.root);
    if (!start) return undefined;
    const end = getLinePos(this.range.end, this.context.root);
    return {
      start,
      end
    };
  }

  get rawValue() {
    if (!this.valueRange || !this.context) return null;
    const {
      start,
      end
    } = this.valueRange;
    return this.context.src.slice(start, end);
  }

  get tag() {
    for (let i = 0; i < this.props.length; ++i) {
      const tag = this.getPropValue(i, Char.TAG, false);

      if (tag != null) {
        if (tag[1] === '<') {
          return {
            verbatim: tag.slice(2, -1)
          };
        } else {
          // eslint-disable-next-line no-unused-vars
          const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);
          return {
            handle,
            suffix
          };
        }
      }
    }

    return null;
  }

  get valueRangeContainsNewline() {
    if (!this.valueRange || !this.context) return false;
    const {
      start,
      end
    } = this.valueRange;
    const {
      src
    } = this.context;

    for (let i = start; i < end; ++i) {
      if (src[i] === '\n') return true;
    }

    return false;
  }

  parseComment(start) {
    const {
      src
    } = this.context;

    if (src[start] === Char.COMMENT) {
      const end = Node.endOfLine(src, start + 1);
      const commentRange = new Range(start, end);
      this.props.push(commentRange);
      return end;
    }

    return start;
  }
  /**
   * Populates the `origStart` and `origEnd` values of all ranges for this
   * node. Extended by child classes to handle descendant nodes.
   *
   * @param {number[]} cr - Positions of dropped CR characters
   * @param {number} offset - Starting index of `cr` from the last call
   * @returns {number} - The next offset, matching the one found for `origStart`
   */


  setOrigRanges(cr, offset) {
    if (this.range) offset = this.range.setOrigRange(cr, offset);
    if (this.valueRange) this.valueRange.setOrigRange(cr, offset);
    this.props.forEach(prop => prop.setOrigRange(cr, offset));
    return offset;
  }

  toString() {
    const {
      context: {
        src
      },
      range,
      value
    } = this;
    if (value != null) return value;
    const str = src.slice(range.start, range.end);
    return Node.addStringTerminator(src, range.end, str);
  }

}

class YAMLError extends Error {
  constructor(name, source, message) {
    if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);
    super();
    this.name = name;
    this.message = message;
    this.source = source;
  }

  makePretty() {
    if (!this.source) return;
    this.nodeType = this.source.type;
    const cst = this.source.context && this.source.context.root;

    if (typeof this.offset === 'number') {
      this.range = new Range(this.offset, this.offset + 1);
      const start = cst && getLinePos(this.offset, cst);

      if (start) {
        const end = {
          line: start.line,
          col: start.col + 1
        };
        this.linePos = {
          start,
          end
        };
      }

      delete this.offset;
    } else {
      this.range = this.source.range;
      this.linePos = this.source.rangeAsLinePos;
    }

    if (this.linePos) {
      const {
        line,
        col
      } = this.linePos.start;
      this.message += ` at line ${line}, column ${col}`;
      const ctx = cst && getPrettyContext(this.linePos, cst);
      if (ctx) this.message += `:\n\n${ctx}\n`;
    }

    delete this.source;
  }

}
class YAMLReferenceError extends YAMLError {
  constructor(source, message) {
    super('YAMLReferenceError', source, message);
  }

}
class YAMLSemanticError extends YAMLError {
  constructor(source, message) {
    super('YAMLSemanticError', source, message);
  }

}
class YAMLSyntaxError extends YAMLError {
  constructor(source, message) {
    super('YAMLSyntaxError', source, message);
  }

}
class YAMLWarning extends YAMLError {
  constructor(source, message) {
    super('YAMLWarning', source, message);
  }

}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

class PlainValue extends Node {
  static endOfLine(src, start, inFlow) {
    let ch = src[start];
    let offset = start;

    while (ch && ch !== '\n') {
      if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;
      const next = src[offset + 1];
      if (ch === ':' && (!next || next === '\n' || next === '\t' || next === ' ' || inFlow && next === ',')) break;
      if ((ch === ' ' || ch === '\t') && next === '#') break;
      offset += 1;
      ch = next;
    }

    return offset;
  }

  get strValue() {
    if (!this.valueRange || !this.context) return null;
    let {
      start,
      end
    } = this.valueRange;
    const {
      src
    } = this.context;
    let ch = src[end - 1];

    while (start < end && (ch === '\n' || ch === '\t' || ch === ' ')) ch = src[--end - 1];

    let str = '';

    for (let i = start; i < end; ++i) {
      const ch = src[i];

      if (ch === '\n') {
        const {
          fold,
          offset
        } = Node.foldNewline(src, i, -1);
        str += fold;
        i = offset;
      } else if (ch === ' ' || ch === '\t') {
        // trim trailing whitespace
        const wsStart = i;
        let next = src[i + 1];

        while (i < end && (next === ' ' || next === '\t')) {
          i += 1;
          next = src[i + 1];
        }

        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
      } else {
        str += ch;
      }
    }

    const ch0 = src[start];

    switch (ch0) {
      case '\t':
        {
          const msg = 'Plain value cannot start with a tab character';
          const errors = [new YAMLSemanticError(this, msg)];
          return {
            errors,
            str
          };
        }

      case '@':
      case '`':
        {
          const msg = `Plain value cannot start with reserved character ${ch0}`;
          const errors = [new YAMLSemanticError(this, msg)];
          return {
            errors,
            str
          };
        }

      default:
        return str;
    }
  }

  parseBlockValue(start) {
    const {
      indent,
      inFlow,
      src
    } = this.context;
    let offset = start;
    let valueEnd = start;

    for (let ch = src[offset]; ch === '\n'; ch = src[offset]) {
      if (Node.atDocumentBoundary(src, offset + 1)) break;
      const end = Node.endOfBlockIndent(src, indent, offset + 1);
      if (end === null || src[end] === '#') break;

      if (src[end] === '\n') {
        offset = end;
      } else {
        valueEnd = PlainValue.endOfLine(src, end, inFlow);
        offset = valueEnd;
      }
    }

    if (this.valueRange.isEmpty()) this.valueRange.start = start;
    this.valueRange.end = valueEnd;
    return valueEnd;
  }
  /**
   * Parses a plain value from the source
   *
   * Accepted forms are:
   * ```
   * #comment
   *
   * first line
   *
   * first line #comment
   *
   * first line
   * block
   * lines
   *
   * #comment
   * block
   * lines
   * ```
   * where block lines are empty or have an indent level greater than `indent`.
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar, may be `\n`
   */


  parse(context, start) {
    this.context = context;
    const {
      inFlow,
      src
    } = context;
    let offset = start;
    const ch = src[offset];

    if (ch && ch !== '#' && ch !== '\n') {
      offset = PlainValue.endOfLine(src, start, inFlow);
    }

    this.valueRange = new Range(start, offset);
    offset = Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);

    if (!this.hasComment || this.valueRange.isEmpty()) {
      offset = this.parseBlockValue(offset);
    }

    return offset;
  }

}

exports.Char = Char;
exports.Node = Node;
exports.PlainValue = PlainValue;
exports.Range = Range;
exports.Type = Type;
exports.YAMLError = YAMLError;
exports.YAMLReferenceError = YAMLReferenceError;
exports.YAMLSemanticError = YAMLSemanticError;
exports.YAMLSyntaxError = YAMLSyntaxError;
exports.YAMLWarning = YAMLWarning;
exports._defineProperty = _defineProperty;
exports.defaultTagPrefix = defaultTagPrefix;
exports.defaultTags = defaultTags;


/***/ }),

/***/ 51387:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var PlainValue = __nccwpck_require__(24941);
var resolveSeq = __nccwpck_require__(39914);
var warnings = __nccwpck_require__(95130);

function createMap(schema, obj, ctx) {
  const map = new resolveSeq.YAMLMap(schema);

  if (obj instanceof Map) {
    for (const [key, value] of obj) map.items.push(schema.createPair(key, value, ctx));
  } else if (obj && typeof obj === 'object') {
    for (const key of Object.keys(obj)) map.items.push(schema.createPair(key, obj[key], ctx));
  }

  if (typeof schema.sortMapEntries === 'function') {
    map.items.sort(schema.sortMapEntries);
  }

  return map;
}

const map = {
  createNode: createMap,
  default: true,
  nodeClass: resolveSeq.YAMLMap,
  tag: 'tag:yaml.org,2002:map',
  resolve: resolveSeq.resolveMap
};

function createSeq(schema, obj, ctx) {
  const seq = new resolveSeq.YAMLSeq(schema);

  if (obj && obj[Symbol.iterator]) {
    for (const it of obj) {
      const v = schema.createNode(it, ctx.wrapScalars, null, ctx);
      seq.items.push(v);
    }
  }

  return seq;
}

const seq = {
  createNode: createSeq,
  default: true,
  nodeClass: resolveSeq.YAMLSeq,
  tag: 'tag:yaml.org,2002:seq',
  resolve: resolveSeq.resolveSeq
};

const string = {
  identify: value => typeof value === 'string',
  default: true,
  tag: 'tag:yaml.org,2002:str',
  resolve: resolveSeq.resolveString,

  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({
      actualString: true
    }, ctx);
    return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);
  },

  options: resolveSeq.strOptions
};

const failsafe = [map, seq, string];

/* global BigInt */

const intIdentify$2 = value => typeof value === 'bigint' || Number.isInteger(value);

const intResolve$1 = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);

function intStringify$1(node, radix, prefix) {
  const {
    value
  } = node;
  if (intIdentify$2(value) && value >= 0) return prefix + value.toString(radix);
  return resolveSeq.stringifyNumber(node);
}

const nullObj = {
  identify: value => value == null,
  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
  default: true,
  tag: 'tag:yaml.org,2002:null',
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => null,
  options: resolveSeq.nullOptions,
  stringify: () => resolveSeq.nullOptions.nullStr
};
const boolObj = {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: str => str[0] === 't' || str[0] === 'T',
  options: resolveSeq.boolOptions,
  stringify: ({
    value
  }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr
};
const octObj = {
  identify: value => intIdentify$2(value) && value >= 0,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'OCT',
  test: /^0o([0-7]+)$/,
  resolve: (str, oct) => intResolve$1(str, oct, 8),
  options: resolveSeq.intOptions,
  stringify: node => intStringify$1(node, 8, '0o')
};
const intObj = {
  identify: intIdentify$2,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  test: /^[-+]?[0-9]+$/,
  resolve: str => intResolve$1(str, str, 10),
  options: resolveSeq.intOptions,
  stringify: resolveSeq.stringifyNumber
};
const hexObj = {
  identify: value => intIdentify$2(value) && value >= 0,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'HEX',
  test: /^0x([0-9a-fA-F]+)$/,
  resolve: (str, hex) => intResolve$1(str, hex, 16),
  options: resolveSeq.intOptions,
  stringify: node => intStringify$1(node, 16, '0x')
};
const nanObj = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^(?:[-+]?\.inf|(\.nan))$/i,
  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: resolveSeq.stringifyNumber
};
const expObj = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'EXP',
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: str => parseFloat(str),
  stringify: ({
    value
  }) => Number(value).toExponential()
};
const floatObj = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^[-+]?(?:\.([0-9]+)|[0-9]+\.([0-9]*))$/,

  resolve(str, frac1, frac2) {
    const frac = frac1 || frac2;
    const node = new resolveSeq.Scalar(parseFloat(str));
    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;
    return node;
  },

  stringify: resolveSeq.stringifyNumber
};
const core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);

/* global BigInt */

const intIdentify$1 = value => typeof value === 'bigint' || Number.isInteger(value);

const stringifyJSON = ({
  value
}) => JSON.stringify(value);

const json = [map, seq, {
  identify: value => typeof value === 'string',
  default: true,
  tag: 'tag:yaml.org,2002:str',
  resolve: resolveSeq.resolveString,
  stringify: stringifyJSON
}, {
  identify: value => value == null,
  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
  default: true,
  tag: 'tag:yaml.org,2002:null',
  test: /^null$/,
  resolve: () => null,
  stringify: stringifyJSON
}, {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^true|false$/,
  resolve: str => str === 'true',
  stringify: stringifyJSON
}, {
  identify: intIdentify$1,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  test: /^-?(?:0|[1-9][0-9]*)$/,
  resolve: str => resolveSeq.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),
  stringify: ({
    value
  }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
  resolve: str => parseFloat(str),
  stringify: stringifyJSON
}];

json.scalarFallback = str => {
  throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);
};

/* global BigInt */

const boolStringify = ({
  value
}) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;

const intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);

function intResolve(sign, src, radix) {
  let str = src.replace(/_/g, '');

  if (resolveSeq.intOptions.asBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;

      case 8:
        str = `0o${str}`;
        break;

      case 16:
        str = `0x${str}`;
        break;
    }

    const n = BigInt(str);
    return sign === '-' ? BigInt(-1) * n : n;
  }

  const n = parseInt(str, radix);
  return sign === '-' ? -1 * n : n;
}

function intStringify(node, radix, prefix) {
  const {
    value
  } = node;

  if (intIdentify(value)) {
    const str = value.toString(radix);
    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
  }

  return resolveSeq.stringifyNumber(node);
}

const yaml11 = failsafe.concat([{
  identify: value => value == null,
  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,
  default: true,
  tag: 'tag:yaml.org,2002:null',
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => null,
  options: resolveSeq.nullOptions,
  stringify: () => resolveSeq.nullOptions.nullStr
}, {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => true,
  options: resolveSeq.boolOptions,
  stringify: boolStringify
}, {
  identify: value => typeof value === 'boolean',
  default: true,
  tag: 'tag:yaml.org,2002:bool',
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => false,
  options: resolveSeq.boolOptions,
  stringify: boolStringify
}, {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'BIN',
  test: /^([-+]?)0b([0-1_]+)$/,
  resolve: (str, sign, bin) => intResolve(sign, bin, 2),
  stringify: node => intStringify(node, 2, '0b')
}, {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'OCT',
  test: /^([-+]?)0([0-7_]+)$/,
  resolve: (str, sign, oct) => intResolve(sign, oct, 8),
  stringify: node => intStringify(node, 8, '0')
}, {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  test: /^([-+]?)([0-9][0-9_]*)$/,
  resolve: (str, sign, abs) => intResolve(sign, abs, 10),
  stringify: resolveSeq.stringifyNumber
}, {
  identify: intIdentify,
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'HEX',
  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,
  resolve: (str, sign, hex) => intResolve(sign, hex, 16),
  stringify: node => intStringify(node, 16, '0x')
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^(?:[-+]?\.inf|(\.nan))$/i,
  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: resolveSeq.stringifyNumber
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'EXP',
  test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: str => parseFloat(str.replace(/_/g, '')),
  stringify: ({
    value
  }) => Number(value).toExponential()
}, {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,

  resolve(str, frac) {
    const node = new resolveSeq.Scalar(parseFloat(str.replace(/_/g, '')));

    if (frac) {
      const f = frac.replace(/_/g, '');
      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;
    }

    return node;
  },

  stringify: resolveSeq.stringifyNumber
}], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);

const schemas = {
  core,
  failsafe,
  json,
  yaml11
};
const tags = {
  binary: warnings.binary,
  bool: boolObj,
  float: floatObj,
  floatExp: expObj,
  floatNaN: nanObj,
  floatTime: warnings.floatTime,
  int: intObj,
  intHex: hexObj,
  intOct: octObj,
  intTime: warnings.intTime,
  map,
  null: nullObj,
  omap: warnings.omap,
  pairs: warnings.pairs,
  seq,
  set: warnings.set,
  timestamp: warnings.timestamp
};

function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter(t => t.tag === tagName);
    const tagObj = match.find(t => !t.format) || match[0];
    if (!tagObj) throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  } // TODO: deprecate/remove class check


  return tags.find(t => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);
}

function createNode(value, tagName, ctx) {
  if (value instanceof resolveSeq.Node) return value;
  const {
    defaultPrefix,
    onTagObj,
    prevObjects,
    schema,
    wrapScalars
  } = ctx;
  if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema.tags);

  if (!tagObj) {
    if (typeof value.toJSON === 'function') value = value.toJSON();
    if (!value || typeof value !== 'object') return wrapScalars ? new resolveSeq.Scalar(value) : value;
    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;
  }

  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  } // Detect duplicate references to the same object & use Alias nodes for all
  // after first. The `obj` wrapper allows for circular references to resolve.


  const obj = {
    value: undefined,
    node: undefined
  };

  if (value && typeof value === 'object' && prevObjects) {
    const prev = prevObjects.get(value);

    if (prev) {
      const alias = new resolveSeq.Alias(prev); // leaves source dirty; must be cleaned by caller

      ctx.aliasNodes.push(alias); // defined along with prevObjects

      return alias;
    }

    obj.value = value;
    prevObjects.set(value, obj);
  }

  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;
  if (tagName && obj.node instanceof resolveSeq.Node) obj.node.tag = tagName;
  return obj.node;
}

function getSchemaTags(schemas, knownTags, customTags, schemaId) {
  let tags = schemas[schemaId.replace(/\W/g, '')]; // 'yaml-1.1' -> 'yaml11'

  if (!tags) {
    const keys = Object.keys(schemas).map(key => JSON.stringify(key)).join(', ');
    throw new Error(`Unknown schema "${schemaId}"; use one of ${keys}`);
  }

  if (Array.isArray(customTags)) {
    for (const tag of customTags) tags = tags.concat(tag);
  } else if (typeof customTags === 'function') {
    tags = customTags(tags.slice());
  }

  for (let i = 0; i < tags.length; ++i) {
    const tag = tags[i];

    if (typeof tag === 'string') {
      const tagObj = knownTags[tag];

      if (!tagObj) {
        const keys = Object.keys(knownTags).map(key => JSON.stringify(key)).join(', ');
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
      }

      tags[i] = tagObj;
    }
  }

  return tags;
}

const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;

class Schema {
  // TODO: remove in v2
  // TODO: remove in v2
  constructor({
    customTags,
    merge,
    schema,
    sortMapEntries,
    tags: deprecatedCustomTags
  }) {
    this.merge = !!merge;
    this.name = schema;
    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
    if (!customTags && deprecatedCustomTags) warnings.warnOptionDeprecation('tags', 'customTags');
    this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);
  }

  createNode(value, wrapScalars, tagName, ctx) {
    const baseCtx = {
      defaultPrefix: Schema.defaultPrefix,
      schema: this,
      wrapScalars
    };
    const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;
    return createNode(value, tagName, createCtx);
  }

  createPair(key, value, ctx) {
    if (!ctx) ctx = {
      wrapScalars: true
    };
    const k = this.createNode(key, ctx.wrapScalars, null, ctx);
    const v = this.createNode(value, ctx.wrapScalars, null, ctx);
    return new resolveSeq.Pair(k, v);
  }

}

PlainValue._defineProperty(Schema, "defaultPrefix", PlainValue.defaultTagPrefix);

PlainValue._defineProperty(Schema, "defaultTags", PlainValue.defaultTags);

exports.Schema = Schema;


/***/ }),

/***/ 44083:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var parseCst = __nccwpck_require__(94611);
var Document$1 = __nccwpck_require__(60525);
var Schema = __nccwpck_require__(51387);
var PlainValue = __nccwpck_require__(24941);
var warnings = __nccwpck_require__(95130);
__nccwpck_require__(39914);

function createNode(value, wrapScalars = true, tag) {
  if (tag === undefined && typeof wrapScalars === 'string') {
    tag = wrapScalars;
    wrapScalars = true;
  }

  const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);
  const schema = new Schema.Schema(options);
  return schema.createNode(value, wrapScalars, tag);
}

class Document extends Document$1.Document {
  constructor(options) {
    super(Object.assign({}, Document$1.defaultOptions, options));
  }

}

function parseAllDocuments(src, options) {
  const stream = [];
  let prev;

  for (const cstDoc of parseCst.parse(src)) {
    const doc = new Document(options);
    doc.parse(cstDoc, prev);
    stream.push(doc);
    prev = doc;
  }

  return stream;
}

function parseDocument(src, options) {
  const cst = parseCst.parse(src);
  const doc = new Document(options).parse(cst[0]);

  if (cst.length > 1) {
    const errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';
    doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));
  }

  return doc;
}

function parse(src, options) {
  const doc = parseDocument(src, options);
  doc.warnings.forEach(warning => warnings.warn(warning));
  if (doc.errors.length > 0) throw doc.errors[0];
  return doc.toJSON();
}

function stringify(value, options) {
  const doc = new Document(options);
  doc.contents = value;
  return String(doc);
}

const YAML = {
  createNode,
  defaultOptions: Document$1.defaultOptions,
  Document,
  parse,
  parseAllDocuments,
  parseCST: parseCst.parse,
  parseDocument,
  scalarOptions: Document$1.scalarOptions,
  stringify
};

exports.YAML = YAML;


/***/ }),

/***/ 94611:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var PlainValue = __nccwpck_require__(24941);

class BlankLine extends PlainValue.Node {
  constructor() {
    super(PlainValue.Type.BLANK_LINE);
  }
  /* istanbul ignore next */


  get includesTrailingLines() {
    // This is never called from anywhere, but if it were,
    // this is the value it should return.
    return true;
  }
  /**
   * Parses a blank line from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first \n character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    this.range = new PlainValue.Range(start, start + 1);
    return start + 1;
  }

}

class CollectionItem extends PlainValue.Node {
  constructor(type, props) {
    super(type, props);
    this.node = null;
  }

  get includesTrailingLines() {
    return !!this.node && this.node.includesTrailingLines;
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    const {
      parseNode,
      src
    } = context;
    let {
      atLineStart,
      lineStart
    } = context;
    if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');
    const indent = atLineStart ? start - lineStart : context.indent;
    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
    let ch = src[offset];
    const inlineComment = ch === '#';
    const comments = [];
    let blankLine = null;

    while (ch === '\n' || ch === '#') {
      if (ch === '#') {
        const end = PlainValue.Node.endOfLine(src, offset + 1);
        comments.push(new PlainValue.Range(offset, end));
        offset = end;
      } else {
        atLineStart = true;
        lineStart = offset + 1;
        const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);

        if (src[wsEnd] === '\n' && comments.length === 0) {
          blankLine = new BlankLine();
          lineStart = blankLine.parse({
            src
          }, lineStart);
        }

        offset = PlainValue.Node.endOfIndent(src, lineStart);
      }

      ch = src[offset];
    }

    if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {
      this.node = parseNode({
        atLineStart,
        inCollection: false,
        indent,
        lineStart,
        parent: this
      }, offset);
    } else if (ch && lineStart > start + 1) {
      offset = lineStart - 1;
    }

    if (this.node) {
      if (blankLine) {
        // Only blank lines preceding non-empty nodes are captured. Note that
        // this means that collection item range start indices do not always
        // increase monotonically. -- eemeli/yaml#126
        const items = context.parent.items || context.parent.contents;
        if (items) items.push(blankLine);
      }

      if (comments.length) Array.prototype.push.apply(this.props, comments);
      offset = this.node.range.end;
    } else {
      if (inlineComment) {
        const c = comments[0];
        this.props.push(c);
        offset = c.end;
      } else {
        offset = PlainValue.Node.endOfLine(src, start + 1);
      }
    }

    const end = this.node ? this.node.valueRange.end : offset;
    this.valueRange = new PlainValue.Range(start, end);
    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    return this.node ? this.node.setOrigRanges(cr, offset) : offset;
  }

  toString() {
    const {
      context: {
        src
      },
      node,
      range,
      value
    } = this;
    if (value != null) return value;
    const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);
    return PlainValue.Node.addStringTerminator(src, range.end, str);
  }

}

class Comment extends PlainValue.Node {
  constructor() {
    super(PlainValue.Type.COMMENT);
  }
  /**
   * Parses a comment line from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */


  parse(context, start) {
    this.context = context;
    const offset = this.parseComment(start);
    this.range = new PlainValue.Range(start, offset);
    return offset;
  }

}

function grabCollectionEndComments(node) {
  let cnode = node;

  while (cnode instanceof CollectionItem) cnode = cnode.node;

  if (!(cnode instanceof Collection)) return null;
  const len = cnode.items.length;
  let ci = -1;

  for (let i = len - 1; i >= 0; --i) {
    const n = cnode.items[i];

    if (n.type === PlainValue.Type.COMMENT) {
      // Keep sufficiently indented comments with preceding node
      const {
        indent,
        lineStart
      } = n.context;
      if (indent > 0 && n.range.start >= lineStart + indent) break;
      ci = i;
    } else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;else break;
  }

  if (ci === -1) return null;
  const ca = cnode.items.splice(ci, len - ci);
  const prevEnd = ca[0].range.start;

  while (true) {
    cnode.range.end = prevEnd;
    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;
    if (cnode === node) break;
    cnode = cnode.context.parent;
  }

  return ca;
}
class Collection extends PlainValue.Node {
  static nextContentHasIndent(src, offset, indent) {
    const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;
    offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);
    const ch = src[offset];
    if (!ch) return false;
    if (offset >= lineStart + indent) return true;
    if (ch !== '#' && ch !== '\n') return false;
    return Collection.nextContentHasIndent(src, offset, indent);
  }

  constructor(firstItem) {
    super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);

    for (let i = firstItem.props.length - 1; i >= 0; --i) {
      if (firstItem.props[i].start < firstItem.context.lineStart) {
        // props on previous line are assumed by the collection
        this.props = firstItem.props.slice(0, i + 1);
        firstItem.props = firstItem.props.slice(i + 1);
        const itemRange = firstItem.props[0] || firstItem.valueRange;
        firstItem.range.start = itemRange.start;
        break;
      }
    }

    this.items = [firstItem];
    const ec = grabCollectionEndComments(firstItem);
    if (ec) Array.prototype.push.apply(this.items, ec);
  }

  get includesTrailingLines() {
    return this.items.length > 0;
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    const {
      parseNode,
      src
    } = context; // It's easier to recalculate lineStart here rather than tracking down the
    // last context from which to read it -- eemeli/yaml#2

    let lineStart = PlainValue.Node.startOfLine(src, start);
    const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling
    // -- eemeli/yaml#17

    firstItem.context.parent = this;
    this.valueRange = PlainValue.Range.copy(firstItem.valueRange);
    const indent = firstItem.range.start - firstItem.context.lineStart;
    let offset = start;
    offset = PlainValue.Node.normalizeOffset(src, offset);
    let ch = src[offset];
    let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;
    let prevIncludesTrailingLines = false;

    while (ch) {
      while (ch === '\n' || ch === '#') {
        if (atLineStart && ch === '\n' && !prevIncludesTrailingLines) {
          const blankLine = new BlankLine();
          offset = blankLine.parse({
            src
          }, offset);
          this.valueRange.end = offset;

          if (offset >= src.length) {
            ch = null;
            break;
          }

          this.items.push(blankLine);
          offset -= 1; // blankLine.parse() consumes terminal newline
        } else if (ch === '#') {
          if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {
            return offset;
          }

          const comment = new Comment();
          offset = comment.parse({
            indent,
            lineStart,
            src
          }, offset);
          this.items.push(comment);
          this.valueRange.end = offset;

          if (offset >= src.length) {
            ch = null;
            break;
          }
        }

        lineStart = offset + 1;
        offset = PlainValue.Node.endOfIndent(src, lineStart);

        if (PlainValue.Node.atBlank(src, offset)) {
          const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);
          const next = src[wsEnd];

          if (!next || next === '\n' || next === '#') {
            offset = wsEnd;
          }
        }

        ch = src[offset];
        atLineStart = true;
      }

      if (!ch) {
        break;
      }

      if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {
        if (offset < lineStart + indent) {
          if (lineStart > start) offset = lineStart;
          break;
        } else if (!this.error) {
          const msg = 'All collection items must start at the same column';
          this.error = new PlainValue.YAMLSyntaxError(this, msg);
        }
      }

      if (firstItem.type === PlainValue.Type.SEQ_ITEM) {
        if (ch !== '-') {
          if (lineStart > start) offset = lineStart;
          break;
        }
      } else if (ch === '-' && !this.error) {
        // map key may start with -, as long as it's followed by a non-whitespace char
        const next = src[offset + 1];

        if (!next || next === '\n' || next === '\t' || next === ' ') {
          const msg = 'A collection cannot be both a mapping and a sequence';
          this.error = new PlainValue.YAMLSyntaxError(this, msg);
        }
      }

      const node = parseNode({
        atLineStart,
        inCollection: true,
        indent,
        lineStart,
        parent: this
      }, offset);
      if (!node) return offset; // at next document start

      this.items.push(node);
      this.valueRange.end = node.valueRange.end;
      offset = PlainValue.Node.normalizeOffset(src, node.range.end);
      ch = src[offset];
      atLineStart = false;
      prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range
      // has advanced to check the current line's indentation level
      // -- eemeli/yaml#10 & eemeli/yaml#38

      if (ch) {
        let ls = offset - 1;
        let prev = src[ls];

        while (prev === ' ' || prev === '\t') prev = src[--ls];

        if (prev === '\n') {
          lineStart = ls + 1;
          atLineStart = true;
        }
      }

      const ec = grabCollectionEndComments(node);
      if (ec) Array.prototype.push.apply(this.items, ec);
    }

    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    this.items.forEach(node => {
      offset = node.setOrigRanges(cr, offset);
    });
    return offset;
  }

  toString() {
    const {
      context: {
        src
      },
      items,
      range,
      value
    } = this;
    if (value != null) return value;
    let str = src.slice(range.start, items[0].range.start) + String(items[0]);

    for (let i = 1; i < items.length; ++i) {
      const item = items[i];
      const {
        atLineStart,
        indent
      } = item.context;
      if (atLineStart) for (let i = 0; i < indent; ++i) str += ' ';
      str += String(item);
    }

    return PlainValue.Node.addStringTerminator(src, range.end, str);
  }

}

class Directive extends PlainValue.Node {
  constructor() {
    super(PlainValue.Type.DIRECTIVE);
    this.name = null;
  }

  get parameters() {
    const raw = this.rawValue;
    return raw ? raw.trim().split(/[ \t]+/) : [];
  }

  parseName(start) {
    const {
      src
    } = this.context;
    let offset = start;
    let ch = src[offset];

    while (ch && ch !== '\n' && ch !== '\t' && ch !== ' ') ch = src[offset += 1];

    this.name = src.slice(start, offset);
    return offset;
  }

  parseParameters(start) {
    const {
      src
    } = this.context;
    let offset = start;
    let ch = src[offset];

    while (ch && ch !== '\n' && ch !== '#') ch = src[offset += 1];

    this.valueRange = new PlainValue.Range(start, offset);
    return offset;
  }

  parse(context, start) {
    this.context = context;
    let offset = this.parseName(start + 1);
    offset = this.parseParameters(offset);
    offset = this.parseComment(offset);
    this.range = new PlainValue.Range(start, offset);
    return offset;
  }

}

class Document extends PlainValue.Node {
  static startCommentOrEndBlankLine(src, start) {
    const offset = PlainValue.Node.endOfWhiteSpace(src, start);
    const ch = src[offset];
    return ch === '#' || ch === '\n' ? offset : start;
  }

  constructor() {
    super(PlainValue.Type.DOCUMENT);
    this.directives = null;
    this.contents = null;
    this.directivesEndMarker = null;
    this.documentEndMarker = null;
  }

  parseDirectives(start) {
    const {
      src
    } = this.context;
    this.directives = [];
    let atLineStart = true;
    let hasDirectives = false;
    let offset = start;

    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {
      offset = Document.startCommentOrEndBlankLine(src, offset);

      switch (src[offset]) {
        case '\n':
          if (atLineStart) {
            const blankLine = new BlankLine();
            offset = blankLine.parse({
              src
            }, offset);

            if (offset < src.length) {
              this.directives.push(blankLine);
            }
          } else {
            offset += 1;
            atLineStart = true;
          }

          break;

        case '#':
          {
            const comment = new Comment();
            offset = comment.parse({
              src
            }, offset);
            this.directives.push(comment);
            atLineStart = false;
          }
          break;

        case '%':
          {
            const directive = new Directive();
            offset = directive.parse({
              parent: this,
              src
            }, offset);
            this.directives.push(directive);
            hasDirectives = true;
            atLineStart = false;
          }
          break;

        default:
          if (hasDirectives) {
            this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');
          } else if (this.directives.length > 0) {
            this.contents = this.directives;
            this.directives = [];
          }

          return offset;
      }
    }

    if (src[offset]) {
      this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);
      return offset + 3;
    }

    if (hasDirectives) {
      this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');
    } else if (this.directives.length > 0) {
      this.contents = this.directives;
      this.directives = [];
    }

    return offset;
  }

  parseContents(start) {
    const {
      parseNode,
      src
    } = this.context;
    if (!this.contents) this.contents = [];
    let lineStart = start;

    while (src[lineStart - 1] === '-') lineStart -= 1;

    let offset = PlainValue.Node.endOfWhiteSpace(src, start);
    let atLineStart = lineStart === start;
    this.valueRange = new PlainValue.Range(offset);

    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {
      switch (src[offset]) {
        case '\n':
          if (atLineStart) {
            const blankLine = new BlankLine();
            offset = blankLine.parse({
              src
            }, offset);

            if (offset < src.length) {
              this.contents.push(blankLine);
            }
          } else {
            offset += 1;
            atLineStart = true;
          }

          lineStart = offset;
          break;

        case '#':
          {
            const comment = new Comment();
            offset = comment.parse({
              src
            }, offset);
            this.contents.push(comment);
            atLineStart = false;
          }
          break;

        default:
          {
            const iEnd = PlainValue.Node.endOfIndent(src, offset);
            const context = {
              atLineStart,
              indent: -1,
              inFlow: false,
              inCollection: false,
              lineStart,
              parent: this
            };
            const node = parseNode(context, iEnd);
            if (!node) return this.valueRange.end = iEnd; // at next document start

            this.contents.push(node);
            offset = node.range.end;
            atLineStart = false;
            const ec = grabCollectionEndComments(node);
            if (ec) Array.prototype.push.apply(this.contents, ec);
          }
      }

      offset = Document.startCommentOrEndBlankLine(src, offset);
    }

    this.valueRange.end = offset;

    if (src[offset]) {
      this.documentEndMarker = new PlainValue.Range(offset, offset + 3);
      offset += 3;

      if (src[offset]) {
        offset = PlainValue.Node.endOfWhiteSpace(src, offset);

        if (src[offset] === '#') {
          const comment = new Comment();
          offset = comment.parse({
            src
          }, offset);
          this.contents.push(comment);
        }

        switch (src[offset]) {
          case '\n':
            offset += 1;
            break;

          case undefined:
            break;

          default:
            this.error = new PlainValue.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');
        }
      }
    }

    return offset;
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    context.root = this;
    this.context = context;
    const {
      src
    } = context;
    let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM

    offset = this.parseDirectives(offset);
    offset = this.parseContents(offset);
    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    this.directives.forEach(node => {
      offset = node.setOrigRanges(cr, offset);
    });
    if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);
    this.contents.forEach(node => {
      offset = node.setOrigRanges(cr, offset);
    });
    if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);
    return offset;
  }

  toString() {
    const {
      contents,
      directives,
      value
    } = this;
    if (value != null) return value;
    let str = directives.join('');

    if (contents.length > 0) {
      if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str += '---\n';
      str += contents.join('');
    }

    if (str[str.length - 1] !== '\n') str += '\n';
    return str;
  }

}

class Alias extends PlainValue.Node {
  /**
   * Parses an *alias from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */
  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;
    let offset = PlainValue.Node.endOfIdentifier(src, start + 1);
    this.valueRange = new PlainValue.Range(start + 1, offset);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    return offset;
  }

}

const Chomp = {
  CLIP: 'CLIP',
  KEEP: 'KEEP',
  STRIP: 'STRIP'
};
class BlockValue extends PlainValue.Node {
  constructor(type, props) {
    super(type, props);
    this.blockIndent = null;
    this.chomping = Chomp.CLIP;
    this.header = null;
  }

  get includesTrailingLines() {
    return this.chomping === Chomp.KEEP;
  }

  get strValue() {
    if (!this.valueRange || !this.context) return null;
    let {
      start,
      end
    } = this.valueRange;
    const {
      indent,
      src
    } = this.context;
    if (this.valueRange.isEmpty()) return '';
    let lastNewLine = null;
    let ch = src[end - 1];

    while (ch === '\n' || ch === '\t' || ch === ' ') {
      end -= 1;

      if (end <= start) {
        if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens
      }

      if (ch === '\n') lastNewLine = end;
      ch = src[end - 1];
    }

    let keepStart = end + 1;

    if (lastNewLine) {
      if (this.chomping === Chomp.KEEP) {
        keepStart = lastNewLine;
        end = this.valueRange.end;
      } else {
        end = lastNewLine;
      }
    }

    const bi = indent + this.blockIndent;
    const folded = this.type === PlainValue.Type.BLOCK_FOLDED;
    let atStart = true;
    let str = '';
    let sep = '';
    let prevMoreIndented = false;

    for (let i = start; i < end; ++i) {
      for (let j = 0; j < bi; ++j) {
        if (src[i] !== ' ') break;
        i += 1;
      }

      const ch = src[i];

      if (ch === '\n') {
        if (sep === '\n') str += '\n';else sep = '\n';
      } else {
        const lineEnd = PlainValue.Node.endOfLine(src, i);
        const line = src.slice(i, lineEnd);
        i = lineEnd;

        if (folded && (ch === ' ' || ch === '\t') && i < keepStart) {
          if (sep === ' ') sep = '\n';else if (!prevMoreIndented && !atStart && sep === '\n') sep = '\n\n';
          str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')

          sep = lineEnd < end && src[lineEnd] || '';
          prevMoreIndented = true;
        } else {
          str += sep + line;
          sep = folded && i < keepStart ? ' ' : '\n';
          prevMoreIndented = false;
        }

        if (atStart && line !== '') atStart = false;
      }
    }

    return this.chomping === Chomp.STRIP ? str : str + '\n';
  }

  parseBlockHeader(start) {
    const {
      src
    } = this.context;
    let offset = start + 1;
    let bi = '';

    while (true) {
      const ch = src[offset];

      switch (ch) {
        case '-':
          this.chomping = Chomp.STRIP;
          break;

        case '+':
          this.chomping = Chomp.KEEP;
          break;

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          bi += ch;
          break;

        default:
          this.blockIndent = Number(bi) || null;
          this.header = new PlainValue.Range(start, offset);
          return offset;
      }

      offset += 1;
    }
  }

  parseBlockValue(start) {
    const {
      indent,
      src
    } = this.context;
    const explicit = !!this.blockIndent;
    let offset = start;
    let valueEnd = start;
    let minBlockIndent = 1;

    for (let ch = src[offset]; ch === '\n'; ch = src[offset]) {
      offset += 1;
      if (PlainValue.Node.atDocumentBoundary(src, offset)) break;
      const end = PlainValue.Node.endOfBlockIndent(src, indent, offset); // should not include tab?

      if (end === null) break;
      const ch = src[end];
      const lineIndent = end - (offset + indent);

      if (!this.blockIndent) {
        // no explicit block indent, none yet detected
        if (src[end] !== '\n') {
          // first line with non-whitespace content
          if (lineIndent < minBlockIndent) {
            const msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
            this.error = new PlainValue.YAMLSemanticError(this, msg);
          }

          this.blockIndent = lineIndent;
        } else if (lineIndent > minBlockIndent) {
          // empty line with more whitespace
          minBlockIndent = lineIndent;
        }
      } else if (ch && ch !== '\n' && lineIndent < this.blockIndent) {
        if (src[end] === '#') break;

        if (!this.error) {
          const src = explicit ? 'explicit indentation indicator' : 'first line';
          const msg = `Block scalars must not be less indented than their ${src}`;
          this.error = new PlainValue.YAMLSemanticError(this, msg);
        }
      }

      if (src[end] === '\n') {
        offset = end;
      } else {
        offset = valueEnd = PlainValue.Node.endOfLine(src, end);
      }
    }

    if (this.chomping !== Chomp.KEEP) {
      offset = src[valueEnd] ? valueEnd + 1 : valueEnd;
    }

    this.valueRange = new PlainValue.Range(start + 1, offset);
    return offset;
  }
  /**
   * Parses a block value from the source
   *
   * Accepted forms are:
   * ```
   * BS
   * block
   * lines
   *
   * BS #comment
   * block
   * lines
   * ```
   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines
   * are empty or have an indent level greater than `indent`.
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this block
   */


  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;
    let offset = this.parseBlockHeader(start);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    offset = this.parseBlockValue(offset);
    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    return this.header ? this.header.setOrigRange(cr, offset) : offset;
  }

}

class FlowCollection extends PlainValue.Node {
  constructor(type, props) {
    super(type, props);
    this.items = null;
  }

  prevNodeIsJsonLike(idx = this.items.length) {
    const node = this.items[idx - 1];
    return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));
  }
  /**
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this
   */


  parse(context, start) {
    this.context = context;
    const {
      parseNode,
      src
    } = context;
    let {
      indent,
      lineStart
    } = context;
    let char = src[start]; // { or [

    this.items = [{
      char,
      offset: start
    }];
    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);
    char = src[offset];

    while (char && char !== ']' && char !== '}') {
      switch (char) {
        case '\n':
          {
            lineStart = offset + 1;
            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);

            if (src[wsEnd] === '\n') {
              const blankLine = new BlankLine();
              lineStart = blankLine.parse({
                src
              }, lineStart);
              this.items.push(blankLine);
            }

            offset = PlainValue.Node.endOfIndent(src, lineStart);

            if (offset <= lineStart + indent) {
              char = src[offset];

              if (offset < lineStart + indent || char !== ']' && char !== '}') {
                const msg = 'Insufficient indentation in flow collection';
                this.error = new PlainValue.YAMLSemanticError(this, msg);
              }
            }
          }
          break;

        case ',':
          {
            this.items.push({
              char,
              offset
            });
            offset += 1;
          }
          break;

        case '#':
          {
            const comment = new Comment();
            offset = comment.parse({
              src
            }, offset);
            this.items.push(comment);
          }
          break;

        case '?':
        case ':':
          {
            const next = src[offset + 1];

            if (next === '\n' || next === '\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace
            char === ':' && this.prevNodeIsJsonLike()) {
              this.items.push({
                char,
                offset
              });
              offset += 1;
              break;
            }
          }
        // fallthrough

        default:
          {
            const node = parseNode({
              atLineStart: false,
              inCollection: false,
              inFlow: true,
              indent: -1,
              lineStart,
              parent: this
            }, offset);

            if (!node) {
              // at next document start
              this.valueRange = new PlainValue.Range(start, offset);
              return offset;
            }

            this.items.push(node);
            offset = PlainValue.Node.normalizeOffset(src, node.range.end);
          }
      }

      offset = PlainValue.Node.endOfWhiteSpace(src, offset);
      char = src[offset];
    }

    this.valueRange = new PlainValue.Range(start, offset + 1);

    if (char) {
      this.items.push({
        char,
        offset
      });
      offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);
      offset = this.parseComment(offset);
    }

    return offset;
  }

  setOrigRanges(cr, offset) {
    offset = super.setOrigRanges(cr, offset);
    this.items.forEach(node => {
      if (node instanceof PlainValue.Node) {
        offset = node.setOrigRanges(cr, offset);
      } else if (cr.length === 0) {
        node.origOffset = node.offset;
      } else {
        let i = offset;

        while (i < cr.length) {
          if (cr[i] > node.offset) break;else ++i;
        }

        node.origOffset = node.offset + i;
        offset = i;
      }
    });
    return offset;
  }

  toString() {
    const {
      context: {
        src
      },
      items,
      range,
      value
    } = this;
    if (value != null) return value;
    const nodes = items.filter(item => item instanceof PlainValue.Node);
    let str = '';
    let prevEnd = range.start;
    nodes.forEach(node => {
      const prefix = src.slice(prevEnd, node.range.start);
      prevEnd = node.range.end;
      str += prefix + String(node);

      if (str[str.length - 1] === '\n' && src[prevEnd - 1] !== '\n' && src[prevEnd] === '\n') {
        // Comment range does not include the terminal newline, but its
        // stringified value does. Without this fix, newlines at comment ends
        // get duplicated.
        prevEnd += 1;
      }
    });
    str += src.slice(prevEnd, range.end);
    return PlainValue.Node.addStringTerminator(src, range.end, str);
  }

}

class QuoteDouble extends PlainValue.Node {
  static endOfQuote(src, offset) {
    let ch = src[offset];

    while (ch && ch !== '"') {
      offset += ch === '\\' ? 2 : 1;
      ch = src[offset];
    }

    return offset + 1;
  }
  /**
   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
   */


  get strValue() {
    if (!this.valueRange || !this.context) return null;
    const errors = [];
    const {
      start,
      end
    } = this.valueRange;
    const {
      indent,
      src
    } = this.context;
    if (src[end - 1] !== '"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing "quote')); // Using String#replace is too painful with escaped newlines preceded by
    // escaped backslashes; also, this should be faster.

    let str = '';

    for (let i = start + 1; i < end - 1; ++i) {
      const ch = src[i];

      if (ch === '\n') {
        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));
        const {
          fold,
          offset,
          error
        } = PlainValue.Node.foldNewline(src, i, indent);
        str += fold;
        i = offset;
        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));
      } else if (ch === '\\') {
        i += 1;

        switch (src[i]) {
          case '0':
            str += '\0';
            break;
          // null character

          case 'a':
            str += '\x07';
            break;
          // bell character

          case 'b':
            str += '\b';
            break;
          // backspace

          case 'e':
            str += '\x1b';
            break;
          // escape character

          case 'f':
            str += '\f';
            break;
          // form feed

          case 'n':
            str += '\n';
            break;
          // line feed

          case 'r':
            str += '\r';
            break;
          // carriage return

          case 't':
            str += '\t';
            break;
          // horizontal tab

          case 'v':
            str += '\v';
            break;
          // vertical tab

          case 'N':
            str += '\u0085';
            break;
          // Unicode next line

          case '_':
            str += '\u00a0';
            break;
          // Unicode non-breaking space

          case 'L':
            str += '\u2028';
            break;
          // Unicode line separator

          case 'P':
            str += '\u2029';
            break;
          // Unicode paragraph separator

          case ' ':
            str += ' ';
            break;

          case '"':
            str += '"';
            break;

          case '/':
            str += '/';
            break;

          case '\\':
            str += '\\';
            break;

          case '\t':
            str += '\t';
            break;

          case 'x':
            str += this.parseCharCode(i + 1, 2, errors);
            i += 2;
            break;

          case 'u':
            str += this.parseCharCode(i + 1, 4, errors);
            i += 4;
            break;

          case 'U':
            str += this.parseCharCode(i + 1, 8, errors);
            i += 8;
            break;

          case '\n':
            // skip escaped newlines, but still trim the following line
            while (src[i + 1] === ' ' || src[i + 1] === '\t') i += 1;

            break;

          default:
            errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));
            str += '\\' + src[i];
        }
      } else if (ch === ' ' || ch === '\t') {
        // trim trailing whitespace
        const wsStart = i;
        let next = src[i + 1];

        while (next === ' ' || next === '\t') {
          i += 1;
          next = src[i + 1];
        }

        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
      } else {
        str += ch;
      }
    }

    return errors.length > 0 ? {
      errors,
      str
    } : str;
  }

  parseCharCode(offset, length, errors) {
    const {
      src
    } = this.context;
    const cc = src.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;

    if (isNaN(code)) {
      errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));
      return src.substr(offset - 2, length + 2);
    }

    return String.fromCodePoint(code);
  }
  /**
   * Parses a "double quoted" value from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */


  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;
    let offset = QuoteDouble.endOfQuote(src, start + 1);
    this.valueRange = new PlainValue.Range(start, offset);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    return offset;
  }

}

class QuoteSingle extends PlainValue.Node {
  static endOfQuote(src, offset) {
    let ch = src[offset];

    while (ch) {
      if (ch === "'") {
        if (src[offset + 1] !== "'") break;
        ch = src[offset += 2];
      } else {
        ch = src[offset += 1];
      }
    }

    return offset + 1;
  }
  /**
   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}
   */


  get strValue() {
    if (!this.valueRange || !this.context) return null;
    const errors = [];
    const {
      start,
      end
    } = this.valueRange;
    const {
      indent,
      src
    } = this.context;
    if (src[end - 1] !== "'") errors.push(new PlainValue.YAMLSyntaxError(this, "Missing closing 'quote"));
    let str = '';

    for (let i = start + 1; i < end - 1; ++i) {
      const ch = src[i];

      if (ch === '\n') {
        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));
        const {
          fold,
          offset,
          error
        } = PlainValue.Node.foldNewline(src, i, indent);
        str += fold;
        i = offset;
        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));
      } else if (ch === "'") {
        str += ch;
        i += 1;
        if (src[i] !== "'") errors.push(new PlainValue.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));
      } else if (ch === ' ' || ch === '\t') {
        // trim trailing whitespace
        const wsStart = i;
        let next = src[i + 1];

        while (next === ' ' || next === '\t') {
          i += 1;
          next = src[i + 1];
        }

        if (next !== '\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;
      } else {
        str += ch;
      }
    }

    return errors.length > 0 ? {
      errors,
      str
    } : str;
  }
  /**
   * Parses a 'single quoted' value from the source
   *
   * @param {ParseContext} context
   * @param {number} start - Index of first character
   * @returns {number} - Index of the character after this scalar
   */


  parse(context, start) {
    this.context = context;
    const {
      src
    } = context;
    let offset = QuoteSingle.endOfQuote(src, start + 1);
    this.valueRange = new PlainValue.Range(start, offset);
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    offset = this.parseComment(offset);
    return offset;
  }

}

function createNewNode(type, props) {
  switch (type) {
    case PlainValue.Type.ALIAS:
      return new Alias(type, props);

    case PlainValue.Type.BLOCK_FOLDED:
    case PlainValue.Type.BLOCK_LITERAL:
      return new BlockValue(type, props);

    case PlainValue.Type.FLOW_MAP:
    case PlainValue.Type.FLOW_SEQ:
      return new FlowCollection(type, props);

    case PlainValue.Type.MAP_KEY:
    case PlainValue.Type.MAP_VALUE:
    case PlainValue.Type.SEQ_ITEM:
      return new CollectionItem(type, props);

    case PlainValue.Type.COMMENT:
    case PlainValue.Type.PLAIN:
      return new PlainValue.PlainValue(type, props);

    case PlainValue.Type.QUOTE_DOUBLE:
      return new QuoteDouble(type, props);

    case PlainValue.Type.QUOTE_SINGLE:
      return new QuoteSingle(type, props);

    /* istanbul ignore next */

    default:
      return null;
    // should never happen
  }
}
/**
 * @param {boolean} atLineStart - Node starts at beginning of line
 * @param {boolean} inFlow - true if currently in a flow context
 * @param {boolean} inCollection - true if currently in a collection context
 * @param {number} indent - Current level of indentation
 * @param {number} lineStart - Start of the current line
 * @param {Node} parent - The parent of the node
 * @param {string} src - Source of the YAML document
 */


class ParseContext {
  static parseType(src, offset, inFlow) {
    switch (src[offset]) {
      case '*':
        return PlainValue.Type.ALIAS;

      case '>':
        return PlainValue.Type.BLOCK_FOLDED;

      case '|':
        return PlainValue.Type.BLOCK_LITERAL;

      case '{':
        return PlainValue.Type.FLOW_MAP;

      case '[':
        return PlainValue.Type.FLOW_SEQ;

      case '?':
        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;

      case ':':
        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;

      case '-':
        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;

      case '"':
        return PlainValue.Type.QUOTE_DOUBLE;

      case "'":
        return PlainValue.Type.QUOTE_SINGLE;

      default:
        return PlainValue.Type.PLAIN;
    }
  }

  constructor(orig = {}, {
    atLineStart,
    inCollection,
    inFlow,
    indent,
    lineStart,
    parent
  } = {}) {
    PlainValue._defineProperty(this, "parseNode", (overlay, start) => {
      if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;
      const context = new ParseContext(this, overlay);
      const {
        props,
        type,
        valueStart
      } = context.parseProps(start);
      const node = createNewNode(type, props);
      let offset = node.parse(context, valueStart);
      node.range = new PlainValue.Range(start, offset);
      /* istanbul ignore if */

      if (offset <= start) {
        // This should never happen, but if it does, let's make sure to at least
        // step one character forward to avoid a busy loop.
        node.error = new Error(`Node#parse consumed no characters`);
        node.error.parseEnd = offset;
        node.error.source = node;
        node.range.end = start + 1;
      }

      if (context.nodeStartsCollection(node)) {
        if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {
          node.error = new PlainValue.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');
        }

        const collection = new Collection(node);
        offset = collection.parse(new ParseContext(context), offset);
        collection.range = new PlainValue.Range(start, offset);
        return collection;
      }

      return node;
    });

    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;
    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;
    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;
    this.indent = indent != null ? indent : orig.indent;
    this.lineStart = lineStart != null ? lineStart : orig.lineStart;
    this.parent = parent != null ? parent : orig.parent || {};
    this.root = orig.root;
    this.src = orig.src;
  }

  nodeStartsCollection(node) {
    const {
      inCollection,
      inFlow,
      src
    } = this;
    if (inCollection || inFlow) return false;
    if (node instanceof CollectionItem) return true; // check for implicit key

    let offset = node.range.end;
    if (src[offset] === '\n' || src[offset - 1] === '\n') return false;
    offset = PlainValue.Node.endOfWhiteSpace(src, offset);
    return src[offset] === ':';
  } // Anchor and tag are before type, which determines the node implementation
  // class; hence this intermediate step.


  parseProps(offset) {
    const {
      inFlow,
      parent,
      src
    } = this;
    const props = [];
    let lineHasProps = false;
    offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);
    let ch = src[offset];

    while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === '\n') {
      if (ch === '\n') {
        let inEnd = offset;
        let lineStart;

        do {
          lineStart = inEnd + 1;
          inEnd = PlainValue.Node.endOfIndent(src, lineStart);
        } while (src[inEnd] === '\n');

        const indentDiff = inEnd - (lineStart + this.indent);
        const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;
        if (src[inEnd] !== '#' && !PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;
        this.atLineStart = true;
        this.lineStart = lineStart;
        lineHasProps = false;
        offset = inEnd;
      } else if (ch === PlainValue.Char.COMMENT) {
        const end = PlainValue.Node.endOfLine(src, offset + 1);
        props.push(new PlainValue.Range(offset, end));
        offset = end;
      } else {
        let end = PlainValue.Node.endOfIdentifier(src, offset + 1);

        if (ch === PlainValue.Char.TAG && src[end] === ',' && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(src.slice(offset + 1, end + 13))) {
          // Let's presume we're dealing with a YAML 1.0 domain tag here, rather
          // than an empty but 'foo.bar' private-tagged node in a flow collection
          // followed without whitespace by a plain string starting with a year
          // or date divided by something.
          end = PlainValue.Node.endOfIdentifier(src, end + 5);
        }

        props.push(new PlainValue.Range(offset, end));
        lineHasProps = true;
        offset = PlainValue.Node.endOfWhiteSpace(src, end);
      }

      ch = src[offset];
    } // '- &a : b' has an anchor on an empty node


    if (lineHasProps && ch === ':' && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;
    const type = ParseContext.parseType(src, offset, inFlow);
    return {
      props,
      type,
      valueStart: offset
    };
  }
  /**
   * Parses a node from the source
   * @param {ParseContext} overlay
   * @param {number} start - Index of first non-whitespace character for the node
   * @returns {?Node} - null if at a document boundary
   */


}

// Published as 'yaml/parse-cst'
function parse(src) {
  const cr = [];

  if (src.indexOf('\r') !== -1) {
    src = src.replace(/\r\n?/g, (match, offset) => {
      if (match.length > 1) cr.push(offset);
      return '\n';
    });
  }

  const documents = [];
  let offset = 0;

  do {
    const doc = new Document();
    const context = new ParseContext({
      src
    });
    offset = doc.parse(context, offset);
    documents.push(doc);
  } while (offset < src.length);

  documents.setOrigRanges = () => {
    if (cr.length === 0) return false;

    for (let i = 1; i < cr.length; ++i) cr[i] -= i;

    let crOffset = 0;

    for (let i = 0; i < documents.length; ++i) {
      crOffset = documents[i].setOrigRanges(cr, crOffset);
    }

    cr.splice(0, cr.length);
    return true;
  };

  documents.toString = () => documents.join('...\n');

  return documents;
}

exports.parse = parse;


/***/ }),

/***/ 39914:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var PlainValue = __nccwpck_require__(24941);

function addCommentBefore(str, indent, comment) {
  if (!comment) return str;
  const cc = comment.replace(/[\s\S]^/gm, `$&${indent}#`);
  return `#${cc}\n${indent}${str}`;
}
function addComment(str, indent, comment) {
  return !comment ? str : comment.indexOf('\n') === -1 ? `${str} #${comment}` : `${str}\n` + comment.replace(/^/gm, `${indent || ''}#`);
}

class Node {}

function toJSON(value, arg, ctx) {
  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));

  if (value && typeof value.toJSON === 'function') {
    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);
    if (anchor) ctx.onCreate = res => {
      anchor.res = res;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (anchor && ctx.onCreate) ctx.onCreate(res);
    return res;
  }

  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);
  return value;
}

class Scalar extends Node {
  constructor(value) {
    super();
    this.value = value;
  }

  toJSON(arg, ctx) {
    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);
  }

  toString() {
    return String(this.value);
  }

}

function collectionFromPath(schema, path, value) {
  let v = value;

  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];

    if (Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      const o = {};
      Object.defineProperty(o, k, {
        value: v,
        writable: true,
        enumerable: true,
        configurable: true
      });
      v = o;
    }
  }

  return schema.createNode(v, false);
} // null, undefined, or an empty non-string iterable (e.g. [])


const isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;
class Collection extends Node {
  constructor(schema) {
    super();

    PlainValue._defineProperty(this, "items", []);

    this.schema = schema;
  }

  addIn(path, value) {
    if (isEmptyPath(path)) this.add(value);else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }

  deleteIn([key, ...rest]) {
    if (rest.length === 0) return this.delete(key);
    const node = this.get(key, true);
    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }

  getIn([key, ...rest], keepScalar) {
    const node = this.get(key, true);
    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;
  }

  hasAllNullValues() {
    return this.items.every(node => {
      if (!node || node.type !== 'PAIR') return false;
      const n = node.value;
      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }

  hasIn([key, ...rest]) {
    if (rest.length === 0) return this.has(key);
    const node = this.get(key, true);
    return node instanceof Collection ? node.hasIn(rest) : false;
  }

  setIn([key, ...rest], value) {
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  } // overridden in implementations

  /* istanbul ignore next */


  toJSON() {
    return null;
  }

  toString(ctx, {
    blockItem,
    flowChars,
    isMap,
    itemIndent
  }, onComment, onChompKeep) {
    const {
      indent,
      indentStep,
      stringify
    } = ctx;
    const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;
    if (inFlow) itemIndent += indentStep;
    const allNullValues = isMap && this.hasAllNullValues();
    ctx = Object.assign({}, ctx, {
      allNullValues,
      indent: itemIndent,
      inFlow,
      type: null
    });
    let chompKeep = false;
    let hasItemWithNewLine = false;
    const nodes = this.items.reduce((nodes, item, i) => {
      let comment;

      if (item) {
        if (!chompKeep && item.spaceBefore) nodes.push({
          type: 'comment',
          str: ''
        });
        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {
          nodes.push({
            type: 'comment',
            str: `#${line}`
          });
        });
        if (item.comment) comment = item.comment;
        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;
      }

      chompKeep = false;
      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);
      if (inFlow && !hasItemWithNewLine && str.includes('\n')) hasItemWithNewLine = true;
      if (inFlow && i < this.items.length - 1) str += ',';
      str = addComment(str, itemIndent, comment);
      if (chompKeep && (comment || inFlow)) chompKeep = false;
      nodes.push({
        type: 'item',
        str
      });
      return nodes;
    }, []);
    let str;

    if (nodes.length === 0) {
      str = flowChars.start + flowChars.end;
    } else if (inFlow) {
      const {
        start,
        end
      } = flowChars;
      const strings = nodes.map(n => n.str);

      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {
        str = start;

        for (const s of strings) {
          str += s ? `\n${indentStep}${indent}${s}` : '\n';
        }

        str += `\n${indent}${end}`;
      } else {
        str = `${start} ${strings.join(' ')} ${end}`;
      }
    } else {
      const strings = nodes.map(blockItem);
      str = strings.shift();

      for (const s of strings) str += s ? `\n${indent}${s}` : '\n';
    }

    if (this.comment) {
      str += '\n' + this.comment.replace(/^/gm, `${indent}#`);
      if (onComment) onComment();
    } else if (chompKeep && onChompKeep) onChompKeep();

    return str;
  }

}

PlainValue._defineProperty(Collection, "maxFlowStringSingleLineLength", 60);

function asItemIndex(key) {
  let idx = key instanceof Scalar ? key.value : key;
  if (idx && typeof idx === 'string') idx = Number(idx);
  return Number.isInteger(idx) && idx >= 0 ? idx : null;
}

class YAMLSeq extends Collection {
  add(value) {
    this.items.push(value);
  }

  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }

  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') return undefined;
    const it = this.items[idx];
    return !keepScalar && it instanceof Scalar ? it.value : it;
  }

  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === 'number' && idx < this.items.length;
  }

  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);
    this.items[idx] = value;
  }

  toJSON(_, ctx) {
    const seq = [];
    if (ctx && ctx.onCreate) ctx.onCreate(seq);
    let i = 0;

    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));

    return seq;
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx) return JSON.stringify(this);
    return super.toString(ctx, {
      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,
      flowChars: {
        start: '[',
        end: ']'
      },
      isMap: false,
      itemIndent: (ctx.indent || '') + '  '
    }, onComment, onChompKeep);
  }

}

const stringifyKey = (key, jsKey, ctx) => {
  if (jsKey === null) return '';
  if (typeof jsKey !== 'object') return String(jsKey);
  if (key instanceof Node && ctx && ctx.doc) return key.toString({
    anchors: Object.create(null),
    doc: ctx.doc,
    indent: '',
    indentStep: ctx.indentStep,
    inFlow: true,
    inStringifyKey: true,
    stringify: ctx.stringify
  });
  return JSON.stringify(jsKey);
};

class Pair extends Node {
  constructor(key, value = null) {
    super();
    this.key = key;
    this.value = value;
    this.type = Pair.Type.PAIR;
  }

  get commentBefore() {
    return this.key instanceof Node ? this.key.commentBefore : undefined;
  }

  set commentBefore(cb) {
    if (this.key == null) this.key = new Scalar(null);
    if (this.key instanceof Node) this.key.commentBefore = cb;else {
      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';
      throw new Error(msg);
    }
  }

  addToJSMap(ctx, map) {
    const key = toJSON(this.key, '', ctx);

    if (map instanceof Map) {
      const value = toJSON(this.value, key, ctx);
      map.set(key, value);
    } else if (map instanceof Set) {
      map.add(key);
    } else {
      const stringKey = stringifyKey(this.key, key, ctx);
      const value = toJSON(this.value, stringKey, ctx);
      if (stringKey in map) Object.defineProperty(map, stringKey, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });else map[stringKey] = value;
    }

    return map;
  }

  toJSON(_, ctx) {
    const pair = ctx && ctx.mapAsMap ? new Map() : {};
    return this.addToJSMap(ctx, pair);
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx || !ctx.doc) return JSON.stringify(this);
    const {
      indent: indentSize,
      indentSeq,
      simpleKeys
    } = ctx.doc.options;
    let {
      key,
      value
    } = this;
    let keyComment = key instanceof Node && key.comment;

    if (simpleKeys) {
      if (keyComment) {
        throw new Error('With simple keys, key nodes cannot have comments');
      }

      if (key instanceof Collection) {
        const msg = 'With simple keys, collection cannot be used as a key value';
        throw new Error(msg);
      }
    }

    let explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL : typeof key === 'object'));
    const {
      doc,
      indent,
      indentStep,
      stringify
    } = ctx;
    ctx = Object.assign({}, ctx, {
      implicitKey: !explicitKey,
      indent: indent + indentStep
    });
    let chompKeep = false;
    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);
    str = addComment(str, ctx.indent, keyComment);

    if (!explicitKey && str.length > 1024) {
      if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
      explicitKey = true;
    }

    if (ctx.allNullValues && !simpleKeys) {
      if (this.comment) {
        str = addComment(str, ctx.indent, this.comment);
        if (onComment) onComment();
      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();

      return ctx.inFlow && !explicitKey ? str : `? ${str}`;
    }

    str = explicitKey ? `? ${str}\n${indent}:` : `${str}:`;

    if (this.comment) {
      // expected (but not strictly required) to be a single-line comment
      str = addComment(str, ctx.indent, this.comment);
      if (onComment) onComment();
    }

    let vcb = '';
    let valueComment = null;

    if (value instanceof Node) {
      if (value.spaceBefore) vcb = '\n';

      if (value.commentBefore) {
        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);
        vcb += `\n${cs}`;
      }

      valueComment = value.comment;
    } else if (value && typeof value === 'object') {
      value = doc.schema.createNode(value, true);
    }

    ctx.implicitKey = false;
    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;
    chompKeep = false;

    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {
      // If indentSeq === false, consider '- ' as part of indentation where possible
      ctx.indent = ctx.indent.substr(2);
    }

    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);
    let ws = ' ';

    if (vcb || this.comment) {
      ws = `${vcb}\n${ctx.indent}`;
    } else if (!explicitKey && value instanceof Collection) {
      const flow = valueStr[0] === '[' || valueStr[0] === '{';
      if (!flow || valueStr.includes('\n')) ws = `\n${ctx.indent}`;
    } else if (valueStr[0] === '\n') ws = '';

    if (chompKeep && !valueComment && onChompKeep) onChompKeep();
    return addComment(str + ws + valueStr, ctx.indent, valueComment);
  }

}

PlainValue._defineProperty(Pair, "Type", {
  PAIR: 'PAIR',
  MERGE_PAIR: 'MERGE_PAIR'
});

const getAliasCount = (node, anchors) => {
  if (node instanceof Alias) {
    const anchor = anchors.get(node.source);
    return anchor.count * anchor.aliasCount;
  } else if (node instanceof Collection) {
    let count = 0;

    for (const item of node.items) {
      const c = getAliasCount(item, anchors);
      if (c > count) count = c;
    }

    return count;
  } else if (node instanceof Pair) {
    const kc = getAliasCount(node.key, anchors);
    const vc = getAliasCount(node.value, anchors);
    return Math.max(kc, vc);
  }

  return 1;
};

class Alias extends Node {
  static stringify({
    range,
    source
  }, {
    anchors,
    doc,
    implicitKey,
    inStringifyKey
  }) {
    let anchor = Object.keys(anchors).find(a => anchors[a] === source);
    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();
    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;
    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';
    throw new Error(`${msg} [${range}]`);
  }

  constructor(source) {
    super();
    this.source = source;
    this.type = PlainValue.Type.ALIAS;
  }

  set tag(t) {
    throw new Error('Alias nodes cannot have tags');
  }

  toJSON(arg, ctx) {
    if (!ctx) return toJSON(this.source, arg, ctx);
    const {
      anchors,
      maxAliasCount
    } = ctx;
    const anchor = anchors.get(this.source);
    /* istanbul ignore if */

    if (!anchor || anchor.res === undefined) {
      const msg = 'This should not happen: Alias anchor was not resolved?';
      if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);
    }

    if (maxAliasCount >= 0) {
      anchor.count += 1;
      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);

      if (anchor.count * anchor.aliasCount > maxAliasCount) {
        const msg = 'Excessive alias count indicates a resource exhaustion attack';
        if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);
      }
    }

    return anchor.res;
  } // Only called when stringifying an alias mapping key while constructing
  // Object output.


  toString(ctx) {
    return Alias.stringify(this, ctx);
  }

}

PlainValue._defineProperty(Alias, "default", true);

function findPair(items, key) {
  const k = key instanceof Scalar ? key.value : key;

  for (const it of items) {
    if (it instanceof Pair) {
      if (it.key === key || it.key === k) return it;
      if (it.key && it.key.value === k) return it;
    }
  }

  return undefined;
}
class YAMLMap extends Collection {
  add(pair, overwrite) {
    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);
    const prev = findPair(this.items, pair.key);
    const sortEntries = this.schema && this.schema.sortMapEntries;

    if (prev) {
      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);
    } else if (sortEntries) {
      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);
      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);
    } else {
      this.items.push(pair);
    }
  }

  delete(key) {
    const it = findPair(this.items, key);
    if (!it) return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }

  get(key, keepScalar) {
    const it = findPair(this.items, key);
    const node = it && it.value;
    return !keepScalar && node instanceof Scalar ? node.value : node;
  }

  has(key) {
    return !!findPair(this.items, key);
  }

  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param {*} arg ignored
   * @param {*} ctx Conversion context, originally set in Document#toJSON()
   * @param {Class} Type If set, forces the returned collection type
   * @returns {*} Instance of Type, Map, or Object
   */


  toJSON(_, ctx, Type) {
    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};
    if (ctx && ctx.onCreate) ctx.onCreate(map);

    for (const item of this.items) item.addToJSMap(ctx, map);

    return map;
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx) return JSON.stringify(this);

    for (const item of this.items) {
      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }

    return super.toString(ctx, {
      blockItem: n => n.str,
      flowChars: {
        start: '{',
        end: '}'
      },
      isMap: true,
      itemIndent: ctx.indent || ''
    }, onComment, onChompKeep);
  }

}

const MERGE_KEY = '<<';
class Merge extends Pair {
  constructor(pair) {
    if (pair instanceof Pair) {
      let seq = pair.value;

      if (!(seq instanceof YAMLSeq)) {
        seq = new YAMLSeq();
        seq.items.push(pair.value);
        seq.range = pair.value.range;
      }

      super(pair.key, seq);
      this.range = pair.range;
    } else {
      super(new Scalar(MERGE_KEY), new YAMLSeq());
    }

    this.type = Pair.Type.MERGE_PAIR;
  } // If the value associated with a merge key is a single mapping node, each of
  // its key/value pairs is inserted into the current mapping, unless the key
  // already exists in it. If the value associated with the merge key is a
  // sequence, then this sequence is expected to contain mapping nodes and each
  // of these nodes is merged in turn according to its order in the sequence.
  // Keys in mapping nodes earlier in the sequence override keys specified in
  // later mapping nodes. -- http://yaml.org/type/merge.html


  addToJSMap(ctx, map) {
    for (const {
      source
    } of this.value.items) {
      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');
      const srcMap = source.toJSON(null, ctx, Map);

      for (const [key, value] of srcMap) {
        if (map instanceof Map) {
          if (!map.has(key)) map.set(key, value);
        } else if (map instanceof Set) {
          map.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
          Object.defineProperty(map, key, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    }

    return map;
  }

  toString(ctx, onComment) {
    const seq = this.value;
    if (seq.items.length > 1) return super.toString(ctx, onComment);
    this.value = seq.items[0];
    const str = super.toString(ctx, onComment);
    this.value = seq;
    return str;
  }

}

const binaryOptions = {
  defaultType: PlainValue.Type.BLOCK_LITERAL,
  lineWidth: 76
};
const boolOptions = {
  trueStr: 'true',
  falseStr: 'false'
};
const intOptions = {
  asBigInt: false
};
const nullOptions = {
  nullStr: 'null'
};
const strOptions = {
  defaultType: PlainValue.Type.PLAIN,
  doubleQuoted: {
    jsonEncoding: false,
    minMultiLineLength: 40
  },
  fold: {
    lineWidth: 80,
    minContentWidth: 20
  }
};

function resolveScalar(str, tags, scalarFallback) {
  for (const {
    format,
    test,
    resolve
  } of tags) {
    if (test) {
      const match = str.match(test);

      if (match) {
        let res = resolve.apply(null, match);
        if (!(res instanceof Scalar)) res = new Scalar(res);
        if (format) res.format = format;
        return res;
      }
    }
  }

  if (scalarFallback) str = scalarFallback(str);
  return new Scalar(str);
}

const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line
// returns index of last newline in more-indented block

const consumeMoreIndentedLines = (text, i) => {
  let ch = text[i + 1];

  while (ch === ' ' || ch === '\t') {
    do {
      ch = text[i += 1];
    } while (ch && ch !== '\n');

    ch = text[i + 1];
  }

  return i;
};
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 *
 * @param {string} text
 * @param {string} indent
 * @param {string} [mode='flow'] `'block'` prevents more-indented lines
 *   from being folded; `'quoted'` allows for `\` escapes, including escaped
 *   newlines
 * @param {Object} options
 * @param {number} [options.indentAtStart] Accounts for leading contents on
 *   the first line, defaulting to `indent.length`
 * @param {number} [options.lineWidth=80]
 * @param {number} [options.minContentWidth=20] Allow highly indented lines to
 *   stretch the line width or indent content from the start
 * @param {function} options.onFold Called once if the text is folded
 * @param {function} options.onFold Called once if any line of text exceeds
 *   lineWidth characters
 */


function foldFlowLines(text, indent, mode, {
  indentAtStart,
  lineWidth = 80,
  minContentWidth = 20,
  onFold,
  onOverflow
}) {
  if (!lineWidth || lineWidth < 0) return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep) return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;

  if (typeof indentAtStart === 'number') {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);else end = lineWidth - indentAtStart;
  }

  let split = undefined;
  let prev = undefined;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;

  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1) end = i + endStep;
  }

  for (let ch; ch = text[i += 1];) {
    if (mode === FOLD_QUOTED && ch === '\\') {
      escStart = i;

      switch (text[i + 1]) {
        case 'x':
          i += 3;
          break;

        case 'u':
          i += 5;
          break;

        case 'U':
          i += 9;
          break;

        default:
          i += 1;
      }

      escEnd = i;
    }

    if (ch === '\n') {
      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);
      end = i + endStep;
      split = undefined;
    } else {
      if (ch === ' ' && prev && prev !== ' ' && prev !== '\n' && prev !== '\t') {
        // space surrounded by non-space can be replaced with newline + indent
        const next = text[i + 1];
        if (next && next !== ' ' && next !== '\n' && next !== '\t') split = i;
      }

      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = undefined;
        } else if (mode === FOLD_QUOTED) {
          // white-space collected at end may stretch past lineWidth
          while (prev === ' ' || prev === '\t') {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          } // Account for newline escape, but don't break preceding escape


          const j = i > escEnd + 1 ? i - 2 : escStart - 1; // Bail out if lineWidth & minContentWidth are shorter than an escape string

          if (escapedFolds[j]) return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = undefined;
        } else {
          overflow = true;
        }
      }
    }

    prev = ch;
  }

  if (overflow && onOverflow) onOverflow();
  if (folds.length === 0) return text;
  if (onFold) onFold();
  let res = text.slice(0, folds[0]);

  for (let i = 0; i < folds.length; ++i) {
    const fold = folds[i];
    const end = folds[i + 1] || text.length;
    if (fold === 0) res = `\n${indent}${text.slice(0, end)}`;else {
      if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
      res += `\n${indent}${text.slice(fold + 1, end)}`;
    }
  }

  return res;
}

const getFoldOptions = ({
  indentAtStart
}) => indentAtStart ? Object.assign({
  indentAtStart
}, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.


const containsDocumentMarker = str => /^(%|---|\.\.\.)/m.test(str);

function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0) return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit) return false;

  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === '\n') {
      if (i - start > limit) return true;
      start = i + 1;
      if (strLen - start <= limit) return false;
    }
  }

  return true;
}

function doubleQuotedString(value, ctx) {
  const {
    implicitKey
  } = ctx;
  const {
    jsonEncoding,
    minMultiLineLength
  } = strOptions.doubleQuoted;
  const json = JSON.stringify(value);
  if (jsonEncoding) return json;
  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
  let str = '';
  let start = 0;

  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
      // space before newline needs to be escaped to not be folded
      str += json.slice(start, i) + '\\ ';
      i += 1;
      start = i;
      ch = '\\';
    }

    if (ch === '\\') switch (json[i + 1]) {
      case 'u':
        {
          str += json.slice(start, i);
          const code = json.substr(i + 2, 4);

          switch (code) {
            case '0000':
              str += '\\0';
              break;

            case '0007':
              str += '\\a';
              break;

            case '000b':
              str += '\\v';
              break;

            case '001b':
              str += '\\e';
              break;

            case '0085':
              str += '\\N';
              break;

            case '00a0':
              str += '\\_';
              break;

            case '2028':
              str += '\\L';
              break;

            case '2029':
              str += '\\P';
              break;

            default:
              if (code.substr(0, 2) === '00') str += '\\x' + code.substr(2);else str += json.substr(i, 6);
          }

          i += 5;
          start = i + 1;
        }
        break;

      case 'n':
        if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
          i += 1;
        } else {
          // folding will eat first newline
          str += json.slice(start, i) + '\n\n';

          while (json[i + 2] === '\\' && json[i + 3] === 'n' && json[i + 4] !== '"') {
            str += '\n';
            i += 2;
          }

          str += indent; // space after newline needs to be escaped to not be folded

          if (json[i + 2] === ' ') str += '\\';
          i += 1;
          start = i + 1;
        }

        break;

      default:
        i += 1;
    }
  }

  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
}

function singleQuotedString(value, ctx) {
  if (ctx.implicitKey) {
    if (/\n/.test(value)) return doubleQuotedString(value, ctx);
  } else {
    // single quoted string can't have leading or trailing whitespace around newline
    if (/[ \t]\n|\n[ \t]/.test(value)) return doubleQuotedString(value, ctx);
  }

  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
}

function blockString({
  comment,
  type,
  value
}, ctx, onComment, onChompKeep) {
  // 1. Block can't end in whitespace unless the last line is non-empty.
  // 2. Strings consisting of only whitespace are best rendered explicitly.
  if (/\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return doubleQuotedString(value, ctx);
  }

  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
  const indentSize = indent ? '2' : '1'; // root is at -1

  const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);
  let header = literal ? '|' : '>';
  if (!value) return header + '\n';
  let wsStart = '';
  let wsEnd = '';
  value = value.replace(/[\n\t ]*$/, ws => {
    const n = ws.indexOf('\n');

    if (n === -1) {
      header += '-'; // strip
    } else if (value === ws || n !== ws.length - 1) {
      header += '+'; // keep

      if (onChompKeep) onChompKeep();
    }

    wsEnd = ws.replace(/\n$/, '');
    return '';
  }).replace(/^[\n ]*/, ws => {
    if (ws.indexOf(' ') !== -1) header += indentSize;
    const m = ws.match(/ +$/);

    if (m) {
      wsStart = ws.slice(0, -m[0].length);
      return m[0];
    } else {
      wsStart = ws;
      return '';
    }
  });
  if (wsEnd) wsEnd = wsEnd.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  if (wsStart) wsStart = wsStart.replace(/\n+/g, `$&${indent}`);

  if (comment) {
    header += ' #' + comment.replace(/ ?[\r\n]+/g, ' ');
    if (onComment) onComment();
  }

  if (!value) return `${header}${indentSize}\n${indent}${wsEnd}`;

  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}\n${indent}${wsStart}${value}${wsEnd}`;
  }

  value = value.replace(/\n+/g, '\n$&').replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent
  .replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);
  return `${header}\n${indent}${body}`;
}

function plainString(item, ctx, onComment, onChompKeep) {
  const {
    comment,
    type,
    value
  } = item;
  const {
    actualString,
    implicitKey,
    indent,
    inFlow
  } = ctx;

  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return doubleQuotedString(value, ctx);
  }

  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    // not allowed:
    // - empty string, '-' or '?'
    // - start with an indicator character (except [?:-]) or /[?-] /
    // - '\n ', ': ' or ' \n' anywhere
    // - '#' not preceded by a non-space char
    // - end with ' ' or ':'
    return implicitKey || inFlow || value.indexOf('\n') === -1 ? value.indexOf('"') !== -1 && value.indexOf("'") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }

  if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\n') !== -1) {
    // Where allowed & type not set explicitly, prefer block style for multiline strings
    return blockString(item, ctx, onComment, onChompKeep);
  }

  if (indent === '' && containsDocumentMarker(value)) {
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
  }

  const str = value.replace(/\n+/g, `$&\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and
  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
  // and others in v1.1.

  if (actualString) {
    const {
      tags
    } = ctx.doc.schema;
    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;
    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);
  }

  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));

  if (comment && !inFlow && (body.indexOf('\n') !== -1 || comment.indexOf('\n') !== -1)) {
    if (onComment) onComment();
    return addCommentBefore(body, indent, comment);
  }

  return body;
}

function stringifyString(item, ctx, onComment, onChompKeep) {
  const {
    defaultType
  } = strOptions;
  const {
    implicitKey,
    inFlow
  } = ctx;
  let {
    type,
    value
  } = item;

  if (typeof value !== 'string') {
    value = String(value);
    item = Object.assign({}, item, {
      value
    });
  }

  const _stringify = _type => {
    switch (_type) {
      case PlainValue.Type.BLOCK_FOLDED:
      case PlainValue.Type.BLOCK_LITERAL:
        return blockString(item, ctx, onComment, onChompKeep);

      case PlainValue.Type.QUOTE_DOUBLE:
        return doubleQuotedString(value, ctx);

      case PlainValue.Type.QUOTE_SINGLE:
        return singleQuotedString(value, ctx);

      case PlainValue.Type.PLAIN:
        return plainString(item, ctx, onComment, onChompKeep);

      default:
        return null;
    }
  };

  if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(value)) {
    // force double quotes on control characters
    type = PlainValue.Type.QUOTE_DOUBLE;
  } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {
    // should not happen; blocks are not valid inside flow containers
    type = PlainValue.Type.QUOTE_DOUBLE;
  }

  let res = _stringify(type);

  if (res === null) {
    res = _stringify(defaultType);
    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);
  }

  return res;
}

function stringifyNumber({
  format,
  minFractionDigits,
  tag,
  value
}) {
  if (typeof value === 'bigint') return String(value);
  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';
  let n = JSON.stringify(value);

  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\d/.test(n)) {
    let i = n.indexOf('.');

    if (i < 0) {
      i = n.length;
      n += '.';
    }

    let d = minFractionDigits - (n.length - i - 1);

    while (d-- > 0) n += '0';
  }

  return n;
}

function checkFlowCollectionEnd(errors, cst) {
  let char, name;

  switch (cst.type) {
    case PlainValue.Type.FLOW_MAP:
      char = '}';
      name = 'flow map';
      break;

    case PlainValue.Type.FLOW_SEQ:
      char = ']';
      name = 'flow sequence';
      break;

    default:
      errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));
      return;
  }

  let lastItem;

  for (let i = cst.items.length - 1; i >= 0; --i) {
    const item = cst.items[i];

    if (!item || item.type !== PlainValue.Type.COMMENT) {
      lastItem = item;
      break;
    }
  }

  if (lastItem && lastItem.char !== char) {
    const msg = `Expected ${name} to end with ${char}`;
    let err;

    if (typeof lastItem.offset === 'number') {
      err = new PlainValue.YAMLSemanticError(cst, msg);
      err.offset = lastItem.offset + 1;
    } else {
      err = new PlainValue.YAMLSemanticError(lastItem, msg);
      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;
    }

    errors.push(err);
  }
}
function checkFlowCommentSpace(errors, comment) {
  const prev = comment.context.src[comment.range.start - 1];

  if (prev !== '\n' && prev !== '\t' && prev !== ' ') {
    const msg = 'Comments must be separated from other tokens by white space characters';
    errors.push(new PlainValue.YAMLSemanticError(comment, msg));
  }
}
function getLongKeyError(source, key) {
  const sk = String(key);
  const k = sk.substr(0, 8) + '...' + sk.substr(-8);
  return new PlainValue.YAMLSemanticError(source, `The "${k}" key is too long`);
}
function resolveComments(collection, comments) {
  for (const {
    afterKey,
    before,
    comment
  } of comments) {
    let item = collection.items[before];

    if (!item) {
      if (comment !== undefined) {
        if (collection.comment) collection.comment += '\n' + comment;else collection.comment = comment;
      }
    } else {
      if (afterKey && item.value) item = item.value;

      if (comment === undefined) {
        if (afterKey || !item.commentBefore) item.spaceBefore = true;
      } else {
        if (item.commentBefore) item.commentBefore += '\n' + comment;else item.commentBefore = comment;
      }
    }
  }
}

// on error, will return { str: string, errors: Error[] }
function resolveString(doc, node) {
  const res = node.strValue;
  if (!res) return '';
  if (typeof res === 'string') return res;
  res.errors.forEach(error => {
    if (!error.source) error.source = node;
    doc.errors.push(error);
  });
  return res.str;
}

function resolveTagHandle(doc, node) {
  const {
    handle,
    suffix
  } = node.tag;
  let prefix = doc.tagPrefixes.find(p => p.handle === handle);

  if (!prefix) {
    const dtp = doc.getDefaults().tagPrefixes;
    if (dtp) prefix = dtp.find(p => p.handle === handle);
    if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);
  }

  if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);

  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {
    if (suffix[0] === '^') {
      doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));
      return suffix;
    }

    if (/[:/]/.test(suffix)) {
      // word/foo -> tag:word.yaml.org,2002:foo
      const vocab = suffix.match(/^([a-z0-9-]+)\/(.*)/i);
      return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;
    }
  }

  return prefix.prefix + decodeURIComponent(suffix);
}

function resolveTagName(doc, node) {
  const {
    tag,
    type
  } = node;
  let nonSpecific = false;

  if (tag) {
    const {
      handle,
      suffix,
      verbatim
    } = tag;

    if (verbatim) {
      if (verbatim !== '!' && verbatim !== '!!') return verbatim;
      const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;
      doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
    } else if (handle === '!' && !suffix) {
      nonSpecific = true;
    } else {
      try {
        return resolveTagHandle(doc, node);
      } catch (error) {
        doc.errors.push(error);
      }
    }
  }

  switch (type) {
    case PlainValue.Type.BLOCK_FOLDED:
    case PlainValue.Type.BLOCK_LITERAL:
    case PlainValue.Type.QUOTE_DOUBLE:
    case PlainValue.Type.QUOTE_SINGLE:
      return PlainValue.defaultTags.STR;

    case PlainValue.Type.FLOW_MAP:
    case PlainValue.Type.MAP:
      return PlainValue.defaultTags.MAP;

    case PlainValue.Type.FLOW_SEQ:
    case PlainValue.Type.SEQ:
      return PlainValue.defaultTags.SEQ;

    case PlainValue.Type.PLAIN:
      return nonSpecific ? PlainValue.defaultTags.STR : null;

    default:
      return null;
  }
}

function resolveByTagName(doc, node, tagName) {
  const {
    tags
  } = doc.schema;
  const matchWithTest = [];

  for (const tag of tags) {
    if (tag.tag === tagName) {
      if (tag.test) matchWithTest.push(tag);else {
        const res = tag.resolve(doc, node);
        return res instanceof Collection ? res : new Scalar(res);
      }
    }
  }

  const str = resolveString(doc, node);
  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);
  return null;
}

function getFallbackTagName({
  type
}) {
  switch (type) {
    case PlainValue.Type.FLOW_MAP:
    case PlainValue.Type.MAP:
      return PlainValue.defaultTags.MAP;

    case PlainValue.Type.FLOW_SEQ:
    case PlainValue.Type.SEQ:
      return PlainValue.defaultTags.SEQ;

    default:
      return PlainValue.defaultTags.STR;
  }
}

function resolveTag(doc, node, tagName) {
  try {
    const res = resolveByTagName(doc, node, tagName);

    if (res) {
      if (tagName && node.tag) res.tag = tagName;
      return res;
    }
  } catch (error) {
    /* istanbul ignore if */
    if (!error.source) error.source = node;
    doc.errors.push(error);
    return null;
  }

  try {
    const fallback = getFallbackTagName(node);
    if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);
    const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;
    doc.warnings.push(new PlainValue.YAMLWarning(node, msg));
    const res = resolveByTagName(doc, node, fallback);
    res.tag = tagName;
    return res;
  } catch (error) {
    const refError = new PlainValue.YAMLReferenceError(node, error.message);
    refError.stack = error.stack;
    doc.errors.push(refError);
    return null;
  }
}

const isCollectionItem = node => {
  if (!node) return false;
  const {
    type
  } = node;
  return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;
};

function resolveNodeProps(errors, node) {
  const comments = {
    before: [],
    after: []
  };
  let hasAnchor = false;
  let hasTag = false;
  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;

  for (const {
    start,
    end
  } of props) {
    switch (node.context.src[start]) {
      case PlainValue.Char.COMMENT:
        {
          if (!node.commentHasRequiredWhitespace(start)) {
            const msg = 'Comments must be separated from other tokens by white space characters';
            errors.push(new PlainValue.YAMLSemanticError(node, msg));
          }

          const {
            header,
            valueRange
          } = node;
          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;
          cc.push(node.context.src.slice(start + 1, end));
          break;
        }
      // Actual anchor & tag resolution is handled by schema, here we just complain

      case PlainValue.Char.ANCHOR:
        if (hasAnchor) {
          const msg = 'A node can have at most one anchor';
          errors.push(new PlainValue.YAMLSemanticError(node, msg));
        }

        hasAnchor = true;
        break;

      case PlainValue.Char.TAG:
        if (hasTag) {
          const msg = 'A node can have at most one tag';
          errors.push(new PlainValue.YAMLSemanticError(node, msg));
        }

        hasTag = true;
        break;
    }
  }

  return {
    comments,
    hasAnchor,
    hasTag
  };
}

function resolveNodeValue(doc, node) {
  const {
    anchors,
    errors,
    schema
  } = doc;

  if (node.type === PlainValue.Type.ALIAS) {
    const name = node.rawValue;
    const src = anchors.getNode(name);

    if (!src) {
      const msg = `Aliased anchor not found: ${name}`;
      errors.push(new PlainValue.YAMLReferenceError(node, msg));
      return null;
    } // Lazy resolution for circular references


    const res = new Alias(src);

    anchors._cstAliases.push(res);

    return res;
  }

  const tagName = resolveTagName(doc, node);
  if (tagName) return resolveTag(doc, node, tagName);

  if (node.type !== PlainValue.Type.PLAIN) {
    const msg = `Failed to resolve ${node.type} node here`;
    errors.push(new PlainValue.YAMLSyntaxError(node, msg));
    return null;
  }

  try {
    const str = resolveString(doc, node);
    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);
  } catch (error) {
    if (!error.source) error.source = node;
    errors.push(error);
    return null;
  }
} // sets node.resolved on success


function resolveNode(doc, node) {
  if (!node) return null;
  if (node.error) doc.errors.push(node.error);
  const {
    comments,
    hasAnchor,
    hasTag
  } = resolveNodeProps(doc.errors, node);

  if (hasAnchor) {
    const {
      anchors
    } = doc;
    const name = node.anchor;
    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor
    // name have already been resolved, so it may safely be renamed.

    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as
    // anchors need to be available during resolution to allow for
    // circular references.

    anchors.map[name] = node;
  }

  if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {
    const msg = 'An alias node must not specify any properties';
    doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));
  }

  const res = resolveNodeValue(doc, node);

  if (res) {
    res.range = [node.range.start, node.range.end];
    if (doc.options.keepCstNodes) res.cstNode = node;
    if (doc.options.keepNodeTypes) res.type = node.type;
    const cb = comments.before.join('\n');

    if (cb) {
      res.commentBefore = res.commentBefore ? `${res.commentBefore}\n${cb}` : cb;
    }

    const ca = comments.after.join('\n');
    if (ca) res.comment = res.comment ? `${res.comment}\n${ca}` : ca;
  }

  return node.resolved = res;
}

function resolveMap(doc, cst) {
  if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {
    const msg = `A ${cst.type} node cannot be resolved as a mapping`;
    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
    return null;
  }

  const {
    comments,
    items
  } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);
  const map = new YAMLMap();
  map.items = items;
  resolveComments(map, comments);
  let hasCollectionKey = false;

  for (let i = 0; i < items.length; ++i) {
    const {
      key: iKey
    } = items[i];
    if (iKey instanceof Collection) hasCollectionKey = true;

    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {
      items[i] = new Merge(items[i]);
      const sources = items[i].value.items;
      let error = null;
      sources.some(node => {
        if (node instanceof Alias) {
          // During parsing, alias sources are CST nodes; to account for
          // circular references their resolved values can't be used here.
          const {
            type
          } = node.source;
          if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;
          return error = 'Merge nodes aliases can only point to maps';
        }

        return error = 'Merge nodes can only have Alias nodes as values';
      });
      if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));
    } else {
      for (let j = i + 1; j < items.length; ++j) {
        const {
          key: jKey
        } = items[j];

        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {
          const msg = `Map keys must be unique; "${iKey}" is repeated`;
          doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));
          break;
        }
      }
    }
  }

  if (hasCollectionKey && !doc.options.mapAsMap) {
    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
  }

  cst.resolved = map;
  return map;
}

const valueHasPairComment = ({
  context: {
    lineStart,
    node,
    src
  },
  props
}) => {
  if (props.length === 0) return false;
  const {
    start
  } = props[0];
  if (node && start > node.valueRange.start) return false;
  if (src[start] !== PlainValue.Char.COMMENT) return false;

  for (let i = lineStart; i < start; ++i) if (src[i] === '\n') return false;

  return true;
};

function resolvePairComment(item, pair) {
  if (!valueHasPairComment(item)) return;
  const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);
  let found = false;
  const cb = pair.value.commentBefore;

  if (cb && cb.startsWith(comment)) {
    pair.value.commentBefore = cb.substr(comment.length + 1);
    found = true;
  } else {
    const cc = pair.value.comment;

    if (!item.node && cc && cc.startsWith(comment)) {
      pair.value.comment = cc.substr(comment.length + 1);
      found = true;
    }
  }

  if (found) pair.comment = comment;
}

function resolveBlockMapItems(doc, cst) {
  const comments = [];
  const items = [];
  let key = undefined;
  let keyStart = null;

  for (let i = 0; i < cst.items.length; ++i) {
    const item = cst.items[i];

    switch (item.type) {
      case PlainValue.Type.BLANK_LINE:
        comments.push({
          afterKey: !!key,
          before: items.length
        });
        break;

      case PlainValue.Type.COMMENT:
        comments.push({
          afterKey: !!key,
          before: items.length,
          comment: item.comment
        });
        break;

      case PlainValue.Type.MAP_KEY:
        if (key !== undefined) items.push(new Pair(key));
        if (item.error) doc.errors.push(item.error);
        key = resolveNode(doc, item.node);
        keyStart = null;
        break;

      case PlainValue.Type.MAP_VALUE:
        {
          if (key === undefined) key = null;
          if (item.error) doc.errors.push(item.error);

          if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {
            const msg = 'Nested mappings are not allowed in compact mappings';
            doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));
          }

          let valueNode = item.node;

          if (!valueNode && item.props.length > 0) {
            // Comments on an empty mapping value need to be preserved, so we
            // need to construct a minimal empty node here to use instead of the
            // missing `item.node`. -- eemeli/yaml#19
            valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);
            valueNode.context = {
              parent: item,
              src: item.context.src
            };
            const pos = item.range.start + 1;
            valueNode.range = {
              start: pos,
              end: pos
            };
            valueNode.valueRange = {
              start: pos,
              end: pos
            };

            if (typeof item.range.origStart === 'number') {
              const origPos = item.range.origStart + 1;
              valueNode.range.origStart = valueNode.range.origEnd = origPos;
              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;
            }
          }

          const pair = new Pair(key, resolveNode(doc, valueNode));
          resolvePairComment(item, pair);
          items.push(pair);

          if (key && typeof keyStart === 'number') {
            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
          }

          key = undefined;
          keyStart = null;
        }
        break;

      default:
        if (key !== undefined) items.push(new Pair(key));
        key = resolveNode(doc, item);
        keyStart = item.range.start;
        if (item.error) doc.errors.push(item.error);

        next: for (let j = i + 1;; ++j) {
          const nextItem = cst.items[j];

          switch (nextItem && nextItem.type) {
            case PlainValue.Type.BLANK_LINE:
            case PlainValue.Type.COMMENT:
              continue next;

            case PlainValue.Type.MAP_VALUE:
              break next;

            default:
              {
                const msg = 'Implicit map keys need to be followed by map values';
                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
                break next;
              }
          }
        }

        if (item.valueRangeContainsNewline) {
          const msg = 'Implicit map keys need to be on a single line';
          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
        }

    }
  }

  if (key !== undefined) items.push(new Pair(key));
  return {
    comments,
    items
  };
}

function resolveFlowMapItems(doc, cst) {
  const comments = [];
  const items = [];
  let key = undefined;
  let explicitKey = false;
  let next = '{';

  for (let i = 0; i < cst.items.length; ++i) {
    const item = cst.items[i];

    if (typeof item.char === 'string') {
      const {
        char,
        offset
      } = item;

      if (char === '?' && key === undefined && !explicitKey) {
        explicitKey = true;
        next = ':';
        continue;
      }

      if (char === ':') {
        if (key === undefined) key = null;

        if (next === ':') {
          next = ',';
          continue;
        }
      } else {
        if (explicitKey) {
          if (key === undefined && char !== ',') key = null;
          explicitKey = false;
        }

        if (key !== undefined) {
          items.push(new Pair(key));
          key = undefined;

          if (char === ',') {
            next = ':';
            continue;
          }
        }
      }

      if (char === '}') {
        if (i === cst.items.length - 1) continue;
      } else if (char === next) {
        next = ':';
        continue;
      }

      const msg = `Flow map contains an unexpected ${char}`;
      const err = new PlainValue.YAMLSyntaxError(cst, msg);
      err.offset = offset;
      doc.errors.push(err);
    } else if (item.type === PlainValue.Type.BLANK_LINE) {
      comments.push({
        afterKey: !!key,
        before: items.length
      });
    } else if (item.type === PlainValue.Type.COMMENT) {
      checkFlowCommentSpace(doc.errors, item);
      comments.push({
        afterKey: !!key,
        before: items.length,
        comment: item.comment
      });
    } else if (key === undefined) {
      if (next === ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));
      key = resolveNode(doc, item);
    } else {
      if (next !== ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));
      items.push(new Pair(key, resolveNode(doc, item)));
      key = undefined;
      explicitKey = false;
    }
  }

  checkFlowCollectionEnd(doc.errors, cst);
  if (key !== undefined) items.push(new Pair(key));
  return {
    comments,
    items
  };
}

function resolveSeq(doc, cst) {
  if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {
    const msg = `A ${cst.type} node cannot be resolved as a sequence`;
    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));
    return null;
  }

  const {
    comments,
    items
  } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);
  const seq = new YAMLSeq();
  seq.items = items;
  resolveComments(seq, comments);

  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection)) {
    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';
    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));
  }

  cst.resolved = seq;
  return seq;
}

function resolveBlockSeqItems(doc, cst) {
  const comments = [];
  const items = [];

  for (let i = 0; i < cst.items.length; ++i) {
    const item = cst.items[i];

    switch (item.type) {
      case PlainValue.Type.BLANK_LINE:
        comments.push({
          before: items.length
        });
        break;

      case PlainValue.Type.COMMENT:
        comments.push({
          comment: item.comment,
          before: items.length
        });
        break;

      case PlainValue.Type.SEQ_ITEM:
        if (item.error) doc.errors.push(item.error);
        items.push(resolveNode(doc, item.node));

        if (item.hasProps) {
          const msg = 'Sequence items cannot have tags or anchors before the - indicator';
          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
        }

        break;

      default:
        if (item.error) doc.errors.push(item.error);
        doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));
    }
  }

  return {
    comments,
    items
  };
}

function resolveFlowSeqItems(doc, cst) {
  const comments = [];
  const items = [];
  let explicitKey = false;
  let key = undefined;
  let keyStart = null;
  let next = '[';
  let prevItem = null;

  for (let i = 0; i < cst.items.length; ++i) {
    const item = cst.items[i];

    if (typeof item.char === 'string') {
      const {
        char,
        offset
      } = item;

      if (char !== ':' && (explicitKey || key !== undefined)) {
        if (explicitKey && key === undefined) key = next ? items.pop() : null;
        items.push(new Pair(key));
        explicitKey = false;
        key = undefined;
        keyStart = null;
      }

      if (char === next) {
        next = null;
      } else if (!next && char === '?') {
        explicitKey = true;
      } else if (next !== '[' && char === ':' && key === undefined) {
        if (next === ',') {
          key = items.pop();

          if (key instanceof Pair) {
            const msg = 'Chaining flow sequence pairs is invalid';
            const err = new PlainValue.YAMLSemanticError(cst, msg);
            err.offset = offset;
            doc.errors.push(err);
          }

          if (!explicitKey && typeof keyStart === 'number') {
            const keyEnd = item.range ? item.range.start : item.offset;
            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));
            const {
              src
            } = prevItem.context;

            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\n') {
              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';
              doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));
              break;
            }
          }
        } else {
          key = null;
        }

        keyStart = null;
        explicitKey = false;
        next = null;
      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {
        const msg = `Flow sequence contains an unexpected ${char}`;
        const err = new PlainValue.YAMLSyntaxError(cst, msg);
        err.offset = offset;
        doc.errors.push(err);
      }
    } else if (item.type === PlainValue.Type.BLANK_LINE) {
      comments.push({
        before: items.length
      });
    } else if (item.type === PlainValue.Type.COMMENT) {
      checkFlowCommentSpace(doc.errors, item);
      comments.push({
        comment: item.comment,
        before: items.length
      });
    } else {
      if (next) {
        const msg = `Expected a ${next} in flow sequence`;
        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));
      }

      const value = resolveNode(doc, item);

      if (key === undefined) {
        items.push(value);
        prevItem = item;
      } else {
        items.push(new Pair(key, value));
        key = undefined;
      }

      keyStart = item.range.start;
      next = ',';
    }
  }

  checkFlowCollectionEnd(doc.errors, cst);
  if (key !== undefined) items.push(new Pair(key));
  return {
    comments,
    items
  };
}

exports.Alias = Alias;
exports.Collection = Collection;
exports.Merge = Merge;
exports.Node = Node;
exports.Pair = Pair;
exports.Scalar = Scalar;
exports.YAMLMap = YAMLMap;
exports.YAMLSeq = YAMLSeq;
exports.addComment = addComment;
exports.binaryOptions = binaryOptions;
exports.boolOptions = boolOptions;
exports.findPair = findPair;
exports.intOptions = intOptions;
exports.isEmptyPath = isEmptyPath;
exports.nullOptions = nullOptions;
exports.resolveMap = resolveMap;
exports.resolveNode = resolveNode;
exports.resolveSeq = resolveSeq;
exports.resolveString = resolveString;
exports.strOptions = strOptions;
exports.stringifyNumber = stringifyNumber;
exports.stringifyString = stringifyString;
exports.toJSON = toJSON;


/***/ }),

/***/ 95130:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var PlainValue = __nccwpck_require__(24941);
var resolveSeq = __nccwpck_require__(39914);

/* global atob, btoa, Buffer */
const binary = {
  identify: value => value instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: false,
  tag: 'tag:yaml.org,2002:binary',

  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve: (doc, node) => {
    const src = resolveSeq.resolveString(doc, node);

    if (typeof Buffer === 'function') {
      return Buffer.from(src, 'base64');
    } else if (typeof atob === 'function') {
      // On IE 11, atob() can't handle newlines
      const str = atob(src.replace(/[\n\r]/g, ''));
      const buffer = new Uint8Array(str.length);

      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);

      return buffer;
    } else {
      const msg = 'This environment does not support reading binary tags; either Buffer or atob is required';
      doc.errors.push(new PlainValue.YAMLReferenceError(node, msg));
      return null;
    }
  },
  options: resolveSeq.binaryOptions,
  stringify: ({
    comment,
    type,
    value
  }, ctx, onComment, onChompKeep) => {
    let src;

    if (typeof Buffer === 'function') {
      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');
    } else if (typeof btoa === 'function') {
      let s = '';

      for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);

      src = btoa(s);
    } else {
      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
    }

    if (!type) type = resolveSeq.binaryOptions.defaultType;

    if (type === PlainValue.Type.QUOTE_DOUBLE) {
      value = src;
    } else {
      const {
        lineWidth
      } = resolveSeq.binaryOptions;
      const n = Math.ceil(src.length / lineWidth);
      const lines = new Array(n);

      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = src.substr(o, lineWidth);
      }

      value = lines.join(type === PlainValue.Type.BLOCK_LITERAL ? '\n' : ' ');
    }

    return resolveSeq.stringifyString({
      comment,
      type,
      value
    }, ctx, onComment, onChompKeep);
  }
};

function parsePairs(doc, cst) {
  const seq = resolveSeq.resolveSeq(doc, cst);

  for (let i = 0; i < seq.items.length; ++i) {
    let item = seq.items[i];
    if (item instanceof resolveSeq.Pair) continue;else if (item instanceof resolveSeq.YAMLMap) {
      if (item.items.length > 1) {
        const msg = 'Each pair must have its own sequence indicator';
        throw new PlainValue.YAMLSemanticError(cst, msg);
      }

      const pair = item.items[0] || new resolveSeq.Pair();
      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? `${item.commentBefore}\n${pair.commentBefore}` : item.commentBefore;
      if (item.comment) pair.comment = pair.comment ? `${item.comment}\n${pair.comment}` : item.comment;
      item = pair;
    }
    seq.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);
  }

  return seq;
}
function createPairs(schema, iterable, ctx) {
  const pairs = new resolveSeq.YAMLSeq(schema);
  pairs.tag = 'tag:yaml.org,2002:pairs';

  for (const it of iterable) {
    let key, value;

    if (Array.isArray(it)) {
      if (it.length === 2) {
        key = it[0];
        value = it[1];
      } else throw new TypeError(`Expected [key, value] tuple: ${it}`);
    } else if (it && it instanceof Object) {
      const keys = Object.keys(it);

      if (keys.length === 1) {
        key = keys[0];
        value = it[key];
      } else throw new TypeError(`Expected { key: value } tuple: ${it}`);
    } else {
      key = it;
    }

    const pair = schema.createPair(key, value, ctx);
    pairs.items.push(pair);
  }

  return pairs;
}
const pairs = {
  default: false,
  tag: 'tag:yaml.org,2002:pairs',
  resolve: parsePairs,
  createNode: createPairs
};

class YAMLOMap extends resolveSeq.YAMLSeq {
  constructor() {
    super();

    PlainValue._defineProperty(this, "add", resolveSeq.YAMLMap.prototype.add.bind(this));

    PlainValue._defineProperty(this, "delete", resolveSeq.YAMLMap.prototype.delete.bind(this));

    PlainValue._defineProperty(this, "get", resolveSeq.YAMLMap.prototype.get.bind(this));

    PlainValue._defineProperty(this, "has", resolveSeq.YAMLMap.prototype.has.bind(this));

    PlainValue._defineProperty(this, "set", resolveSeq.YAMLMap.prototype.set.bind(this));

    this.tag = YAMLOMap.tag;
  }

  toJSON(_, ctx) {
    const map = new Map();
    if (ctx && ctx.onCreate) ctx.onCreate(map);

    for (const pair of this.items) {
      let key, value;

      if (pair instanceof resolveSeq.Pair) {
        key = resolveSeq.toJSON(pair.key, '', ctx);
        value = resolveSeq.toJSON(pair.value, key, ctx);
      } else {
        key = resolveSeq.toJSON(pair, '', ctx);
      }

      if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');
      map.set(key, value);
    }

    return map;
  }

}

PlainValue._defineProperty(YAMLOMap, "tag", 'tag:yaml.org,2002:omap');

function parseOMap(doc, cst) {
  const pairs = parsePairs(doc, cst);
  const seenKeys = [];

  for (const {
    key
  } of pairs.items) {
    if (key instanceof resolveSeq.Scalar) {
      if (seenKeys.includes(key.value)) {
        const msg = 'Ordered maps must not include duplicate keys';
        throw new PlainValue.YAMLSemanticError(cst, msg);
      } else {
        seenKeys.push(key.value);
      }
    }
  }

  return Object.assign(new YAMLOMap(), pairs);
}

function createOMap(schema, iterable, ctx) {
  const pairs = createPairs(schema, iterable, ctx);
  const omap = new YAMLOMap();
  omap.items = pairs.items;
  return omap;
}

const omap = {
  identify: value => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: 'tag:yaml.org,2002:omap',
  resolve: parseOMap,
  createNode: createOMap
};

class YAMLSet extends resolveSeq.YAMLMap {
  constructor() {
    super();
    this.tag = YAMLSet.tag;
  }

  add(key) {
    const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);
    const prev = resolveSeq.findPair(this.items, pair.key);
    if (!prev) this.items.push(pair);
  }

  get(key, keepPair) {
    const pair = resolveSeq.findPair(this.items, key);
    return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;
  }

  set(key, value) {
    if (typeof value !== 'boolean') throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = resolveSeq.findPair(this.items, key);

    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new resolveSeq.Pair(key));
    }
  }

  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }

  toString(ctx, onComment, onChompKeep) {
    if (!ctx) return JSON.stringify(this);
    if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');
  }

}

PlainValue._defineProperty(YAMLSet, "tag", 'tag:yaml.org,2002:set');

function parseSet(doc, cst) {
  const map = resolveSeq.resolveMap(doc, cst);
  if (!map.hasAllNullValues()) throw new PlainValue.YAMLSemanticError(cst, 'Set items must all have null values');
  return Object.assign(new YAMLSet(), map);
}

function createSet(schema, iterable, ctx) {
  const set = new YAMLSet();

  for (const value of iterable) set.items.push(schema.createPair(value, null, ctx));

  return set;
}

const set = {
  identify: value => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: 'tag:yaml.org,2002:set',
  resolve: parseSet,
  createNode: createSet
};

const parseSexagesimal = (sign, parts) => {
  const n = parts.split(':').reduce((n, p) => n * 60 + Number(p), 0);
  return sign === '-' ? -n : n;
}; // hhhh:mm:ss.sss


const stringifySexagesimal = ({
  value
}) => {
  if (isNaN(value) || !isFinite(value)) return resolveSeq.stringifyNumber(value);
  let sign = '';

  if (value < 0) {
    sign = '-';
    value = Math.abs(value);
  }

  const parts = [value % 60]; // seconds, including ms

  if (value < 60) {
    parts.unshift(0); // at least one : is required
  } else {
    value = Math.round((value - parts[0]) / 60);
    parts.unshift(value % 60); // minutes

    if (value >= 60) {
      value = Math.round((value - parts[0]) / 60);
      parts.unshift(value); // hours
    }
  }

  return sign + parts.map(n => n < 10 ? '0' + String(n) : String(n)).join(':').replace(/000000\d*$/, '') // % 60 may introduce error
  ;
};

const intTime = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:int',
  format: 'TIME',
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,
  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),
  stringify: stringifySexagesimal
};
const floatTime = {
  identify: value => typeof value === 'number',
  default: true,
  tag: 'tag:yaml.org,2002:float',
  format: 'TIME',
  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,
  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),
  stringify: stringifySexagesimal
};
const timestamp = {
  identify: value => value instanceof Date,
  default: true,
  tag: 'tag:yaml.org,2002:timestamp',
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
  '(?:(?:t|T|[ \\t]+)' + // t | T | whitespace
  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
  '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
  ')?' + ')$'),
  resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {
    if (millisec) millisec = (millisec + '00').substr(1, 3);
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);

    if (tz && tz !== 'Z') {
      let d = parseSexagesimal(tz[0], tz.slice(1));
      if (Math.abs(d) < 30) d *= 60;
      date -= 60000 * d;
    }

    return new Date(date);
  },
  stringify: ({
    value
  }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '')
};

/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */
function shouldWarn(deprecation) {
  const env = typeof process !== 'undefined' && process.env || {};

  if (deprecation) {
    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;
    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;
  }

  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;
  return !env.YAML_SILENCE_WARNINGS;
}

function warn(warning, type) {
  if (shouldWarn(false)) {
    const emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to
    // https://github.com/facebook/jest/issues/2549

    if (emit) emit(warning, type);else {
      // eslint-disable-next-line no-console
      console.warn(type ? `${type}: ${warning}` : warning);
    }
  }
}
function warnFileDeprecation(filename) {
  if (shouldWarn(true)) {
    const path = filename.replace(/.*yaml[/\\]/i, '').replace(/\.js$/, '').replace(/\\/g, '/');
    warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, 'DeprecationWarning');
  }
}
const warned = {};
function warnOptionDeprecation(name, alternative) {
  if (!warned[name] && shouldWarn(true)) {
    warned[name] = true;
    let msg = `The option '${name}' will be removed in a future release`;
    msg += alternative ? `, use '${alternative}' instead.` : '.';
    warn(msg, 'DeprecationWarning');
  }
}

exports.binary = binary;
exports.floatTime = floatTime;
exports.intTime = intTime;
exports.omap = omap;
exports.pairs = pairs;
exports.set = set;
exports.timestamp = timestamp;
exports.warn = warn;
exports.warnFileDeprecation = warnFileDeprecation;
exports.warnOptionDeprecation = warnOptionDeprecation;


/***/ }),

/***/ 44603:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(44083).YAML


/***/ }),

/***/ 65741:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * marked v4.2.12 - a markdown parser
 * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */



function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

function getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: '',
    highlight: null,
    langPrefix: 'language-',
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
exports.defaults = getDefaults();
function changeDefaults(newDefaults) {
  exports.defaults = newDefaults;
}

/**
 * Helpers
 */
var escapeTest = /[&<>"']/;
var escapeReplace = new RegExp(escapeTest.source, 'g');
var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');
var escapeReplacements = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
var getEscapeReplacement = function getEscapeReplacement(ch) {
  return escapeReplacements[ch];
};
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

/**
 * @param {string} html
 */
function unescape(html) {
  // explicitly match decimal, hex, and named HTML entities
  return html.replace(unescapeTest, function (_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}
var caret = /(^|[^\[])\^/g;

/**
 * @param {string | RegExp} regex
 * @param {string} opt
 */
function edit(regex, opt) {
  regex = typeof regex === 'string' ? regex : regex.source;
  opt = opt || '';
  var obj = {
    replace: function replace(name, val) {
      val = val.source || val;
      val = val.replace(caret, '$1');
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: function getRegex() {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
var nonWordAndColonTest = /[^\w:]/g;
var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

/**
 * @param {boolean} sanitize
 * @param {string} base
 * @param {string} href
 */
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    var prot;
    try {
      prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, '').toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, '%');
  } catch (e) {
    return null;
  }
  return href;
}
var baseUrls = {};
var justDomain = /^[^:]+:\/*[^/]*$/;
var protocol = /^([^:]+:)[\s\S]*$/;
var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

/**
 * @param {string} base
 * @param {string} href
 */
function resolveUrl(base, href) {
  if (!baseUrls[' ' + base]) {
    // we can ignore everything in base after the last slash of its path component,
    // but we might need to add _that_
    // https://tools.ietf.org/html/rfc3986#section-3
    if (justDomain.test(base)) {
      baseUrls[' ' + base] = base + '/';
    } else {
      baseUrls[' ' + base] = rtrim(base, '/', true);
    }
  }
  base = baseUrls[' ' + base];
  var relativeBase = base.indexOf(':') === -1;
  if (href.substring(0, 2) === '//') {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, '$1') + href;
  } else if (href.charAt(0) === '/') {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, '$1') + href;
  } else {
    return base + href;
  }
}
var noopTest = {
  exec: function noopTest() {}
};
function merge(obj) {
  var i = 1,
    target,
    key;
  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }
  return obj;
}
function splitCells(tableRow, count) {
  // ensure that every cell-delimiting pipe has a space
  // before it to distinguish it from an escaped pipe
  var row = tableRow.replace(/\|/g, function (match, offset, str) {
      var escaped = false,
        curr = offset;
      while (--curr >= 0 && str[curr] === '\\') {
        escaped = !escaped;
      }
      if (escaped) {
        // odd number of slashes means | is escaped
        // so we leave it alone
        return '|';
      } else {
        // add space before unescaped |
        return ' |';
      }
    }),
    cells = row.split(/ \|/);
  var i = 0;

  // First/last cell in a row cannot be empty if it has no leading/trailing pipe
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count) {
      cells.push('');
    }
  }
  for (; i < cells.length; i++) {
    // leading or trailing whitespace is ignored per the gfm spec
    cells[i] = cells[i].trim().replace(/\\\|/g, '|');
  }
  return cells;
}

/**
 * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
 * /c*$/ is vulnerable to REDOS.
 *
 * @param {string} str
 * @param {string} c
 * @param {boolean} invert Remove suffix of non-c chars instead. Default falsey.
 */
function rtrim(str, c, invert) {
  var l = str.length;
  if (l === 0) {
    return '';
  }

  // Length of suffix matching the invert condition.
  var suffLen = 0;

  // Step left until we fail to match the invert condition.
  while (suffLen < l) {
    var currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  var l = str.length;
  var level = 0,
    i = 0;
  for (; i < l; i++) {
    if (str[i] === '\\') {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
  }
}

// copied from https://stackoverflow.com/a/5450113/806777
/**
 * @param {string} pattern
 * @param {number} count
 */
function repeatString(pattern, count) {
  if (count < 1) {
    return '';
  }
  var result = '';
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}

function outputLink(cap, link, raw, lexer) {
  var href = link.href;
  var title = link.title ? escape(link.title) : null;
  var text = cap[1].replace(/\\([\[\]])/g, '$1');
  if (cap[0].charAt(0) !== '!') {
    lexer.state.inLink = true;
    var token = {
      type: 'link',
      raw: raw,
      href: href,
      title: title,
      text: text,
      tokens: lexer.inlineTokens(text)
    };
    lexer.state.inLink = false;
    return token;
  }
  return {
    type: 'image',
    raw: raw,
    href: href,
    title: title,
    text: escape(text)
  };
}
function indentCodeCompensation(raw, text) {
  var matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  var indentToCode = matchIndentToCode[1];
  return text.split('\n').map(function (node) {
    var matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    var indentInNode = matchIndentInNode[0];
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join('\n');
}

/**
 * Tokenizer
 */
var Tokenizer = /*#__PURE__*/function () {
  function Tokenizer(options) {
    this.options = options || exports.defaults;
  }
  var _proto = Tokenizer.prototype;
  _proto.space = function space(src) {
    var cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: 'space',
        raw: cap[0]
      };
    }
  };
  _proto.code = function code(src) {
    var cap = this.rules.block.code.exec(src);
    if (cap) {
      var text = cap[0].replace(/^ {1,4}/gm, '');
      return {
        type: 'code',
        raw: cap[0],
        codeBlockStyle: 'indented',
        text: !this.options.pedantic ? rtrim(text, '\n') : text
      };
    }
  };
  _proto.fences = function fences(src) {
    var cap = this.rules.block.fences.exec(src);
    if (cap) {
      var raw = cap[0];
      var text = indentCodeCompensation(raw, cap[3] || '');
      return {
        type: 'code',
        raw: raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, '$1') : cap[2],
        text: text
      };
    }
  };
  _proto.heading = function heading(src) {
    var cap = this.rules.block.heading.exec(src);
    if (cap) {
      var text = cap[2].trim();

      // remove trailing #s
      if (/#$/.test(text)) {
        var trimmed = rtrim(text, '#');
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          // CommonMark requires space before trailing #s
          text = trimmed.trim();
        }
      }
      return {
        type: 'heading',
        raw: cap[0],
        depth: cap[1].length,
        text: text,
        tokens: this.lexer.inline(text)
      };
    }
  };
  _proto.hr = function hr(src) {
    var cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: 'hr',
        raw: cap[0]
      };
    }
  };
  _proto.blockquote = function blockquote(src) {
    var cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      var text = cap[0].replace(/^ *>[ \t]?/gm, '');
      var top = this.lexer.state.top;
      this.lexer.state.top = true;
      var tokens = this.lexer.blockTokens(text);
      this.lexer.state.top = top;
      return {
        type: 'blockquote',
        raw: cap[0],
        tokens: tokens,
        text: text
      };
    }
  };
  _proto.list = function list(src) {
    var cap = this.rules.block.list.exec(src);
    if (cap) {
      var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      var bull = cap[1].trim();
      var isordered = bull.length > 1;
      var list = {
        type: 'list',
        raw: '',
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : '',
        loose: false,
        items: []
      };
      bull = isordered ? "\\d{1,9}\\" + bull.slice(-1) : "\\" + bull;
      if (this.options.pedantic) {
        bull = isordered ? bull : '[*+-]';
      }

      // Get next list item
      var itemRegex = new RegExp("^( {0,3}" + bull + ")((?:[\t ][^\\n]*)?(?:\\n|$))");

      // Check if current bullet point can start a new List Item
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          // End list if bullet was actually HR (possibly move into itemRegex?)
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split('\n', 1)[0].replace(/^\t+/, function (t) {
          return ' '.repeat(3 * t.length);
        });
        nextLine = src.split('\n', 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/); // Find first non-space char
          indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          // Items begin with at most one blank line
          raw += nextLine + '\n';
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          var nextBulletRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))");
          var hrRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)");
          var fencesBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:```|~~~)");
          var headingBeginRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}#");

          // Check if following lines should be included in List Item
          while (src) {
            rawLine = src.split('\n', 1)[0];
            nextLine = rawLine;

            // Re-align to follow commonmark nesting rules
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');
            }

            // End list item if found code fences
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }

            // End list item if found start of new heading
            if (headingBeginRegex.test(nextLine)) {
              break;
            }

            // End list item if found start of new bullet
            if (nextBulletRegex.test(nextLine)) {
              break;
            }

            // Horizontal rule found
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              // Dedent if possible
              itemContents += '\n' + nextLine.slice(indent);
            } else {
              // not enough indentation
              if (blankLine) {
                break;
              }

              // paragraph continuation unless last line was a different block level element
              if (line.search(/[^ ]/) >= 4) {
                // indented code block
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += '\n' + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              // Check if current line is blank
              blankLine = true;
            }
            raw += rawLine + '\n';
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list.loose) {
          // If the previous item ended with a blank line, the list is loose
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }

        // Check for task list items
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== '[ ] ';
            itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
          }
        }
        list.items.push({
          type: 'list_item',
          raw: raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list.raw += raw;
      }

      // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      var l = list.items.length;

      // Item child tokens handled here at end because we needed to have the final item to trim it first
      for (i = 0; i < l; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        if (!list.loose) {
          // Check if list should be loose
          var spacers = list.items[i].tokens.filter(function (t) {
            return t.type === 'space';
          });
          var hasMultipleLineBreaks = spacers.length > 0 && spacers.some(function (t) {
            return /\n.*\n/.test(t.raw);
          });
          list.loose = hasMultipleLineBreaks;
        }
      }

      // Set all items to loose if list is loose
      if (list.loose) {
        for (i = 0; i < l; i++) {
          list.items[i].loose = true;
        }
      }
      return list;
    }
  };
  _proto.html = function html(src) {
    var cap = this.rules.block.html.exec(src);
    if (cap) {
      var token = {
        type: 'html',
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: cap[0]
      };
      if (this.options.sanitize) {
        var text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        token.type = 'paragraph';
        token.text = text;
        token.tokens = this.lexer.inline(text);
      }
      return token;
    }
  };
  _proto.def = function def(src) {
    var cap = this.rules.block.def.exec(src);
    if (cap) {
      var tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
      var href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline._escapes, '$1') : '';
      var title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, '$1') : cap[3];
      return {
        type: 'def',
        tag: tag,
        raw: cap[0],
        href: href,
        title: title
      };
    }
  };
  _proto.table = function table(src) {
    var cap = this.rules.block.table.exec(src);
    if (cap) {
      var item = {
        type: 'table',
        header: splitCells(cap[1]).map(function (c) {
          return {
            text: c
          };
        }),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, '').split('\n') : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        var l = item.align.length;
        var i, j, k, row;
        for (i = 0; i < l; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }
        l = item.rows.length;
        for (i = 0; i < l; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map(function (c) {
            return {
              text: c
            };
          });
        }

        // parse child tokens inside headers and cells

        // header child tokens
        l = item.header.length;
        for (j = 0; j < l; j++) {
          item.header[j].tokens = this.lexer.inline(item.header[j].text);
        }

        // cell child tokens
        l = item.rows.length;
        for (j = 0; j < l; j++) {
          row = item.rows[j];
          for (k = 0; k < row.length; k++) {
            row[k].tokens = this.lexer.inline(row[k].text);
          }
        }
        return item;
      }
    }
  };
  _proto.lheading = function lheading(src) {
    var cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: 'heading',
        raw: cap[0],
        depth: cap[2].charAt(0) === '=' ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  };
  _proto.paragraph = function paragraph(src) {
    var cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      var text = cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1];
      return {
        type: 'paragraph',
        raw: cap[0],
        text: text,
        tokens: this.lexer.inline(text)
      };
    }
  };
  _proto.text = function text(src) {
    var cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: 'text',
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  };
  _proto.escape = function escape$1(src) {
    var cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: 'escape',
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  };
  _proto.tag = function tag(src) {
    var cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? 'text' : 'html',
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
      };
    }
  };
  _proto.link = function link(src) {
    var cap = this.rules.inline.link.exec(src);
    if (cap) {
      var trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        // commonmark requires matching angle brackets
        if (!/>$/.test(trimmedUrl)) {
          return;
        }

        // ending angle bracket cannot be escaped
        var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        // find closing parenthesis
        var lastParenIndex = findClosingBracket(cap[2], '()');
        if (lastParenIndex > -1) {
          var start = cap[0].indexOf('!') === 0 ? 5 : 4;
          var linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = '';
        }
      }
      var href = cap[2];
      var title = '';
      if (this.options.pedantic) {
        // split pedantic href and title
        var link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : '';
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          // pedantic allows starting angle bracket without ending angle bracket
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
        title: title ? title.replace(this.rules.inline._escapes, '$1') : title
      }, cap[0], this.lexer);
    }
  };
  _proto.reflink = function reflink(src, links) {
    var cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      var link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = links[link.toLowerCase()];
      if (!link) {
        var text = cap[0].charAt(0);
        return {
          type: 'text',
          raw: text,
          text: text
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  };
  _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
    if (prevChar === void 0) {
      prevChar = '';
    }
    var match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match) return;

    // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well
    if (match[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/)) return;
    var nextChar = match[1] || match[2] || '';
    if (!nextChar || nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))) {
      var lLength = match[0].length - 1;
      var rDelim,
        rLength,
        delimTotal = lLength,
        midDelimTotal = 0;
      var endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;

      // Clip maskedSrc to same section of string as src (move to lexer?)
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim) continue; // skip single * in __abc*abc__

        rLength = rDelim.length;
        if (match[3] || match[4]) {
          // found another Left Delim
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          // either Left or Right Delim
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue; // CommonMark Emphasis Rules 9-10
          }
        }

        delimTotal -= rLength;
        if (delimTotal > 0) continue; // Haven't found enough closing delimiters

        // Remove extra characters. *a*** -> *a*
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        var raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);

        // Create `em` if smallest delimiter has odd char count. *a***
        if (Math.min(lLength, rLength) % 2) {
          var _text = raw.slice(1, -1);
          return {
            type: 'em',
            raw: raw,
            text: _text,
            tokens: this.lexer.inlineTokens(_text)
          };
        }

        // Create 'strong' if smallest delimiter has even char count. **a***
        var text = raw.slice(2, -2);
        return {
          type: 'strong',
          raw: raw,
          text: text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  };
  _proto.codespan = function codespan(src) {
    var cap = this.rules.inline.code.exec(src);
    if (cap) {
      var text = cap[2].replace(/\n/g, ' ');
      var hasNonSpaceChars = /[^ ]/.test(text);
      var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape(text, true);
      return {
        type: 'codespan',
        raw: cap[0],
        text: text
      };
    }
  };
  _proto.br = function br(src) {
    var cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: 'br',
        raw: cap[0]
      };
    }
  };
  _proto.del = function del(src) {
    var cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: 'del',
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  };
  _proto.autolink = function autolink(src, mangle) {
    var cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      var text, href;
      if (cap[2] === '@') {
        text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
        href = 'mailto:' + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      return {
        type: 'link',
        raw: cap[0],
        text: text,
        href: href,
        tokens: [{
          type: 'text',
          raw: text,
          text: text
        }]
      };
    }
  };
  _proto.url = function url(src, mangle) {
    var cap;
    if (cap = this.rules.inline.url.exec(src)) {
      var text, href;
      if (cap[2] === '@') {
        text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
        href = 'mailto:' + text;
      } else {
        // do extended autolink path validation
        var prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === 'www.') {
          href = 'http://' + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: 'link',
        raw: cap[0],
        text: text,
        href: href,
        tokens: [{
          type: 'text',
          raw: text,
          text: text
        }]
      };
    }
  };
  _proto.inlineText = function inlineText(src, smartypants) {
    var cap = this.rules.inline.text.exec(src);
    if (cap) {
      var text;
      if (this.lexer.state.inRawBlock) {
        text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
      } else {
        text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
      }
      return {
        type: 'text',
        raw: cap[0],
        text: text
      };
    }
  };
  return Tokenizer;
}();

/**
 * Block-Level Grammar
 */
var block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: '^ {0,3}(?:' // optional indentation
  + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
  + '|comment[^\\n]*(\\n+|$)' // (2)
  + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
  + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
  + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
  + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
  + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
  + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
  + ')',
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace('label', block._label).replace('title', block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace('bull', block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))').replace('def', '\\n+(?=' + block.def.source + ')').getRegex();
block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
.replace('|table', '').replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
.replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
.getRegex();
block.blockquote = edit(block.blockquote).replace('paragraph', block.paragraph).getRegex();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  table: '^ *([^\\n ].*\\|.*)\\n' // Header
  + ' {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?' // Align
  + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells
});

block.gfm.table = edit(block.gfm.table).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
.replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
.getRegex();
block.gfm.paragraph = edit(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
.replace('table', block.gfm.table) // interrupt paragraphs with table
.replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
.replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
.getRegex();
/**
 * Pedantic grammar (original John Gruber's loose markdown specification)
 */

block.pedantic = merge({}, block.normal, {
  html: edit('^ *(?:comment *(?:\\n|\\s*$)' + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
  + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b').getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace('hr', block.hr).replace('heading', ' *#{1,6} *[^\n]').replace('lheading', block.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()
});

/**
 * Inline-Level Grammar
 */
var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: '^comment' + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
  + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
  + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
  + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
  + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: 'reflink|nolink(?!\\()',
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ // ^- Not allowed for _
  },

  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};

// list of punctuation marks from CommonMark spec
// without * and _ to handle the different emphasis markers * and _
inline._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();

// sequences em should skip over [title](link), `code`, <html>
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
// lookbehind is not available on Safari as of version 16
// inline.escapedEmSt = /(?<=(?:^|[^\\)(?:\\[^])*)\\[*_]/g;
inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
inline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, 'g').replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, 'g').replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace('comment', inline._comment).replace('attribute', inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace('label', inline._label).replace('ref', block._label).getRegex();
inline.nolink = edit(inline.nolink).replace('ref', block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, 'g').replace('reflink', inline.reflink).replace('nolink', inline.nolink).getRegex();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace('label', inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace('label', inline._label).getRegex()
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: edit(inline.escape).replace('])', '~|])').getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
});
inline.gfm.url = edit(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();
/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: edit(inline.br).replace('{2,}', '*').getRegex(),
  text: edit(inline.gfm.text).replace('\\b_', '\\b_| {2,}\\n').replace(/\{2,\}/g, '*').getRegex()
});

/**
 * smartypants text replacement
 * @param {string} text
 */
function smartypants(text) {
  return text
  // em-dashes
  .replace(/---/g, "\u2014")
  // en-dashes
  .replace(/--/g, "\u2013")
  // opening singles
  .replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018")
  // closing singles & apostrophes
  .replace(/'/g, "\u2019")
  // opening doubles
  .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C")
  // closing doubles
  .replace(/"/g, "\u201D")
  // ellipses
  .replace(/\.{3}/g, "\u2026");
}

/**
 * mangle email addresses
 * @param {string} text
 */
function mangle(text) {
  var out = '',
    i,
    ch;
  var l = text.length;
  for (i = 0; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }
  return out;
}

/**
 * Block Lexer
 */
var Lexer = /*#__PURE__*/function () {
  function Lexer(options) {
    this.tokens = [];
    this.tokens.links = Object.create(null);
    this.options = options || exports.defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    var rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }

  /**
   * Expose Rules
   */
  /**
   * Static Lex Method
   */
  Lexer.lex = function lex(src, options) {
    var lexer = new Lexer(options);
    return lexer.lex(src);
  }

  /**
   * Static Lex Inline Method
   */;
  Lexer.lexInline = function lexInline(src, options) {
    var lexer = new Lexer(options);
    return lexer.inlineTokens(src);
  }

  /**
   * Preprocessing
   */;
  var _proto = Lexer.prototype;
  _proto.lex = function lex(src) {
    src = src.replace(/\r\n|\r/g, '\n');
    this.blockTokens(src, this.tokens);
    var next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }

  /**
   * Lexing
   */;
  _proto.blockTokens = function blockTokens(src, tokens) {
    var _this = this;
    if (tokens === void 0) {
      tokens = [];
    }
    if (this.options.pedantic) {
      src = src.replace(/\t/g, '    ').replace(/^ +$/gm, '');
    } else {
      src = src.replace(/^( *)(\t+)/gm, function (_, leading, tabs) {
        return leading + '    '.repeat(tabs.length);
      });
    }
    var token, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function (extTokenizer) {
        if (token = extTokenizer.call({
          lexer: _this
        }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }

      // newline
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          // if there's a single \n as a spacer, it's terminating the last line,
          // so move it there so that we don't get unecessary paragraph tags
          tokens[tokens.length - 1].raw += '\n';
        } else {
          tokens.push(token);
        }
        continue;
      }

      // code
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        // An indented code block cannot interrupt a paragraph.
        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }

      // fences
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // heading
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // hr
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // blockquote
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // list
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // html
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // def
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }

      // table (gfm)
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // lheading
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // top-level paragraph
      // prevent paragraph consuming extensions by clipping 'src' to extension start
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        (function () {
          var startIndex = Infinity;
          var tempSrc = src.slice(1);
          var tempStart = void 0;
          _this.options.extensions.startBlock.forEach(function (getStartIndex) {
            tempStart = getStartIndex.call({
              lexer: this
            }, tempSrc);
            if (typeof tempStart === 'number' && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        })();
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === 'paragraph') {
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }

      // text
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === 'text') {
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  };
  _proto.inline = function inline(src, tokens) {
    if (tokens === void 0) {
      tokens = [];
    }
    this.inlineQueue.push({
      src: src,
      tokens: tokens
    });
    return tokens;
  }

  /**
   * Lexing/Compiling
   */;
  _proto.inlineTokens = function inlineTokens(src, tokens) {
    var _this2 = this;
    if (tokens === void 0) {
      tokens = [];
    }
    var token, lastToken, cutSrc;

    // String with links masked to avoid interference with em and strong
    var maskedSrc = src;
    var match;
    var keepPrevChar, prevChar;

    // Mask out reflinks
    if (this.tokens.links) {
      var links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    // Mask out other blocks
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }

    // Mask out escaped em & strong delimiters
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = '';
      }
      keepPrevChar = false;

      // extensions
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function (extTokenizer) {
        if (token = extTokenizer.call({
          lexer: _this2
        }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }

      // escape
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // tag
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === 'text' && lastToken.type === 'text') {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }

      // link
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // reflink, nolink
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === 'text' && lastToken.type === 'text') {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }

      // em & strong
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // code
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // br
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // del (gfm)
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // autolink
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // url (gfm)
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // text
      // prevent inlineText consuming extensions by clipping 'src' to extension start
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        (function () {
          var startIndex = Infinity;
          var tempSrc = src.slice(1);
          var tempStart = void 0;
          _this2.options.extensions.startInline.forEach(function (getStartIndex) {
            tempStart = getStartIndex.call({
              lexer: this
            }, tempSrc);
            if (typeof tempStart === 'number' && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src.substring(0, startIndex + 1);
          }
        })();
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== '_') {
          // Track prevChar before string of ____ started
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === 'text') {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  };
  _createClass(Lexer, null, [{
    key: "rules",
    get: function get() {
      return {
        block: block,
        inline: inline
      };
    }
  }]);
  return Lexer;
}();

/**
 * Renderer
 */
var Renderer = /*#__PURE__*/function () {
  function Renderer(options) {
    this.options = options || exports.defaults;
  }
  var _proto = Renderer.prototype;
  _proto.code = function code(_code, infostring, escaped) {
    var lang = (infostring || '').match(/\S*/)[0];
    if (this.options.highlight) {
      var out = this.options.highlight(_code, lang);
      if (out != null && out !== _code) {
        escaped = true;
        _code = out;
      }
    }
    _code = _code.replace(/\n$/, '') + '\n';
    if (!lang) {
      return '<pre><code>' + (escaped ? _code : escape(_code, true)) + '</code></pre>\n';
    }
    return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? _code : escape(_code, true)) + '</code></pre>\n';
  }

  /**
   * @param {string} quote
   */;
  _proto.blockquote = function blockquote(quote) {
    return "<blockquote>\n" + quote + "</blockquote>\n";
  };
  _proto.html = function html(_html) {
    return _html;
  }

  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */;
  _proto.heading = function heading(text, level, raw, slugger) {
    if (this.options.headerIds) {
      var id = this.options.headerPrefix + slugger.slug(raw);
      return "<h" + level + " id=\"" + id + "\">" + text + "</h" + level + ">\n";
    }

    // ignore IDs
    return "<h" + level + ">" + text + "</h" + level + ">\n";
  };
  _proto.hr = function hr() {
    return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
  };
  _proto.list = function list(body, ordered, start) {
    var type = ordered ? 'ol' : 'ul',
      startatt = ordered && start !== 1 ? ' start="' + start + '"' : '';
    return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
  }

  /**
   * @param {string} text
   */;
  _proto.listitem = function listitem(text) {
    return "<li>" + text + "</li>\n";
  };
  _proto.checkbox = function checkbox(checked) {
    return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox"' + (this.options.xhtml ? ' /' : '') + '> ';
  }

  /**
   * @param {string} text
   */;
  _proto.paragraph = function paragraph(text) {
    return "<p>" + text + "</p>\n";
  }

  /**
   * @param {string} header
   * @param {string} body
   */;
  _proto.table = function table(header, body) {
    if (body) body = "<tbody>" + body + "</tbody>";
    return '<table>\n' + '<thead>\n' + header + '</thead>\n' + body + '</table>\n';
  }

  /**
   * @param {string} content
   */;
  _proto.tablerow = function tablerow(content) {
    return "<tr>\n" + content + "</tr>\n";
  };
  _proto.tablecell = function tablecell(content, flags) {
    var type = flags.header ? 'th' : 'td';
    var tag = flags.align ? "<" + type + " align=\"" + flags.align + "\">" : "<" + type + ">";
    return tag + content + ("</" + type + ">\n");
  }

  /**
   * span level renderer
   * @param {string} text
   */;
  _proto.strong = function strong(text) {
    return "<strong>" + text + "</strong>";
  }

  /**
   * @param {string} text
   */;
  _proto.em = function em(text) {
    return "<em>" + text + "</em>";
  }

  /**
   * @param {string} text
   */;
  _proto.codespan = function codespan(text) {
    return "<code>" + text + "</code>";
  };
  _proto.br = function br() {
    return this.options.xhtml ? '<br/>' : '<br>';
  }

  /**
   * @param {string} text
   */;
  _proto.del = function del(text) {
    return "<del>" + text + "</del>";
  }

  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */;
  _proto.link = function link(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    var out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += '>' + text + '</a>';
    return out;
  }

  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */;
  _proto.image = function image(href, title, text) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    var out = "<img src=\"" + href + "\" alt=\"" + text + "\"";
    if (title) {
      out += " title=\"" + title + "\"";
    }
    out += this.options.xhtml ? '/>' : '>';
    return out;
  };
  _proto.text = function text(_text) {
    return _text;
  };
  return Renderer;
}();

/**
 * TextRenderer
 * returns only the textual part of the token
 */
var TextRenderer = /*#__PURE__*/function () {
  function TextRenderer() {}
  var _proto = TextRenderer.prototype;
  // no need for block level renderers
  _proto.strong = function strong(text) {
    return text;
  };
  _proto.em = function em(text) {
    return text;
  };
  _proto.codespan = function codespan(text) {
    return text;
  };
  _proto.del = function del(text) {
    return text;
  };
  _proto.html = function html(text) {
    return text;
  };
  _proto.text = function text(_text) {
    return _text;
  };
  _proto.link = function link(href, title, text) {
    return '' + text;
  };
  _proto.image = function image(href, title, text) {
    return '' + text;
  };
  _proto.br = function br() {
    return '';
  };
  return TextRenderer;
}();

/**
 * Slugger generates header id
 */
var Slugger = /*#__PURE__*/function () {
  function Slugger() {
    this.seen = {};
  }

  /**
   * @param {string} value
   */
  var _proto = Slugger.prototype;
  _proto.serialize = function serialize(value) {
    return value.toLowerCase().trim()
    // remove html tags
    .replace(/<[!\/a-z].*?>/ig, '')
    // remove unwanted chars
    .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '').replace(/\s/g, '-');
  }

  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */;
  _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
    var slug = originalSlug;
    var occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + '-' + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }

  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */;
  _proto.slug = function slug(value, options) {
    if (options === void 0) {
      options = {};
    }
    var slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options.dryrun);
  };
  return Slugger;
}();

/**
 * Parsing & Compiling
 */
var Parser = /*#__PURE__*/function () {
  function Parser(options) {
    this.options = options || exports.defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }

  /**
   * Static Parse Method
   */
  Parser.parse = function parse(tokens, options) {
    var parser = new Parser(options);
    return parser.parse(tokens);
  }

  /**
   * Static Parse Inline Method
   */;
  Parser.parseInline = function parseInline(tokens, options) {
    var parser = new Parser(options);
    return parser.parseInline(tokens);
  }

  /**
   * Parse Loop
   */;
  var _proto = Parser.prototype;
  _proto.parse = function parse(tokens, top) {
    if (top === void 0) {
      top = true;
    }
    var out = '',
      i,
      j,
      k,
      l2,
      l3,
      row,
      cell,
      header,
      body,
      token,
      ordered,
      start,
      loose,
      itemBody,
      item,
      checked,
      task,
      checkbox,
      ret;
    var l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];

      // Run any renderer extensions
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({
          parser: this
        }, token);
        if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {
          out += ret || '';
          continue;
        }
      }
      switch (token.type) {
        case 'space':
          {
            continue;
          }
        case 'hr':
          {
            out += this.renderer.hr();
            continue;
          }
        case 'heading':
          {
            out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
            continue;
          }
        case 'code':
          {
            out += this.renderer.code(token.text, token.lang, token.escaped);
            continue;
          }
        case 'table':
          {
            header = '';

            // header
            cell = '';
            l2 = token.header.length;
            for (j = 0; j < l2; j++) {
              cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {
                header: true,
                align: token.align[j]
              });
            }
            header += this.renderer.tablerow(cell);
            body = '';
            l2 = token.rows.length;
            for (j = 0; j < l2; j++) {
              row = token.rows[j];
              cell = '';
              l3 = row.length;
              for (k = 0; k < l3; k++) {
                cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {
                  header: false,
                  align: token.align[k]
                });
              }
              body += this.renderer.tablerow(cell);
            }
            out += this.renderer.table(header, body);
            continue;
          }
        case 'blockquote':
          {
            body = this.parse(token.tokens);
            out += this.renderer.blockquote(body);
            continue;
          }
        case 'list':
          {
            ordered = token.ordered;
            start = token.start;
            loose = token.loose;
            l2 = token.items.length;
            body = '';
            for (j = 0; j < l2; j++) {
              item = token.items[j];
              checked = item.checked;
              task = item.task;
              itemBody = '';
              if (item.task) {
                checkbox = this.renderer.checkbox(checked);
                if (loose) {
                  if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {
                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                      item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                    }
                  } else {
                    item.tokens.unshift({
                      type: 'text',
                      text: checkbox
                    });
                  }
                } else {
                  itemBody += checkbox;
                }
              }
              itemBody += this.parse(item.tokens, loose);
              body += this.renderer.listitem(itemBody, task, checked);
            }
            out += this.renderer.list(body, ordered, start);
            continue;
          }
        case 'html':
          {
            // TODO parse inline content if parameter markdown=1
            out += this.renderer.html(token.text);
            continue;
          }
        case 'paragraph':
          {
            out += this.renderer.paragraph(this.parseInline(token.tokens));
            continue;
          }
        case 'text':
          {
            body = token.tokens ? this.parseInline(token.tokens) : token.text;
            while (i + 1 < l && tokens[i + 1].type === 'text') {
              token = tokens[++i];
              body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
            }
            out += top ? this.renderer.paragraph(body) : body;
            continue;
          }
        default:
          {
            var errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
      }
    }
    return out;
  }

  /**
   * Parse Inline Tokens
   */;
  _proto.parseInline = function parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    var out = '',
      i,
      token,
      ret;
    var l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];

      // Run any renderer extensions
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({
          parser: this
        }, token);
        if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {
          out += ret || '';
          continue;
        }
      }
      switch (token.type) {
        case 'escape':
          {
            out += renderer.text(token.text);
            break;
          }
        case 'html':
          {
            out += renderer.html(token.text);
            break;
          }
        case 'link':
          {
            out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
            break;
          }
        case 'image':
          {
            out += renderer.image(token.href, token.title, token.text);
            break;
          }
        case 'strong':
          {
            out += renderer.strong(this.parseInline(token.tokens, renderer));
            break;
          }
        case 'em':
          {
            out += renderer.em(this.parseInline(token.tokens, renderer));
            break;
          }
        case 'codespan':
          {
            out += renderer.codespan(token.text);
            break;
          }
        case 'br':
          {
            out += renderer.br();
            break;
          }
        case 'del':
          {
            out += renderer.del(this.parseInline(token.tokens, renderer));
            break;
          }
        case 'text':
          {
            out += renderer.text(token.text);
            break;
          }
        default:
          {
            var errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
      }
    }
    return out;
  };
  return Parser;
}();

/**
 * Marked
 */
function marked(src, opt, callback) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
  }
  if (typeof opt === 'function') {
    callback = opt;
    opt = null;
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  if (callback) {
    var highlight = opt.highlight;
    var tokens;
    try {
      tokens = Lexer.lex(src, opt);
    } catch (e) {
      return callback(e);
    }
    var done = function done(err) {
      var out;
      if (!err) {
        try {
          if (opt.walkTokens) {
            marked.walkTokens(tokens, opt.walkTokens);
          }
          out = Parser.parse(tokens, opt);
        } catch (e) {
          err = e;
        }
      }
      opt.highlight = highlight;
      return err ? callback(err) : callback(null, out);
    };
    if (!highlight || highlight.length < 3) {
      return done();
    }
    delete opt.highlight;
    if (!tokens.length) return done();
    var pending = 0;
    marked.walkTokens(tokens, function (token) {
      if (token.type === 'code') {
        pending++;
        setTimeout(function () {
          highlight(token.text, token.lang, function (err, code) {
            if (err) {
              return done(err);
            }
            if (code != null && code !== token.text) {
              token.text = code;
              token.escaped = true;
            }
            pending--;
            if (pending === 0) {
              done();
            }
          });
        }, 0);
      }
    });
    if (pending === 0) {
      done();
    }
    return;
  }
  function onError(e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if (opt.silent) {
      return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
    }
    throw e;
  }
  try {
    var _tokens = Lexer.lex(src, opt);
    if (opt.walkTokens) {
      if (opt.async) {
        return Promise.all(marked.walkTokens(_tokens, opt.walkTokens)).then(function () {
          return Parser.parse(_tokens, opt);
        })["catch"](onError);
      }
      marked.walkTokens(_tokens, opt.walkTokens);
    }
    return Parser.parse(_tokens, opt);
  } catch (e) {
    onError(e);
  }
}

/**
 * Options
 */

marked.options = marked.setOptions = function (opt) {
  merge(marked.defaults, opt);
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = exports.defaults;

/**
 * Use Extension
 */

marked.use = function () {
  var extensions = marked.defaults.extensions || {
    renderers: {},
    childTokens: {}
  };
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  args.forEach(function (pack) {
    // copy options to new object
    var opts = merge({}, pack);

    // set async to true if it was set to true before
    opts.async = marked.defaults.async || opts.async;

    // ==-- Parse "addon" extensions --== //
    if (pack.extensions) {
      pack.extensions.forEach(function (ext) {
        if (!ext.name) {
          throw new Error('extension name required');
        }
        if (ext.renderer) {
          // Renderer extensions
          var prevRenderer = extensions.renderers[ext.name];
          if (prevRenderer) {
            // Replace extension with func to run new extension but fall back if false
            extensions.renderers[ext.name] = function () {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              var ret = ext.renderer.apply(this, args);
              if (ret === false) {
                ret = prevRenderer.apply(this, args);
              }
              return ret;
            };
          } else {
            extensions.renderers[ext.name] = ext.renderer;
          }
        }
        if (ext.tokenizer) {
          // Tokenizer Extensions
          if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions[ext.level]) {
            extensions[ext.level].unshift(ext.tokenizer);
          } else {
            extensions[ext.level] = [ext.tokenizer];
          }
          if (ext.start) {
            // Function to check for start of token
            if (ext.level === 'block') {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext.start);
              } else {
                extensions.startBlock = [ext.start];
              }
            } else if (ext.level === 'inline') {
              if (extensions.startInline) {
                extensions.startInline.push(ext.start);
              } else {
                extensions.startInline = [ext.start];
              }
            }
          }
        }
        if (ext.childTokens) {
          // Child tokens to be visited by walkTokens
          extensions.childTokens[ext.name] = ext.childTokens;
        }
      });
      opts.extensions = extensions;
    }

    // ==-- Parse "overwrite" extensions --== //
    if (pack.renderer) {
      (function () {
        var renderer = marked.defaults.renderer || new Renderer();
        var _loop = function _loop(prop) {
          var prevRenderer = renderer[prop];
          // Replace renderer with func to run extension, but fall back if false
          renderer[prop] = function () {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }
            var ret = pack.renderer[prop].apply(renderer, args);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args);
            }
            return ret;
          };
        };
        for (var prop in pack.renderer) {
          _loop(prop);
        }
        opts.renderer = renderer;
      })();
    }
    if (pack.tokenizer) {
      (function () {
        var tokenizer = marked.defaults.tokenizer || new Tokenizer();
        var _loop2 = function _loop2(prop) {
          var prevTokenizer = tokenizer[prop];
          // Replace tokenizer with func to run extension, but fall back if false
          tokenizer[prop] = function () {
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }
            var ret = pack.tokenizer[prop].apply(tokenizer, args);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args);
            }
            return ret;
          };
        };
        for (var prop in pack.tokenizer) {
          _loop2(prop);
        }
        opts.tokenizer = tokenizer;
      })();
    }

    // ==-- Parse WalkTokens extensions --== //
    if (pack.walkTokens) {
      var _walkTokens = marked.defaults.walkTokens;
      opts.walkTokens = function (token) {
        var values = [];
        values.push(pack.walkTokens.call(this, token));
        if (_walkTokens) {
          values = values.concat(_walkTokens.call(this, token));
        }
        return values;
      };
    }
    marked.setOptions(opts);
  });
};

/**
 * Run callback for every token
 */

marked.walkTokens = function (tokens, callback) {
  var values = [];
  var _loop3 = function _loop3() {
    var token = _step.value;
    values = values.concat(callback.call(marked, token));
    switch (token.type) {
      case 'table':
        {
          for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done;) {
            var cell = _step2.value;
            values = values.concat(marked.walkTokens(cell.tokens, callback));
          }
          for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done;) {
            var row = _step3.value;
            for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {
              var _cell = _step4.value;
              values = values.concat(marked.walkTokens(_cell.tokens, callback));
            }
          }
          break;
        }
      case 'list':
        {
          values = values.concat(marked.walkTokens(token.items, callback));
          break;
        }
      default:
        {
          if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
            // Walk any extensions
            marked.defaults.extensions.childTokens[token.type].forEach(function (childTokens) {
              values = values.concat(marked.walkTokens(token[childTokens], callback));
            });
          } else if (token.tokens) {
            values = values.concat(marked.walkTokens(token.tokens, callback));
          }
        }
    }
  };
  for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {
    _loop3();
  }
  return values;
};

/**
 * Parse Inline
 * @param {string} src
 */
marked.parseInline = function (src, opt) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked.parseInline(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  try {
    var tokens = Lexer.lexInline(src, opt);
    if (opt.walkTokens) {
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser.parseInline(tokens, opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if (opt.silent) {
      return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
    }
    throw e;
  }
};

/**
 * Expose
 */
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parse = marked;
var parser = Parser.parse;
var lexer = Lexer.lex;

exports.Lexer = Lexer;
exports.Parser = Parser;
exports.Renderer = Renderer;
exports.Slugger = Slugger;
exports.TextRenderer = TextRenderer;
exports.Tokenizer = Tokenizer;
exports.getDefaults = getDefaults;
exports.lexer = lexer;
exports.marked = marked;
exports.options = options;
exports.parse = parse;
exports.parseInline = parseInline;
exports.parser = parser;
exports.setOptions = setOptions;
exports.use = use;
exports.walkTokens = walkTokens;


/***/ }),

/***/ 83163:
/***/ ((module) => {

let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = ''
    let i = size
    while (i--) {
      id += alphabet[(Math.random() * alphabet.length) | 0]
    }
    return id
  }
}
let nanoid = (size = 21) => {
  let id = ''
  let i = size
  while (i--) {
    id += urlAlphabet[(Math.random() * 64) | 0]
  }
  return id
}
module.exports = { nanoid, customAlphabet }


/***/ }),

/***/ 66151:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"assert":true,"node:assert":[">= 14.18 && < 15",">= 16"],"assert/strict":">= 15","node:assert/strict":">= 16","async_hooks":">= 8","node:async_hooks":[">= 14.18 && < 15",">= 16"],"buffer_ieee754":">= 0.5 && < 0.9.7","buffer":true,"node:buffer":[">= 14.18 && < 15",">= 16"],"child_process":true,"node:child_process":[">= 14.18 && < 15",">= 16"],"cluster":">= 0.5","node:cluster":[">= 14.18 && < 15",">= 16"],"console":true,"node:console":[">= 14.18 && < 15",">= 16"],"constants":true,"node:constants":[">= 14.18 && < 15",">= 16"],"crypto":true,"node:crypto":[">= 14.18 && < 15",">= 16"],"_debug_agent":">= 1 && < 8","_debugger":"< 8","dgram":true,"node:dgram":[">= 14.18 && < 15",">= 16"],"diagnostics_channel":[">= 14.17 && < 15",">= 15.1"],"node:diagnostics_channel":[">= 14.18 && < 15",">= 16"],"dns":true,"node:dns":[">= 14.18 && < 15",">= 16"],"dns/promises":">= 15","node:dns/promises":">= 16","domain":">= 0.7.12","node:domain":[">= 14.18 && < 15",">= 16"],"events":true,"node:events":[">= 14.18 && < 15",">= 16"],"freelist":"< 6","fs":true,"node:fs":[">= 14.18 && < 15",">= 16"],"fs/promises":[">= 10 && < 10.1",">= 14"],"node:fs/promises":[">= 14.18 && < 15",">= 16"],"_http_agent":">= 0.11.1","node:_http_agent":[">= 14.18 && < 15",">= 16"],"_http_client":">= 0.11.1","node:_http_client":[">= 14.18 && < 15",">= 16"],"_http_common":">= 0.11.1","node:_http_common":[">= 14.18 && < 15",">= 16"],"_http_incoming":">= 0.11.1","node:_http_incoming":[">= 14.18 && < 15",">= 16"],"_http_outgoing":">= 0.11.1","node:_http_outgoing":[">= 14.18 && < 15",">= 16"],"_http_server":">= 0.11.1","node:_http_server":[">= 14.18 && < 15",">= 16"],"http":true,"node:http":[">= 14.18 && < 15",">= 16"],"http2":">= 8.8","node:http2":[">= 14.18 && < 15",">= 16"],"https":true,"node:https":[">= 14.18 && < 15",">= 16"],"inspector":">= 8","node:inspector":[">= 14.18 && < 15",">= 16"],"_linklist":"< 8","module":true,"node:module":[">= 14.18 && < 15",">= 16"],"net":true,"node:net":[">= 14.18 && < 15",">= 16"],"node-inspect/lib/_inspect":">= 7.6 && < 12","node-inspect/lib/internal/inspect_client":">= 7.6 && < 12","node-inspect/lib/internal/inspect_repl":">= 7.6 && < 12","os":true,"node:os":[">= 14.18 && < 15",">= 16"],"path":true,"node:path":[">= 14.18 && < 15",">= 16"],"path/posix":">= 15.3","node:path/posix":">= 16","path/win32":">= 15.3","node:path/win32":">= 16","perf_hooks":">= 8.5","node:perf_hooks":[">= 14.18 && < 15",">= 16"],"process":">= 1","node:process":[">= 14.18 && < 15",">= 16"],"punycode":">= 0.5","node:punycode":[">= 14.18 && < 15",">= 16"],"querystring":true,"node:querystring":[">= 14.18 && < 15",">= 16"],"readline":true,"node:readline":[">= 14.18 && < 15",">= 16"],"readline/promises":">= 17","node:readline/promises":">= 17","repl":true,"node:repl":[">= 14.18 && < 15",">= 16"],"smalloc":">= 0.11.5 && < 3","_stream_duplex":">= 0.9.4","node:_stream_duplex":[">= 14.18 && < 15",">= 16"],"_stream_transform":">= 0.9.4","node:_stream_transform":[">= 14.18 && < 15",">= 16"],"_stream_wrap":">= 1.4.1","node:_stream_wrap":[">= 14.18 && < 15",">= 16"],"_stream_passthrough":">= 0.9.4","node:_stream_passthrough":[">= 14.18 && < 15",">= 16"],"_stream_readable":">= 0.9.4","node:_stream_readable":[">= 14.18 && < 15",">= 16"],"_stream_writable":">= 0.9.4","node:_stream_writable":[">= 14.18 && < 15",">= 16"],"stream":true,"node:stream":[">= 14.18 && < 15",">= 16"],"stream/consumers":">= 16.7","node:stream/consumers":">= 16.7","stream/promises":">= 15","node:stream/promises":">= 16","stream/web":">= 16.5","node:stream/web":">= 16.5","string_decoder":true,"node:string_decoder":[">= 14.18 && < 15",">= 16"],"sys":[">= 0.4 && < 0.7",">= 0.8"],"node:sys":[">= 14.18 && < 15",">= 16"],"node:test":[">= 16.17 && < 17",">= 18"],"timers":true,"node:timers":[">= 14.18 && < 15",">= 16"],"timers/promises":">= 15","node:timers/promises":">= 16","_tls_common":">= 0.11.13","node:_tls_common":[">= 14.18 && < 15",">= 16"],"_tls_legacy":">= 0.11.3 && < 10","_tls_wrap":">= 0.11.3","node:_tls_wrap":[">= 14.18 && < 15",">= 16"],"tls":true,"node:tls":[">= 14.18 && < 15",">= 16"],"trace_events":">= 10","node:trace_events":[">= 14.18 && < 15",">= 16"],"tty":true,"node:tty":[">= 14.18 && < 15",">= 16"],"url":true,"node:url":[">= 14.18 && < 15",">= 16"],"util":true,"node:util":[">= 14.18 && < 15",">= 16"],"util/types":">= 15.3","node:util/types":">= 16","v8/tools/arguments":">= 10 && < 12","v8/tools/codemap":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/consarray":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/csvparser":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/logreader":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/profile_view":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/splaytree":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8":">= 1","node:v8":[">= 14.18 && < 15",">= 16"],"vm":true,"node:vm":[">= 14.18 && < 15",">= 16"],"wasi":">= 13.4 && < 13.5","worker_threads":">= 11.7","node:worker_threads":[">= 14.18 && < 15",">= 16"],"zlib":">= 0.5","node:zlib":[">= 14.18 && < 15",">= 16"]}');

/***/ }),

/***/ 76052:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('[{"name":"nodejs","version":"0.2.0","date":"2011-08-26","lts":false,"security":false},{"name":"nodejs","version":"0.3.0","date":"2011-08-26","lts":false,"security":false},{"name":"nodejs","version":"0.4.0","date":"2011-08-26","lts":false,"security":false},{"name":"nodejs","version":"0.5.0","date":"2011-08-26","lts":false,"security":false},{"name":"nodejs","version":"0.6.0","date":"2011-11-04","lts":false,"security":false},{"name":"nodejs","version":"0.7.0","date":"2012-01-17","lts":false,"security":false},{"name":"nodejs","version":"0.8.0","date":"2012-06-22","lts":false,"security":false},{"name":"nodejs","version":"0.9.0","date":"2012-07-20","lts":false,"security":false},{"name":"nodejs","version":"0.10.0","date":"2013-03-11","lts":false,"security":false},{"name":"nodejs","version":"0.11.0","date":"2013-03-28","lts":false,"security":false},{"name":"nodejs","version":"0.12.0","date":"2015-02-06","lts":false,"security":false},{"name":"nodejs","version":"4.0.0","date":"2015-09-08","lts":false,"security":false},{"name":"nodejs","version":"4.1.0","date":"2015-09-17","lts":false,"security":false},{"name":"nodejs","version":"4.2.0","date":"2015-10-12","lts":"Argon","security":false},{"name":"nodejs","version":"4.3.0","date":"2016-02-09","lts":"Argon","security":false},{"name":"nodejs","version":"4.4.0","date":"2016-03-08","lts":"Argon","security":false},{"name":"nodejs","version":"4.5.0","date":"2016-08-16","lts":"Argon","security":false},{"name":"nodejs","version":"4.6.0","date":"2016-09-27","lts":"Argon","security":true},{"name":"nodejs","version":"4.7.0","date":"2016-12-06","lts":"Argon","security":false},{"name":"nodejs","version":"4.8.0","date":"2017-02-21","lts":"Argon","security":false},{"name":"nodejs","version":"4.9.0","date":"2018-03-28","lts":"Argon","security":true},{"name":"nodejs","version":"5.0.0","date":"2015-10-29","lts":false,"security":false},{"name":"nodejs","version":"5.1.0","date":"2015-11-17","lts":false,"security":false},{"name":"nodejs","version":"5.2.0","date":"2015-12-09","lts":false,"security":false},{"name":"nodejs","version":"5.3.0","date":"2015-12-15","lts":false,"security":false},{"name":"nodejs","version":"5.4.0","date":"2016-01-06","lts":false,"security":false},{"name":"nodejs","version":"5.5.0","date":"2016-01-21","lts":false,"security":false},{"name":"nodejs","version":"5.6.0","date":"2016-02-09","lts":false,"security":false},{"name":"nodejs","version":"5.7.0","date":"2016-02-23","lts":false,"security":false},{"name":"nodejs","version":"5.8.0","date":"2016-03-09","lts":false,"security":false},{"name":"nodejs","version":"5.9.0","date":"2016-03-16","lts":false,"security":false},{"name":"nodejs","version":"5.10.0","date":"2016-04-01","lts":false,"security":false},{"name":"nodejs","version":"5.11.0","date":"2016-04-21","lts":false,"security":false},{"name":"nodejs","version":"5.12.0","date":"2016-06-23","lts":false,"security":false},{"name":"nodejs","version":"6.0.0","date":"2016-04-26","lts":false,"security":false},{"name":"nodejs","version":"6.1.0","date":"2016-05-05","lts":false,"security":false},{"name":"nodejs","version":"6.2.0","date":"2016-05-17","lts":false,"security":false},{"name":"nodejs","version":"6.3.0","date":"2016-07-06","lts":false,"security":false},{"name":"nodejs","version":"6.4.0","date":"2016-08-12","lts":false,"security":false},{"name":"nodejs","version":"6.5.0","date":"2016-08-26","lts":false,"security":false},{"name":"nodejs","version":"6.6.0","date":"2016-09-14","lts":false,"security":false},{"name":"nodejs","version":"6.7.0","date":"2016-09-27","lts":false,"security":true},{"name":"nodejs","version":"6.8.0","date":"2016-10-12","lts":false,"security":false},{"name":"nodejs","version":"6.9.0","date":"2016-10-18","lts":"Boron","security":false},{"name":"nodejs","version":"6.10.0","date":"2017-02-21","lts":"Boron","security":false},{"name":"nodejs","version":"6.11.0","date":"2017-06-06","lts":"Boron","security":false},{"name":"nodejs","version":"6.12.0","date":"2017-11-06","lts":"Boron","security":false},{"name":"nodejs","version":"6.13.0","date":"2018-02-10","lts":"Boron","security":false},{"name":"nodejs","version":"6.14.0","date":"2018-03-28","lts":"Boron","security":true},{"name":"nodejs","version":"6.15.0","date":"2018-11-27","lts":"Boron","security":true},{"name":"nodejs","version":"6.16.0","date":"2018-12-26","lts":"Boron","security":false},{"name":"nodejs","version":"6.17.0","date":"2019-02-28","lts":"Boron","security":true},{"name":"nodejs","version":"7.0.0","date":"2016-10-25","lts":false,"security":false},{"name":"nodejs","version":"7.1.0","date":"2016-11-08","lts":false,"security":false},{"name":"nodejs","version":"7.2.0","date":"2016-11-22","lts":false,"security":false},{"name":"nodejs","version":"7.3.0","date":"2016-12-20","lts":false,"security":false},{"name":"nodejs","version":"7.4.0","date":"2017-01-04","lts":false,"security":false},{"name":"nodejs","version":"7.5.0","date":"2017-01-31","lts":false,"security":false},{"name":"nodejs","version":"7.6.0","date":"2017-02-21","lts":false,"security":false},{"name":"nodejs","version":"7.7.0","date":"2017-02-28","lts":false,"security":false},{"name":"nodejs","version":"7.8.0","date":"2017-03-29","lts":false,"security":false},{"name":"nodejs","version":"7.9.0","date":"2017-04-11","lts":false,"security":false},{"name":"nodejs","version":"7.10.0","date":"2017-05-02","lts":false,"security":false},{"name":"nodejs","version":"8.0.0","date":"2017-05-30","lts":false,"security":false},{"name":"nodejs","version":"8.1.0","date":"2017-06-08","lts":false,"security":false},{"name":"nodejs","version":"8.2.0","date":"2017-07-19","lts":false,"security":false},{"name":"nodejs","version":"8.3.0","date":"2017-08-08","lts":false,"security":false},{"name":"nodejs","version":"8.4.0","date":"2017-08-15","lts":false,"security":false},{"name":"nodejs","version":"8.5.0","date":"2017-09-12","lts":false,"security":false},{"name":"nodejs","version":"8.6.0","date":"2017-09-26","lts":false,"security":false},{"name":"nodejs","version":"8.7.0","date":"2017-10-11","lts":false,"security":false},{"name":"nodejs","version":"8.8.0","date":"2017-10-24","lts":false,"security":false},{"name":"nodejs","version":"8.9.0","date":"2017-10-31","lts":"Carbon","security":false},{"name":"nodejs","version":"8.10.0","date":"2018-03-06","lts":"Carbon","security":false},{"name":"nodejs","version":"8.11.0","date":"2018-03-28","lts":"Carbon","security":true},{"name":"nodejs","version":"8.12.0","date":"2018-09-10","lts":"Carbon","security":false},{"name":"nodejs","version":"8.13.0","date":"2018-11-20","lts":"Carbon","security":false},{"name":"nodejs","version":"8.14.0","date":"2018-11-27","lts":"Carbon","security":true},{"name":"nodejs","version":"8.15.0","date":"2018-12-26","lts":"Carbon","security":false},{"name":"nodejs","version":"8.16.0","date":"2019-04-16","lts":"Carbon","security":false},{"name":"nodejs","version":"8.17.0","date":"2019-12-17","lts":"Carbon","security":true},{"name":"nodejs","version":"9.0.0","date":"2017-10-31","lts":false,"security":false},{"name":"nodejs","version":"9.1.0","date":"2017-11-07","lts":false,"security":false},{"name":"nodejs","version":"9.2.0","date":"2017-11-14","lts":false,"security":false},{"name":"nodejs","version":"9.3.0","date":"2017-12-12","lts":false,"security":false},{"name":"nodejs","version":"9.4.0","date":"2018-01-10","lts":false,"security":false},{"name":"nodejs","version":"9.5.0","date":"2018-01-31","lts":false,"security":false},{"name":"nodejs","version":"9.6.0","date":"2018-02-21","lts":false,"security":false},{"name":"nodejs","version":"9.7.0","date":"2018-03-01","lts":false,"security":false},{"name":"nodejs","version":"9.8.0","date":"2018-03-07","lts":false,"security":false},{"name":"nodejs","version":"9.9.0","date":"2018-03-21","lts":false,"security":false},{"name":"nodejs","version":"9.10.0","date":"2018-03-28","lts":false,"security":true},{"name":"nodejs","version":"9.11.0","date":"2018-04-04","lts":false,"security":false},{"name":"nodejs","version":"10.0.0","date":"2018-04-24","lts":false,"security":false},{"name":"nodejs","version":"10.1.0","date":"2018-05-08","lts":false,"security":false},{"name":"nodejs","version":"10.2.0","date":"2018-05-23","lts":false,"security":false},{"name":"nodejs","version":"10.3.0","date":"2018-05-29","lts":false,"security":false},{"name":"nodejs","version":"10.4.0","date":"2018-06-06","lts":false,"security":false},{"name":"nodejs","version":"10.5.0","date":"2018-06-20","lts":false,"security":false},{"name":"nodejs","version":"10.6.0","date":"2018-07-04","lts":false,"security":false},{"name":"nodejs","version":"10.7.0","date":"2018-07-18","lts":false,"security":false},{"name":"nodejs","version":"10.8.0","date":"2018-08-01","lts":false,"security":false},{"name":"nodejs","version":"10.9.0","date":"2018-08-15","lts":false,"security":false},{"name":"nodejs","version":"10.10.0","date":"2018-09-06","lts":false,"security":false},{"name":"nodejs","version":"10.11.0","date":"2018-09-19","lts":false,"security":false},{"name":"nodejs","version":"10.12.0","date":"2018-10-10","lts":false,"security":false},{"name":"nodejs","version":"10.13.0","date":"2018-10-30","lts":"Dubnium","security":false},{"name":"nodejs","version":"10.14.0","date":"2018-11-27","lts":"Dubnium","security":true},{"name":"nodejs","version":"10.15.0","date":"2018-12-26","lts":"Dubnium","security":false},{"name":"nodejs","version":"10.16.0","date":"2019-05-28","lts":"Dubnium","security":false},{"name":"nodejs","version":"10.17.0","date":"2019-10-22","lts":"Dubnium","security":false},{"name":"nodejs","version":"10.18.0","date":"2019-12-17","lts":"Dubnium","security":true},{"name":"nodejs","version":"10.19.0","date":"2020-02-05","lts":"Dubnium","security":true},{"name":"nodejs","version":"10.20.0","date":"2020-03-26","lts":"Dubnium","security":false},{"name":"nodejs","version":"10.21.0","date":"2020-06-02","lts":"Dubnium","security":true},{"name":"nodejs","version":"10.22.0","date":"2020-07-21","lts":"Dubnium","security":false},{"name":"nodejs","version":"10.23.0","date":"2020-10-27","lts":"Dubnium","security":false},{"name":"nodejs","version":"10.24.0","date":"2021-02-23","lts":"Dubnium","security":true},{"name":"nodejs","version":"11.0.0","date":"2018-10-23","lts":false,"security":false},{"name":"nodejs","version":"11.1.0","date":"2018-10-30","lts":false,"security":false},{"name":"nodejs","version":"11.2.0","date":"2018-11-15","lts":false,"security":false},{"name":"nodejs","version":"11.3.0","date":"2018-11-27","lts":false,"security":true},{"name":"nodejs","version":"11.4.0","date":"2018-12-07","lts":false,"security":false},{"name":"nodejs","version":"11.5.0","date":"2018-12-18","lts":false,"security":false},{"name":"nodejs","version":"11.6.0","date":"2018-12-26","lts":false,"security":false},{"name":"nodejs","version":"11.7.0","date":"2019-01-17","lts":false,"security":false},{"name":"nodejs","version":"11.8.0","date":"2019-01-24","lts":false,"security":false},{"name":"nodejs","version":"11.9.0","date":"2019-01-30","lts":false,"security":false},{"name":"nodejs","version":"11.10.0","date":"2019-02-14","lts":false,"security":false},{"name":"nodejs","version":"11.11.0","date":"2019-03-05","lts":false,"security":false},{"name":"nodejs","version":"11.12.0","date":"2019-03-14","lts":false,"security":false},{"name":"nodejs","version":"11.13.0","date":"2019-03-28","lts":false,"security":false},{"name":"nodejs","version":"11.14.0","date":"2019-04-10","lts":false,"security":false},{"name":"nodejs","version":"11.15.0","date":"2019-04-30","lts":false,"security":false},{"name":"nodejs","version":"12.0.0","date":"2019-04-23","lts":false,"security":false},{"name":"nodejs","version":"12.1.0","date":"2019-04-29","lts":false,"security":false},{"name":"nodejs","version":"12.2.0","date":"2019-05-07","lts":false,"security":false},{"name":"nodejs","version":"12.3.0","date":"2019-05-21","lts":false,"security":false},{"name":"nodejs","version":"12.4.0","date":"2019-06-04","lts":false,"security":false},{"name":"nodejs","version":"12.5.0","date":"2019-06-26","lts":false,"security":false},{"name":"nodejs","version":"12.6.0","date":"2019-07-03","lts":false,"security":false},{"name":"nodejs","version":"12.7.0","date":"2019-07-23","lts":false,"security":false},{"name":"nodejs","version":"12.8.0","date":"2019-08-06","lts":false,"security":false},{"name":"nodejs","version":"12.9.0","date":"2019-08-20","lts":false,"security":false},{"name":"nodejs","version":"12.10.0","date":"2019-09-04","lts":false,"security":false},{"name":"nodejs","version":"12.11.0","date":"2019-09-25","lts":false,"security":false},{"name":"nodejs","version":"12.12.0","date":"2019-10-11","lts":false,"security":false},{"name":"nodejs","version":"12.13.0","date":"2019-10-21","lts":"Erbium","security":false},{"name":"nodejs","version":"12.14.0","date":"2019-12-17","lts":"Erbium","security":true},{"name":"nodejs","version":"12.15.0","date":"2020-02-05","lts":"Erbium","security":true},{"name":"nodejs","version":"12.16.0","date":"2020-02-11","lts":"Erbium","security":false},{"name":"nodejs","version":"12.17.0","date":"2020-05-26","lts":"Erbium","security":false},{"name":"nodejs","version":"12.18.0","date":"2020-06-02","lts":"Erbium","security":true},{"name":"nodejs","version":"12.19.0","date":"2020-10-06","lts":"Erbium","security":false},{"name":"nodejs","version":"12.20.0","date":"2020-11-24","lts":"Erbium","security":false},{"name":"nodejs","version":"12.21.0","date":"2021-02-23","lts":"Erbium","security":true},{"name":"nodejs","version":"12.22.0","date":"2021-03-30","lts":"Erbium","security":false},{"name":"nodejs","version":"13.0.0","date":"2019-10-22","lts":false,"security":false},{"name":"nodejs","version":"13.1.0","date":"2019-11-05","lts":false,"security":false},{"name":"nodejs","version":"13.2.0","date":"2019-11-21","lts":false,"security":false},{"name":"nodejs","version":"13.3.0","date":"2019-12-03","lts":false,"security":false},{"name":"nodejs","version":"13.4.0","date":"2019-12-17","lts":false,"security":true},{"name":"nodejs","version":"13.5.0","date":"2019-12-18","lts":false,"security":false},{"name":"nodejs","version":"13.6.0","date":"2020-01-07","lts":false,"security":false},{"name":"nodejs","version":"13.7.0","date":"2020-01-21","lts":false,"security":false},{"name":"nodejs","version":"13.8.0","date":"2020-02-05","lts":false,"security":true},{"name":"nodejs","version":"13.9.0","date":"2020-02-18","lts":false,"security":false},{"name":"nodejs","version":"13.10.0","date":"2020-03-04","lts":false,"security":false},{"name":"nodejs","version":"13.11.0","date":"2020-03-12","lts":false,"security":false},{"name":"nodejs","version":"13.12.0","date":"2020-03-26","lts":false,"security":false},{"name":"nodejs","version":"13.13.0","date":"2020-04-14","lts":false,"security":false},{"name":"nodejs","version":"13.14.0","date":"2020-04-29","lts":false,"security":false},{"name":"nodejs","version":"14.0.0","date":"2020-04-21","lts":false,"security":false},{"name":"nodejs","version":"14.1.0","date":"2020-04-29","lts":false,"security":false},{"name":"nodejs","version":"14.2.0","date":"2020-05-05","lts":false,"security":false},{"name":"nodejs","version":"14.3.0","date":"2020-05-19","lts":false,"security":false},{"name":"nodejs","version":"14.4.0","date":"2020-06-02","lts":false,"security":true},{"name":"nodejs","version":"14.5.0","date":"2020-06-30","lts":false,"security":false},{"name":"nodejs","version":"14.6.0","date":"2020-07-20","lts":false,"security":false},{"name":"nodejs","version":"14.7.0","date":"2020-07-29","lts":false,"security":false},{"name":"nodejs","version":"14.8.0","date":"2020-08-11","lts":false,"security":false},{"name":"nodejs","version":"14.9.0","date":"2020-08-27","lts":false,"security":false},{"name":"nodejs","version":"14.10.0","date":"2020-09-08","lts":false,"security":false},{"name":"nodejs","version":"14.11.0","date":"2020-09-15","lts":false,"security":true},{"name":"nodejs","version":"14.12.0","date":"2020-09-22","lts":false,"security":false},{"name":"nodejs","version":"14.13.0","date":"2020-09-29","lts":false,"security":false},{"name":"nodejs","version":"14.14.0","date":"2020-10-15","lts":false,"security":false},{"name":"nodejs","version":"14.15.0","date":"2020-10-27","lts":"Fermium","security":false},{"name":"nodejs","version":"14.16.0","date":"2021-02-23","lts":"Fermium","security":true},{"name":"nodejs","version":"14.17.0","date":"2021-05-11","lts":"Fermium","security":false},{"name":"nodejs","version":"14.18.0","date":"2021-09-28","lts":"Fermium","security":false},{"name":"nodejs","version":"14.19.0","date":"2022-02-01","lts":"Fermium","security":false},{"name":"nodejs","version":"14.20.0","date":"2022-07-07","lts":"Fermium","security":true},{"name":"nodejs","version":"14.21.0","date":"2022-11-01","lts":"Fermium","security":false},{"name":"nodejs","version":"15.0.0","date":"2020-10-20","lts":false,"security":false},{"name":"nodejs","version":"15.1.0","date":"2020-11-04","lts":false,"security":false},{"name":"nodejs","version":"15.2.0","date":"2020-11-10","lts":false,"security":false},{"name":"nodejs","version":"15.3.0","date":"2020-11-24","lts":false,"security":false},{"name":"nodejs","version":"15.4.0","date":"2020-12-09","lts":false,"security":false},{"name":"nodejs","version":"15.5.0","date":"2020-12-22","lts":false,"security":false},{"name":"nodejs","version":"15.6.0","date":"2021-01-14","lts":false,"security":false},{"name":"nodejs","version":"15.7.0","date":"2021-01-25","lts":false,"security":false},{"name":"nodejs","version":"15.8.0","date":"2021-02-02","lts":false,"security":false},{"name":"nodejs","version":"15.9.0","date":"2021-02-18","lts":false,"security":false},{"name":"nodejs","version":"15.10.0","date":"2021-02-23","lts":false,"security":true},{"name":"nodejs","version":"15.11.0","date":"2021-03-03","lts":false,"security":false},{"name":"nodejs","version":"15.12.0","date":"2021-03-17","lts":false,"security":false},{"name":"nodejs","version":"15.13.0","date":"2021-03-31","lts":false,"security":false},{"name":"nodejs","version":"15.14.0","date":"2021-04-06","lts":false,"security":false},{"name":"nodejs","version":"16.0.0","date":"2021-04-20","lts":false,"security":false},{"name":"nodejs","version":"16.1.0","date":"2021-05-04","lts":false,"security":false},{"name":"nodejs","version":"16.2.0","date":"2021-05-19","lts":false,"security":false},{"name":"nodejs","version":"16.3.0","date":"2021-06-03","lts":false,"security":false},{"name":"nodejs","version":"16.4.0","date":"2021-06-23","lts":false,"security":false},{"name":"nodejs","version":"16.5.0","date":"2021-07-14","lts":false,"security":false},{"name":"nodejs","version":"16.6.0","date":"2021-07-29","lts":false,"security":true},{"name":"nodejs","version":"16.7.0","date":"2021-08-18","lts":false,"security":false},{"name":"nodejs","version":"16.8.0","date":"2021-08-25","lts":false,"security":false},{"name":"nodejs","version":"16.9.0","date":"2021-09-07","lts":false,"security":false},{"name":"nodejs","version":"16.10.0","date":"2021-09-22","lts":false,"security":false},{"name":"nodejs","version":"16.11.0","date":"2021-10-08","lts":false,"security":false},{"name":"nodejs","version":"16.12.0","date":"2021-10-20","lts":false,"security":false},{"name":"nodejs","version":"16.13.0","date":"2021-10-26","lts":"Gallium","security":false},{"name":"nodejs","version":"16.14.0","date":"2022-02-08","lts":"Gallium","security":false},{"name":"nodejs","version":"16.15.0","date":"2022-04-26","lts":"Gallium","security":false},{"name":"nodejs","version":"16.16.0","date":"2022-07-07","lts":"Gallium","security":true},{"name":"nodejs","version":"16.17.0","date":"2022-08-16","lts":"Gallium","security":false},{"name":"nodejs","version":"16.18.0","date":"2022-10-12","lts":"Gallium","security":false},{"name":"nodejs","version":"16.19.0","date":"2022-12-13","lts":"Gallium","security":false},{"name":"nodejs","version":"17.0.0","date":"2021-10-19","lts":false,"security":false},{"name":"nodejs","version":"17.1.0","date":"2021-11-09","lts":false,"security":false},{"name":"nodejs","version":"17.2.0","date":"2021-11-30","lts":false,"security":false},{"name":"nodejs","version":"17.3.0","date":"2021-12-17","lts":false,"security":false},{"name":"nodejs","version":"17.4.0","date":"2022-01-18","lts":false,"security":false},{"name":"nodejs","version":"17.5.0","date":"2022-02-10","lts":false,"security":false},{"name":"nodejs","version":"17.6.0","date":"2022-02-22","lts":false,"security":false},{"name":"nodejs","version":"17.7.0","date":"2022-03-09","lts":false,"security":false},{"name":"nodejs","version":"17.8.0","date":"2022-03-22","lts":false,"security":false},{"name":"nodejs","version":"17.9.0","date":"2022-04-07","lts":false,"security":false},{"name":"nodejs","version":"18.0.0","date":"2022-04-18","lts":false,"security":false},{"name":"nodejs","version":"18.1.0","date":"2022-05-03","lts":false,"security":false},{"name":"nodejs","version":"18.2.0","date":"2022-05-17","lts":false,"security":false},{"name":"nodejs","version":"18.3.0","date":"2022-06-02","lts":false,"security":false},{"name":"nodejs","version":"18.4.0","date":"2022-06-16","lts":false,"security":false},{"name":"nodejs","version":"18.5.0","date":"2022-07-06","lts":false,"security":true},{"name":"nodejs","version":"18.6.0","date":"2022-07-13","lts":false,"security":false},{"name":"nodejs","version":"18.7.0","date":"2022-07-26","lts":false,"security":false},{"name":"nodejs","version":"18.8.0","date":"2022-08-24","lts":false,"security":false},{"name":"nodejs","version":"18.9.0","date":"2022-09-07","lts":false,"security":false},{"name":"nodejs","version":"18.10.0","date":"2022-09-28","lts":false,"security":false},{"name":"nodejs","version":"18.11.0","date":"2022-10-13","lts":false,"security":false},{"name":"nodejs","version":"18.12.0","date":"2022-10-25","lts":"Hydrogen","security":false},{"name":"nodejs","version":"18.13.0","date":"2023-01-05","lts":"Hydrogen","security":false},{"name":"nodejs","version":"18.14.0","date":"2023-02-01","lts":"Hydrogen","security":false},{"name":"nodejs","version":"19.0.0","date":"2022-10-17","lts":false,"security":false},{"name":"nodejs","version":"19.1.0","date":"2022-11-14","lts":false,"security":false},{"name":"nodejs","version":"19.2.0","date":"2022-11-29","lts":false,"security":false},{"name":"nodejs","version":"19.3.0","date":"2022-12-14","lts":false,"security":false},{"name":"nodejs","version":"19.4.0","date":"2023-01-05","lts":false,"security":false},{"name":"nodejs","version":"19.5.0","date":"2023-01-24","lts":false,"security":false},{"name":"nodejs","version":"19.6.0","date":"2023-02-01","lts":false,"security":false}]');

/***/ }),

/***/ 78864:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"v0.8":{"start":"2012-06-25","end":"2014-07-31"},"v0.10":{"start":"2013-03-11","end":"2016-10-31"},"v0.12":{"start":"2015-02-06","end":"2016-12-31"},"v4":{"start":"2015-09-08","lts":"2015-10-12","maintenance":"2017-04-01","end":"2018-04-30","codename":"Argon"},"v5":{"start":"2015-10-29","maintenance":"2016-04-30","end":"2016-06-30"},"v6":{"start":"2016-04-26","lts":"2016-10-18","maintenance":"2018-04-30","end":"2019-04-30","codename":"Boron"},"v7":{"start":"2016-10-25","maintenance":"2017-04-30","end":"2017-06-30"},"v8":{"start":"2017-05-30","lts":"2017-10-31","maintenance":"2019-01-01","end":"2019-12-31","codename":"Carbon"},"v9":{"start":"2017-10-01","maintenance":"2018-04-01","end":"2018-06-30"},"v10":{"start":"2018-04-24","lts":"2018-10-30","maintenance":"2020-05-19","end":"2021-04-30","codename":"Dubnium"},"v11":{"start":"2018-10-23","maintenance":"2019-04-22","end":"2019-06-01"},"v12":{"start":"2019-04-23","lts":"2019-10-21","maintenance":"2020-11-30","end":"2022-04-30","codename":"Erbium"},"v13":{"start":"2019-10-22","maintenance":"2020-04-01","end":"2020-06-01"},"v14":{"start":"2020-04-21","lts":"2020-10-27","maintenance":"2021-10-19","end":"2023-04-30","codename":"Fermium"},"v15":{"start":"2020-10-20","maintenance":"2021-04-01","end":"2021-06-01"},"v16":{"start":"2021-04-20","lts":"2021-10-26","maintenance":"2022-10-18","end":"2023-09-11","codename":"Gallium"},"v17":{"start":"2021-10-19","maintenance":"2022-04-01","end":"2022-06-01"},"v18":{"start":"2022-04-19","lts":"2022-10-25","maintenance":"2023-10-18","end":"2025-04-30","codename":"Hydrogen"},"v19":{"start":"2022-10-18","maintenance":"2023-04-01","end":"2023-06-01"},"v20":{"start":"2023-04-18","lts":"2023-10-24","maintenance":"2024-10-22","end":"2026-04-30","codename":""}}');

/***/ }),

/***/ 74503:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"assert":true,"node:assert":[">= 14.18 && < 15",">= 16"],"assert/strict":">= 15","node:assert/strict":">= 16","async_hooks":">= 8","node:async_hooks":[">= 14.18 && < 15",">= 16"],"buffer_ieee754":">= 0.5 && < 0.9.7","buffer":true,"node:buffer":[">= 14.18 && < 15",">= 16"],"child_process":true,"node:child_process":[">= 14.18 && < 15",">= 16"],"cluster":">= 0.5","node:cluster":[">= 14.18 && < 15",">= 16"],"console":true,"node:console":[">= 14.18 && < 15",">= 16"],"constants":true,"node:constants":[">= 14.18 && < 15",">= 16"],"crypto":true,"node:crypto":[">= 14.18 && < 15",">= 16"],"_debug_agent":">= 1 && < 8","_debugger":"< 8","dgram":true,"node:dgram":[">= 14.18 && < 15",">= 16"],"diagnostics_channel":[">= 14.17 && < 15",">= 15.1"],"node:diagnostics_channel":[">= 14.18 && < 15",">= 16"],"dns":true,"node:dns":[">= 14.18 && < 15",">= 16"],"dns/promises":">= 15","node:dns/promises":">= 16","domain":">= 0.7.12","node:domain":[">= 14.18 && < 15",">= 16"],"events":true,"node:events":[">= 14.18 && < 15",">= 16"],"freelist":"< 6","fs":true,"node:fs":[">= 14.18 && < 15",">= 16"],"fs/promises":[">= 10 && < 10.1",">= 14"],"node:fs/promises":[">= 14.18 && < 15",">= 16"],"_http_agent":">= 0.11.1","node:_http_agent":[">= 14.18 && < 15",">= 16"],"_http_client":">= 0.11.1","node:_http_client":[">= 14.18 && < 15",">= 16"],"_http_common":">= 0.11.1","node:_http_common":[">= 14.18 && < 15",">= 16"],"_http_incoming":">= 0.11.1","node:_http_incoming":[">= 14.18 && < 15",">= 16"],"_http_outgoing":">= 0.11.1","node:_http_outgoing":[">= 14.18 && < 15",">= 16"],"_http_server":">= 0.11.1","node:_http_server":[">= 14.18 && < 15",">= 16"],"http":true,"node:http":[">= 14.18 && < 15",">= 16"],"http2":">= 8.8","node:http2":[">= 14.18 && < 15",">= 16"],"https":true,"node:https":[">= 14.18 && < 15",">= 16"],"inspector":">= 8","node:inspector":[">= 14.18 && < 15",">= 16"],"_linklist":"< 8","module":true,"node:module":[">= 14.18 && < 15",">= 16"],"net":true,"node:net":[">= 14.18 && < 15",">= 16"],"node-inspect/lib/_inspect":">= 7.6 && < 12","node-inspect/lib/internal/inspect_client":">= 7.6 && < 12","node-inspect/lib/internal/inspect_repl":">= 7.6 && < 12","os":true,"node:os":[">= 14.18 && < 15",">= 16"],"path":true,"node:path":[">= 14.18 && < 15",">= 16"],"path/posix":">= 15.3","node:path/posix":">= 16","path/win32":">= 15.3","node:path/win32":">= 16","perf_hooks":">= 8.5","node:perf_hooks":[">= 14.18 && < 15",">= 16"],"process":">= 1","node:process":[">= 14.18 && < 15",">= 16"],"punycode":">= 0.5","node:punycode":[">= 14.18 && < 15",">= 16"],"querystring":true,"node:querystring":[">= 14.18 && < 15",">= 16"],"readline":true,"node:readline":[">= 14.18 && < 15",">= 16"],"readline/promises":">= 17","node:readline/promises":">= 17","repl":true,"node:repl":[">= 14.18 && < 15",">= 16"],"smalloc":">= 0.11.5 && < 3","_stream_duplex":">= 0.9.4","node:_stream_duplex":[">= 14.18 && < 15",">= 16"],"_stream_transform":">= 0.9.4","node:_stream_transform":[">= 14.18 && < 15",">= 16"],"_stream_wrap":">= 1.4.1","node:_stream_wrap":[">= 14.18 && < 15",">= 16"],"_stream_passthrough":">= 0.9.4","node:_stream_passthrough":[">= 14.18 && < 15",">= 16"],"_stream_readable":">= 0.9.4","node:_stream_readable":[">= 14.18 && < 15",">= 16"],"_stream_writable":">= 0.9.4","node:_stream_writable":[">= 14.18 && < 15",">= 16"],"stream":true,"node:stream":[">= 14.18 && < 15",">= 16"],"stream/consumers":">= 16.7","node:stream/consumers":">= 16.7","stream/promises":">= 15","node:stream/promises":">= 16","stream/web":">= 16.5","node:stream/web":">= 16.5","string_decoder":true,"node:string_decoder":[">= 14.18 && < 15",">= 16"],"sys":[">= 0.4 && < 0.7",">= 0.8"],"node:sys":[">= 14.18 && < 15",">= 16"],"node:test":">= 18","timers":true,"node:timers":[">= 14.18 && < 15",">= 16"],"timers/promises":">= 15","node:timers/promises":">= 16","_tls_common":">= 0.11.13","node:_tls_common":[">= 14.18 && < 15",">= 16"],"_tls_legacy":">= 0.11.3 && < 10","_tls_wrap":">= 0.11.3","node:_tls_wrap":[">= 14.18 && < 15",">= 16"],"tls":true,"node:tls":[">= 14.18 && < 15",">= 16"],"trace_events":">= 10","node:trace_events":[">= 14.18 && < 15",">= 16"],"tty":true,"node:tty":[">= 14.18 && < 15",">= 16"],"url":true,"node:url":[">= 14.18 && < 15",">= 16"],"util":true,"node:util":[">= 14.18 && < 15",">= 16"],"util/types":">= 15.3","node:util/types":">= 16","v8/tools/arguments":">= 10 && < 12","v8/tools/codemap":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/consarray":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/csvparser":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/logreader":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/profile_view":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/splaytree":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8":">= 1","node:v8":[">= 14.18 && < 15",">= 16"],"vm":true,"node:vm":[">= 14.18 && < 15",">= 16"],"wasi":">= 13.4 && < 13.5","worker_threads":">= 11.7","node:worker_threads":[">= 14.18 && < 15",">= 16"],"zlib":">= 0.5","node:zlib":[">= 14.18 && < 15",">= 16"]}');

/***/ }),

/***/ 61214:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"tailwindcss","version":"3.2.7","description":"A utility-first CSS framework for rapidly building custom user interfaces.","license":"MIT","main":"lib/index.js","types":"types/index.d.ts","repository":"https://github.com/tailwindlabs/tailwindcss.git","bugs":"https://github.com/tailwindlabs/tailwindcss/issues","homepage":"https://tailwindcss.com","bin":{"tailwind":"lib/cli.js","tailwindcss":"lib/cli.js"},"tailwindcss":{"engine":"stable"},"scripts":{"prebuild":"npm run generate && rimraf lib","build":"swc src --out-dir lib --copy-files","postbuild":"esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false","rebuild-fixtures":"npm run build && node -r @swc/register scripts/rebuildFixtures.js","style":"eslint .","pretest":"npm run generate","test":"jest","test:integrations":"npm run test --prefix ./integrations","install:integrations":"node scripts/install-integrations.js","generate:plugin-list":"node -r @swc/register scripts/create-plugin-list.js","generate:types":"node -r @swc/register scripts/generate-types.js","generate":"npm run generate:plugin-list && npm run generate:types","release-channel":"node ./scripts/release-channel.js","release-notes":"node ./scripts/release-notes.js","prepublishOnly":"npm install --force && npm run build"},"files":["src/*","cli/*","lib/*","peers/*","scripts/*.js","stubs/*.stub.js","nesting/*","types/**/*","*.d.ts","*.css","*.js"],"devDependencies":{"@swc/cli":"0.1.59","@swc/core":"1.3.24","@swc/jest":"0.2.24","@swc/register":"0.1.10","autoprefixer":"^10.4.13","browserslist":"^4.21.4","concurrently":"^7.5.0","cssnano":"^5.1.14","esbuild":"^0.16.10","eslint":"^8.31.0","eslint-config-prettier":"^8.6.0","eslint-plugin-prettier":"^4.2.1","jest":"^28.1.3","jest-diff":"^28.1.3","lightningcss":"^1.18.0","prettier":"^2.8.1","rimraf":"^3.0.0","source-map-js":"^1.0.2","turbo":"^1.6.3"},"peerDependencies":{"postcss":"^8.0.9"},"dependencies":{"arg":"^5.0.2","chokidar":"^3.5.3","color-name":"^1.1.4","detective":"^5.2.1","didyoumean":"^1.2.2","dlv":"^1.1.3","fast-glob":"^3.2.12","glob-parent":"^6.0.2","is-glob":"^4.0.3","lilconfig":"^2.0.6","micromatch":"^4.0.5","normalize-path":"^3.0.0","object-hash":"^3.0.0","picocolors":"^1.0.0","postcss":"^8.0.9","postcss-import":"^14.1.0","postcss-js":"^4.0.0","postcss-load-config":"^3.1.4","postcss-nested":"6.0.0","postcss-selector-parser":"^6.0.11","postcss-value-parser":"^4.2.0","quick-lru":"^5.1.1","resolve":"^1.22.1"},"browserslist":["> 1%","not edge <= 18","not ie 11","not op_mini all"],"jest":{"testTimeout":30000,"setupFilesAfterEnv":["<rootDir>/jest/customMatchers.js"],"testPathIgnorePatterns":["/node_modules/","/integrations/","/standalone-cli/","\\\\.test\\\\.skip\\\\.js$"],"transformIgnorePatterns":["node_modules/(?!lightningcss)"],"transform":{"\\\\.js$":"@swc/jest","\\\\.ts$":"@swc/jest"}},"engines":{"node":">=12.13.0"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__nccwpck_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
const core = __nccwpck_require__(42186);
const https = __nccwpck_require__(22286);
const { build, ManifestObjects } = __nccwpck_require__(25772);
const { tailwindBuild } = __nccwpck_require__(50881);

const outputPath = 'output';

// Entry Point
(async () => {
  try {
    await render();
    inform();
  } catch (error) {
    console.error(error);
    process.exit(2);
  }
})();

async function render() {
  const featuresSource = await fetch('https://github.com/ably/features/raw/main/sdk.yaml');

  const sdkManifestObjects = new ManifestObjects(
    ['this'],
    new Map([['this', '.ably/capabilities.yaml']]),
  );

  console.log(`Feature List Version from ${sdkManifestObjects.objects.size} manifests: ${sdkManifestObjects.commonVersion}`);

  build(
    featuresSource,
    sdkManifestObjects,
    outputPath,
  );

  await tailwindBuild();
}

function inform() {
  const emit = (key, value) => {
    core.info(`${key}: ${value}`);
    core.setOutput(key, value);
  };

  emit('matrix-path', outputPath);
  emit('matrix-artifact-name', 'features');
}

/**
 * Simple Web-Fetch-alike function to HTTP GET a resource.
 * API based upon: https://developer.mozilla.org/en-US/docs/Web/API/fetch
 * We need this because Node.js 16 (the maximum version supported by GitHub Actions) doesn't have Fetch.
 */
async function fetch(url) {
  return new Promise((resolve, reject) => {
    const fetchOrFollowRedirect = (location, depth) => {
      if (depth > 3) {
        throw new Error('Exceeded arbitrary redirect follow limit.');
      }

      https.get(location, (response) => {
        const { statusCode } = response;
        const contentType = response.headers['content-type'];

        if (statusCode === 302) {
          fetchOrFollowRedirect(response.headers.location, depth + 1);
          return;
        }

        let error;
        if (statusCode !== 200) {
          error = new Error(`Request failed with status code ${statusCode}.`);
        } else if (!/^text\/plain/.test(contentType)) {
          error = new Error(`Unexpected content-type. Expected 'text/plain' but received '${contentType}'.`);
        }

        if (error) {
          response.resume(); // Consume response data to free up memory
          reject(error);
          return;
        }

        response.setEncoding('utf8');
        let bodyData = '';
        response.on('data', (chunk) => { bodyData += chunk; });
        response.on('end', () => {
          resolve(bodyData);
        });
      });
    };

    fetchOrFollowRedirect(url, 0);
  });
}

})();

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=index.js.map